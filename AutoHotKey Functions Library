/*
FUNCIONES  AUTOHOTKEY UNICODE 32 & 64 BITS.
-------------------------------------------------------------------------
SO: WXP, WV, W7 & W8 ~ 32 & 64 Bits.
Funciones: archivos, carpetas, cadena, criptografía, procesos, internet,
					gui & dialogos, gui controles, registro, control, mouse & teclado, sistema,
					ventanas, servicios, unidades, sonido, monitor, números &
					operaciones matemáticas, menús, ejecutar, barra de tareas,
					escritorio & explorador & menu inicio, recursos, otros.
Link: http://ahkscript.org/boards/viewtopic.php?f=42&t=5535
AutoHotKey: 1.1.21.01+
Actualizado: AHK-U1.1.22.03 || Viernes, 24 de julio de 2015
Historial De Cambios: https://raw.githubusercontent.com/flipeador/AutoHotKey/master/AutoHotKey Functions Library ~ Change Log
*/ ;flipeador@gmail.com ################################################################################################
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
; ::::::::::::::::::::::::::::::::::::::::::::: FUNCIONES APARTE :::::::::::::::::::::::::::::::::: 																										   ###
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
_mnum(f, s) { ;suma(+), resta(-) o alterna(^) un valor a otro dependiendo el modificador(+-^) inicial. por defecto lo suma(+).
	return i:=(_:=StrLeft(s:=Trim(s)))!="-"&&_!="+"&&_!="^"?(f&s?f:f+s)
	: ((s:=StrTrimLeft(s))?(_="-"?(f&s?f-s:f):_="^"?(f&s?f-s:f+s):(f&s?f:f+s)):f)
	, ErrorLevel := i=f||!f||!s
}
_cstr(Array, Value, m, i) { ;une(|.), suma(+) o resta(+) un conjunto de valores dependiendo del valor espesificado y si cumple con el modo(&=~) espesificado. [A] [V] [&=~] [+-|.]
	_:=i="+"||i="-"||i="|"?0:""
	for k, v in Array
		x:=(m="&"?Value&v:m="="?Value=v:m="~"?InStr(Value, k):0)?(m="~"?v:k):(i="-"?0:i="+"?0:i="|"?0:"")
		, x:=i="."?(_.=x):i="|"?(_|=x):i="-"?(_-=x):i="+"?(_+=x):""
	return _, ErrorLevel := _=""
}
_trim(String, OmitChars := "") { ;quita caracteres iniciales y finales de una cadena
	DllCall("Shlwapi.dll\StrTrimW", "Str", String, "Str", OmitChars=""?A_Space A_Tab:OmitChars)
	return String
} 
_len(String) { ;devuelve el número de caracteres de una cadena
	return DllCall("Kernel32.dll\lstrlenW", "Str", String)
} 
_cpath(path, ByRef cpath := "") { ;convierte la ruta (si es una unidad, agrega \ al final)
	return cpath:=(StrLen(i:=GetFullPathName(path))=2?i "\":i)
}
_clfm(f, m, r, ByRef ok := "") { ;modos para LoopFiles en versiones anteriores a la AHK1.1.20
	m := m=0?"F":m=1?"FD":m=2?"D":m=-1?(IsDir(f)?"D":"F"):m, m .= r?"R":""
	return m?m:"", ok := 0, ErrorLevel := m=""
}
_wildc(path, r := 0) { ;comprueba si se usan comodines (*?)
	return r||InStr(path,"*")||InStr(path,"?")
}
Set(Var, Value := "") { ;establece datos en un array
	static Array := []
	if (Value=""||Var="?"||Var="!")
		return Var="?"||Var="!"?(Var="?"?Array[Value]:Var="!"?Array:""):Array.Delete(Var)
	return Value, Array[Var] := Value
}
Get(Var, ByRef Value := "") { ;obtiene los datos establecidos por Set()
	return Value := Set( "?", Var )
}
_wpname(h,p,x:=0,i:=0) { ;obtiene el id o nombre del proceso dependiendo del valor espesificado
	if p&&InStr(p,".")
		WinGetPID(h?h:x,,i)
	else if p
		i:=WinGetPID(h?h:x)
	return i
}
_fspdtest(Count, Func, Param*) { ;test de velocidad para una funcion, en milisegundos (ms)
	StartTime := A_TickCount
	Loop, %Count%
		%Func%(Param*)
	return A_TickCount - StartTime
}
_fspdtestex(Count, Func, Param*) { ;test de velocidad para una funcion, mayor precisión
	static Frequency
	if !Frequency
		DllCall("Kernel32.dll\QueryPerformanceFrequency", "Int64*", Frequency)
	DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", StartTime)
	Loop, %Count%
		%Func%(Param*)
	DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", CurrentTime)
	return (CurrentTime - StartTime) / Frequency
}
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;####################################################################################################################




























;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	<<-------------	FUNCIONES	------------->>	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: ARCHIVOS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;eliminar archivo(s)
;devuelve el número de archivos eliminados
;Sintaxis: FileDelete( [archivo], [¿operar en subcarpetas?] )
FileDelete(FilePattern, Recurse := 0) {
	if !_wildc(FilePattern, Recurse) {
		FilePattern := GetFullPathName( FilePattern )
		if !(i := DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" FilePattern))
			FileSetAttrib( "-R", A_LoopFileLongPath, 0 )
			, i := DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" FilePattern)
		return i, ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileDelete( A_LoopFileLongPath ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}

;eliminar archivo(s) al reiniciar
FileRDelete(FilePattern, Recurse := 0) {
	if !_wildc(FilePattern, Recurse) {
		FilePattern := GetFullPathName( FilePattern )
		return i := DllCall("Kernel32.dll\MoveFileExW", "Str", "\\?\" FilePattern, "Ptr", 0, "UInt", 0x4)
			, ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileRDelete( A_LoopFileLongPath ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}
	
;eliminar archivo(s) de forma segura
;Sintáxis: FileSDelete( [archivo], [pasadas], [¿incluir subcarpetas?] )
FileSDelete(FilePattern, Pases := 1, Recurse := 0) {
	if !_wildc(FilePattern, Recurse) {
		FilePattern := GetFullPathName( FilePattern )
		if !IsFile( FilePattern )
			return 0, ErrorLevel := 1
		i := FileOpen2( FilePattern )
		Loop, %Pases% {
			nSize := i.Length < (10 ** 8) ? i.Length : (10 ** 8)
			VarSetCapacity(IpBuffer, nSize, A_Index)
			Loop, % Floor(i.Length / (10 ** 8))
				i.RawWrite(IpBuffer, nSize)
			nSize := Mod(i.Length, (10 ** 8))
			VarSetCapacity(IpBuffer, nSize, A_index)
			i.RawWrite(IpBuffer, nSize)
		}
		i.Close()
		FileSetTime( 2000, FilePattern, "MCA" )
		return i := FileDelete( FilePattern ), ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileSDelete( A_LoopFileLongPath, Pases ), i++
	return ok, ErrorLevel := ok = i ? 0 : 1
}

;renombrar archivo(s)
;Sintaxis: Rename( [Archivo], [Nuevo Nombre] )
;devuelve la cantidad de archivos renombrados
FileRename(FilePattern, NewName, Recurse := 0) {
	ValidateName( NewName )
	if (NewName = "")
		return 0
	if !_wildc(FilePattern, Recurse) {
		FilePattern := GetFullPathName( FilePattern )
		SplitPath( FilePattern,, Directory )
		return i := FileMove( FilePattern, Directory "\" NewName ), ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileRename( A_LoopFileLongPath, NewName ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}

FileGetVersion( Filename ) {
	FileGetVersion, IpVersion, %Filename%
	return IpVersion
}

;comparar 2 versiones (By. boiler; modificado): http://ahkscript.org/boards/viewtopic.php?f=6&t=5959
;RESULTADO:
	;0: Ver1 = Ver2
	;1: Ver1 > Ver2
	;2: Ver1 < Ver2
VersionCompare(version1, version2) {
	version1 := Trim( RegExReplace(version1, "[^0-9.]"), "." )
	version2 := Trim( RegExReplace(version2, "[^0-9.]"), "." )
	verA := StrSplit( version1, "." ), verB := StrSplit( version2, "." )
	Count := verA.MaxIndex()>verB.MaxIndex()?verA.MaxIndex():verB.MaxIndex()
	Loop, %Count% {
		if (verA.MaxIndex() < A_Index)
			verA[A_Index] := 0
		if (verB.MaxIndex() < A_Index)
			verB[A_Index] := 0
		if (verA[A_Index] > verB[A_Index])
			return 1
		if (verB[A_Index] > verA[A_Index])
			return 2
	}
	return 0
}
FileVersionCompare(version1, version2) {
	return VersionCompare( version1, version2 )
}

;comparar el tamaño de varios archivos
;RESULTADO:
	;0: todos tienen el mismo tamaño
	;1: el primer tamaño (1º archivo) es mayor al segundo (2º archivo)
	;2: el primer tamaño (1º archivo) es menor al segundo (2º archivo)
	;3+: devuelve la posicion de larchivo con el tamaño diferente
FileSizeCompare(Files*) {
	if !(Files.MaxIndex() >= 2)
		return 0, ErrorLevel := 1
	Loop, % Files.MaxIndex() {
		CurrentFileSize := FileGetSize( Files[A_Index] )
		FirstFileSize := A_Index = 1 ? CurrentFileSize : FirstFileSize
		SecondFileSize := A_Index = 2 ? CurrentFileSize : SecondFileSize
		if (A_Index > 1) && (CurrentFileSize != LastFileSize)
			return FirstFileSize>SecondFileSize?1:(FirstFileSize<SecondFileSize?2:A_Index)
		LastFileSize := CurrentFileSize
	}
	return ErrorLevel := 0
}

;obtener tamaño del archivo
;Sintáxis: FileGetSize( [archivo], [KB|MB|GB] )
FileGetSize(lpFileName, Units := 0) {
	static sKB := 1024, sMB := 1024 ** 2, sGB := 1024 ** 3
	lpFileName := GetFullPathName( lpFileName )
	hFile := DllCall("Kernel32.dll\CreateFileW", "Str", "\\?\" lpFileName, "UInt", 128, "UInt", 1, "UInt", 0, "UInt", 3, "UInt", 0, "Ptr", 0)
	VarSetCapacity(lpFileSize, 1048576, 0)
	DllCall("Kernel32.dll\GetFileSizeEx", "UInt", hFile, "UInt", &lpFileSize)
	fs := NumGet(lpFileSize, 0, "Int64*")
	return s%Units% ? fs / s%Units% : fs
		, DllCall("Kernel32.dll\CloseHandle", "UInt", hFile)
	;VarSetCapacity( WIN32_FIND_DATA, 1140, 0 ) ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418%28v=vs.85%29.aspx
	;DllCall("Kernel32.dll\FindFirstFileW", "Str", ComSpec, "Ptr", &WIN32_FIND_DATA)
	;nFileSizeHigh := NumGet( WIN32_FIND_DATA, 16, "UInt")
	;nFileSizeLow := NumGet( WIN32_FIND_DATA, 20, "UInt")
}

;Sintaxis: FileCreate( [archivo], [Acceso deseado], [0|1(R)|2(W)|4(D)] )
FileCreate(lpFileName, dwDesiredAccess := 28, dwShareMode := 7, lpSecurityAttributes := 0, dwCreationDisposition := 3, dwFlagsAndAttributes := 0, hTemplateFile := 0) {
	if (dwDesiredAccess = "r")
		dwDesiredAccess := 0x80000000
	else	if (dwDesiredAccess = "w")
		dwDesiredAccess := 0x40000000
	else	if (dwDesiredAccess = "rw")
		dwDesiredAccess := 0x80000000|0x40000000
	return DllCall("Kernel32.dll\CreateFileW", "Str", "\\?\" lpFileName, "UInt", dwDesiredAccess, "UInt", dwShareMode
		, "UInt", lpSecurityAttributes, "UInt", dwCreationDisposition, "UInt", dwFlagsAndAttributes, "Ptr", hTemplateFile)
}

;mover archivo
;Sintaxis: FileMove( [archivo], [archivo destino], [sobreescribir] )
FileMove(Source, Dest, Flag := 0) {
	if !IsFile( Source )
		return 0, ErrorLevel := 2
	FileMove, %Source%, %Dest%, %Flag%
	return !ErrorLevel
}

;Sintaxis: FileSetTime( [fecha], [archivo], [M|C|A], [0(F)|1(FD)|2(D)], [0|1(R)] )
FileSetTime(Time := "", FilePattern := "", WhichTimeMCA := "M", OperateOnFolders := 0, Recurse := 0) {
	Loop, Parse, % WhichTimeMCA
		FileSetTime, %Time%, %FilePattern%, %A_LoopField%, %OperateOnFolders%, %Recurse%
	return !ErrorLevel
}

;obtener fecha de creacion, modificacion y/o último acceso
;Sintaxis: FileGetTime( [archivo/carpeta], [M/C/A] )
;EJEMPLO:
	;Time := FileGetTime(comspec, "M", obj)
	;MsgBox % Time "`n" obj.Year "`n" obj.Mon "`n" obj.Day "`n" obj.Hour "`n" obj.Min "`n" obj.Sec
	;MsgBox % FileGetTime(comspec).M
FileGetTime(Filename, WhichTime := 0, ByRef ObjTime := "") {
	Filename := RTrim( Filename, "\" ), i := {}
	if WhichTime {
		FileGetTime, Time, %Filename%, %WhichTime%
		if IsByRef( ObjTime )
			FTime := FormatTime( Time )
			, i.Year := SubStr( FTime, 1, 4 ), i.Mon := SubStr( FTime, 5, 2 )
			, i.Day := SubStr( FTime, 7, 2 ), i.Hour := SubStr( FTime, 9, 2 )
			, i.Min := SubStr( FTime, 11, 2 ), i.Sec := SubStr( FTime, 13, 2 )
		return Time, i.Time := Time, ObjTime := i
	}
	i.M := i.ModificationTime := FileGetTime( Filename, "M" )
	i.C := i.CreationTime := FileGetTime( Filename, "C" )
	i.A := i.LastAccessTime := FileGetTime( Filename, "A" )
	return i
}

;recyclar archivo(s) o carpeta(s)
;FileRecycle( [archivo/carpeta], [¿operar en subcarpetas?] )
FileRecycle(FilePattern, Recurse := 0) {
	if !_wildc(FilePattern, Recurse) {
		FilePattern := GetFullPathName( FilePattern )
		FileSetAttrib( "-RS", FilePattern )
		FileRecycle, %FilePattern%
		return !ErrorLevel
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileRecycle( A_LoopFileLongPath ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}

;comprueba si es archivo
;Sintaxis: IsFile( [archivo]  )
IsFile(Filename) {
	return !InStr(i:=FileExist(Filename),"D")&&i
}

;obtener atributos de un archivo o carpeta
;Sintaxis: FileGetAttrib( [Archivo/Carpeta] )
;ATRIBUTOS: ver FileSetAttrib()
FileGetAttrib(lpFileName, ByRef hAttrib := "", ByRef _cpath := "") {
	static List := {"R": 0x1, "A": 0x20, "S": 0x4, "H": 0x2, "N": 0x80, "D": 0x10, "O": 0x1000, "C": 0x800, "T": 0x100, "E": 0x4000, "V": 0x10000}
	if ((hAttrib:=DllCall("Kernel32.dll\GetFileAttributesW", "Str", "\\?\" _cpath(lpFileName, _cpath)))=-1)
		return 0, ErrorLevel := 1
	return _cstr(List, hAttrib, "&", "."), ErrorLevel := 0
}

;cambiar atributo(s)
;Sintaxis: FileSetAttrib( [atributos], [archivos/carpeta], [modo] )
;NOTA: devuelve el número de archivos/carpetas modificadas
;ATRIBUTOS (ejemplo: R-SH+A): 
	;R = solo lectura (modificable)
	;A = archivo | modificado (modificable)
	;S = sistema (modificable)
	;H = oculto (modificable)
	;N = normal (modificable, único)
	;D = directorio | carpeta
	;O = fuera de linea (modificable)
	;C = comprimido
	;T = temporal (modificable)
	;E = encriptado
	;V = virtual
FileSetAttrib(Attributes, FilePattern, Mode := 0, Recurse := 0) {
	static R := 0x1, A := 0x20, S := 0x4, H := 0x2, N := 0x80, O := 0x1000, T := 0x100
	if !_wildc(FilePattern, Recurse)&&(Mode:="+") {
		FileGetAttrib( FilePattern, hAttrib, lpFileName )
		Loop, Parse, % Attributes
			if !InVar(A_LoopField, "R,A,S,H,N,O,T") {
				Mode := A_LoopField="+"||A_LoopField="-"||A_LoopField="^"?A_LoopField:"+"
				continue
			} else
				hAttrib := _mnum(hAttrib, Mode %A_LoopField%)
		return i := DllCall("Kernel32.dll\SetFileAttributesW", "Str",  "\\?\" lpFileName, "UInt", hAttrib)
			, ErrorLevel := !i
	}
	Loop, Files, %FilePattern%, % _clfm(FilePattern, Mode, Recurse, ok)
		ok += FileSetAttrib(Attributes, A_LoopFileLongPath), i := A_Index
	return ok, ErrorLevel := ok!=i
}

SplitPath(InputVar, ByRef OutFileName := "", ByRef OutDir := "", ByRef OutExtension := "", ByRef OutNameNoExt := "", ByRef OutDrive := "") {
	SplitPath, InputVar, OutFileName, OutDir, OutExtension, OutNameNoExt, OutDrive
	i := {}, i.FileName := i.FN := OutFileName ;nombre.ext
		, i.Dir := OutDir ;directorio
		, i.Ext := i.Extension := OutExtension ;extension
		, i.Name := OutNameNoExt ;nombre
		, i.Drive := OutDrive ;unidad
	return i
}

;copiar archivo(s); devuelve el número de archivos copiados
;Sintaxis 1: FileCopy( [archivo], [destino\nombre.ext], [¿sobreescribir?], [¿incluir archivos en subcarpetas?] )
;Sintaxis 2: FileCopy( [directorio\*.*], [destino], [¿sobreescribir?], [¿incluir archivos en subcarpetas?] )
FileCopy(Source, Dest, Overwrite := 0, Recurse := 0) {
	Flags := Overwrite ? 0x00001000 : 0x00000001|0x00001000
	Flags_ := Overwrite ? 0 : 0x00000001, Dest := RTrim( Dest, "\" )
	if !_wildc(Source, Recurse) {
		Source := GetFullPathName( Source )
		_ := IsDir( Dest ) ? Dest "\" SplitPath(Source).FileName : Dest
		if DllCall("Kernel32.dll\CopyFileExW", "Str", "\\?\" Source, "Str", "\\?\" _, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags)
		|| DllCall("Kernel32.dll\CopyFileExW", "Str", "\\?\" Source, "Str", "\\?\" _, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags_)
			return 1, ErrorLevel := 0
		return 0, ErrorLevel := 1
	}
	ok := i := 0
	Loop, Files, %Source%, % Recurse ? "FR" : "F"
		if DllCall("Kernel32.dll\CopyFileExW", "Str", "\\?\" A_LoopFileLongPath, "Str", "\\?\" Dest "\" A_LoopFileName, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags)
		|| DllCall("Kernel32.dll\CopyFileExW", "Str", "\\?\" A_LoopFileLongPath, "Str", "\\?\" Dest "\" A_LoopFileName, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags_)
			ok := ok + 1, i := i + 1
	return ok, ErrorLevel := ok = i ? 0 : 1
}

FileGetShortcut(ShortcutFile, ByRef OutTarget := "", ByRef OutDir := "", ByRef OutArgs := "", ByRef OutDescription := "", ByRef OutIcon := "", ByRef OutIconNum := "", ByRef OutRunState := "") {
	FileGetShortcut, %ShortcutFile%, OutTarget, OutDir, OutArgs, OutDescription, OutIcon, OutIconNum, OutRunState
	return ErrorLevel ? ShortcutFile : OutTarget ? OutTarget : ShortcutFile
}

FileCreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := "", ShortcutKey := "", IconNumber := "", RunState := "") {
	FileCreateShortcut, %Target%, %ShortcutFile%, %WorkingDir%, %Args%, %Description%, %IconFile%, %ShortcutKey%, %IconNumber%, %RunState%
	return !ErrorLevel
}

;dialogo para seleccionar archivos
;Sintaxis: FileSelect( [Archivo/Directorio], [Filtro], [Opciones/VentanaID], [Título de la ventana] )
FileSelect(RootDirFilename := "", Filter := "", Options := 3, Prompt := "") {
	if (StrLen(Options) >= 3) AND IsWindow( Options )
		WinDisable( Options ), i := 1
	FileSelectFile, OutputVar, %Options%, %RootDirFilename%, %Prompt%, %Filter%
	return OutputVar, i:=i?WinEnable(Options):""
}

;dialogo para guardar archivo
;Sintaxis: FileSave( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
FileSave(RootDirFilename := "", Filter := "", Options := 24, Prompt := "") {
	if (StrLen(Options) >= 3) AND IsWindow( Options )
		WinDisable( Options ), i := 1
	FileSelectFile, OutputVar, S%Options%, %RootDirFilename%, %Prompt%, %Filter%
	return OutputVar, i:=i?WinEnable(Options):""
}

;leer archivo
;Sintáxis: FileRead( [Archivo] )
FileRead(Filename) {
	try FileRead, OutputVar, %Filename%
	return OutputVar
}

;leer texto de un número de linea de un archivo
;Sintaxis: FileReadLine( [Archivo], [Linea] )
FileReadLine(Filename, LineNum, Encoding := "") {
	i := FileOpen(Filename, "r", Encoding)
	Loop, % (LineNum - 1)
		i.ReadLine()
	return i.ReadLine(), i.Close()
}

;escribir en un archivo (añadir)
;Sintáxis: FileAppend( [Texto], [Archivo] )
FileAppend(Text, Filename, Encoding := "") {
	FileAppend, %Text%, %Filename%, %Encoding%
	if ErrorLevel {
		FileSetAttrib("-R", Filename)
		FileAppend, %Text%, %Filename%, %Encoding%
	}
	return !ErrorLevel
}

;escribir en un número de linea de un archivo (añadir)
;Sintáxis: FileAppendLine( [Texto], [Archivo], [Número de linea] )
FileAppendLine(Text, Filename, LineNum, Encoding := "") {
	ThisContent := [], FileAppend( "`n", Filename, Encoding )
	Loop, Read, %Filename%
		ThisContent.Push(A_LoopReadLine)
	if (ThisContent.MaxIndex() < LineNum) {
		i := FileOpen(Filename, "a", Encoding)
		Loop, % ( LineNum - ThisContent.MaxIndex() )
			ThisContent.Push(""), i.Write("`n")
		i.Close()
	}
	for k, v in ThisContent
			ThisFileNewText .= k = LineNum ? v Text "`n" : v "`n"
	return FileWrite( RTrim(ThisFileNewText, "`n"), Filename, Encoding)
}

;escribir en un archivo (mismo efecto que eliminar el archivo y volver a crearlo).
;Sintáxis: FileWrite( [Texto], [Archivo] )
FileWrite(Text, Filename, Encoding := "") {
	i := FileOpen2( Filename, "w", Encoding )
	return i.Write( Text ), i.Close()
}
	
;escribir en un número de linea de un archivo (reemplazar linea entera)
;Sintáxis: FileWriteLine( [Texto], [Archivo], [Número de linea] )
FileWriteLine(Text, Filename, LineNum, Encoding := "") {
	ThisContent := [], FileAppend( "`n", Filename, Encoding )
	Loop, Read, %Filename%
		ThisContent.Push(A_LoopReadLine)
	if (ThisContent.MaxIndex() < LineNum) {
		i := FileOpen(Filename, "a", Encoding)
		Loop, % ( LineNum - ThisContent.MaxIndex() )
			ThisContent.Push(""), i.Write("`n")
		i.Close()
	}
	for k, v in ThisContent
			ThisFileNewText .= k = LineNum ? Text "`n" : v "`n"
	return FileWrite( RTrim(ThisFileNewText, "`n"), Filename, Encoding)
}

FileOpen2(file, mode := "rw", encoding := "") {
	i := FileOpen(file, mode, encoding)
	if !IsObject( i ) AND Contains(mode, "w,a")
		FileSetAttrib( "-R", file, 0 )
		, i := FileOpen(file, mode, encoding)
	return i, ErrorLevel := !IsObject( i )
}

FileFNPath(Filename, String := "(%A_Index%)", Add := 1) {
	tmppath := 0, SplitPath( Filename, FullName, Dir, Ext, Name )
	if !Add AND (String = "(%A_Index%)") AND (StrRight(Name) = ")") AND InStr(Name, "(") {
		index := StrTrimLeft( Name, InStr(Name, "(",, -1) )
		index := StrLeft( index, InStr(index, ")") - 1 )
		if IsNumber( index )
			Name := StrTrimRight( Name, 1 + StrLen( index ) + 1 )
	}
	Loop {
		if IsFile( tmppath ? tmppath : Filename ) {
			tmppath := Dir "\" Name ( InStr(String, "%A_Index%") ? StrReplace(String, "%A_Index%", A_Index) : "(" A_Index ")" ) "." Ext
		} else {
			return tmppath ? tmppath : Filename
		}
	}
}

;obtiene informacion sobre un archivo
;EJEMPLOS:
	;MsgBox % FileGetInfo( comspec ).CompanyName
	;MsgBox % FileGetInfo( comspec, "FileDescription" )
FileGetInfo(FileName, InfoType := "") {
	static InfoList := ["Comments","InternalName","ProductName","CompanyName","LegalCopyright","ProductVersion"
		,"FileDescription","LegalTrademarks","PrivateBuild","FileVersion","OriginalFilename","SpecialBuild"]
	;InfoSize := DllCall("Version.dll\GetFileVersionInfoSizeExW", "UInt", 0, "Str", FileName, "Ptr", 0)
	InfoSize := DllCall("Version.dll\GetFileVersionInfoSizeW", "Str", FileName, "Ptr", 0)
	VarSetCapacity(InfoData, InfoSize * 2, 0)
	;DllCall("Version.dll\GetFileVersionInfoExW", "UInt"; 0, "Str", FileName, "UInt", 0, "UInt", InfoSize, "Ptr", &InfoData)
	DllCall("Version.dll\GetFileVersionInfoW", "Str", FileName, "UInt", 0, "UInt", InfoSize, "Ptr", &InfoData)
	DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\VarFileInfo\Translation", "PtrP", aInfoData, "PtrP", InfoSize+1)
	Lang := NumGet(aInfoData+0, "UShort"), CodePage := NumGet(aInfoData+2, "UShort")
	Lang_CodePage := Format( "{:04X}{:04X}", Lang, CodePage)
	if InfoType {
		DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\StringFileInfo\" Lang_CodePage "\" InfoType, "PtrP", aInfoData, "PtrP", InfoSize)
		return StrGet(aInfoData, InfoSize)
	} FileInfo := {}
	for Index, InfoType in InfoList
		if DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\StringFileInfo\" Lang_CodePage "\" InfoType, "PtrP", aInfoData, "PtrP", InfoSize)
			FileInfo[InfoType] := StrGet(aInfoData, InfoSize)
	return FileInfo
}

;obtiene informacion de un archivo (mas lento)
FileGetInfo2(Filename, ValidatePath := 0) {
	Filename := ValidatePath ? FileGetValidPath(Filename) : Filename
	if !IsFile( Filename )
		return "", ErrorLevel := 1
	Filename := StrReplace(Filename, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Datafile WHERE Name = '" Filename "'")
		i.AccessMask := a.AccessMask
		, i.Archive := a.Archive
		, i.Caption := a.Caption
		, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod
		, i.CreationClassName := a.CreationClassName
		, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName
		, i.CSName := a.CSName
		, i.Description := a.Description
		, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName
		, i.Encrypted := a.Encrypted
		, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension
		, i.FileName := a.FileName
		, i.FileSize := a.FileSize
		, i.FileType := a.FileType
		, i.FSCreationClassName := a.FSCreationClassName
		, i.FSName := a.FSName
		, i.Hidden := a.Hidden
		, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount
		, i.LastAccessed := a.LastAccessed
		, i.LastModified := a.LastModified
		, i.ManuFacturer := a.Manufacturer
		, i.Name := a.Name
		, i.Path := a.Path
		, i.Readable := a.Readable
		, i.Status := a.Status
		, i.System := a.System
		, i.Version := a.Version
		, i.Writeable := a.Writeable
	return i, ErrorLevel := !i.Name
}

;obtiene una ruta valida para un archivo
;Útil para cuando la ruta contiene caracteres no permitidos, espacios, parámetros y/o comillas
FileGetValidPath(Filename) {
	Filename := Trim(RegExReplace(Filename, "[Q*/?" Chr(34) "<>|`n\E]"))
	if IsFile( Filename )
		return Filename, ErrorLevel := 0
	if IsFile( i := StrLeft( Filename, InStr( Filename, " " ) - 1 ) )
		return i, ErrorLevel := 0
	Loop, Parse, % Filename, %A_Space%, %A_Tab%
	{
		_ .= (A_Index=1?"":" ") A_LoopField 
		if IsFile( _ )
			return _, ErrorLevel := 0
	}
	return Filename, ErrorLevel := 1
}

;abre un directorio y selecciona el/los archivo(s)
;Sintaxis : FileExplore( [Directorio/Archivo], [Archivos*] )
FileExplore(sPath, Files*) {
	sPath := Trim( sPath )
	if IsFile( sPath )
		SplitPath( sPath, filename, filedir )
		, Files := "", Files := []
		, Files[1] := filename
		, sPath := filedir "\"
	else
		sPath .= SubStr(sPath, 0, 1) = "\" ? "" : "\"
	DllCall("Shell32.dll\SHParseDisplayName", "Str", sPath, "Ptr", 0, "Ptr*", FolderPidl, "UInt", 0, "UInt*", 0)
	VarSetCapacity(PidlArray, Files.MaxIndex() * A_PtrSize, 0)
	for v in Files
		DllCall("Shell32.dll\SHParseDisplayName", "Str", sPath Files[v], "Ptr", 0, "Ptr*", ItemPidl, "UInt", 0, "UInt*", 0)
		, NumPut(ItemPidl, PidlArray, (v - 1) * A_PtrSize) 
	i := DllCall("shell32\SHOpenFolderAndSelectItems", "Ptr", FolderPidl, "UInt", Files.MaxIndex(), "Ptr", &PidlArray, "UInt", 0)
	for i in Files 
		DllCall("Ole32.dll\CoTaskMemFree", "Ptr", NumGet(PidlArray, (i - 1) * A_PtrSize))
	DllCall("Ole32.dll\CoTaskMemFree", "Ptr", FolderPidl)
	if !i AND filename
		return FileExplore2( sPath Files[1]  )
	return i, ErrorLevel := !i
}
FileExplore2(Filename) {
	pszName := RTrim( Trim( pszName ), "\" )
	if !IsFile( Filename )
		return 0, ErrorLevel := 1
	return Run( A_WinDir "\explorer.exe /n,/select," Chr(34) Filename Chr(34) )
}



























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: EJECUTAR ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;ejecutar archivo, abrir carpeta/URL
;Sintáxis: Run( [Archivo], [directorio de trabajo], [opciones], [PID] )
Run(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	if !Contains(Target, Chr(34) ",*,?,/,:,<,>,|")&&FileExist(Target)
		Target := Chr(34) Target Chr(34)
	Run, %Target%, %WorkingDir%, UseErrorLevel %Options%, OutputVarPID
	return ErrorLevel ? 0 : (OutputVarPID ? OutputVarPID : 1)
}

;ejecutar archivo (esperar)
;Sintáxis: RunWait( [Archivo], [directorio de trabajo], [opciones], [PID] )
RunWait(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	if !Contains(Target, Chr(34) ",*,?,/,:,<,>,|")&&FileExist(Target)
		Target := Chr(34) Target Chr(34)
	RunWait, %Target%, %WorkingDir%, UseErrorLevel %Options%, OutputVarPID
	return ErrorLevel ? 0 : (OutputVarPID ? OutputVarPID : 1)
}

;ejecuta como
;Sintáxis: RunAs( [usuario], [contraseña], [dominio|@YourComputerName] )
RunAs(User := "", Password := "", Domain*) {
	if (User="")&&(Password="")&&!Domain.MaxIndex()
		RunAs
	else if Domain.MaxIndex()
		RunAs, %User%, %Password%, % Domain[1]
	else
		RunAs, %User%, %Password%
}

;Sintaxis: Start( [archivo], [parámetros*] ) 
Start(Target := "", Param*) {
	Loop, % Param.MaxIndex()
		_ .= (A_Index=1?"":A_Space) (RegExMatch(Param[A_Index], "\s")?Chr(34) Param[A_Index] Chr(34):Param[A_Index])
	return StrLeft(Target)="*"?RunWait(Chr(34) StrTrimLeft(Target,1) Chr(34) " " _):Run(Chr(34) Target Chr(34) " " _)
}

;abrir propiedades de un archivo/carpeta
;Sintaxis: Properties( [archivo/carpeta], [esperar (segundos)] )
;Nota: para esperar indefinidamente, espesificar 0 (segundo parametro)
;EJEMPLO: i:=Properties( comspec, 0 ) ExitApp()
Properties(Target, WaitClose := -1) {
	if !FileExist(Target)
		return 0, ErrorLevel := 2
	i := Run( "Properties " Chr(34) Target Chr(34) )
	if (WaitClose>-1) {
		WinWaitActive(, 5, "#32770", ProcessExist() )
		return WinWaitClose(, WaitClose, "#32770", ProcessExist() )
	}
	return i, ErrorLevel := !i
}

;esperar a que un archivo exista o no
;Sintaxis: FileWait( [archivo], [segundos], [¿esperar a que no exista?] )
FileWait(FileName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	FileName := GetFullPathName(FileName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsFile(FileName))||(!NotExist&&IsFile(FileName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
	}
}































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: CARPETAS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;eliminar carpeta
;Sintaxis: DirDelete( [carpeta], [¿eliminar archivos y subcarpetas?] )
DirDelete(lpPathName, Recurse := 0) {
	lpPathName := RTrim( Trim( lpPathName ), "\" )
	if !Recurse {
		lpPathName := GetFullPathName( lpPathName )
		return DllCall("Kernel32.dll\RemoveDirectoryW", "Str", "\\?\" lpPathName)
	}
	FileRemoveDir, %lpPathName%, %Recurse%
	return !ErrorLevel
}

;eliminar carpeta(s) al reiniciar
DirRDelete(FilePattern, Recurse := 0) {
	ok := 0
	Loop, Files, %FilePattern%, % Recurse ? "DR" : "D"
		error := !DllCall("Kernel32.dll\MoveFileExW", "Str", "\\?\" A_LoopFileLongPath, "Ptr", 0, "UInt", 0x4)
		, ok := error ? ok : ok + 1
	return ok, ErrorLevel := error
}

;eliminar carpeta de forma segura
;Sintáxis: DirSDelete( [carpeta], [pasadas] )
DirSDelete(Filename, Pases := 1) {
	Filename := RTrim(Filename, "\")
	ok := FileSDelete( Filename "\*.*", Pases, 1 )
	ok := FileSetTime( 2000, Filename, "MAC", 2 ) + ok
	return DirDelete(Filename, 1) + ok
}

;renombrar carpeta(s)
;Sintaxis: Rename( [Carpeta], [Nuevo Nombre], [¿Incluir carpetas en subdirectorios?] )
DirRename(Source, NewName, Recurse := 0) {
	ValidateName( NewName ), ok := 0
	if (NewName = "")
		return 0
	Loop, Files, %Source%, % Recurse ? "DR" : "D"
		SplitPath( A_LoopFileLongPath,, Dir )
		, ok += DirMove( A_LoopFileLongPath, Dir "\" NewName, "R")
	return ok, ErrorLevel := !ok
}

;Mover carpeta
DirMove(Source, Dest, Flag := "") {
	Source := RTrim(Source, "\"), Dest := RTrim(Dest, "\")
	FileMoveDir, %Source%, %Dest%, %Flag%
	return !ErrorLevel
}

;copiar carpeta
DirCopy(Source, Dest, Flag := 0) {
	Source := RTrim(Source, "\"), Dest := RTrim(Dest, "\")
	FileCopyDir, %Source%, %Dest%, %Flag%
	return !ErrorLevel
}

;crear carpeta
;devuelve el número de carpetas creadas (+subcarpetas)
DirCreate(lpPathName) {
	ok := 0, ValidatePath( lpPathName )
	if IsDir( lpPathName )
		return 1, ErrorLevel := 0
	Loop, Parse, % lpPathName, \, %A_Space%
	{
		path .= A_LoopField "\"
		if (A_Index > 1)
			ok += DllCall("Kernel32.dll\CreateDirectoryW", "Str", "\\?\" RTrim(path, "\"), "Ptr", 0)
	}
	return ok, ErrorLevel := !ok
}

;dialogo: seleccionar carpeta
;Sintaxis: DirSelect( [Directorio], [Opciones/VentanaID], [Título] )
DirSelect(StartingFolder := "", Options := 1,  Prompt := "") {
	if (StrLen(Options) >= 3) AND IsWindow( Options )
		WinDisable( Options ), i := 1
	FileSelectFolder, OutputVar, %StartingFolder%, %Options%, %Prompt%
	return RTrim( OutputVar, "\" ), i:=i?WinEnable(Options):""
}

;comprueba si es carpeta
;Sintaxis: IsDir( [carpeta] )
IsDir(DirName) {
	return InStr(FileExist(DirName),"D")
}
IsFolder(DirName) {
	return InStr(FileExist(DirName),"D")
}

;comprueba si el directorio existe
;transforma la ruta en su forma larga (FilePattern)
DirExist(ByRef FilePattern, Recurse := 0) {
	FilePattern := RTrim( FilePattern, "\" )
	Loop, Files, %FilePattern%, % Recurse ? "DR" : "D"
		return FilePattern := A_LoopFileLongPath
	return 0
}

;abrir carpeta con explorer.exe
;Sintaxis: DirOpen( [carpeta], [abrir en una nueva ventana] ) 
DirOpen(Dir, NewWindow := 0) {
	if !DirExist( Dir )
		return 0
	return Run( A_WinDir "\explorer.exe " (NewWindow?"/n,":"") Chr(34) Dir Chr(34) )
}

;obtiene informacion sobre un directorio
;EJEMPLO: MsgBox % DirGetInfo( A_WinDir ).CSName
DirGetInfo(Dirname, ValidatePath := 0) {
	ComObjError( false )
	if !DirExist( Dirname )
		return "", ErrorLevel := 1
	Dirname := StrReplace(Dirname, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Directory WHERE Name = '" Dirname "'")
		i.AccessMask := a.AccessMask
		, i.Archive := a.Archive
		, i.Caption := a.Caption
		, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod
		, i.CreationClassName := a.CreationClassName
		, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName
		, i.CSName := a.CSName
		, i.Description := a.Description
		, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName
		, i.Encrypted := a.Encrypted
		, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension
		, i.FileName := a.FileName
		, i.FileSize := a.FileSize
		, i.FileType := a.FileType
		, i.FSCreationClassName := a.FSCreationClassName
		, i.FSName := a.FSName
		, i.Hidden := a.Hidden
		, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount
		, i.LastAccessed := a.LastAccessed
		, i.LastModified := a.LastModified
		, i.Name := a.Name
		, i.Path := a.Path
		, i.Readable := a.Readable
		, i.Status := a.Status
		, i.System := a.System
		, i.Version := a.Version
		, i.Writeable := a.Writeable
	return i, ErrorLevel := !i.Name
}

;esperar a que un directorio exista o no
;Sintaxis: DirWait( [directorio], [segundos], [¿esperar a que no exista?] )
DirWait(DirName, Seconds := 0, NotExist := 0) {
	if (Seconds=-1)
		return 0
	DirName := GetFullPathName(DirName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsDir(DirName))||(!NotExist&&IsDir(DirName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
	}
}





















































/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: NÚMEROS & OPERACIONES MATEMÁTICAS ::::::::::::::::::::::::::::::::::
Links:
	• http://ahkscript.org/boards/viewtopic.php?t=3925
	• https://dl.dropboxusercontent.com/u/186419968/html/BaseConversion/index.html
Nota: algunas operaciones aceptan números de mas de 18 cifras, para ello, el número debe estar encerrado entre comillas (cadena).
	Ejemplo (suma): MsgBox % "Normal: " (9999999999999999999+1) " (ERROR)`nAdd(): " Add("9999999999999999999", 1) " (OK)"
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
;elevar un numero (potenciación)
;Sintaxis: Power( [base], [exponente] )
;Ejemplo: Power(99, 999)
;NOTA: evitar números de 4 cifras o mas (muy lento)
Power(Base, Exponent) {
	SLB := StrLen(Base), VarSetCapacity(B, SLB, 0)
	Loop, Parse, % Base
		NumPut(A_LoopField, B, SLB - A_Index, "UChar")
	VarSetCapacity(P, SLB, 0)
	DllCall("RtlMoveMemory", "Ptr", &P, "Ptr", &B, "Ptr", PL := SLB)
	Loop, % (Exponent - 1) {
		V := 0, VarSetCapacity(R, RL := PL + SLB + 1, 0)
		Loop, %SLB% { ; multiply
			If (I := NumGet(B, A_Index - 1, "UChar")) {
				Loop, %PL%
					N := NumGet(R, J := A_Index + V - 1, "UChar") + (NumGet(P, A_Index - 1, "UChar") * I)
					, NumPut(SubStr(N, 0), R, J++, "UChar")
					, NumPut(NumGet(R, J, "UChar") + SubStr("0" . N, -1, 1), R, J, "UChar")
			} V++
		} VarSetCapacity(P, RL, 0), DllCall("RtlMoveMemory", "Ptr", &P, "Ptr", &R, "Ptr", PL := RL)
		while !NumGet(P, PL - 1, "UChar") ; remove trailing zeroes
			PL--
	} VarSetCapacity(V, RL, 0)
	Loop, %RL%
		V .= NumGet(R, --RL, "UChar")
	return LTrim(V, "0")
} ;http://ahkscript.org/boards/viewtopic.php?p=49693#p49693

;convierte cualquier número a la forma perfecta, es decir, elimina ceros adicionales y agrega requeridos.
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
Prefect(num) {
	if !num
		return 0
	if InStr(num, "-")
		num := Substr(num, 2), neg := "-"
	if InStr(num, ".") {
		num := Trim(num, 0)
		if (Substr(num, 1, 1) = ".")
			num := "0" num
		if (Substr(num, 0) = ".")
			num := Substr(num, 1, -1)
		return neg num
	} else
		return Trim(num, 0)?neg LTrim(num, 0):0
}

;redondear un número
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
RoundEx(num, places := 0) {
	if !(dot:=InStr(num, "."))
		return num
	ndec := ((len:=StrLen(num))-dot)=0?len:dot
	if (ndec>places) {
		if ((dig:=Substr(num, dot+places+1, 1))>=5)
			Loop, % (places-1)
				z .= "0"
		num := Add(Substr(num, 1, InStr(num, ".")+places), (dig>=5)?"0." z "1":"0")
	} else {
		Loop, % (places-ndec)
			z .= "0"
		num .= z
	}
	return Rtrim(num, ".")
}

;multiplicar dos números.
;Sintaxis: Multiply( [(-)valor 1], [(-)valor2] )
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
Multiply(num1, num2) {
	ps := (mnum2:=InStr(num2, "-"))?0:1
	, ps := (mnum1:=InStr(num1, "-"))?!ps:ps
	, num1 := SubStr(num1, mnum1?2:1)
	, num2 := Substr(num2, mnum2?2:1)
	, dec := (dot1:=InStr(num1, "."))?StrLen(num1)-dot1:0
	, dec := (dot2:=InStr(num2, "."))?dec+StrLen(num2)-dot2:dec
	, num1 := StrReplace(num1, "."), num2 := StrReplace(num2, ".")
	Loop, % StrLen(num2)
		tnum2 .= SubStr(num2, 1-A_Index, 1)
	num2 := tnum2, pr := "0"
	Loop, Parse, % num2
	{
		rw := "0", zr := ""
		if A_LoopField
			Loop, %A_LoopField%
				rw := Add(rw, num1)
		else
			Loop, % (StrLen(num1)-1)
				rw .= "0"
		Loop, % (A_Index-1)
			zr .= "0"
		rw .= zr, pr := Add(pr, rw)
	}
	if dec
		pr := Prefect(SubStr(pr, 1, StrLen(pr)-dec) "." SubStr(pr, 1-dec))
	return (ps?"":"-") pr
}

;comprueba si num1>num2. si el 3er parametro es verdadero, devuelve 1 si ambos números son iguales.
;Sintaxis: IsGreater( [valor mayor], [valor menor], [param3] )
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
IsGreater(num1, num2, teq := false) {
	neg1 := InStr(num1, "-"), neg2 := InStr(num2, "-")
	if !neg1&&neg2
		return true
	if neg1&&!neg2
		return false
	num1 := Prefect(num1), num2 := Prefect(num2)
	, dot1 := InStr(num1, "."), dot2 := InStr(num2, ".")
	, dec1 := dot1?StrLen(num1)-dot1:0
	, dec2 := dot2?StrLen(num2)-dot2:0
	if (dec1>dec2)
		Loop, % (dec1-dec2)
			num2 .= "0"
	else if (dec2 > dec1)
		Loop, % (dec2-dec1) 
			num1 .= "0"
	num1 := StrReplace(num1, "."), num2 := StrReplace(num2, ".")
	if ((len1:=StrLen(num1))>(len2:=StrLen(num2)))
		return neg1?0:1
	else if (len2>len1)
		return neg1?1:0
	else
		Loop {
			if ((sub1:=SubStr(num1, A_Index, 1))>(sub2:=Substr(num2, A_index, 1)))
				return neg1?0:1
			else if (sub2>sub1)
				return neg1?1:0
			else if (A_Index=len1)
				return teq?1:0
		}
}

;sumar o restar dos números. para restar, agregar '-' al inicio del segundo número.
;Sintaxis: Add( [(-)valor 1], [(-)valor2] )
;Ejemplo: Add("99999999999999999999999999999999999999", "9999999999999")
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
Add(num1, num2, Prefect := false) {
	count := (dneg2:=InStr(num2, "--"))?2:InStr(num2, "-")?1:0
	, count := count+((neg1:=InStr(num1, "-"))?1:0)
	, cnum1 := num1, cnum2 := num2
	, num1 := StrReplace(num1, "-"), num2 := StrReplace(num2, "-")
	, dec1 := (dot1:=InStr(num1, "."))?StrLen(num1)-dot1:0
	, dec2 := (dot2:=InStr(num2, "."))?StrLen(num2)-dot2:0
	if (dec1>dec2) {
		dec := dec1
		Loop, % (dec1-dec2)
			num2 .= "0"
	} else if (dec2>dec1) {
		dec := dec2
		Loop, % (dec2-dec1)
			num1 .= "0"
	} else
		dec := dec1
	num1 := StrReplace(num1, "."), num2 := StrReplace(num2, ".")
	if ((len1:=StrLen(num1))>=(len2:=StrLen(num2)))
		Loop, % (len1-len2)
			num2 := "0" num2
	else
		Loop, % (len2-len1)
			num1 := "0" num1
	if (count!=1&&count!=3)&&((len1:=StrLen(num1))!="*") {
		Loop {
			digit := SubStr(num1, 1-A_Index, 1)+SubStr(num2, 1-A_index, 1)+(cr?1:0)
			if (A_Index=len1) {
				sm := digit sm
				break
			} else if (digit>9)
				cr := true, digit := SubStr(digit, 0, 1)
			else
				cr := false
			sm := digit sm
		}
		if neg1&&InStr(cnum2, "-")
			sm := "-" sm
	} else if ((len1:=StrLen(num1))!="*") {
		if !(nc:=IsGreater(num1, num2, true))
			tnum2 := num2, num2 := num1, num1 := tnum2
		Loop {
			digit := SubStr(num1, 1-A_Index, 1)-SubStr(num2, 1-A_index, 1)+(bw?-1:0)
			if (A_Index=len1) {
				sm := StrReplace(digit, "-") sm
				break
			} else if InStr(digit, "-")
				bw := true, digit += 10
			else
				bw := false
			sm := digit sm
		}
		if ((dneg2||InStr(cnum1, "-"))&&nc)||(InStr(cnum2, "-")&&!nc)
			sm := "-" sm
	}
	if (sm = "-")
		sm := 0
	sm := dec&&sm?SubStr(sm, 1, StrLen(sm)-dec) "." SubStr(sm, 1-dec):sm
	return Prefect?Prefect(sm):sm
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;obtiene el mayor numero
;EJEMPLO: MsgBox % Max( 7, 9, 0, -11, 6, 3, 5, 8 ) "`n" Max( "5,2,8,-44,7" )
Max(n*) {
	n := n.MaxIndex() = 1 ? StrSplit( n[1], ",", A_Space ) : n, _ := n[1]
	Loop, % n.MaxIndex()
		_ := _ < n[A_Index+1] ? n[A_Index+1] : _
	return _
}

;obtiene el menor numero
;EJEMPLO: MsgBox % Min( 7, 9, 0, 222, -0.2 ) "`n" Min( "5,2,8,-44,7" )
Min(n*) {
	n := n.MaxIndex() = 1 ? StrSplit( n[1], ",", A_Space ) : n, _ := n[1]
	Loop, % n.MaxIndex()
		_ := _ > n[A_Index+1] ? (n[A_Index+1] = "" ? _ : n[A_Index+1]) : _
	return _
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;if [value] between [low] [high]
;comprueba si un número esta contenido entre otros dos valores (inclusive)
;Sintaxis: Between( [número], [valor menor], [valor mayor], [valor a excluir] ) 
Between(value, low, high, nval := "") {
    return value>=low&&value<=high?(nval=""?1:value!=nval):0
}

;si el número es par devuelve 1, caso contrario 0 (impar)
IsEven(num) {
	return !(num&1)
}

;determina si es Número
;Sintaxis: IsNumber( [número], [carácteres no permitidos separados por coma] )
;EJEMPLO: MsgBox % IsNumber(-23.02) "`n" IsNumber("*1") "`n" IsNumber(-1) "`n" IsNumber(0xF,"*") "`n" IsNumber(+1)
IsNumber( num, IfChars := "*,x" ) {
	return Contains(num,IfChars)||(num+1)=""?0:1
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir a hexadecimal
;Sintaxis: Hex( [número], [max prefijo 0], [¿mayúscula?] )
Hex(int, max := 0, may := 0) {
	return max = 0 ? Format("0x{:" (may ? "X" : "x") "}", int)
		: Format("0x{:" 0 LTrim(max,0) (may ? "X" : "x") "}", int)
}

;convertir a Unsigned Integer
;Sintaxis: Int( [número], [¿Signed?] )
Int(hex, Signed := 0) {
	return Format("{:" (Signed ? "d" : "u") "}", hex)
}

;convertir a RGB
RGB(Color) {
	Color := (Color & 255) << 16 | (Color & 65280) | (Color >> 16), Color := SubStr(Color, 1)
	return Hex( Color,, 1 )
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir entero a hexadecimal
IntToHex(int) {
    HEX_INT := 8
    while (HEX_INT--) {
        n := (int >> (HEX_INT * 4)) & 0xf
        h .= n > 9 ? chr(0x37 + n) : n
        if (HEX_INT == 0 && HEX_INT//2 == 0)
            h .= " "
    }
    return "0x" h
}

;convertir binario a octal
BinToOct(Bin) {
    i := Oct := Dec := 0
    while (Bin != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		}
        Dec += Mod(Bin, 10) * z
        i++
        Bin /= 10
    }
    i := 1
    while (Dec != 0) {
        Oct += Mod(Dec, 8) * i
        Dec /= 8
        i *= 10
    }
    return Oct
}

;convertir binario a decimal
BinToDec(Bin) {
    i := Dec := 0
    while (Bin != 0) {
        rem := Mod(Bin, 10)
		Bin /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		}
        Dec += rem * z
		i++
    }
    return Dec
}

;convertir decimal a binario
DecToBin(Dec) {
    Bin := !(i:=1)
    while (Dec != 0) {
        rem := Mod(Dec, 2)
        Dec /= 2
        Bin += rem * i
        i *= 10
	}
    return Bin
}

;convertir decimal a hexadecimal
DecToHex(Dec) {
    VarSetCapacity(s, 66, 0)
    value := DllCall("msvcrt.dll\_wcstoui64", "Str", 119, "UInt", 0, "UInt", Dec, "CDECL Int64")
    DllCall("msvcrt.dll\_i64tow", "Int64", value, "Str", s, "UInt", 16, "CDECL")
    return s
}

;convertir decimal a octal
DecToOct(Dec) {
    Oct := !(i:=1)
    while (Dec > 0) {
        rem := Mod(Dec, 8)
        Dec /= 8
        Oct += rem * i
        i *= 10
    }
    return Oct
}

;convertir octal a decimal
OctToDec(Oct) {
    i := Dec := 0
    while (Oct != 0) {
        rem := Mod(Oct, 10)
        Oct /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		}
        Dec += rem * z
        i++
    }
    return Dec
}

;convertir octal a binario
OctToBin(Oct) {
    i := Dec := Bin := 0
    while (Oct != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		}
        Dec += Mod(Oct, 10) * z
        i++
        Oct /= 10
    }
    i := 1
    while (Dec != 0) {
        Bin += Mod(Dec, 2) * i
        Dec /= 2
        i *= 10
    }
    return Bin
}

;convertir hexadecimal a decimal
HexToDec(Hex) {
    VarSetCapacity(s, 66, 0)
    value := DllCall("msvcrt.dll\_wcstoui64", "Str", 77, "UInt", 0, "UInt", Hex, "CDECL Int64")
    DllCall("msvcrt.dll\_i64tow", "Int64", value, "Str", s, "UInt", 10, "CDECL")
    return s
}

;convertir hexadecimal a cadena de carácteres
HexToStr(Hex) {
    Loop, Parse, % Hex, %A_Space%, %A_Tab%
        char .= Chr(DllCall("msvcrt.dll\_wcstoui64", "Str", A_LoopField, "Uint", 0, "UInt", 16, "CDECL Int64"))
    return char
}

;convertir hexadecimal a RGB
HexToRGB(Hex) {
    H := InStr(Hex, "0x") ? Hex : (InStr(Hex, "#") ? "0x" SubStr(Hex, 2) : "0x" Hex)
    return (H & 0xFF0000) >> 16 "," (H & 0xFF00) >> 8 "," (H & 0xFF)
}

;convertir RGB a hexadecimal
;Sintaxis: RGBToHex( [rojo], [verde], [azul], [prefijo 1(#)|2(0x)|0] )
RGBToHex(R, G, B, H := 1) {
    H := ((H = 1) ? "#" : ((H = 2) ? "0x" : ""))
    VarSetCapacity(Hex, 17 << !!A_IsUnicode, 0)
    DllCall("Shlwapi.dll\wnsprintf", "Str", Hex, "Int", 17, "Str", "%016I64X", "UInt64", (R << 16) + (G << 8) + B, "Int")
    return H SubStr(Hex, StrLen(Hex) - 6 + 1)
}

;convertir cadena de carácteres a hexadecimal
StrToHex(Str) {
    Loop, Parse, % Str
        VarSetCapacity(s, 65, 0)
        , DllCall("msvcrt.dll\_i64tow", "Int64", Asc(A_LoopField), "Str", s, "UInt", 16, "CDECL")
        , hex .= "0x" s " "
    return SubStr(hex, 1, (StrLen(hex) - 1))
}

;Convierte una cadena que representa un número decimal o hexadecimal a un entero
StrToInt(String, Flags := 0) {
	DllCall("shlwapi.dll\StrToIntEx", "Ptr", &String, "Int", Flags, "Int*", Ret)
	return Ret
}

;Convierte una cadena que representa un valor decimal o hexadecimal a un entero de 64 bits
StrToInt64(String, Flags := 0) {
	DllCall("shlwapi.dll\StrToInt64Ex", "Ptr", &String, "Int", Flags, "Int64*", Ret)
	return Ret
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir tiempo. hora, minuto, segundo, milisegundo, dias, mes, año.
;Sintaxis: ConvertTime( [tiempo], [de], [a], [decimales 0~14] )
;Uso: ConvertTime( [h:m:s|hora|min|seg|ms|dia|mes|año], [time|hour|min|sec|ms|day|mon|year], [hour|min|sec|ms|day|mon|year] )
;EJEMPLOS (ver funcion): MsgBox % ConvertTime( 0xFFF, "ms", "sec", 0 )
ConvertTime(time, from, to, Places := 2) {
	;--------------------------------------------------------------------------------------------------------------------------------
	;tiempo: ConvertTime( "01:60:3600", "time", "hour" ) ;1hora 60min 3600seg = 3horas
	if (from = "time")
		RegExMatch(time, "(?<h>\d+):(?<m>\d+):(?<s>\d+)", _)
		, time_hour := _h+(_m/60)+(_s/3600), time_min := (_h*60)+_m+(_s/60)
		, time_sec := (_h/3600)+(_m*60)+_s, time_ms := (_h*3600000)+(_m*60000)+(_s*1000)
		, time_day := (_h/24)+(_m/1440)+(_s/86400), time_mon := (_h/730.484398)+(_m/43829.0639)+(_s/2629743.83)
		, time_year := (_h/8765.81277)+(_m/525948.766)+(_s/31556926)
	;--------------------------------------------------------------------------------------------------------------------------------
	;milisegundos: ConvertTime( 60000, "ms", "min" ) ;60000ms = 1min
	else if (from = "ms")
		ms_hour := time/3600000, ms_min := time/60000, ms_sec := time*0.001
		, ms_day := time/86400000, ms_mon := time/2629743830, ms_year := time/31556926000
	;--------------------------------------------------------------------------------------------------------------------------------
	;segundos: ConvertTime( 3600, "sec", "min" ) ;3600seg = 60minutos
	else if (from = "sec")
		sec_hour := time/3600, sec_min := time/60, sec_ms := time*1000
		, sec_day := time/86400, sec_mon := time/2629743.83, sec_year := time/31556926
	;--------------------------------------------------------------------------------------------------------------------------------
	;minutos: ConvertTime( 1, "min", "sec" ) ;1min = 60seg
	else if (from = "min")
		min_hour := time/60, min_sec := time*60, min_ms := time*60000
		, min_day := time/1440, min_mon := time/43829.0639, min_year := time/525948.766
	;--------------------------------------------------------------------------------------------------------------------------------
	;horas: ConvertTime( 2, "hour", "min" ) ;2horas = 120min
	else if (from = "hour")
		hour_min := time*60, hour_sec := time*3600, hour_ms := time*3600000
		, hour_day := time/24, hour_mon := time/730.484398, hour_year := time/8765.81277
	;--------------------------------------------------------------------------------------------------------------------------------
	;días: ConvertTime( 1, "day", "hour" ) ;1dia = 24horas
	else if (from = "day")
		day_hour := time*24, day_min := time*1440, day_sec := time*86400, day_ms := time*86400000
		, day_mon := time/30, day_year := time/365.242199
	;--------------------------------------------------------------------------------------------------------------------------------
	;mes: ConvertTime( 1, "mon", "hour" ) ;1mes = 730,48horas
	else if (from = "mon")
		mon_hour := time*730.484398, mon_min := time*43829.0639, mon_sec := time*2629743.83, mon_ms := time*2629743830
		, mon_day := time*30, mon_year := time/12
	;--------------------------------------------------------------------------------------------------------------------------------
	;año: ConvertTime( 1, "year", "mon" ) ;1año = 12meses
	else if (from = "year")
		year_hour := time*8765.81277, year_min := time*525948.766, year_sec := time*31556926, year_ms := time*31556926000
		year_day := time*365.242199, year_mon := time*12
	;--------------------------------------------------------------------------------------------------------------------------------
	return Round(%from%_%to%, Places)
}

;añadir marca decimal a un numero (coma o punto, por defecto: automatico dependiendo del idioma del sistema)
;Sintaxis: FormatNumComma( [número], [codigo de idioma o espesificar un punto o una coma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;EJEMPLO: MsgBox % FormatNumComma( 1000000 ) ;1.000.000 | 1,000,000
FormatNumComma(lpValue, Locale := 0x0400) {
	Locale := Locale="."?0x0456:Locale=","?0x0409:!Locale?0x0400:Locale
	if !(cchNumber := DllCall("kernel32.dll\GetNumberFormatEx", "UInt", Locale, "UInt", 0, "Str", lpValue, "Ptr", 0, "Ptr", 0, "Int", 0))
		cchNumber := DllCall("kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", lpValue, "Ptr", 0, "Ptr", 0, "Int", 0)
    VarSetCapacity(lpNumberStr, cchNumber * 2)
    if !DllCall("kernel32.dll\GetNumberFormatEx", "UInt", Locale, "UInt", 0, "Str", lpValue, "Ptr", 0, "Str", lpNumberStr, "Int", cchNumber)
		DllCall("kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", lpValue, "Ptr", 0, "Str", lpNumberStr, "Int", cchNumber)
    return SubStr(lpNumberStr, 1, StrLen(lpNumberStr) - 3)
}

;saca el promedio
NumAverage(num*) {
	Sum := 0, num := num.MaxIndex()=1?StrSplit(num[1], ","):num
	Loop, % num.MaxIndex()
		Sum += num[A_Index]
	return Sum/(num.MaxIndex()+0.0)
}

Random(Min, Max) {
	Random, OutputVar, %Min%, %Max%
	return OutputVar
}




































































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: RECURSOS (.EXE & .DLL) ::::::::::::::::::::::::::::::::::
;NOTA: sin terminar.
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
ResourceOpen(FileName := "*", Free := false) {
	static ResTypes := {1: "RT_CURSOR", 2: "RT_BITMAP", 3: "RT_ICON", 4: "RT_MENU", 5: "RT_DIALOG", 23: "RT_HTML"
	, 6: "RT_STRING", 7: "RT_FONTDIR", 8: "RT_FONT", 9: "RT_ACCELERATOR", 10: "RT_RCDATA", 22: "RT_ANIICON"
	, 11: "RT_MESSAGETABLE", 12: "RT_GROUP_CURSOR", 14: "RT_GROUP_ICON", 15: "RT_NAMETABLE"
	, 16: "RT_VERSION", 17: "RT_DLGINCLUDE", 19: "RT_PLUGPLAY", 20: "RT_VXD", 21: "RT_ANICURSOR"}
	static ResNames := {"RT_CURSOR": 1, "RT_BITMAP": 2, "RT_ICON": 3, "RT_MENU": 4, "RT_DIALOG": 5, "RT_HTML": 23
	, "RT_STRING": 6, "RT_FONTDIR": 7, "RT_FONT": 8, "RT_ACCELERATOR": 9, "RT_RCDATA": 10, "RT_ANIICON": 22
	, "RT_MESSAGETABLE": 11, "RT_GROUP_CURSOR": 12, "RT_GROUP_ICON": 14, "RT_NAMETABLE": 15
	, "RT_VERSION": 16, "RT_DLGINCLUDE": 17, "RT_PLUGPLAY": 19, "RT_VXD": 20, "RT_ANICURSOR": 21}
	static CurrentFileName, hFile
	if (FileName="*") {
		if !Free {
			if hFile 
				return hFile, ErrorLevel := 0
		} else if (Free=1) {
			return ResTypes, ErrorLevel := 0
		} else if (Free=2) {
			return ResNames, ErrorLevel := 0
		} else if (Free=3) {
			if CurrentFileName
				return CurrentFileName, ErrorLevel := 0
		}
	} else if Free||(FileName="free") {
		if hFile {
			ResourceEnumLanguages(-1,0), ResourceEnumTypes(-1), ResourceEnumNames(-1,0)
			, ResourceCopy("end", true), ResourceAdd("end", true), ResourceDelete("end", true)
			return FreeLibrary(hFile), CurrentFileName:=hFile:=""
		}
	} else if FileExist(FileName) {
		if (FileName!=CurrentFileName) {
			if hFile
				ResourceCopy("end", true), ResourceAdd("end", true), ResourceDelete("end", true)
				, FreeLibrary(hFile)
			return hFile:=LoadLibrary(CurrentFileName:=FileName,, 0x2)
		}
	}
	return 0, ErrorLevel := 1 
}

ResourceEnumTypes(ByRef StringTypes := "", ByRef Total := "", Delimiter := "`n") {
	static lpEnumFunc
	if (StringTypes=-1)
		return lpEnumFunc?DllCall("Kernel32.dll\GlobalFree", "Ptr", lpEnumFunc):0, lpEnumFunc:=""
	if !(hModule:=ResourceOpen())
		return 0
	if !lpEnumFunc
		lpEnumFunc := RegisterCallback("EnumResTypeProc", "Fast", 3)
	Param := {Index: 0, ResourceTypes: "", Delimiter: Delimiter, StringTypes: [], EnableST: IsByRef(StringTypes)}
	, DllCall("Kernel32.dll\EnumResourceTypesW", "Ptr", hModule, "Ptr", lpEnumFunc, "Ptr", &Param)
	return RTrim(Param.ResourceTypes, Delimiter ""), Total := Param.Index, StringTypes := Param.StringTypes
}
EnumResTypeProc(hModule, lpszType, lParam) {
	static ResTypes := ResourceOpen(, 1)
	Param := Object(lParam)
	if ResTypes[lpszType] {
		Param.Index++
		Param.ResourceTypes .= lpszType Param.Delimiter
		if Param.EnableST
			Param.StringTypes[Param.Index] .= ResTypes[lpszType]
	}
	return true
}

ResourceEnumNames(ResourceType, ByRef Total := "", Delimiter := "`n") {
	static ResTypes := ResourceOpen(, 2)
	static lpEnumFunc
	if (ResourceType=-1)
		return lpEnumFunc?DllCall("Kernel32.dll\GlobalFree", "Ptr", lpEnumFunc):0, lpEnumFunc := ""
	if !(hModule:=ResourceOpen())
		return 0
	if !lpEnumFunc
		lpEnumFunc := RegisterCallback("EnumResNameProc", "Fast", 4)
	Param := {Index: 0, ResourceNames: "", Delimiter: Delimiter}
	, DllCall("Kernel32.dll\EnumResourceNamesW", "Ptr", hModule
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType, "Ptr", lpEnumFunc, "Ptr", &Param)
	return RTrim(Param.ResourceNames, Delimiter ""), Total := Param.Index
} ;http://ahkscript.org/boards/viewtopic.php?f=5&t=8659
EnumResNameProc(hModule, lpszType, lpszName, lParam) {
	Param := Object(lParam)
	if lpszName
		Param.Index += 1
		, Param.ResourceNames .= lpszName Param.Delimiter 
	return true
}

ResourceSize(ResourceType, ResourceName) {
	static ResTypes := ResourceOpen(, 2)
	if !(hModule:=ResourceOpen())
		return 0
	hRes := DllCall("Kernel32.dll\FindResourceW", "Ptr", hModule, "Ptr", ResourceName+1=""?&ResourceName:ResourceName
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType)
	return DllCall("Kernel32.dll\SizeofResource", "Ptr", hModule, "Ptr", hRes)
}

ResourceEnumLanguages(ResourceType, ResourceName, ByRef Total := "", Delimiter := "`n") {
	static ResTypes := ResourceOpen(, 2)
	static lpEnumFunc
	if (ResourceType=-1)
		return lpEnumFunc?DllCall("Kernel32.dll\GlobalFree", "Ptr", lpEnumFunc):0
	if !(hModule:=ResourceOpen())
		return 0
	if !lpEnumFunc
		lpEnumFunc := RegisterCallback("EnumResLangProc", "Fast", 5)
	Param := {Index: 0, ResourceLanguages: "", Delimiter: Delimiter}
	DllCall("Kernel32.dll\EnumResourceLanguagesW", "Ptr", hModule
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType
		, "Ptr", ResourceName, "Ptr", lpEnumFunc, "Ptr", &Param)
	return Param.ResourceLanguages=""?0x0000:RTrim(Param.ResourceLanguages, Delimiter ""), Total := Param.Index
}
EnumResLangProc(hModule, lpszType, lpszName, wIDLanguage, lParam) {
	Param := Object(lParam)
	if lpszName
		Param.ResourceLanguages .= wIDLanguage Param.Delimiter
	return true
}

ResourceCopy(FileName, OutputResourceType := 0, OutputResourceName := 1, InputResourceType := "", InputResourceName := "") {
	static ResTypes := ResourceOpen(, 2)
	static hUpdateResource, hFile
	if !(hModule:=ResourceOpen())
		return 0
	if (FileName="end")
		return hUpdateResource?DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hUpdateResource, "Int", OutputResourceType?1:0):0, hUpdateResource := ""
	FileName := FileName="*"?hFile:FileName, InputResourceType := InputResourceType=""?OutputResourceType:InputResourceType
	, InputResourceName := InputResourceName=""?OutputResourceName:InputResourceName
	if hUpdateResource&&(hFile!=FileName)
		DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hUpdateResource, "Int", true), hUpdateResource := ""
	hResource := DllCall("Kernel32.dll\FindResourceW", "Ptr", hModule, "Ptr", OutputResourceName
		, "Ptr", ResTypes[OutputResourceType]>0?ResTypes[OutputResourceType]:OutputResourceType)
	hResourceLoad := DllCall("Kernel32.dll\LoadResource", "Ptr", hModule, "Ptr", hResource)
	lpResourceLock  := DllCall("Kernel32.dll\LockResource", "Ptr", hResourceLoad)
	hUpdateResource := hUpdateResource?hUpdateResource:DllCall("Kernel32.dll\BeginUpdateResourceW", "Str", FileName, "Int", false)
	return DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hUpdateResource
		, "Ptr", ResTypes[InputResourceType]>0?ResTypes[InputResourceType]:InputResourceType
		, "Str", InputResourceName, "UShort", ResourceEnumLanguages(OutputResourceType, OutputResourceName), "Ptr", lpResourceLock
		, "UInt", DllCall("Kernel32.dll\SizeofResource", "Ptr", hModule, "Ptr", hResource)) ? 1
		: DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hUpdateResource
		, "Ptr", ResTypes[InputResourceType]>0?ResTypes[InputResourceType]:InputResourceType
		, "Ptr", InputResourceName, "UShort", ResourceEnumLanguages(OutputResourceType, OutputResourceName), "Ptr", lpResourceLock
		, "UInt", DllCall("Kernel32.dll\SizeofResource", "Ptr", hModule, "Ptr", hResource))
		, hFile := FileName
}

ResourceAdd(ResourceType, ResourceName := 0, Data := "", Language := 0x0000, DataType := "String") {
	static hUpdateResource
	if !(hModule:=ResourceOpen(, 3))
		return 0
	if (ResourceType="end")
		return hUpdateResource?DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hUpdateResource, "Int", ResourceName?1:0):0, hUpdateResource := ""
	hUpdateResource := hUpdateResource?hUpdateResource:DllCall("Kernel32.dll\BeginUpdateResourceW", "Str", hModule, "Int", false)
	if (DataType="File") {
		if !FileExist(Data)
			return 0
		VarSetCapacity(IpData, nSize:=FileGetSize(Data), 0), IpData := FileRead("*c " Data)
	} else {
		IpData := Data, nSize := StrLen(Data)
	}
	if !(nSize>0)
		return 0
	return DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hUpdateResource
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType
		, "Str", ResourceName, "UShort", Language, "Ptr", &IpData, "UInt", nSize) ? 1
		: DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hUpdateResource
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType
		, "Ptr", ResourceName, "UShort", Language, "Ptr", &IpData, "UInt", nSize)
}

ResourceDelete(ResourceType, ResourceName := 0, Language := "auto") {
	static hUpdateResource
	if !(hModule:=ResourceOpen(, 3))
		return 0
	if (ResourceType="end")
		return hUpdateResource?DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hUpdateResource, "Int", ResourceName?1:0):0, hUpdateResource := ""
	hUpdateResource := hUpdateResource?hUpdateResource:DllCall("Kernel32.dll\BeginUpdateResourceW", "Str", hModule, "Int", false)
	return DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hUpdateResource
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType
		, "Ptr", ResourceName, "UShort", Language="auto"?ResourceEnumLanguages(ResourceType, ResourceName):Language, "Ptr", 0, "UInt", 0)?1
		: DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hUpdateResource
		, "Ptr", ResTypes[ResourceType]>0?ResTypes[ResourceType]:ResourceType
		, "Str", ResourceName, "UShort", Language="auto"?ResourceEnumLanguages(ResourceType, ResourceName):Language, "Ptr", 0, "UInt", 0)
}































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: STRING ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtiene un array con el texto entre comillas
;Sintaxis: SplitTextBetweenQuotes( [texto], [cantidad] )
;EJEMPLO: MsgBox % SplitTextBetweenQuotes(Chr(34) "AA" Chr(34) 1 Chr(34) "BB" Chr(34), 2)[2]
SplitTextBetweenQuotes(String, Count) {
	Array := []
	Loop, %Count%
		_ .= ".*" Chr(34) "(.*)" Chr(34)
	RegExMatch(String Chr(34) Chr(34), "U)" Chr(34) "(.*)" Chr(34) _, i)
	Loop, %Count%
		Array[A_Index] := i%A_Index%
	return Array, ErrorLevel := Array.MaxIndex()
}
StrSplitP(String, Delimiter := "'", OmitChars := "", ReplaceLiteralVar := 0) {
	Array := [], Index := 0
	Loop, Parse, % String, %Delimiter%, %OmitChars%
		if IsEven(A_Index) {
			Index++
			Array[Index] := ReplaceLiteralVar ? ReplaceLiteralVar(A_LoopField) : A_LoopField
		}
	return Array, ErrorLevel := Array.MaxIndex()
}

StrNormalize(String) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd319093%28v=vs.85%29.aspx
    len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", 0, "Int", 0)
    Loop {
        VarSetCapacity(buf, len * 2)
        len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", &buf, "Int", len)
        if (len >= 0)
            break
        if (A_LastError != 122) ;ERROR_INSUFFICIENT_BUFFER
            return
        len *= -1
    }
    return RegExReplace(StrGet(&buf, len, "UTF-16"), "\pM")
}
	
;Separa una cadena en una matriz de subcadenas utilizando los delimitadores especificados.
;Sintaxis: StrSplit( [cadena], [delimitador], [omitir], [defecto si es vacio] )
;NOTA: ErrorLevel se establecen en la cantidad total de índices
;StrSplit(String, Delimiter := "", OmitChars := "", Default := "") {
;	if IsObject( String )
;		return String, ErrorLevel := String.MaxIndex()
;	Array := []
;	Loop, Parse, % String, %Delimiter%, %OmitChars%
;		Array[ A_Index ] := A_LoopField = "" ? Default : A_LoopField
;	return Array, ErrorLevel := Array.MaxIndex()
;}
;StrMergeArray(Array, Delimiter := "") {
;	if IsObject( Array )
;		for k, v in Array
;			Array .= k = 1 ? v : Delimiter v
;	return Array
;}

;quitar caracteres de izquierda a derecha
;Sintaxis : StrTrimLeft( [Var], [Limite] )
StrTrimLeft(String, Length := 1) {
	return SubStr(String, Length+1)
}

;quitar caracteres de derecha a izquierda
;Sintaxis : StrTrimRight( [Var], [Limite] )
StrTrimRight(String, Length := 1) {
	return SubStr(String, 1, StrLen(String)-Length)
}

;obtener caracteres de izquierda a derecha
;Sintaxis : StrLeft( [Var], [Limite] )
StrLeft(String, Length := 1) {
	return SubStr(String, 1, Length)
}
	
;obtener caracteres de derecha a izquierda
;Sintaxis : StrRight( [Var], [Limite] )
StrRight(String, Length := 1) {
	return SubStr(String, -(Length-1))
}

;If [var] in [ .. ]
;comprueba si el contenido de la variable coincide exactamente con los elementos espesificados
;Sintaxis: InVar( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
InVar(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := 0) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (!CaseSensitive&&(Haystack=A_LoopField))||(CaseSensitive&&(Haystack==A_LoopField))
			return 1
	return 0
}

;If [var] contains [ .. ]
;comprueba si el contenido de la variable coincide exactamente o parcialmente con los elementos espesificados
;Sintaxis: Contains( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
Contains(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := 0) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if InStr( Haystack, A_LoopField, CaseSensitive )
			return 1
	return 0
}

;obtener un nombre válido para un archivo
ValidateName(ByRef IpName) {
	return IpName := RegExReplace(IpName, "[\Q*/\:?" Chr(34) "<>|`n\E]")
}

;obtener una ruta válida para un directorio
;EJEMPLOS: 
	;MsgBox % ValidatePath( "\<`n||\ " A_WinDir "\/\ \ *Sys/t<e>m?32\c::md.:exe|`n\\" )
	;MsgBox % SetWorkingDir(A_WinDir) ValidatePath( "\system32\\cmd.:exe\ " )
ValidatePath(ByRef IpPath) {
	IpPath := RegExReplace(IpPath, "[\Q*/?" Chr(34) "<>|`n\E]")
	IpPath := Trim( IpPath ), IpPath := Trim( IpPath, "\" ), IpPath := Trim( IpPath )
	IpDrive := StrLeft( IpPath, 2 ) 
	if FileExist( IpDrive ) AND InStr( IpDrive, ":" )
		IpPath := IpDrive StrReplace( StrTrimLeft( IpPath, 2 ), ":" )
	else
		IpPath := A_WorkingDir "\" StrReplace( IpPath, ":" )
	IpPath := StrReplace(IpPath, "\\", "\")
	IpPath := StrReplace(IpPath, " \ ", "\")
	IpPath := Trim( IpPath ), IpPath := Trim( IpPath, "\" ), IpPath := Trim( IpPath )
	return IpPath := StrReplace(IpPath, "\\", "\")
}

;obtiene el mayór número (no negativos)
;Ver: Max()
StrMax(num, Delimiter := ",") {
	num := RegExReplace(num, "[^0-9\Q" Delimiter "\E]")
	RegExMatch(Sort(num, "D" Delimiter " N R"), "[\d.-]*", z)
	return z
}

;obtiene el menór número (no negativos)
;Ver: Min()
StrMin(num, Delimiter := ",") {
	num := RegExReplace(num, "[^0-9\Q" Delimiter "\E]")
	RegExMatch(Sort(num, "D" Delimiter " N"), "[\d.-]*", z)
	return z
}

Sort(VarName, Options := "") {
	Sort, VarName, %Options%
	return VarName
}

;convertir texto en minúscula 
StrLower(String, T := 0) {
	return Format(T ? "{:T}" : "{:L}", String)
	String2 := DllCall("User32.dll\CharLowerW", "Str", String)
	return StrGet( String2, StrLen(String) )
}

;comprueba si es minúscula
IsLower(String) {
	if String is LOWER
		return 1
	return 0
}

;convertir texto en mayuscula
StrUpper(String, T := 0) {
	return Format(T ? "{:T}" : "{:U}", String)
	String2 := DllCall("User32.dll\CharUpperW", "Str", String)
	return StrGet( String2, StrLen(String) )
}

;comprueba si es mayúscula
IsUpper(String) {
	if String is UPPER
		return 1
	return 0
}

;Convierte la ruta especificada a su forma larga
StrLPath(lpszShortPath) {
	lpszShortPath := RegExReplace(RegExReplace(RegExReplace(lpszShortPath, "^\s+"), "\s+$"), "\\+$")
	cchBuffer := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" lpszShortPath, "Ptr", 0, "UInt", 0)
	VarSetCapacity( lpszLongPath, cchBuffer * 2, 0 )
	i := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" lpszShortPath, "Str", lpszLongPath, "UInt", cchBuffer)
	return i ? RegExReplace(lpszLongPath, "^\\\\\?\\+") : lpszShortPath, ErrorLevel := !i
}

;Convierte la ruta especificada a su forma corta
StrSPath(lpszShortPath) {
	lpszShortPath := RegExReplace(RegExReplace(RegExReplace(lpszShortPath, "^\s+"), "\s+$"), "\\+$")
	cchBuffer := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" lpszShortPath, "Ptr", 0, "UInt", 0)
	VarSetCapacity( lpszLongPath, cchBuffer * 2, 0 )
	i := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" lpszShortPath, "Str", lpszLongPath, "UInt", cchBuffer)
	return i ? RegExReplace(lpszLongPath, "^\\\\\?\\+") : lpszShortPath, ErrorLevel := !i
}

StrDownload(URL) {
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	i.Open("GET", URL), i.Send()
	return i.ResponseText
}

;reemplaza variables literales.
;Sintaxis: ReplaceLiteralVar( [Var], [archivo] )
ReplaceLiteralVar(String, IsFile := 0) {
	;variables del sistema y usuario -----------------------------------
	i := {"HKCU" : "Environment", "HKLM" : "SYSTEM\ControlSet001\Control\Session Manager\Environment"}
	for k, v in i
		Loop, Reg, %k%\%v%, V
			String := StrReplace(String, "%" A_LoopRegName "%", EnvGet(A_LoopRegName))
	i := ""
	;otras variables y cmd -----------------------------------R
	i := {"Temp" : A_Temp(), "ProgramFiles" : A_ProgramFiles(), "CD" : A_WorkingDir(), "CommonProgramFiles" : A_ProgramsCommon(), "AppData" : A_AppData(), "OS" : A_OSVersion()
		, "COMPUTERNAME" : A_ComputerName(), "DATE" : (d:=A_DD) "/" (m2:=A_Mon) "/" (y:=A_Year), "HOMEDRIVE" : SubStr(A_WinDir(), 1, 2), "LOCALAPPDATA" : A_AppDataCommon(), "desktop" : A_Desktop()
		, "WINDIR" : A_WinDir(), "USERNAME" : A_UserName(), "TIME" : (h:=A_Hour) ":" (m:=A_Min) ":" (s:=A_Sec), "SYSTEMROOT" : A_WinDir(), "PROCESSOR_ARCHITECTURE" : A_Is64bitOS ? "64" : "32"
		, "LOCALAPPDATA" : A_AppDataCommon(), "CMDEXTVERSION" : A_OSType(), "StartMenu" : A_StartMenu(), "MyDocuments" : A_MyDocuments(), "Documents" : A_MyDocuments(), "DateTime" : y "_" m2 "_" d "_" h "_" m "_" s
		, "Cursor" : A_Cursor(), "SendTo" : A_SendTo(), "Recent" : A_Recent(), "MyVideo" : A_MyVideo(), "MyPictures" : A_MyPictures(), "MyMusic" : A_MyMusic(), "DocumentsCommon" : A_DocumentsCommon()
		, "Programs" : A_Programs(), "ComSpec" : A_ComSpec(), "SysWinDir" : A_SysWinDir(), "SysDir" : A_SysDir(), "SysDir64" : A_SysDir64(), "DefaultUserProfile" : A_DefaultUserProfile()
		, "Profiles" : A_Profiles, "AllUsersProfile" : A_AllUsersProfile(), "UserProfile" : A_UserProfile() }
	for k, v in i
		String := StrReplace(String, "%" k "%", v)
	i := ""
	;variables autohotkey -----------------------------------
	i := {"A_Temp" : A_Temp(), "A_DDD" : A_DDD, "A_DDDD" : A_DDDD, "A_MMM" : A_MMM, "A_MMMM" : A_MMMM, "A_DD" : d, "A_MM" : A_MM, "A_YYYY" : A_YYYY, "A_DD" : A_DD, "A_AhkVersion" : A_AhkVersion, "A_ScriptName" : A_ScriptName()
		, "A_ScriptFullPath" : A_ScriptFullPath(), "A_WorkingDir" : A_WorkingDir, "A_ScriptDir" : A_ScriptDir(), "A_Space" : A_Space(), "A_Tab" : A_Tab(), "A_Year" : y, "A_Mon" : m2, "A_WDay" : A_WDay, "A_YDay" : A_YDay, "A_Hour" : h
		, "A_YWeek" : A_YWeek, "A_Min" : m, "A_Sec" : s, "A_Now" : A_Now, "A_MSec" : A_MSec, "ComSpec" : A_ComSpec(), "A_OSVersion" : A_OSVersion(), "A_WinDir" : A_WinDir()
		, "A_ProgramFiles" : A_ProgramFiles(), "A_AppData" : A_AppData(), "A_Language" : A_Language(), "A_Desktop" : A_Desktop(), "A_StartMenu" : A_StartMenu(), "A_UserName" : A_UserName(), "A_AppDataCommon" : A_AppDataCommon()
		, "A_ComputerName" : A_ComputerName(), "A_StartMenuCommon" : A_StartMenuCommon(), "A_Programs" : A_Programs(), "A_ProgramsCommon" : A_ProgramsCommon(), "A_Cursor" : A_Cursor(), "A_Startup" : A_Startup(), "A_IsAdmin" : A_IsAdmin()
		, "A_DesktopCommon" : A_DesktopCommon(), "Clipboard" : Clipboard, "A_LastError" : A_LastError(), "A_StartupCommon" : A_StartupCommon(), "A_ScreenHeight" : A_ScreenHeight(), "A_ScreenWidth" : A_ScreenWidth(), "A_IPAddress4" : A_IPAddress4()
		, "A_IPAddress1" : A_IPAddress1(), "A_IPAddress2" : A_IPAddress2(), "A_IPAddress3" : A_IPAddress3(), "ClipboardAll" : ClipboardAll, "A_MyDocuments" : A_MyDocuments}
	for k, v in i
		String := StrReplace(String, "%" k "%", v)
	i := ""
	;variables para el archivo especificado -----------------------------------
	if IsFile
		String := StrReplace(String, "%A_FileVersion%", FileGetVersion(IsFile))
	;--------------------------------------------------------------------------------------------------------------------------------------------
	return String
}


















































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: CRIPTOGRAFÍA ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
Base32Encode(Decoded, UseHex := 0, Len := 0) { 
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	If (Len = 0)
		Len := StrPut(Decoded, "UTF-8") - 1
		, VarSetCapacity(UTF8, Len, 0)
		, StrPut(Decoded, &UTF8, "UTF-8")
		, BinAddr := &UTF8
	else
		BinAddr := &Decoded
	VarSetCapacity(Endcoded, Len * 2, 0)
	I := 0
	while (I < Len) {
		J := N := 0
		S := 40
		Loop, 5
			N += NumGet(BinAddr + I++, "UChar") << (8 * (5 - ++J))
		Until (I >= Len)
		Loop, % Ceil((8 * J) / 5)
			Encoded .= SubStr(Chars, ((N >> (S -= 5)) & 0x1F) + 1, 1)
	}
	Loop, % ((40 - (J * 8)) // 5)
		Encoded .= "="
	return Encoded
}

Base64Encode(pbBinary) {
	static dwFlags := CRYPT_STRING_BASE64 := 0x00000001
	cbBinary := StrLen( pbBinary ) * 2
	DllCall( "Crypt32.dll\CryptBinaryToStringW", "UChar", &pbBinary, "UInt", cbBinary, "UInt", dwFlags, "Ptr", 0, "UInt*", pcchString, "CDECL Int")
	pcchString := VarSetCapacity( pszString, pcchString * 2 )
	i := DllCall( "Crypt32.dll\CryptBinaryToStringW", "UChar", &pbBinary, "UInt", cbBinary, "UInt", dwFlags, "Str", pszString, "UInt*", pcchString, "CDECL Int")
	return pszString, ErrorLevel := !i
}

;----------------------------------------

Base32Decode(Encoded, UseHex := 0, ByRef Decoded := "") {
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	Len := StrLen(Encoded)
	VarSetCapacity(Decoded, Len * 2, 0)
	I := J := K := 0
	Loop, Parse, % Encoded
	{
		If !(N := InStr(Chars, A_LoopField))
			break
		K += --N << (5 * (8 - ++J))
		If (J = 8) {
			S := 40
			Loop, 5
				NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
			J := K := 0
		}
	}
	If (J < 8) {
		S := 40
		Loop, % Ceil((5 * J) / 8)
			NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
	}
	return IsByRef(Decoded) ? I : StrGet(&Decoded, I, "UTF-8")
}

Base64Decode(pszString, nSize := 0) {
	static dwFlags := CRYPT_STRING_BASE64 := 0x00000001
	cchString := nSize?(nSize+3)*2:StrLen(pszString)
	DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &pszString, "UInt", cchString, "UInt", dwFlags, "UChar", 0, "UInt*", pcbBinary, "UInt*", 0, "UInt*", 0, "CDECL Int")
	pcbBinary := VarSetCapacity( pbBinary, pcbBinary * 2)
	i := DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &pszString, "UInt", cchString, "UInt", dwFlags, "Str", pbBinary, "UInt*", pcbBinary, "UInt*", 0, "UInt*", 0, "CDECL Int")
	return pbBinary, ErrorLevel := !i
}



















































/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  ::::::::::::::::::::::::::::::::::::::::::::: PROCESOS ::::::::::::::::::::::::::::::::::
---------------------------------------------------------------------------------------------------------------------------------------------------------------
NOTA: las funciones aceptan el PID y Nombre del proceso (este último lo hace mas lento)
*/
;devuelve una lista de todos los procesos + informacion
;ErrorLevel es 1 si ha ocurrido un error
;NOTA: ver CreateToolhelp32Snapshot() en ProcessExist()
;EJEMPLO:
	;for k, v in ProcessEnum()
		;MsgBox % k "- " v.Name A_Tab v.ProcessId A_Tab v.UserDomain "\" v.UserName
ProcessEnum() {
	ppProcessInfo := pCount := 0, List := {}
	hModule := LoadLibrary( "Wtsapi32.dll" )
	hWts := DllCall("Wtsapi32.dll\WTSEnumerateProcessesW", "Ptr", 0, "UInt", 0, "UInt", 1, "Ptr*", ppProcessInfo, "UInt*", pCount)
	WTS_PROCESS_INFO_EX := ppProcessInfo
	Loop, %pCount% {
		Info := "", Info := {}, Info.Count := pCount ;número de procesos
		Info.SessionId := NumGet(WTS_PROCESS_INFO_EX + 0, "UInt") ;sid sesión para la sesión asociada con el proceso
		Info.ProcessId := NumGet(WTS_PROCESS_INFO_EX + 4, "UInt") ;PID
		Info.Name := StrGet(NumGet(WTS_PROCESS_INFO_EX + 8)) ;nombre
		Info.UserSid := NumGet(WTS_PROCESS_INFO_EX + 16) ;sid del usuario
			VarSetCapacity(UserName, 512, 0), VarSetCapacity(UserDomain, 512, 0), VarSetCapacity(peUse, 512, 0)
			DllCall("Advapi32.dll\LookupAccountSid", "Ptr", 0, "Ptr", Info.UserSid, "Str", UserName, "UIntP", 256, "Str", UserDomain, "UIntP", 256, "UIntP", peUse)
		Info.UserName := UserName ;nombre del usuario
		Info.UserDomain := UserDomain ;dominio
		Info.peUse := peUse ;valor SID_NAME_USE que indica el tipo de la cuenta.
		List.InsertAt(A_Index, Info), WTS_PROCESS_INFO_EX += (A_PtrSize = 4 ? 16 : 24)
	}
	return List
		, DllCall("Wtsapi32.dll\WTSFreeMemory", "Ptr", ppProcessInfo)
		, FreeLibrary( hModule )
		, ErrorLevel := !hWts
}

;Recupera información sobre el uso de memoria del proceso especificado en bytes
ProcessMemoryInfo(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0010|0x0400, "UInt", 0, "UInt", ProcessId)
	nSize := VarSetCapacity(memCounters, A_PtrSize = 8 ? 72 : 40), NumPut(nSize, memCounters)
	if !DllCall("Psapi.dll\GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", nSize) {
		memCounters := "", nSize := VarSetCapacity(memCounters, A_PtrSize = 8 ? 80 : 44), NumPut(nSize, memCounters)
		if !DllCall("Kernel32.dll\K32GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", nSize)
			return 0
	}
	i := {} ; i.Length := NumGet(memCounters, 0, "UInt")
		, i.PageFaultCount := NumGet(memCounters, 4, "UInt") ;número de fallos de página.
		, i.PeakWorkingSetSize := NumGet(memCounters, 8, "Ptr") ;tamaño máximo de trabajo
		, i.WorkingSetSize := NumGet(memCounters, A_PtrSize = 8 ? 16 : 12, "Ptr") ;El tamaño del conjunto de trabajo actual, en bytes. (uso de memoria)
		, i.QuotaPeakPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 24 : 16, "Ptr")
		, i.QuotaPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 32 : 20, "Ptr")
		, i.QuotaPeakNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 40 : 24, "Ptr")
		, i.QuotaNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 48 : 28, "Ptr")
		, i.PagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 56 : 32, "Ptr")
		, i.PeakPagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 64 : 36, "Ptr")
		, i.PrivateUsage := NumGet(memCounters, A_PtrSize = 8 ? 72 : 40, "Ptr")
	return i, DllCall("kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;uso de CPU del proceso
ProcessCPULoad(ProcessName) {
		Static oldKrnlTime, oldUserTime, newKrnlTime, newUserTime
		ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
		oldKrnlTime := newKrnlTime, oldUserTime := newUserTime
		hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		DllCall("Kernel32.dll\GetProcessTimes", "Uint", hProcess, "int64P", CreationTime, "int64P", ExitTime, "int64P", newKrnlTime, "int64P", newUserTime) 
		return ( ( (newKrnlTime - oldKrnlTime) + (newUserTime-oldUserTime) ) / 10000000) * 100, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;comprueba si el proceso existe
;Sintaxis: ProcessExist( [ProcessName] )
;NOTAS:
	;Devuelve el PID o 0 en caso de error
	;ErrorLevel se establece en el PID o 0 en caso de error
ProcessExist(Proc*) {
	static CurrentProcessId := DllCall("Kernel32.dll\GetCurrentProcessId")
	static CurrentThreadId := DllCall("Kernel32.dll\GetCurrentThreadId")
	ProcessName := Trim( Proc[1] )
	if (ProcessName = "")&&Proc.MaxIndex()
		return 0, ErrorLevel := 1
	;---------------------------------------------------------------------------------------------------------------------
	if (ProcessName = -1)||!Proc.MaxIndex()
		return CurrentProcessId
	;---------------------------------------------------------------------------------------------------------------------
	if (ProcessName = -2)
		return CurrentThreadId
	;---------------------------------------------------------------------------------------------------------------------
	dwSize := VarSetCapacity(lppe, A_PtrSize = 4 ? 296 : 304, 0), NumPut(dwSize, lppe, 0, "UInt")
	hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
	DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
	Loop {
		ProcessId := NumGet(lppe, 8, "UInt")
		ProcessExe := StrGet(&lppe + (A_PtrSize = 4 ? 36 : 44), 260, "CP0")
		if (ProcessId = ProcessName) OR (ProcessExe = ProcessName)
			return ProcessId, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot), ErrorLevel := ProcessId
		if !DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe)
			return 0, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot), ErrorLevel := 0
	}
}

;esperar a que el proceso exista
;Sintaxis: ProcessWait( [Proceso], [Segundos a esperar] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no existe; caso contrario devuelve el PID
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWait(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if ( ProcessId := ProcessExist( ProcessName ) )
			return ProcessId, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que el proceso finalize
;Sintaxis: ProcessWaitClose( [Proceso], [Segundos] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no se ha cerrado; caso contrario devuelve 1
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWaitClose(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !ProcessExist( ProcessName )
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}
WaitForSingleObject(ProcessName, Seconds := 0) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032%28v=vs.85%29.aspx
	if (Seconds = -1)
		return 0
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x00100000, "UInt", 0, "UInt", ProcessId)
	i := DllCall("Kernel32.dll\WaitForSingleObject", "Ptr", hProcess, "UInt", Seconds > 0 ? Seconds : 0xFFFFFFFF)
	return i = 0 OR i = -1 ? (ProcessId ? ProcessId : 1) : 0
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ErrorLevel := i = 0 OR i = -1 ? 0 : 1
}

;obtener/establecer prioridad 
;Sintaxis: ProcessPriority( [Nombre o PID], [Prioridad] )
;Nota: dejar vacio el segundo parametro para recuperar la prioridad
ProcessPriority(ProcessName, dwPriorityClass := 0, Spa := 0) {
	static r32 := "Normal", r64 := "Low", r128 := "High" , r256 := "RealTime", r16384 := "BelowNormal", r32768 := "AboveNormal"
	static rn32 := "Normal", rn64 := "Baja", rn128 := "Alta" , rn256 := "Tiempo real", rn16384 := "Debajo de lo normal", rn32768 := "Arriba de lo normal"
	static rNormal := rN := 32, rLow := rL := 64, rHigh := rH := 128 , rRealTime := rR := 256, rBelowNormal := rB := 16384, rAboveNormal := rA := 32768
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	if !dwPriorityClass {
		hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		hCPriority := DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess)
		return Spa ? (rn%hCPriority% ? rn%hCPriority% : hCPriority) : (r%hCPriority% ? r%hCPriority% : hCPriority)
			, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
			, ErrorLevel := Spa ? (rn%hCPriority% ? 1 : 0) : (r%hCPriority% ? 1 : 0)
	}
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0200, "UInt", 0, "UInt", ProcessId)
	return i := DllCall("kernel32.dll\SetPriorityClass", "Ptr", hProcess, "UInt", r%dwPriorityClass% ? r%dwPriorityClass% : dwPriorityClass)
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ErrorLevel := r%dwPriorityClass% ? !i : 0
}
	
;cerrar proceso(s)
;Sintaxis: ProcessClose( [PID/Nombre*], [¿Esperar? (segundos)], [¿Terminar SubProcesos?], [código de salida] )
;NOTAS: 
	;espesificar * para terminar todos los procesos que coincidan con el nombre espesificado
	;espesificar 0 segundos para esperar indefinidamente
;Terminar SubProcesos: 
	;1 = terminar el proceso junto con todos los procesos que inició
	;2 = teminar todos los procesos que el proceso espesificado inició
ProcessClose(ProcessName, WaitClose := -1, SubProcess := 0, uExitCode := 0) {
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	if InStr(ProcessName, "*") { ;terminar procesos que coincidan con el mismo nombre
		ProcessName := StrReplace(ProcessName, "*")
		dwSize := VarSetCapacity(lppe, A_PtrSize = 4 ? 296 : 304, 0), NumPut(dwSize, lppe, 0, "UInt")
		hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		if DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
			Loop {
				ProcessId := NumGet(lppe, 8, "UInt")
				ProcessExe := StrGet(&lppe + (A_PtrSize = 4 ? 36 : 44), 260, "CP0")
				if (ProcessExe = ProcessName)
					hList .= ProcessClose( ProcessId, WaitClose, SubProcess, uExitCode ) "`n"
				if !DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe)
					return RTrim(hList, "`n"), DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot)
			}
	}
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	if InStr(ProcessName, ".") OR (ProcessName = -1)
		ProcessId := ProcessExist( ProcessName )
	else
		ProcessId := ProcessName
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	if SubProcess { ;termina el proceso junto con todos sus subprocesos
		dwSize := VarSetCapacity(lppe, A_PtrSize = 4 ? 296 : 304, 0), NumPut(dwSize, lppe, 0, "UInt")
		hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
		Loop {
			Process_ID := NumGet(lppe, 8, "UInt"), Parent := NumGet(lppe, A_PtrSize = 4 ? 24 : 32, "UInt")
			if (Process_ID != ProcessId) AND (Parent = ProcessId)
				hList .= ProcessClose( Process_ID, WaitClose,, uExitCode ) "`n"
			if !DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe)
				return SubProcess = 1 ? hList ProcessClose(ProcessId, WaitClose,, uExitCode) : RTrim(hList, "`n")
					, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot)
		}
	}
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0001, "UInt", 0, "UInt", ProcessId)
	hResult := DllCall("Kernel32.dll\TerminateProcess", "Ptr", hProcess, "UInt", uExitCode)
	return hResult ? ProcessId : 0
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ProcessWaitClose(ProcessId, WaitClose), ErrorLevel := !hResult
} ;----------------------------------------------------------------------------------------------------------------------------------------------------------------

;recupera la ruta completa al archivo ejecutable del proceso
;Sintaxis: ProcessPath( [ID], [nombre del ejecutable (out)] )
ProcessPath(ProcessName, ByRef ProcessEName := "") {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400|0x0010, "UInt", 0, "UInt", ProcessId)
	FileNameSize := VarSetCapacity(ModuleFileName, (260 + 1) * 2, 0) / 2
	if !DllCall("Psapi.dll\GetModuleFileNameExW", "Ptr", hProcess, "Ptr", 0, "Str", ModuleFileName, "UInt", FileNameSize)
		if !DllCall("Kernel32.dll\K32GetModuleFileNameExW", "Ptr", hProcess, "Ptr", 0, "Str", ModuleFileName, "UInt", FileNameSize)
			DllCall("Kernel32.dll\QueryFullProcessImageNameW", "Ptr", hProcess, "UInt", 1, "Str", ModuleFileName, "UIntP", FileNameSize)
	return ModuleFileName, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ProcessEName := IsByRef( ProcessEName ) ? ProcessName( ProcessId ) : ""
}

;recupera el nombre del archivo ejecutable del proceso
ProcessName(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400|0x0010, "UInt", 0, "UInt", ProcessId)
	nSize := VarSetCapacity(lpBaseName, (260 + 1) * 2, 0) / 2
	if !DllCall("Psapi.dll\GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", lpBaseName, "UInt", nSize)
		DllCall("Kernel32.dll\K32GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", lpBaseName, "UInt", nSize)
	return lpBaseName, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}
ProcessEName(ProcessName) {
	return ProcessName( ProcessName )
}

;establece el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessSetWorkingSetSize( [Proceso], [Min], [Max] )
ProcessSetWorkingSetSize(ProcessName, Min := -1, Max := -1) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0100, "UInt", 0, "UInt", ProcessId)
	return i := DllCall("Kernel32.dll\SetProcessWorkingSetSize", "Ptr", hProcess, "UPtr", Min, "UPtr", Max)
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess), ErrorLevel := !i
}

;obtiene el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessGetWorkingSetSize( [Proceso], [Min (salida)], [Max (salida)] )
ProcessGetWorkingSetSize(ProcessName, ByRef Min := "", ByRef Max := "") {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId), i := {}
	r := DllCall("Kernel32.dll\GetProcessWorkingSetSize", "Ptr", hProcess, "UPtrP", Min, "UPtrP", Max)
	i.Min := Min, i.Max := Max
	return r ? i : 0, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess), ErrorLevel := !r
}

;Habilitar/Deshabilitar privilegios para el proceso
;Sintaxis: ProcessSetPrivilege( [Proceso], [privilegios separados por coma], [0|1 (deshabilitar/habilitar)] )
;Privilegios: https://msdn.microsoft.com/en-us/library/windows/desktop/bb530716%28v=vs.85%29.aspx
;Nota: espesificar 'All' en Privilegios para establecer todos.
ProcessSetPrivilege(ProcessName, Privileges, Set := true) {
	static AllPrivileges := "SeChangeNotifyPrivilege,SeCreateGlobalPrivilege,SeDebugPrivilege,"
		. "SeShutdownPrivilege,SeSystemtimePrivilege,SeCreatePagefilePrivilege,SeImpersonatePrivilege,SeIncreaseQuotaPrivilege,"
		. "SeTimeZonePrivilege,SeIncreaseBasePriorityPrivilege,SeManageVolumePrivilege,SeRemoteShutdownPrivilege,"
		. "SeSecurityPrivilege,SeTakeOwnershipPrivilege,SeBackupPrivilege,SeProfileSingleProcessPrivilege,SeRestorePrivilege,"
		. "SeSystemEnvironmentPrivilege,SeSystemProfilePrivilege"
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
	DllCall("Advapi32.dll\OpenProcessToken", "Ptr", hProcess, "UInt", 0x0020|0x00000008, "UIntP", hToken)
	PrivilegesLuid := [], i := 0
	Loop, Parse, % (Privileges="All"?AllPrivileges:Privileges), `,
		DllCall("Advapi32.dll\LookupPrivilegeValueW", "Ptr", 0, "Str", A_LoopField, "Int64P", lpLuid)
		, PrivilegesLuid[A_Index] := lpLuid
	for k, v in PrivilegesLuid
		ti := "", VarSetCapacity(ti, 16, 0), NumPut(1, ti, 0, "UInt"), NumPut(v, ti, 4, "Int64"), NumPut(2, ti, 12, "UInt")
		, i := i+(DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", hToken, "Int", !Set, "Ptr", &ti, "UInt", 0, "Ptr", 0, "Ptr", 0)?1:0)
	DllCall("kernel32.dll\CloseHandle", "Ptr", hToken)
	DllCall("kernel32.dll\CloseHandle", "Ptr", hProcess)
	return i, ErrorLevel := PrivilegesLuid.MaxIndex()!=i
}

;suspender
ProcessSuspend(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0800, "UInt", 0, "UInt", ProcessId)
	DllCall("ntdll.dll\NtSuspendProcess", "Ptr", hProcess)
	return hProcess, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}
	
;reanudar
ProcessResume(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0800, "UInt", 0, "UInt", ProcessId)
	DllCall("ntdll.dll\NtResumeProcess", "Ptr", hProcess)
	return hProcess, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}
	
;obtiene el SID, opcional también el nombre de usuario y dominio del proceso
;Sintaxis: ProcessGetSID( [proceso], [nombre de usuario (salida)], [dominio (salida)] )
ProcessGetSID(ProcessName, ByRef UserName := "", ByRef UserDomain := "") {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x00020000, "UInt", 0, "UInt", ProcessId)
	i := DllCall("Advapi32.dll\GetSecurityInfo", "Ptr", hProcess, "UInt", 6, "UInt", 1, "PtrP", PSID, "PtrP", 0, "PtrP", 0, "PtrP", 0)
	if IsByRef( UserName ) OR IsByRef( UserDomain )
		VarSetCapacity(UserName, 256 * 2), VarSetCapacity(UserDomain, 256 * 2)
		, DllCall("Advapi32.dll\LookupAccountSid", "Ptr", 0, "Ptr", PSID, "Str", UserName, "UIntP", 256, "Str", UserDomain, "UIntP", 256, "UIntP", 0)
	return PSID, ErrorLevel := i
}

;obtener una lista de los Hilos del proceso espesificado
;Sintaxis: ProcessThreadList( [ID], [Delimitador] )
;EJEMPLO:
	;for k, v in ProcessThreadList()
		;if (i:=ProcessName(v.ProcessId))
			;MsgBox % "ThreadId: " v.ThreadId ", OwnerProcessId: " v.ProcessId " (" i ")"
ProcessThreadList(ProcessName := "", Delimiter := "`n") {
	dwSize := VarSetCapacity(THREADENTRY32, A_PtrSize = 4 ? 28 : 40, 0)
	NumPut(dwSize, THREADENTRY32, 0, "UInt")
	hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000004, "UInt", 0)
	DllCall("Kernel32.dll\Thread32First", "Ptr", hSnapshot, "Ptr", &THREADENTRY32)
	Loop {
		th32OwnerProcessID := NumGet( THREADENTRY32, A_PtrSize = 4 ? 12 : 20, "UInt" )
		th32ThreadID := NumGet( THREADENTRY32, 8, "UInt" )
		if ProcessName {
			if (ProcessName=th32OwnerProcessID)
				ThreadList .= (A_Index=1?"":Delimiter) th32ThreadID
		} else {
			if !IsObject( ThreadList )
				ThreadList := []
			ThreadInfo := []
			ThreadInfo.ThreadId := th32ThreadID
			ThreadInfo.ProcessId := th32OwnerProcessID
			ThreadList.InsertAt( A_Index, ThreadInfo )
		}
		if !DllCall("Kernel32.dll\Thread32Next", "Ptr", hSnapshot, "UInt", &THREADENTRY32)
			return ThreadList, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot), ErrorLevel := hSnapshot=-1
	}
}






































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: INTERNET ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------

;descargar archivo
;Sintaxis: Download( [URL], [Archivo] )
Download(URL, Filename) {
	URLDownloadToFile, %URL%, %Filename%
	return !ErrorLevel
}

;comprueba la conexion a internet
NetGetState(lpdwFlags := 0x40) {
	i := DllCall("Wininet.dll\InternetGetConnectedState", "UInt*", 0x40, "UInt", 0)
	return i, ErrorLevel := !i
}

;obtener tamaño del archivo
NetGetFileSize(URL) {
	ComObjError(false)
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	i.Open("HEAD", URL), i.Send()
	return i.GetResponseHeader("Content-Length")
}

;obtener texto
NetGetString() {
	ComObjError(false)
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	i.Open("GET", URL), i.Send()
	return i.ResponseText
}

;enviar e-mail
;Sintáxis: EmailSend( [email], [contraseña], [email destino], [cuerpo], [asunto] )
;NOTA: para gmail activar el Acceso De Aplicaciones Menos Seguras: https://www.google.com/settings/security/lesssecureapps
EmailSend(User, Pass, To, Body, Subject := "", CC := "", BCC := "", Attach := "") {
	pmsg := ComObjCreate("CDO.Message")
	pmsg.From := User
	pmsg.To := To, pmsg.BCC := BCC, pmsg.CC := CC
	pmsg.Subject := Subject, pmsg.TextBody := Body
	sAttach := Attach
	Loop, Parse, % sAttach, `n, `r
		pmsg.AddAttachment(A_LoopField)
	fields := Object()
	fields.smtpserver := "smtp.gmail.com" ; specify your SMTP server
	fields.smtpserverport := 465 ; 25
	fields.smtpusessl := True ; False
	fields.sendusing := 2 ; cdoSendUsingPort
	fields.smtpauthenticate := 1 ; cdoBasic
	fields.sendusername := User
	fields.sendpassword := Pass
	fields.smtpconnectiontimeout := 60
	schema := "http://schemas.microsoft.com/cdo/configuration/"
	pfld := pmsg.Configuration.Fields
	for field, value in fields
		pfld.Item(schema . field) := value
	pfld.Update()
	try {
		pmsg.Send()
	} catch { 
		return 0
	}		
	return 1
}




































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: BARRA DE TAREAS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;establecer porcentaje de progreso en la barra de tareas
;Sintaxis: TaskBarProgress( [ESTADO], [Ventana ID] )
;ESTADOS: 0~100, Normal, Paused, Indeterminate, Error
TaskBarProgress(State, hWnd := "") { ;http://ahkscript.org/boards/viewtopic.php?p=48329#p48329
	static i := ComObjError(false)
	static ppv := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf}")
	static s0 := 0, sI := sIndeterminate := 1, sN := sNormal := 2, sE := sError := 4, sP := sPaused := 8
	if InVar( State, "0,N,P,E,I,Normal,Paused,Error,Indeterminate" )
		return DllCall(NumGet(NumGet(ppv+0)+10*A_PtrSize), "Ptr", ppv, "Ptr", hWnd?hWnd:IsWindow(), "UInt", s%State%)
	return DllCall(NumGet(NumGet(ppv+0)+9*A_PtrSize), "Ptr", ppv, "Ptr", hWnd?hWnd:IsWindow(), "Int64", State * 10, "Int64", 1000)
} ;https://msdn.microsoft.com/en-us/library/dd391698(v=vs.85).aspx

;quitar ventana de la barra de tareas
;Sintaxis: TaskBarRemove( [ID], [¿mostrar?] )
TaskBarRemove(hWnd, Show := 0) {
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (Show?4:5)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
		, ObjRelease( hTaskBar )
}

;activa la ventana en la barra de tareas
;TaskBarActivate( [ID], [¿marcar siempre como activo (no visualmente)?] )
TaskBarActivate(hWnd, SetActiveAlt := 0) {
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (SetActiveAlt?7:6)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
		, ObjRelease( hTaskBar )
}

;obtiene posicion de la barra de tareas
;Sintaxis: TaskBarGetPos( [xpos], [ypos], [ancho], [alto] )
TaskBarGetPos(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	return WinGetPos( GetTaskBar(), x, y, Width, Height )
}

;obtiene hWnd de la barra de tareas, opcional: área de notificacion, reloj y boton inicio
;Sintaxis: GetTaskBar( [área de notificacion], [área de notificacion (iconos ocultos)], [reloj] )
;EJEMPLO: leer hora que indica el reloj de la barra de tareas. para otro ejemplo ver TaskBarGetPos()
	;MsgBox % ControlGetText( "TrayClockWClass1", GetTaskBar() ) ;[control], [ventana id o hWnd]
GetTaskBar(ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0)
	if IsByRef(hNotifArea)||IsByRef(hOverFNotifArea)||IsByRef(hTrayClock) {
		hNotify := DllCall("User32.dll\FindWindowExW", "Ptr", hTaskBar, "Ptr", 0, "Str", "TrayNotifyWnd", "Ptr", 0)
		hSyspager := DllCall("User32.dll\FindWindowExW", "Ptr", hNotify, "Ptr", 0, "Str", "SysPager", "Ptr", 0)
		if !(hNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hSyspager, "Ptr", 0, "Str", "ToolbarWindow32", "Str", "User Promoted Notification Area"))
			if !(hNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hSyspager, "Ptr", 0, "Str", "ToolbarWindow32", "Str", "Notification Area"))
				hNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hSyspager, "Ptr", 0, "Str", "ToolbarWindow32", "Ptr", 0)
		if IsByRef(hOverFNotifArea)
			hNotifIcon := DllCall("User32.dll\FindWindowW", "Ptr", 0, "Str", "NotifyIconOverflowWindow")
			, hOverFNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hNotifIcon, "Ptr", 0, "Str", "ToolbarWindow32", "Str", "Overflow Notification Area")
	}
	return hTaskBar, hTrayClock := IsByRef(hTrayClock)?DllCall("User32.dll\FindWindowExW", "Ptr", hNotify, "Ptr", 0, "Str", "TrayClockWClass", "Ptr", 0):""
		, hStartButton := IsByRef(hStartButton)?DllCall("User32.dll\FindWindowExW", "Ptr", hTaskBar, "Ptr", 0, "Str", "Button", "Ptr", 0):""
}

;redibujar barra de tareas, área de notificacion, reloj y boton inicio.
TaskBarRedraw(ByRef hTaskBar := "", ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := GetTaskBar(hNotifArea, hOverFNotifArea, hTrayClock, hStartButton)
	return i:=WinRedraw(hTaskBar)+WinRedraw(hNotifArea)+WinRedraw(hOverFNotifArea)+WinRedraw(hTrayClock)+WinRedraw(hStartButton)
		, ErrorLevel := i!=5
}





























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: ESCRITORIO, EXPLORADOR & MENU INICIO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;reiniciar explorador de windows
RestartWindowsExplorer() {
	if ProcessClose( "explorer.exe*", 5 )
		return Run( A_WinDir "\explorer.exe" )
	return 0, ErrorLevel := 1
}

;muestra el menú inicio
ShowStartMenu() {
	return DllCall("User32.dll\PostMessageW", "Ptr", IsWindow(), "UInt", 0x112, "UInt", 0xF130, "Ptr", 0)
}

;muestra el escritorio y establece foco en él
;Sintaxis: ShowDesktop( [¿esperar? (segundos)], [¿redibujar?] )
ShowDesktop(Wait := -1, Redraw := 0) {
	ComObjCreate( "shell.application" ).ToggleDesktop()
	i := WinActivate( GetDesktop(), Wait, 1 )
	if Redraw
		DesktopRedraw()
	return i, ErrorLevel := !i
}

;obtener hWnd del control SysListView32 del escritorio (control de los iconos)
GetDesktop(ByRef ShellWindow := "", ByRef DesktopWindow := "") {
	hProgman := DllCall("User32.dll\FindWindowW", "Str", "Progman", "Ptr", 0)
	hSDDefView := DllCall("User32.dll\FindWindowExW", "Ptr", hProgman, "Ptr", 0, "Str", "SHELLDLL_DefView", "Ptr", 0)
	if !(hDesktop := DllCall("User32.dll\FindWindowExW", "Ptr", hSDDefView, "Ptr", 0, "Str", "SysListView32", "Str", "FolderView"))
		hDesktop := DllCall("User32.dll\FindWindowExW", "Ptr", hSDDefView, "Ptr", 0, "Str", "SysListView32", "Ptr", 0)
	return hDesktop, ShellWindow := IsByRef(ShellWindow) ? DllCall("User32.dll\GetShellWindow") : ""
		, DesktopWindow := IsByRef(DesktopWindow) ? DllCall("User32.dll\GetDesktopWindow") : ""
}

;redibujar escritorio
DesktopRedraw() {
	return WinRedraw( GetDesktop() )
}

;obtener cantidad de iconos en el escritorio
DesktopIconCount(ByRef SysListView32 := "") {
	return LV_GetItemCount( SysListView32:=GetDesktop() )
}

;obtener una lista con todos los iconos del escritorio
DesktopIconList(RowNumber := 1) {
	Loop, % DesktopIconCount(hDesktop)
		List .= LV_GetItemTextEx(hDesktop, A_Index) "`n"
	return Rtrim(List, "`n")
}

;guardar captura de pantalla
;Sintaxis: SaveScreen( [Archivo] )
SaveScreenshot(Filename, Quality := 100) {
	pToken := Gdip_Startup()
	pBitmap := Gdip_BitmapFromScreen("0|0|" A_ScreenWidth "|" A_ScreenHeight, 0x40000000 + 0x00CC0020)
	Gdip_SaveBitmapToFile(pBitmap, Filename, Quality), Gdip_DisposeImage(pBitmap), Gdip_Shutdown(pToken)
	return pBitmap
}




































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: OTROS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;ejecuta el script como administrador, solo lo intenta una vez, si falla continua normal.
;establece la prioridad en Alta.
;modifica los privilegios para el correcto funcionamiento del script.
;modifica retrasos y otras configuraciones del script.
;NOTA: esta funcion es llamada automáticamente al inicio del script.
RunAsAdmin() { ;//-->
	static StaticRunAsAdmin := RunAsAdmin() ;llama a la funcion automáticamente al inicio del script.
	if !StaticRunAsAdmin { ;evita que la funcion sea ejecutada mas de 1 vez.
	ProcessSetPrivilege := ProcessSetPrivilege(ProcessExist(), "All") ;establece todos los privilegios disponibles para el proceso.
	ProcessPriority := ProcessPriority(ProcessExist(), "High") ;establece la prioridad del proceso actual Alta.
	;---------------------------------------------------------------------------------------------------------------------------------------------------------
	;NOTA: esta parte es ejecutada solo una vez. o ninguna dependiedo si el script es ejecutado como administrador.
	;si (no es ejecutado como administrador) y (el parametro 1 no es la ruta del script) y (el SO no es windows xp).
	if !A_IsAdmin&&(%true%!=A_ScriptFullPath)&&(A_OSVersion!="WIN_XP") {
		_ := A_IsCompiled?A_ScriptFullPath:A_AhkPath ;si esta compilado, ruta al script, de lo contrario usar ruta de autohotkey.
		;Compilado: [ruta script] [ruta script (que establece el parametro 1)] [ruta script (solo funcional para sin compilar)].
		;Sin Compilar: [ruta autohotkey] [ruta script] [ruta script (que establece el parametro 1]
		Run, *RunAs "%_%" "%A_ScriptFullPath%" "%A_ScriptFullPath%",, UseErrorLevel
		if !ErrorLevel ;si no ha ocurrido error al ejecutar el script nuevamente -->
			ExitApp ;salir de la sesion actual. caso contrario, seguir normalmente. <--
	} ;---------------------------------------------------------------------------------------------------------------------------------------------------------
	SetWorkingDir, %A_ScriptDir% ;establece el directorio de trabajo.
	SetBatchLines, -1 ;hace que el script trabaje a la máxima velocidad posible (afecta y es afectada por al uso de CPU).
	SetTitleMatchMode, 2 ;el título de una ventana puede contener «WinTitle» en cualquier lugar dentro para ser valido.
	SendMode, Input ;SendInput es generalmente mas rápido y mas fiable.
	SetControlDelay, 10 ;establece algunos retrasos para mejorar la fiabilidad y/o velocidad de respuesta entre cada comando. -->
	SetKeyDelay, 10, 10, 10
	SetMouseDelay, 0
	SetWinDelay, 50 ;<--
	#NoEnv ;evita comprobar las variables vacías para ver si son variables de entorno (recomendado para todos los nuevos scripts).
	#MaxMem 4095 ;establece la capacidad máxima de cada variable, en megabytes.
	return true ;devuelve 1, esto establece la variable RunAsAdmin en 1 para evitar volver a ejecutar esta funcion mas de una vez.
}} ;<-- //RunAsAdmin

;bloquear mouse y teclado
;Sintaxis: BlockInput( [0|1] )
BlockInput(OnOff, Delay := 500, DisableTaskManager := true) {
	static BlockInput := Func("BlockInput").Bind("Enable")
	if (OnOff="Enable"||OnOff="Disable") { ;Enable | Disable = bloquear/desbloquear normal
		return DllCall("User32.dll\BlockInput", "Int", OnOff="Enable"?true:false)
	} else if (OnOff=0||OnOff="Off") { ;Off = desbloquear
		SetTimer(BlockInput,  "Off")
		RegDelete( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger" )
		Suspend, Off
		return DllCall("User32.dll\BlockInput", "Int", false)
	} else if (OnOff=1||OnOff="On") { ;On = bloquear
		Suspend, On
		if (Delay>0)
			SetTimer(BlockInput, Delay)
		if DisableTaskManager
			RegWrite(, "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger", "Disable")
		return DllCall("User32.dll\BlockInput", "Int", true)
}}

;Devuelve una matriz asociativa de objetos COM activos,donde cada tecla es el apodo, artículo o sufijo del objeto.
;Si se especifica un prefijo, sólo los objetos cuyos apodos del elemento que coincida con el prefijo dado son devueltos, y el prefijo se omite de las teclas devueltas.
GetActiveObjects(Prefix:="", CaseSensitive:=false) { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=6494 || By Lexikos
    DllCall("ole32.dll\CoGetMalloc", "UInt", 1, "Ptr*", malloc), objects := {}
    DllCall("ole32.dll\CreateBindCtx", "UInt", 0, "Ptr*", bindCtx)
    DllCall(NumGet(NumGet(bindCtx+0)+8*A_PtrSize), "Ptr", bindCtx, "Ptr*", rot)
    DllCall(NumGet(NumGet(rot+0)+9*A_PtrSize), "Ptr", rot, "Ptr*", enum)
    while DllCall(NumGet(NumGet(enum+0)+3*A_PtrSize), "Ptr", enum, "UInt", 1, "Ptr*", mon, "Ptr", 0) = 0
    {
        DllCall(NumGet(NumGet(mon+0)+20*A_PtrSize), "Ptr", mon, "Ptr", bindCtx, "Ptr", 0, "Ptr*", pname) 
        name := StrGet(pname, "UTF-16")
        DllCall(NumGet(NumGet(malloc+0)+5*A_PtrSize), "Ptr", malloc, "Ptr", pname)
        if InStr(name, Prefix, CaseSensitive) = 1 {
            DllCall(NumGet(NumGet(rot+0)+6*A_PtrSize), "Ptr", rot, "Ptr", mon, "Ptr*", punk)
            if (pdsp := ComObjQuery(punk, "{00020400-0000-0000-C000-000000000046}"))
                obj := ComObject(9, pdsp, 1), ObjRelease(punk)
            else
                obj := ComObject(13, punk, 1)
            objects[SubStr(name, StrLen(Prefix) + 1)] := obj
        }
        ObjRelease(mon)
    }
    ObjRelease(enum), ObjRelease(rot), ObjRelease(bindCtx), ObjRelease(malloc)
    return objects
}

;Define el contenido de la variable de entorno especificada para el proceso actual .
EnvAdd(lpName, lpValue) {
	return DllCall("Kernel32.dll\SetEnvironmentVariableW", "Str", lpName, "Str", lpValue)
}	

;Recupera el contenido de la variable especificada desde el bloque de entorno del proceso invocador .
;ErrorLevel es:
	;0 = Sin errores | 1 = Error | 2 = La variable de entorno especificada no se encontró
EnvGet(EnvVarName, ByRef UserEnv := "", ByRef SystemEnv := "") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683188%28v=vs.85%29.aspx
	UserEnv := IsByRef( UserEnv ) ? RegRead( "HKCU\Environment", EnvVarName ) : ""
	SystemEnv := IsByRef( SystemEnv ) ? RegRead( "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", EnvVarName ) : ""
	if !( nSize := DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Ptr", 0, "UInt", 0) )
		return "", ErrorLevel := 2
	VarSetCapacity(lpBuffer, nSize * 2) ;max 32767
	if !DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Str", lpBuffer, "UInt", nSize)
		return "", ErrorLevel := 1
	return lpBuffer, ErrorLevel := 0
}

;Notifica el sistema operativo y todas las aplicaciones que se ejecutan que las variable(s) del sistema han cambiado .
EnvUpdate() {
	return SendMessage(0xFFFF, 0x001A,,, "Str", "Environment")
}

;añadir al registro: para el usuario actual
UserEnvAdd(lpName, lpValue) {
	return RegWrite(, "HKCU\Environment", lpName, lpValue )
}

;añadir al registro: para todos los usuarios
SystemEnvAdd(lpName, lpValue) {
	return RegWrite(, "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", lpName, lpValue )
}

;cambiar fondo de pantalla
;la imagen en lo posible debe ser .BMP, si no es bmp se intenta convertir a este formato.
;Sintaxis: SetDesktopBackground( [imagen], [ancho], [alto] )
;Nota: es necesario iniciar gdip si la imagen no es .BMP. Gdip_Startup()
;Ejemplo:
	;pToken := Gdip_Startup()
	;SetDesktopBackground("C:\Image.JPG")
	;Gdip_Shutdown(pToken)
	;ExitApp
SetDesktopBackground(Image, Width := "", Height := "") {
    if !IsFile(Image)
        return false
	if (SplitPath(Image,,,, ImageName).Ext!="bmp") ;necesario Gdip_Startup() -->
		ImageConvert(Image, _:=A_AppData "\AutoHotKey\Windows\desktopwallpaper\" ImageName ".bmp", Width, Height)
		, Image := _ ;<--
    return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0014, "UInt", 0, "Str", Image, "UInt", 0x0001|0x0002)
}

;recupera la ruta y el nombre completo del archivo/carpeta especificado
GetFullPathName(lpFileName) {
	if InStr(lpFileName, ":")&&(StrLen(lpFileName)=2)
		lpFileName .= "\"
	nBufferLength := DllCall("Kernel32.dll\GetFullPathNameW", "Str", lpFileName, "UInt", 0, "Ptr", 0, "PtrP", 0)
	VarSetCapacity( lpBuffer, nBufferLength * 2 ) 
	i := DllCall("Kernel32.dll\GetFullPathNameW", "Str", lpFileName, "UInt", nBufferLength, "Str", lpBuffer, "PtrP", 0)
	return RTrim( lpBuffer, "\" ), ErrorLevel := !i
}

;ACCIÓN AL CERRAR/ABRIR TAPA DEL PORTATIL
;Sintáxis: StartPSN( [FUNCIÓN] )
;registrar
StartPSN(Function := "WM_POWERBROADCAST") {
  VarSetCapacity(guid, 16)
  Numput(0xBA3E0F4D, guid, 0, "UInt"), Numput(0x4094B817, guid, 4, "UInt")
  Numput(0x63D5D1A2, guid, 8, "UInt"), Numput(0xF3A0E679, guid, 12, "UInt")
  if ( R := DllCall("User32.dll\RegisterPowerSettingNotification", "Ptr", A_ScriptHwnd, "Ptr", &guid, "UInt", 0) ) {
      OnMessage(0x218, Function)
      return R
  }
  return 0
}
;Sintáxis: StopPSN( [valor que devuelve StartPSN] )
;anular
StopPSN(H) {
  return DllCall("User32.dll\UnregisterPowerSettingNotification", "Ptr", H), OnMessage(0x218, "")
}
;acción a tomar al cerrar o abrir (función)
WM_POWERBROADCAST(wparam, lparam) {
  if (wparam = 0x8013) { ;PBT_POWERSETTINGCHANGE 32787 (0x8013) --> Identificador de sucesos.
      S := Numget(lparam + 20, 0, "uchar") ? 1 : 0 ;POWERBROADCAST_SETTING  --> https://msdn.microsoft.com/en-us/library/windows/desktop/hh448380%28v=vs.85%29.aspx
      MsgBox, 4160, PowerSettingNotification, Estado: %S%
  }
  return 1
}

ComVar() { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3964
	static base := {__Get: "ComVarGet", __Set: "ComVarSet", __Delete: "ComVarDel"}
	static ComObjParam := A_AhkVersion < "2" ? "ComObjParameter" : "ComObject"
	; Create an array of 1 VARIANT.  This method allows built-in code to take
	; care of all conversions between VARIANT and AutoHotkey internal types.
	arr := ComObjArray(0xC, 1)
	; Lock the array and retrieve a pointer to the VARIANT.
	DllCall("oleaut32\SafeArrayAccessData", "ptr", ComObjValue(arr), "ptr*", arr_data)
	; Store the array and an object which can be used to pass the VARIANT ByRef.
	return {ref: %ComObjParam%(0x400C, arr_data), _: arr, base: base}
}

ComVarGet(cv, p*) { ;Called when script accesses an unknown field.
	if p.MaxIndex() = "" ; No name/parameters, i.e. cv[]
		return cv._[0]
}

ComVarSet(cv, v, p*) { ;Called when script sets an unknown field.
	if p.MaxIndex() = "" ; No name/parameters, i.e. cv[]:=v
		return cv._[0] := v
}

ComVarDel(cv) { ;Called when the object is being freed.
	; This must be done to allow the internal array to be freed.
	DllCall("oleaut32\SafeArrayUnaccessData", "ptr", ComObjValue(cv._))
}

;obtener sugerencias de una palabra vía google
GoogleSuggest(query) { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=7182
	if !query
		return
    i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, i.Open("GET", "http://suggestqueries.google.com/complete/search?output=firefox&q=" query, 1)
		, i.Send(), i.WaitForResponse()
    s := StrReplace(i.ResponseText, Chr(34) ",[" Chr(34), "`r`n")
		, s := StrReplace(s, Chr(34) "," Chr(34), "`r`n"), s := StrReplace(s, Chr(34))
		, s := StrReplace(s, "["), s := StrReplace(s, "]"), s := StrReplace(s, query,,, 1)
	return StrReplace(s, "`r`n",,, 1)
}

;SendMessage / SendMessageTimeOut / SendMessageCallback
;envía el mensaje especificado a una ventana
;Sintaixs: SendMessage( [ID], [mensaje], [wtipo], [wParam], [Itipo], [IParam], [CallBackFunc/tiempo fuera (ms 1~15000)], [CallBackData] )
SendMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0, TimeOut := 5000, CallBackData := "") {
	if (CallBackData!="")
		r1 := DllCall("User32.dll\SendMessageCallbackW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam, "Ptr", TimeOut, "UPtr", CallBackData)
	else if (TimeOut>0)
		r1 := DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam, "UInt", 0x0002, "UInt", TimeOut, "UPtrP", r2)
	else
		r1 := DllCall("User32.dll\SendMessageW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam)
	return TimeOut>0&&CallBackData=""?r2:r1, ErrorLevel := !r1
}

;PostMessage
;Sintaixs: PostMessage( [ID], [mensaje], [tipo], [wParam], [tipo], [IParam] )
PostMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0) {
	r1 := DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam)
	return r1, ErrorLevel := !r1
}

;Libera la biblioteca (DLL ) módulo cargado de vínculos dinámicos
FreeLibrary(hModule) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683152%28v=vs.85%29.aspx
	return i:=DllCall("Kernel32.dll\FreeLibrary", "Ptr", hModule), ErrorLevel := !i
}

;Carga los módulos especificados en el espacio de direcciones del proceso de llamada 
;el valor devuelto es un identificador para el módulo cargado
;Sintaxis: LoadLibrary( [archivo|dll], [0], [opciones] )
LoadLibrary(lpFileName, hFile := false, dwFlags := false) {
	if dwFlags
		i:=DllCall("Kernel32.dll\LoadLibraryExW", "Str", lpFileName, "UInt", hFile, "UInt", dwFlags) 
	else
		i:=DllCall("Kernel32.dll\LoadLibraryW", "Str", lpFileName) 
	return i, ErrorLevel := !i
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179%28v=vs.85%29.aspx

;Sintaxis: SetTimer( [Etiqueta], [Período], [Prioridad -2147483648~2147483647] )
SetTimer(Label := "", PeriodOnOffDelete := "On", ThreadPriority := 0) {
	SetTimer, %Label%, %PeriodOnOffDelete%, %ThreadPriority%
}

gosub(Label) {
	if IsLabel(Label)
		gosub, %Label%
}

;esperar (ms)
;Sintaxis: Sleep( [milisegundos], [¿usar mayor precisión?] )
Sleep(Delay := 0, pc := false) {
	static Frequency
	if (Delay>=-1) {
		if !pc {
			Sleep, %Delay%
		} else {
			if !Frequency
				DllCall("Kernel32.dll\QueryPerformanceFrequency", "Int64*", Frequency)
			DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Start)
			Finish := Start + (Frequency * (Delay / 1000))
			Loop
				DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Current)
			until (Current >= Finish)
		}
	}
}

;reiniciar script
Reload(Force := 0, ExitCode := 0) {
	if Force {
		if A_IsCompiled
			Run, "%A_ScriptFullPath%"
		else
			Run, "%A_AhkPath%" "%A_ScriptFullPath%"
		ExitApp( Force, ExitCode )
	}
	Reload
}

;termina el script
;Sintaxis: ExitApp( [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
ExitApp(Force := false, ExitCode := 0) {
	if (Force)
		ProcessClose(ProcessExist(),,, ExitCode)
	ExitApp, %ExitCode% ;DllCall("User32.dll\PostQuitMessage", "Int", 0)
}

;tiempo fuera en el que el script finaliza
;Sintaxis: ExitAppTimer( [segundos], [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
;EJEMPLO:
	;ExitAppTimer(5)
	;Loop {
		;ToolTip % ExitAppTimer()
		;Sleep 100
	;}
ExitAppTimer(Seconds := "", Force := 0, ExitCode := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=46906#p46906
    static ending
	static ExitAppTimer := Func("ExitAppTimer")
    if (Seconds="ExitApp")
        MsgBox(Force "`n" ExitCode), ExitApp(Force, ExitCode)
    if !Seconds
        return (ending - A_TickCount) / 1000.0
    SetTimer(ExitAppTimer.Bind("ExitApp", Force, ExitCode), -(Seconds*1000))
    ending := A_TickCount+(Seconds*1000)
}

;potapapeles
;Sintaxis: Clipboard( [texto], [¿copiar seleccionado al portapapeles? (segundos a esperar)] )
Clipboard(String := "", Selected := 0) {
	if Selected {
		try {
			Temp := ClipboardAll, Clipboard()
			Send("{LCtrl Down}c{LCtrl Up}")
			ClipWait(Selected>0?Selected:1)
			return Clipboard, Clipboard := Temp
		} catch {
			return ""
		}
	}
	if (String="") {
		if !DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd) {
			ElapsedTime := A_TickCount+3000
			Loop {
				if DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd)
					break
				if (A_TickCount>=ElapsedTime)
					return 0
				Sleep(100)
			}
		}
		return DllCall("User32.dll\EmptyClipboard"), DllCall("User32.dll\CloseClipboard")
	}
	try return Clipboard := String
}

;recupera el tiempo que ha pasado (ms) desde que el script se inició
GetTickCount(ByRef TickCount := "") {
	return TickCount := DllCall("Kernel32.dll\GetTickCount")
}

;espera a que el portapapeles contenga datos
;Sintaxis: ClipWait( [segundos], [¿cualquier tipo de datos?] )
ClipWait( Seconds := -1, AnyFormats := 1 ) {
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (AnyFormats&&DllCall("User32.dll\CountClipboardFormats"))
		||(!AnyFormats&&(DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 1)||DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 15)))
			return 1, ErrorLevel := 0
		if (Seconds>=0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(50)
	}
}

;establece el directorio de trabajo.
SetWorkingDir(DirName) {
	return DllCall("kernel32.dll\SetCurrentDirectoryW", "Str", DirName)
}

;obtiene el directorio de trabajo
GetWorkingDir() {
	uSize := VarSetCapacity(lpBuffer, (260 + 1) * 2) / 2
	DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt*", uSize, "Str", lpBuffer)
	return lpBuffer
}

;A_LastError
GetLastError(ByRef FormatMessage := "") {
	return LastError := DllCall("Kernel32.dll\GetLastError")
		, FormatMessage := IsByRef( FormatMessage ) ? FormatMessage( LastError ) : ""
}

;establece A_LastError
SetLastError(num) {
	return DllCall("User32.dll\SetLastErrorEx", "UInt", num, "UInt", 0)
}

;descripcion del error
FormatMessage(dwMessageId := "") {
	dwMessageId := dwMessageId != "" ? dwMessageId : GetLastError()
	nSize := VarSetCapacity(lpBuffer, 2024) - 1524
	if DllCall("Kernel32.dll\FormatMessageW", "UInt", 0x1000, "Ptr", 0, "UInt", dwMessageId, "UInt", 0x800, "Str", lpBuffer, "UInt", nSize, "UInt", 0)
		return lpBuffer
}

FormatTime(Time, Format := "yyyyMMddHmmss") {
	FormatTime, hTime, %Time%, % Format=""?"dd/MM/yyyy (HH:mm:ss tt)":Format
	return hTime
}

;comprueba si existe un archivo o carpeta y obtiene la ruta completa.
Exist(ByRef Filename) {
	return i := FileExist( Filename )
		, Filename := RTrim(GetFullPathName( Filename ), "\")
		, ErrorLevel := !i
}

;leer archivo ini
;Sintaxis: IniRead( [archivo], [seccion], [clave] )
IniRead(Filename, Section := "", Key := "", OutputVar := " ") {
	if (Key != "") AND (Section != "")
		IniRead, OutputVar, %Filename%, %Section%, %Key%, %OutputVar% ;OutputVar
	else if (Key = "") AND (Section != "")
		IniRead, OutputVar, %Filename%, %Section% ;OutputVarSection
	else if (Key = "") AND (Section = "")
		IniRead, OutputVar, %Filename% ;OutputVarSectionNames
	return OutputVar
}

IniWrite(Value, Filename, Section, Key := "") {
	if (Key != "")
		IniWrite, %Value%, %Filename%, %Section%, %Key%
	else
		IniWrite, %Value%, %Filename%, %Section%
	return !ErrorLevel
}

IniDelete(Filename, Section, Key := "") {
	if (Key != "")
		IniDelete, %Filename%, %Section%, %Key%
	else
		IniDelete, %Filename%, %Section%
	return !ErrorLevel
}

Edit(Filename := -1, OpenWith := 0) {
	if (Filename = -1) {
		Edit
		return 1
	}
	if OpenWith
		Run, "%OpenWith%" "%Filename%",, UseErrorLevel, PID
	if ErrorLevel OR !OpenWith
		Run, Edit "%Filename%",, UseErrorLevel, PID
	return PID
}

;Thread, NoTimers [, false]
;Thread, Priority, n
;Thread, Interrupt [, Duration, LineCount]
Thread(Setting := "NoTimers", P2 := "", P3 := "") {
	Thread, %Setting%, %P2%, %P3%
}

;ejecutar script
;Sintaxis: ExecScript( [script], [parámetros], [ejecutableAHK], [nombre] )
ExecScript(Script, Params := "", AhkPath := "", Name := "") {
	Name := Name = "" ? "AutoHotKey" A_AhkVersion : Name, Pipe := []
	AhkPath := IsFile( AhkPath ) ? AhkPath : A_AhkPath
	Call := Chr(34) AhkPath Chr(34) " /CP65001 " Chr(34) "\\.\pipe\" Name Chr(34)
	Pipe[1] := DllCall("CreateNamedPipe", "Str", "\\.\pipe\" Name, "UInt", 2, "UInt", 0, "UInt", 255, "UInt", 0, "UInt", 0, "UPtr", 0, "UPtr", 0, "UPtr")
	Pipe[2] := DllCall("CreateNamedPipe", "Str", "\\.\pipe\" Name, "UInt", 2, "UInt", 0, "UInt", 255, "UInt", 0, "UInt", 0, "UPtr", 0, "UPtr", 0, "UPtr")
	Shell := ComObjCreate("WScript.Shell"), Exec := Shell.Exec(Call " " Params)
	DllCall("ConnectNamedPipe", "UPtr", Pipe[1], "UPtr", 0), DllCall("CloseHandle", "UPtr", Pipe[1])
	DllCall("ConnectNamedPipe", "UPtr", Pipe[2], "UPtr", 0), FileOpen(Pipe[2], "h", "UTF-8").Write( Script )
	return Exec, DllCall("CloseHandle", "UPtr", Pipe[2])
}

;traducir texto vía google translate
;Sintaxis: Translate( [texto], [entrada], [salida] )
;EJEMPLO: MsgBox % Translate( "Hello, this is a test", "en", "es" )
Translate(String, From := "", To := "") {
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	url := "https://translate.google.com/translate_a/single?client=t&sl=" From "&tl=" To
	     . "&dt=bd&dt=ex&dt=ld&dt=md&dt=qca&dt=rw&dt=rm&dt=ss&dt=t&dt=at&ie=UTF-8&oe=UTF-8&otf=2&srcrom=0&ssel=0&tsel=3&q=" string
	i.Open("GET", url, true)
	i.SetRequestHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko)")
	i.Send()
	i.WaitForResponse()
	return RegExReplace(i.ResponseText, "^.*?""(.*?)"".*$", "$1")
}

;obtener ancho y alto de una imagen
;Sintaxis: ImageGetDimension( [imagen], [ancho (out)], [alto (out)] )
;Nota: es necesario iniciar gdip. Gdip_Startup()
ImageGetDimension(Image, ByRef Width := "", ByRef Height := "", Free := true) {
	pBitmap := Gdip_CreateBitmapFromFile(Image)
	pGraphics := Gdip_GraphicsFromImage(pBitmap)
	x:=Gdip_GetImageDimensions(pBitmap, Width, Height)
	Gdip_DeleteGraphics(pGraphics)
	Gdip_DisposeImage(pBitmap)
	i := {}, i.w := i.Width := Width, i.h := i.Height := Height
	return i, ErrorLevel := !x
}

;establecer dimenciones de la imagen y/o modificar extension a png, bmp, jpg, tiff o gif
;Sintaxis: ImageConvert( [imagen], [directorio\nombre.ext (png|bmp|jpg|tiff|gif)], [ancho], [alto], [¿preservar la relacion de aspecto?], [profundidad de bits 24/32 (solo .bmp)] )
;Nota: es necesario iniciar gdip. Gdip_Startup() - ver ejemplo: SetDesktopBackground()
ImageConvert(Image, Output := "", Width := "", Height := "", PreserveAspectRatio := true, BitDepth := 32) {
	SplitPath(Output,, ImageDir, ImageExt), pBitmapFile := Gdip_CreateBitmapFromFile(Image)
	, CurrentWidth := Gdip_GetImageWidth(pBitmapFile), CurrentHeight := Gdip_GetImageHeight(pBitmapFile)
	, NewWidth := Width=""?CurrentWidth:Width, NewHeight := Height=""?CurrentHeight:Height
	if PreserveAspectRatio&&((r1:=CurrentWidth/NewWidth)>(r2:=CurrentHeight/NewHeight))
		NewHeight := CurrentHeight/r1
	else if PreserveAspectRatio
		NewWidth := CurrentWidth/r2
	if !IsDir(ImageDir) ;si el directorio donde se va a crear la imagen no existe
		DirCreate(ImageDir) ;crearlo
	pBitmap := Gdip_CreateBitmap(NewWidth, NewHeight, ImageExt="bmp"&&BitDepth=24?0x00021808:0x26200A)
	, pGraphics := Gdip_GraphicsFromImage(pBitmap), Gdip_SetSmoothingMode(pGraphics, 4), Gdip_SetInterpolationMode(pGraphics, 7)
	, Gdip_DrawImage(pGraphics, pBitmapFile, false, false, NewWidth, NewHeight), Gdip_DisposeImage(pBitmapFile)
	, Gdip_SaveBitmapToFile(pBitmap, Output), Gdip_DisposeImage(pBitmap), Gdip_DeleteGraphics(pGraphics) 
} ;http://ahkscript.org/boards/viewtopic.php?f=6&p=49878&sid=8974c43be898318cea6b8dc509f2e6df#p49878

;efecto de agua para una imagen. (ver notas)
;Sintaxis: ImageWaterCtrl( [ID], [Modo], [Opciones*] )
;PARÁMETROS:
	;ID = HWND de la ventana (GUI) | ruta de waterctrl.dll (ver notas) | control (modo SETPARENT)
	;MODOS (descripcion) = OPCIONES (las opciones varian dependiendo el modo espesificado):
		;SETPATH = establecer directorio de waterctrl.dll (ver notas). Nota: solo debe espesificarce una vez
		;ENABLE (habilitar) = [Imagen ruta o Imagen HWND] [xpos] [ypos] [radio] [alto]
		;DISABLE (deshabilitar)
		;BLOB (efecto gota de agua) = [xpos] [ypos] [radio] [alto]
		;SETPARENT (establecer en el control espesificado en ID)
		;FLATTEN = parar efecto
		;EXIT = liberar la memoria para waterctrl.dll
;NOTAS: 
	;--> necesario waterctrl.dll, descarga: http://restools.hanzify.org/article.asp?id=80 | http://restools.hanzify.org/inno/waterctrl/inno_waterctrl_v2.zip
	;--> poner waterctrl.dll en el mismo directorio que el script o espesificar la ruta en el primer parámetro y establecer el Modo a 'SETPATH'
	;--> valor de ErrorLevel = ver funcion
;EJEMPLO (quitar '/*' y '*/'):
	/*;cargar waterctrl.dll. poner WaterCtrl.dll en el escritorio
	ImageWaterCtrl( A_Desktop "\WaterCtrl.dll", "SETPATH")
	Gui, +HWND_G
		;establecer ventana. poner imagen en el escritorio con el nombre ahk_logo, extension .BMP
		;link imagen (o buscar una .BMP): https://i.imgur.com/uK1ZX7p.png
		ImageWaterCtrl(_G, "Enable", A_Desktop "\ahk_logo.bmp") 
	Gui, Add, Text, x0 y111 w542 h111 HWND_T
		;establecer imagen en el control de texto
		ImageWaterCtrl(_T, "SETPARENT") 
	Gui, Add, Button, x15 y255 gWaterBlob, WaterBlob
	Gui, Add, Button, x85 y255 gFlattenWater, FlattenWater
	Gui, Show,, ImageWaterCtrl
	Return
	WaterBlob:
	ImageWaterCtrl(, "BLOB", 500, 50) ;efecto gota
	ImageWaterCtrl(, "BLOB", 50, 50) ;efecto gota
	ImageWaterCtrl(, "BLOB", 250, 50) ;efecto gota
	Return
	FlattenWater:
	ImageWaterCtrl(, "FLATTEN") ;quitar efectos
	Return
	GuiClose:
	ImageWaterCtrl(, "EXIT") ;liberar WaterCtrl.dll 
	ExitApp
	*/
ImageWaterCtrl(hWnd := "", Mode := "Enable", Option*) {
	static LoadLibrary, LibraryPath
	if (Mode="SETPATH")
		return (i:=FileExist(hWnd))?(LibraryPath:=hWnd):0, ErrorLevel := !i
	if !LibraryPath&&!FileExist(A_ScriptDir "\waterctrl.dll")
		return 0, ErrorLevel := 2 ;ErrorLevel 2 = waterctrl.dll no se encuentra
	if LoadLibrary&&(Mode="EXIT"||Mode="FREE") {
		ImageWaterCtrl(, "DETACH")
		return i:=FreeLibrary(LoadLibrary), ErrorLevel := !i, LoadLibrary := ""
	}
	if !LoadLibrary&&!(LoadLibrary:=LoadLibrary(LibraryPath?LibraryPath:A_ScriptDir "\waterctrl.dll"))
		return 0, ErrorLevel := 3 ;ErrorLevel 3 = error al cargar waterctrl.dll
	if (Mode="ATTACH"||Mode="ENABLE") {
		if FileExist(Option[1])
			SplitPath(Option[1],,, Ext)
			, Img := DllCall("User32.dll\LoadImageW", "Int", 0, "Str", Option[1], "UInt", Ext="Ico"?1:0, "Int", 0, "Int", 0, "UInt", 0x2010)
		return i:=DllCall("waterctrl\enablewater", "Ptr", hWnd, "Int", Option[2]=""?0:Option[2]
			, "Int", Option[3]=""?0:Option[3], "Ptr", Img?Img:Option[1], "Int", Option[3]=""?3:Option[3]
			, "Int", Option[4]=""?20:Option[4]), ErrorLevel := !i
	} else if (Mode="DETACH"||Mode="DISABLE") {
		return i:=DllCall("waterctrl\disablewater"), ErrorLevel := !i
	} else if (Mode="BLOB") {
		return i:=DllCall("waterctrl\waterblob", "Int", Option[1]=""?0:Option[1], "Int", Option[2]=""?0:Option[2]
		, "Int", Option[3]=""?30:Option[3], "Int", Option[4]=""?30:Option[4]), ErrorLevel := !i
	} else if (Mode="SETPARENT") {
		return i:=DllCall("waterctrl\setwaterparent", "Ptr", hWnd), ErrorLevel := !i
	} else if (Mode="FLATTEN") {
		return i:=DllCall("waterctrl\flattenwater"), ErrorLevel := !i
	}
	return 0, ErrorLevel := 1 ;ErrorLevel 1 = el modo espesificado es inválido
} ;http://ahkscript.org/boards/viewtopic.php?f=22&t=3302&p=16261&hilit=waterctrl#p16261













































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: REGISTRO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;leer en el registro
;Sintáxis: RegRead( [Clave\SubClave], [Valor] )
RegRead(Key, ValueName*) {
	if (ValueName.MaxIndex() > 0)
		RegRead, OutputVar, %Key%, % ValueName[1]
	else
		RegRead, OutputVar, %Key%
	return OutputVar
}
	
;elimina en el registro
;Sintáxis: RegDelete( [Clave\SubClave], [Valor] )
;en caso de éxito devuelve la clave
RegDelete(Key, ValueName*) {
	if !Key
		return 0
	if (ValueName.MaxIndex() > 0) {
		if (ValueName[1] = "")
			return 0
		RegDelete, %Key%, % ValueName[1]
	} else
		RegDelete, %Key%
	return ErrorLevel ? 0 : Key
}
	
;escribe en el registro
;Sintáxis: RegWrite( [Tipo], [Clave\SubClave], [Valor], [Datos] )
;Sintáxis 2: RegWrite( [Clave\SubClave] )
;EJEMPLOS:
	;RegWrite( "HKCC\2" )
	;RegWrite(, "HKCC\2", "RSZ", "VAL_RSZ" )
	;RegWrite( "TIPO INVÁLIDO", "HKCC\2", "RSZ2", "VAL_RSZ2" )
	;RegWrite( "REG_DWORD", "HKCC\2", "RDW", 1024 ** 3 )
RegWrite(ValueType := 0, Key := "", ValueName := "", Value := "") {
	if !InVar( ValueType, "REG_BINARY,REG_DWORD,REG_EXPAND_SZ,REG_MULTI_SZ,REG_SZ" )
		Key := Key ? Key : ValueType, ValueType := "REG_SZ"
	if !Key
		return 0
	if (ValueName = "")
		RegWrite, %ValueType%, %Key%,, %Value%
	else
		RegWrite, %ValueType%, %Key%, %ValueName%, %Value%
	return !ErrorLevel
}

;importar clave
;sintaxis: RegImport( [Archivo], [¿Esperar?] )
RegImport(Filename, Wait := 0) {
	return Start((Wait?"*":"") A_WinDir "\regedit.exe", "-v", "-s", Filename)
}
	
;exportar clave
;sintaxis: RegExport( [Archivo], [Clave], [¿Esperar?] )
RegExport(Filename, Key, Wait := 0) {
	return Start((Wait?"*":"") A_WinDir "\regedit.exe", "-e", Filename, RegSKName(Key, 1))
}

;renombrar un valor/clave
;Sintaxis: RegRename( [clave], [valor], [nuevo nombre], [¿forzar?] )
;NOTA 1: para renombrar una clave, dejar vacio 'valor' (el segundo parámetro). Puede ser MUY LENTO dependiendo de las subclaves y valores
;NOTA 2: el cuarto parámetro (forzar) aumenta la precision. renombra la clave aún si no hay subclaves, valores ni valor por defecto, pero lo hace mas lento dependiendo la cantidad de claves hermanas y/o valores
;A_LastError SE ESTABLECE EN:
	;1 = error al renombrar el valor o la clave.
	;0 = sin errores
	;-1 = el valor o clave a renombrar no existe
	;-2 = ya existe un valor o clave con el mismo nombre
RegRename(Key, ValueName := "", NewName := "", Force := 0) {
	;-----------------------------------------------------------------------------------------------------------
	NewName := StrReplace(StrReplace(NewName, "["), "]") ;quitar '[' y ']' en el nuevo nombre
	if (NewName = "") ;sin nombre
		return 0, SetLastError( 1 )
	;-----------------------------------------------------------------------------------------------------------
	if (ValueName != "") { ; ::::::::::::::::: RENOMBRAR VALOR :::::::::::::::::
		if !( ValueType := RegExist(Key, ValueName, Force) ) ;si no existe el valor
			return 0, SetLastError( -1 )
		if RegExist(Key, NewName, Force) ;si ya existe un valor con el nuevo nombre
			return 0, SetLastError( -2 )
		ValueData := RegRead(Key, ValueName) ;leer datos
			, RegDelete(Key, ValueName) ;eliminar
			, RegWrite(ValueType, Key, NewName, ValueData) ;crear
		return !ErrorLevel, SetLastError( ErrorLevel )
	} 
	;-----------------------------------------------------------------------------------------------------------
	return RegCopy(Key, SplitPath(Key).Dir "\" NewName, Force), RegDelete( Key )
} ;-----------------------------------------------------------------------------------------------------------

RegMove(Key, KeyDest, Force := 0) {
	if !RegCopy(Key, KeyDest, Force)
		return 0
	return RegDelete( Key )
}

;copia una clave a otra nueva
;Sintaxis: Copy( [clave a copiar], [destino], [¿Forzar?] )
;A_LastError SE ESTABLECE EN:
	;1 = error al copiar
	;0 = sin errores
	;-1 = la clave a copiar no existe
	;-2 = la clave destino ya existe
RegCopy(Key, KeyDest, Force := 0) {
	Key := RegSKName(Key, 1, KeyLen)
	if !InStr(Key, "\") OR !InStr(KeyDest, "\") ;clave inválida
		return 0, SetLastError( 1 )
	if !RegExist(Key,, Force) ;la clave a renombrar no existe -1
			return 0, SetLastError( -1 )
	if RegExist(KeyDest,, Force) ;la clave destino ya existe
			return 0, SetLastError( -2 )
	DefaultValue := RegRead(Key) ;leer valor por defecto
	if !ErrorLevel
		RegWrite(, KeyDest,, DefaultValue) ;establecer valor por defecto
	Loop, Reg, %Key%, KVR ;busca claves(K) y valores(V) includas todas las subclaves(R)
	{
		if (A_LoopRegType = "KEY") { ;si es una clave
			SKey_ := KeyDest "\" RegExReplace(SubStr(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, (KeyLen + 2)), "\\+$")
				, RegWrite( SKey_ )
			if ErrorLevel
				return 0, SetLastError( 1 )
		} else if SKey_ { ;si es un valor
			DefaultValue := RegRead(A_LoopRegKey "\" A_LoopRegSubKey) ;leer valor por defecto
				, RegWrite(, SKey_,, DefaultValue) ;establecer valor por defecto
			if ErrorLevel
				return 0, SetLastError( 1 )
			ValueName := RegRead(A_LoopRegKey "\" A_LoopRegSubKey, A_LoopRegName) ;leer datos
				, RegWrite(A_LoopRegType, SKey_, A_LoopRegName, ValueName) ;establecer datos
			if ErrorLevel
				return 0, SetLastError( 1 )
		}
	}
	Loop, Reg, %Key%, V ;copiar valores
	{
		ValueData := RegRead(A_LoopRegKey "\" A_LoopRegSubkey, A_LoopRegName) ;leer datos
			, RegWrite(A_LoopRegType, KeyDest, A_LoopRegName, ValueData) ;establecer datos
		if ErrorLevel
			return 0, SetLastError( 1 )
	}
	return 1, SetLastError( 0 )
}

;comprueba si existe una clave o un valor
;NOTA 1: VALOR: devuelve el tipo de valor | CLAVE: devuelve la fecha de modificacion (solo si se usa 'forzar')
;NOTA 2: omite si no hay claves, valores y el valor por defecto es 'valor no establecido' (devuelve 0 como si no existiera)
;NOTA 3: para evitar lo anterior, debe establecer 'forzar' en 1, pero puede ser lento dependiendo la cantidad de claves hermanas
;Sintaxis: RegExist( [clave], [valor], [¿forzar?] )
RegExist(Key, ValueName := "", Force := false) {
	;-----------------------------------------------------------------------------------------------------------
	if (ValueName != "") { ; :::::::::: COMPROBAR SI EXISTE UN VALOR ::::::::::::::::
		if Force { ;forzar
			Loop, Reg, %Key%, V
				if (A_LoopRegName = ValueName)
					return A_LoopRegType ? A_LoopRegType : 1
			return 0
		} ;normal
		RegRead(Key, ValueName)
		return !ErrorLevel
	} ;-----------------------------------------------------------------------------------------------------------
	if Force { ; ::::::::::::: COMPROBAR SI EXISTE UNA CLAVE ::::::::::::::
		SplitPath( Key, KeyName, Key_ ) ;forzar
		Loop, Reg, %Key_%, K
			if (A_LoopRegName = KeyName)
				return A_LoopRegTimeModified ? A_LoopRegTimeModified : 1
		return RegExist(Key)
	} ;normal
	Loop, Reg, %key%, KV
		return 1
	RegRead(key)
	return !ErrorLevel
} ;-----------------------------------------------------------------------------------------------------------

;transforma una clave en su forma larga/corta
;Sintaxis: RegSKName( [clave], [¿forma larga?] )
RegSKName(Key, Full := 0, ByRef Len := "") {
	Key := RegExReplace(Key, "^\s+"), Key := RegExReplace(Key, "\s+$")
	if ( KeyPos := InStr(Key, "\") )
		SubKey := "\" SubStr(Key, (KeyPos + 1))
			, Key := SubStr(Key, 1, KeyPos)
	Key := RegExReplace(Key, "[^a-zA-Z_]")
	if Full
		HKCR := "HKEY_CLASSES_ROOT", HKCC := "HKEY_CURRENT_CONFIG",  HKCU := "HKEY_CURRENT_USER", HKLM := "HKEY_LOCAL_MACHINE", HKU := "HKEY_USERS"
	else
		HKEY_CLASSES_ROOT := "HKCR", HKEY_CURRENT_CONFIG := "HKCC",  HKEY_CURRENT_USER := "HKCU", HKEY_LOCAL_MACHINE := "HKLM", HKEY_USERS := "HKU"
	return FullKey := ( ( %Key% ? %Key% : Key ) SubKey ), Len := IsByRef(Len) ? StrLen(FullKey) : ""
}

;separa una clave en clave, subclave
SplitKey(_Key, ByRef Key := "", ByRef SubKey := "") {
	return (Key := (KeyPos:=InStr(_Key, "\"))?SubStr(_Key, 1, KeyPos - 1):_Key)
		. "\" (SubKey := KeyPos?SubStr(_Key, (KeyPos + 1)):"")
}

SetRegView(RegView_32or64 := "Default") {
	SetRegView, %RegView_32or64%
}

RegFNKey(Key, Force := 0, String := "(%A_Index%)") {
	tmpkey := 0, Key := Trim( Key )
	Loop {
		if RegExist( tmpkey ? tmpkey : Key,, Force ) {
			tmpkey := Key ( InStr(String, "%A_Index%") ? StrReplace(String, "%A_Index%", A_Index) : "(" A_Index ")" )
		} else {
			return tmpkey ? tmpkey : Key
		}
	}
}

;abrir clave en regedit
;Sintaxis: RegOpenKey( [clave\subclave], [¿comprobar si existe?], [¿forzar?] )
RegOpenKey(Key, CheckExist := 0, Force := 0) {
	Key := Trim( Key )
	if CheckExist && !RegExist( Key,, Force )
		return 0, ErrorLevel := 1
	Key := RegSKName( Key, 1 )
	RegWrite(, "HKCU\Software\Microsoft\Windows\CurrentVersion\Applets\Regedit", "LastKey", Key )
	return Run( A_WinDir "\RegEdit.exe" )
}

;Copia la clave de registro especificada, junto con sus valores y subclaves, a la clave de destino especificada.
;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379768%28v=vs.85%29.aspx
RegCopyTree(Key, Dest) {
	;valores de las claves
	HKEY_CLASSES_ROOT := HKCR := 0x80000000
	HKEY_CURRENT_USER := HKCU := 0x8000000
	HKEY_LOCAL_MACHINE := HKLM := 0x80000002
	HKEY_USERS := HKU := 0x80000003
	HKEY_CURRENT_CONFIG := HKCC := 0x80000005
	
	;inicio: clave\subclave
	Key := Trim( Key ), Pos := InStr( Key, "\" )
	SubKey := Pos ? StrTrimLeft( Key, Pos ) : "" ;subclave
	Key := Pos ? StrLeft( Key, Pos - 1 ) : Key ;clave
	
	Dest := Trim( Dest ), Pos2 := InStr( Dest, "\" )
	SubKey2 := Pos2 ? StrTrimLeft( Dest, Pos2 ) : "" ;subclave
	Key2 := Pos2 ? StrLeft( Dest, Pos2 - 1 ) : Dest ;clave
	
	;abrir la clave
	if !DllCall("Advapi32.dll\RegOpenKeyExW", "Ptr", %Key%, "Ptr", &SubKey, "UInt", 0, "UInt", 0x20019, "Ptr", hKey)
		return 0, ErrorLevel := 2 ;ErrorLevel es 2 si ha ocurrido un error al abrir la clave a copiar
	
	;crear clave destino, si ya existe la abre
	if !DllCall("Advapi32.dll\RegCreateKeyExW", "Ptr", %Key2%, "Ptr", &SubKey2, "UInt", 0, "Ptr", 0, "UInt", 0, "UInt", 0x0004, "Ptr", 0, "Ptr", hKey2, "Ptr", 0)
		return 0, ErrorLevel := 3 ;ErrorLevel es 3 si ha ocurrido un error al abrir/crear la clave destino

	;copiar clave
	if !DllCall("Advapi32.dll\RegCopyTreeW", "Ptr", hKey, "Ptr", 0, hKey2)
		return 0, ErrorLevel := 1 ;ErrorLevel es 1 si ha ocurrido un error al copir la clave
	
	;cerrar clave
	if (SubKey != "")
		DllCall("Advapi32.dll\RegCloseKey", "Ptr", hKey)
		, DllCall("Advapi32.dll\RegCloseKey", "Ptr", hKey2)
	
	return 1, ErrorLevel := 0
}



























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: LISTVIEW CONTROL ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtiene la cantidad de items
LV_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1000+4)
}

;elimina item. dejar vacio el segundo parámetro para eliminar todos los items
LV_DeleteItem(hWnd, Item := 0) {
	return SendMessage(hWnd, 0x1000+(Item>0?8:9),, Item>0?Item-1:0)
}

;eliminar columna
LV_DeleteColumn(hWnd, Column := 1) {
	return SendMessage(hWnd, 0x1000+28,, Column-1)
}

;actualiza un item
LV_Update(hWnd, Item) {
	return SendMessage(hWnd, 0x1000+42,, Item-1)
}

;redibujar items
LV_RedrawItem(hWnd, ItemFirst := 0, ItemLast := 0) {
	return SendMessage(hWnd, 0x1000+21,, ItemFirst-1,, ItemLast-1)
}

;cambiar texto a un item
;Sintaxis: LV_SetItemText( [LV], [texto], [item], [columna] )
LV_SetItemText(hWnd, pszText := "", Item := 1, Column := 1) {
	VarSetCapacity(LVITEM, A_PtrSize = 4 ? 60 : 80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	NumPut(&pszText, LVITEM, A_PtrSize = 4 ? 20 : 24, "Ptr"), NumPut(StrLen(pszText)+1, LVITEM, A_PtrSize = 4 ? 24 : 32, "Int")
	return SendMessage(hWnd, 0x1000+116,, Item-1,, &LVITEM)
}

;obtener texto de un item
;Sintaxis: LV_GetItemText( [LV], [item], [columna] )
LV_GetItemText(hWnd, Item := 0, Column := 1) {
	VarSetCapacity(LVITEM, A_PtrSize = 4 ? 60 : 80, 0)
	NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int"), cchTextMax := (VarSetCapacity(pszText, 1024 * 2, 0) / 2) + 1
	NumPut(&pszText, LVITEM, A_PtrSize = 4 ? 20 : 24, "Ptr"), NumPut(cchTextMax, LVITEM, A_PtrSize = 4 ? 24 : 32, "Int")
	TextLength := SendMessage(hWnd, 0x1000+115,, Item-1,, &LVITEM)
	return StrGet(&pszText, TextLength)
}

;obtener texto de un item.
;Sintaxis: LV_GetItemTextEx( [LV], [item], [columna (opcional)], [proceso id (opcional)] )
;NOTA: solo usar en casos en que no se pueda obtener con LV_GetItemText()
LV_GetItemTextEx(hWnd, Item, Column := 1, ProcessId := 0) { ;http://www.autohotkey.com/board/topic/81820-how-to-get-specific-row-text-in-a-syslistview32-easily/
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0008|0x0010|0x0020, "Int", 0 , "UInt", ProcessId?ProcessId:WinGetPid(hWnd))
	pAddress := DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "PtrP", 0, "UPtr", A_PtrSize = 4 ? 60 : 80, "UInt", 0x00001000, "UInt", 0x04)
	pAddress2 := DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "PtrP", 0, "UPtr", cchTextMax := 1024 + 1, "UInt", 0x00001000, "UInt", 0x04)
	VarSetCapacity(LVITEM, A_PtrSize = 4 ? 60 : 80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	VarSetCapacity(pszText, cchTextMax * 2, 1), NumPut(pAddress2, LVITEM, A_PtrSize = 4 ? 20 : 24, "Ptr"), NumPut(cchTextMax, LVITEM, A_PtrSize = 4 ? 24 : 32, "Int") 
	DllCall("Kernel32.dll\WriteProcessMemory", "Ptr", hProcess, "UInt", pAddress, "Ptr", &lvItem, "UPtr", A_PtrSize = 4 ? 60 : 80, "UPtr", 0)
	i := SendMessage(hWnd, 0x1000+115,, Item-1, "UInt", pAddress)
	DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, "UInt", pAddress2, "Ptr", &pszText, "UPtr", cchTextMax, "UPtr", 0)
	return pszText, DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", pAddress, "UPtr", 0, "UInt", 0x8000)
		, DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", pAddress2, "UPtr", 0, "UInt", 0x8000), DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ErrorLevel := !i
}

;busca items uno por uno.
;Sintaxis: LV_GetNextItem( [LV], [modo] )
;Modos: F = foco | S = seleccionado
LV_GetNextItem(hWnd, Item := 0, Mode := "") {
	Index := SendMessage(hWnd, 0x1000+12,, Item,, Mode="S"?0x0002:Mode="F"?0x0001:0x0000)
	return Index, ErrorLevel := Index=-1
}

;ListView: establece el estilo extendido
;Sintaxis: LV_SetExStyle( [hWnd], [Estilo], [Remover = 0] )
;ESTILOS:
	;0x010000 = dibujo vía doble búfer, lo que reduce el parpadeo
	;0x00000004 = activa las casillas de verificación para los elementos (checkbox)
	;0x00000001 = muestra líneas de cuadrícula alrededor de los elementos y subelementos (grid)
LV_SetExStyle(hWnd, wParam, lParam := "*") {
	return SendMessage(hWnd, 0x1036, "UInt", lParam="*"?wParam:lParam, "UInt", lParam)
}

;autoselecciona items en el listview al escribir en un edit.
;Sintaxis: AutoSelect( [Texto], [Columna], [fila inicio], [fila fin], [¿sensible a mayusculas?] )
;NOTA: devuelve el número de fila; o 0 si no encontro nada
LV_AutoSelect(Text := "", Col := 0, Start := 1, End := 0, CaseSensitive := 0) {
	if !(Col > 0) {
		Loop, % LV_GetCount( "Col" )
			if (i:=LV_AutoSelect( Text, A_Index, Start, End, CaseSensitive ))
				return i, ErrorLevel := 0
		return 0, ErrorLevel := 1
	}
	Count := LV_GetCount(), Length := StrLen( Text )
	Loop, %Count%
		LV_Modify(A_Index, "-Select")
	if (Length > 0)
		Loop, %Count% {
			if (A_Index < Start)
				continue
			LV_GetText(_Text, A_Index, Col)
			if (Length = 1) {
				Text_ := StrLeft( _Text, 1 )
				if (!CaseSensitive&&(_Text=Text))||(CaseSensitive&&(_Text==Text))
					return A_Index, i:=LV_Modify(A_Index, "+Select +Vis"), ErrorLevel := !i
				else if (A_Index < Count)
					continue
			}
			if InStr(_Text, Text, CaseSensitive)
				return A_Index, i:=LV_Modify(A_Index, "+Select +Vis"), ErrorLevel := !i
			else if End&&(A_Index >= End)
				break
		}
	return 0, ErrorLevel := 1
}
	
LV_Set( Row := 0, Flags := "+Select", Type := -1 ) {
	if (Type != -1) {
		RowNumber := 0
		while (RowNumber := LV_GetNext(RowNumber, Type="F"?"F":Type="C"? "C":""))
			if (Row>0)&&(Row!=RowNumber)
				continue
			else
				LV_Modify(A_Index, Flags), List .= A_Index ","
	} else {
		Loop, % LV_GetCount( Type )
			if (Row>0)&&(Row!=A_Index)
				continue
			else
				LV_Modify(A_Index, Flags), List .= A_Index ","
	}
	return RTrim( List, "," )
}

;recupera texto en un item espesificado
;Sintaxis: LV_GetSelected( [columna], [F|C] )
LV_GetSelected(Col := 1, Type := "F", RowNumber := 0) {
	while ( RowNumber := LV_GetNext(RowNumber, Type) ) {
		LV_GetText(Text, RowNumber, Col) 
		Result .= (A_Index=1?"":"`n") Text
	}
	return Result
}



























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;::::::::::::::::::::::::::::::::::::::::::::: TREEVIEW CONTROL ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Obtener item
;Sintaxis: TV_GetNextItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773622%28v=vs.85%29.aspx
;Nota: espesificar 'CARET' para obtener el item seleccionado (3er parametro)
TV_GetNextItem(hWnd, Item := 0, Mode := "NEXT") {
	static Modes := {"CARET": 0x0009, "CHILD": 0x0004, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "LASTVISIBLE": 0x000A, "NEXT": 0x0001
	, "NEXTSELECTED": 0x000B, "NEXTVISIBLE": 0x0006, "PARENT": 0x0003, "PREVIOUS": 0x0002, "PREVIOUSVISIBLE": 0x0007, "ROOT": 0x0000}
	return SendMessage(hWnd, 0x110A, "UInt", Modes[Mode],, Item)
}

;obtiene la cantidad de items
;Sintaxis: TV_GetItemCount( [ID], [Modo] )
;Modos: ALL|SELECTED|VISIBLE
TV_GetItemCount(hWnd, Mode := "ALL") {
	if (Mode="ALL")
		return SendMessage(hWnd, 0x1105)
	else if (Mode="VISIBLE")
		return SendMessage(hWnd, 0x1110)
	else if (Mode="SELECTED") {
		ItemSelectedCount := 0
		while TV_GetNextItem(hWnd,, "NEXTSELECTED")
			ItemSelectedCount++
		return ItemSelectedCount
	}
	return 0, ErrorLevel := 1
}

;seleccionar item
;TV_SelectItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773736%28v=vs.85%29.aspx
TV_SelectItem(hWnd, Item := 0, Mode := "CARET") {
	static Modes := {"CARET": 0x0009, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "NOSINGLEEXPAND": 0x8000}
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x110B, "UInt", Modes[Mode],, Item-1)
}

;hacer visible un item
;TV_VisibleItem( [ID], [Item] )
TV_VisibleItem(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1114,,,, Item-1)
}

;editar etiqueta del item
;TV_EditLabel( [ID], [Item] )
TV_EditLabel(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1141,,,, Item-1)
}

;eliminar un item o 'todos (defecto)'
;Sintaxis: TV_DeleteItem( [ID], [Item] )
TV_DeleteItem(hWnd, Item := 0) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1101,,,, -65536)
	return SendMessage(hWnd, 0x1101,,,, Item-1)
}

;expandir/contraer/invertir items
;Sintaxis: TV_Expand( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773568%28v=vs.85%29.aspx
TV_Expand(hWnd, Item := 0, Mode := "EXPAND") {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	static Modes := {"COLLAPSE": 0x0001, "COLLAPSERESET": 0x8000, "EXPAND": 0x0002, "EXPANDPARTIAL": 0x4000, "TOGGLE": 0x0003}
	return SendMessage(hWnd, 0x1102, "UInt", Modes[Mode],, Item-1)
}

;cambiar nombre
;Sintaxis: TV_SetItemText( [ID], [texto], [Item] )
TV_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	NumPut(0x0001, TVITEMEX, 0, "UInt")
	NumPut(Item-1, TVITEMEX, 4, "Ptr")
	NumPut(&NewText, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
	NumPut(StrLen(NewText), TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
	return return SendMessage(hWnd, 0x113F,,,, &TVITEMEX)
}

;obtener nombre
;Sintaxis: TV_GetItemText( [ID], [Item] )
TV_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	NumPut(0x0001, TVITEMEX, 0, "UInt")
	NumPut(Item-1, TVITEMEX, 4, "Ptr")
    VarSetCapacity(TVTEXT, 256 * 2, 0)
    NumPut(&TVTEXT, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
    NumPut(256, TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
    SendMessage(hWnd, 0x113E,,,, &TVITEMEX)
    return StrGet(NumGet(TVITEMEX, A_PtrSize = 4 ? 16 : 20, "UPtr"))
}
























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;::::::::::::::::::::::::::::::::::::::::::::: TAB CONTROL ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener cantidad de items
;Sintaxis: TC_GetItemCount( [ID] )
TC_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1304)
}

;obtener posicion del item que tiene el foco o el item seleccionado.
;Sintaxis: TC_GetItemFocus( [ID], [¿seleccionado?] )
TC_GetItemFocus(hWnd, Selected := 1) {
	return SendMessage(hWnd, Selected?0x130B:0x132F)+1
}

;obtener texto de un item
;Sintaxis: TC_GetItemText( [ID], [Item] )
TC_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	NumPut(0x0001, TCITEM, 0, "UInt")
	VarSetCapacity(TCTEXT, 256 * 2, 0)
	NumPut(&TCTEXT, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	NumPut(256, TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	SendMessage(hWnd, 0x133C,, Item-1,, &TCITEM)
	return StrGet(NumGet(TCITEM, A_PtrSize = 4 ? 12 : 16, "UPtr"))
}

;cambiar texto de un item
;Sintaxis: TC_SetItemText( [ID], [Texto], [Item] )
TC_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	NumPut(0x0001, TCITEM, 0, "UInt")
	NumPut(&NewText, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	NumPut(StrLen(NewText), TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	return SendMessage(hWnd, 0x133D,, Item-1,, &TCITEM)
}

;dar foco a un item o seleccionarlo
;Sintaxis: TC_SetItemFocus( [ID], [Item], [¿seleccionar?] )
;Notas: si se omite el 2do parametro, auto-selecciona el item anterior o 'siguiente si no hay anterior'.
TC_SetItemFocus(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		Item := ((i:=TC_GetItemFocus(hWnd, Select))-1)>0?i-1:(i=1?i+(TC_GetItemCount(hWnd)>1?1:0):1)
	return SendMessage(hWnd, Select?0x130C:0x1330,, Item-1)
}

;deselecciona todos los items o todos menos el item seleccionado
;Sintaxis: TC_Reset( [ID], [¿evitar deseleccionar el item seleccionado?] )
TC_Reset(hWnd, Mode := 0) {
	return SendMessage(hWnd, 0x1332,, Mode)
}

;eliminar un item, opcional seleccionar el anterior (o siguiente si no hay anterior)
;Sintaxis: TC_DeleteItem( [ID], [Item], [¿seleccionar el item anterior?] )
;Nota: dejar vacio el 2do parametro (o establecerlo <0) para eliminar todos los items.
TC_DeleteItem(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1309)
	i := SendMessage(hWnd, 0x1308,, Item-1)
	if Select
		TC_SetItemFocus(hWnd, ((Item-1)>0?(Item-1):1))
	return i, ErrorLevel := !i
}

;resalta el item
;Sintaxis: TC_HighlightItem( [ID], [Item], [Estado 0|1] )
TC_HighlightItem(hWnd, Item := 0, State := 1) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	return SendMessage(hWnd, 0x1333, "Int", Item-1, "Int", State)
}













































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: GUI & DIALOGOS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;caja de mensaje: MessageBox
;Sintaxis: MsgBox( [opciones], [titulo], [texto], [tiempo fuera] )
;ErrorLevel: contiene el resultado (Yes, No, Ok ... )
;NOTA: recomendado usar la variable global A_MsgBoxResult
;EJEMPLO:
	;MsgBox % "Resultado: " MsgBox() "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox( 0 ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(4112, "ERROR!",, 1 ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(20, "Título" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(34,, "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(16694, "Título", "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
MsgBox(Options := "", Title := "", Text := "", Timeout := "") {
	global A_MsgBoxResult ;AHKv2
	if (Options=""&&Title=""&&Text="")
		MsgBox, 0, *, Press OK to continue., %Timeout%
	else if (Options!=""&&Title=""&&Text="")
		MsgBox, 0, *, %Options%, %Timeout%
	else
		MsgBox, % Options, %Title%, %Text%, %Timeout%
	;return ErrorLevel := A_MsgBoxResult ;AHKv2
	Loop, Parse, % "Yes No Ok Cancel Abort Ignore Retry Timeout Continue TryAgain", %A_Space% ;AHKv1 -->
		IfMsgBox, %A_LoopField%
			return ErrorLevel := A_MsgBoxResult := A_LoopField
}

;dialogo para elegir color
;Sintaxis: ColorSelect( [defecto], [ID ventana propietaria], [¿mostrar todos los colores? 0|1] )
;EJEMPLO: MsgBox % "Color: " (i:=ColorSelect(255,,1)) "`nRGB: " RGB(i) "`nHex: " Hex(i) "`n`nErrorLevel: " ErrorLevel
ColorSelect(Color := "", hWnd := 0, FullOpen := "") {
	VarSetCapacity(CUSTOM, 16 * A_PtrSize, 0)
	Loop, 16
		NumPut( IniRead( A_Temp "\defaultusercolorpalette.ini", "Color", A_Index, 0 )
			, CUSTOM, (A_Index - 1) * 4, "UInt")
	lStructSize := VarSetCapacity(CHOOSECOLOR, 9 * A_PtrSize, 0)
	NumPut( lStructSize, CHOOSECOLOR, 0, "UInt" )
	NumPut( hWnd, CHOOSECOLOR, A_PtrSize, "Ptr" )
	NumPut( Color = "" ? IniRead( A_Temp "\defaultusercolorpalette.ini", "Default", "Color", 0 )
		: Color, CHOOSECOLOR, 3 * A_PtrSize, "Ptr" )
	NumPut( &CUSTOM, CHOOSECOLOR, 4 * A_PtrSize, "PtrP" )
	NumPut( 0x1|0x100|(FullOpen=0?0x4:FullOpen?0x2:0x0), CHOOSECOLOR, 5 * A_PtrSize, "UInt" )
	i := DllCall("comdlg32.dll\ChooseColorW", "UPtr", &CHOOSECOLOR, "UInt")
	Loop, 16
		IniWrite( NumGet(custom, (A_Index - 1) * 4, "UInt")
			, A_Temp "\defaultusercolorpalette.ini", "Color", A_Index)
	return Color := NumGet(CHOOSECOLOR, 3 * A_PtrSize, "UInt")
		, i:=i?IniWrite( Color, A_Temp "\defaultusercolorpalette.ini", "Default", "Color" ):""
		, ErrorLevel := !i
}

;Sintaxis: InputBox( [Título], [Texto], [Defecto], [Tiempo Fuera (seg)], [Opciones Edit], [Alto], [Ancho] )
;ErrorLevel es:
	;0 = el usuario precionó Aceptar
	;1 = el usuario precionó Cancelar o Cerrar
	;2 = la ventana ya existe
	;3 = se ha alcanzado el tiempo máximo para la ventana
InputBox(Title, Text, Default := "", Timeout := 0, EditOptions := "", Height := 217, Width := 420) {
	;inicio
	global _InputBoxResult, _InputBoxErrorLevel, _InputBoxInfoText
	_InputBoxResult := _InputBoxErrorLevel := ""
	static _InputBoxId
	
	;comprueba si ya existe la ventana
	if IsWindow(_InputBoxId)
		return "", ErrorLevel := 2
	
	;interfaz
	Gui, _InputBoxGuiName:-Caption +ToolWindow +OwnDialogs +LastFound +HWND_InputBoxHWND +AlwaysOnTop +MinSize420x217 +MaxSize%A_ScreenWidth%x%A_ScreenHeight%
		_InputBoxId := _InputBoxHWND
	Gui, %_InputBoxHWND%:Color, White
	Gui, %_InputBoxHWND%:Margin, 0, 0
	Gui, %_InputBoxHWND%:Font, s12 w600 Q5, Times New Roman
	Gui, %_InputBoxHWND%:Add, Button, x0 y0 w%A_ScreenWidth% h30 HWND_InputBoxTitle Disabled +Left, % " " Title
		GuiButtonStyle( _InputBoxTitle, 7 )
	Gui, %_InputBoxHWND%:Add, Text, x0 y0 w350 h30 g_InputBoxTMove BackgroundTrans
	Gui, %_InputBoxHWND%:Font, s10 Q5 w400, Marlett
	Gui, %_InputBoxHWND%:Add, Button, x388 y2 w30 h25 HWND_InputBoxClose g_InputBoxClose, r
		GuiButtonStyle( _InputBoxClose, 3 )
	Gui, %_InputBoxHWND%:Font, s12 w400 Q5, Courier New
	Gui, %_InputBoxHWND%:Add, Button, x357 y2 w30 h25 HWND_InputBoxMax g_InputBoxMax, % Chr(9794)
		GuiButtonStyle( _InputBoxMax, 4 )
	Gui, %_InputBoxHWND%:Font, s9 w400 Q5, Segoe UI
	Gui, %_InputBoxHWND%:Add, Edit, x5 y155 w410 h25 HWND_InputBoxResult v_InputBoxResult %EditOptions%, %Default%
		AttachEditControlText( _InputBoxResult, " " Default ) 
	Gui, %_InputBoxHWND%:Add, Text, x5 y35 w410 h115 v_InputBoxInfoText g_InputBoxInfoText, %Text%
	Gui, %_InputBoxHWND%:Font, s11 w500 Q5, Times New Roman
	Gui, %_InputBoxHWND%:Add, Button, x212 y185 w95 h27 HWND_InputBoxAccept g_InputBoxAccept Default, Aceptar
		GuiButtonStyle( _InputBoxAccept, 8 )
	Gui, %_InputBoxHWND%:Add, Button, x320 y185 w95 h27 HWND_InputBoxCancel g_InputBoxClose, Cancelar
		GuiButtonStyle( _InputBoxCancel, 8 )
	Gui, %_InputBoxHWND%:Show, w%Width% h%Height% Hide
	WinAnimate(_InputBoxHWND, 100), WinRedraw(_InputBoxHWND)
	Gui, %_InputBoxHWND%:Default
	GuiControl, Focus, _InputBoxResult
	ControlSend(_InputBoxHWND, "Edit1", "{End}")
	
	;esperar a que la ventana cierre
	if !WinWaitClose( _InputBoxHWND, Timeout ) {
		Gui, %_InputBoxHWND%:Destroy
		return "", WinEnable( hWnd ), ErrorLevel := 3
	}

	;devuelve el resultado
	return _InputBoxResult, ErrorLevel := _InputBoxErrorLevel
		, _InputBoxErrorLevel := _InputBoxId := _InputBoxInfoText := ""
	;-------------------------------------------------------------------------------------------------------------------------------------
	
	;ajustar tamaño de la ventana
	_InputBoxGuiNameGuiSize:
	Gui, %_InputBoxHWND%:Default
	GuiControl, Move, Button2, % "x" (A_GuiWidth - 32)
	GuiControl, Move, Button3, % "x" (A_GuiWidth - 63)
	GuiControl, MoveDraw, Button4, % "x" (A_GuiWidth - 210) " y" (A_GuiHeight - 32)
	GuiControl, MoveDraw, Button5, % "x" (A_GuiWidth - 100) " y" (A_GuiHeight - 32)
	GuiControl, Move, Static1, % "w" (A_GuiWidth - 70)
	GuiControl, MoveDraw, Static2, % "w" (A_GuiWidth - 10) " h" (A_GuiHeight - 102)
	GuiControl, MoveDraw, Edit1, % "y" (A_GuiHeight - 60) " w" (A_GuiWidth - 10)
	return

	;texto
	_InputBoxInfoText:
	Gui, %_InputBoxHWND%:Default
	GuiControl, Focus, _InputBoxInfoText
	return
	
	;boton Titulo (mover ventana)
	_InputBoxTMove:
	Gui, %_InputBoxHWND%:Default
	GuiControl, Focus, _InputBoxInfoText
	DllCall("User32.dll\PostMessageW", "Ptr", _InputBoxHWND, "UInt", 0xA1, "Ptr", 2, "Ptr", 0)
	return
	
	;boton Aceptar, Cerrar y Cancelar
	_InputBoxClose:
	_InputBoxAccept:
	Gui, %_InputBoxHWND%:Default
	GuiControlGet, _InputBoxResult
	_InputBoxErrorLevel := A_ThisLabel="_InputBoxClose"?1:0
	WinAnimate(_InputBoxHWND, 100, "HS1")
	Gui, %_InputBoxHWND%:Destroy
	return
	
	;boton Cambiar Tamaño Si/No (habilita a la ventana para cambiar el tamaño)
	_InputBoxMax:
	if !_InputBoxErrorLevel
		Gui, %_InputBoxHWND%: +Resize
	else
		Gui, %_InputBoxHWND%: -Resize
	_InputBoxErrorLevel := !_InputBoxErrorLevel
	return
}

;Sintaxis: ToolTip( [texto], [xpos], [ypos], [tiempo fuera, en segondos] )
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
ToolTip(Text := "", xpos := "", ypos := "", TimeOut := 0) {
	static ToolTip := Func("ToolTip").Bind()
	SetTimer(ToolTip, "Off")
	if (Text="")
		ToolTip,,,, 20
	else {
		ToolTip, %Text%, %xpos%, %ypos%, 20
		if TimeOut
			SetTimer(ToolTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
	}
}

;TrayTip( [titulo], [texto], [tiempo fuera, en segundos], [opciones] )
;OPCIONES:
	;0 = sin icono | 1 = Info (defecto) | 2 = Advertencia | 3 = Error
	;+M = sin sonido (0M, 1M, 2M, 3M)
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundosundos
TrayTip(Title := "", Text := "", TimeOut := 0, Options := 1) {
	static TrayTip := Func("TrayTip").Bind()
	SetTimer(TrayTip, "Off")
	if (Text=""&&Title="")
		TrayTip
	else {
		TrayTip, %Title%, %Text%, 30, % RegExReplace(Options, "[^0-9]")+(InStr(Options, "M")?16:0)
		if TimeOut
			SetTimer(TrayTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
	} ;necesario por si no funciona:
	;RegWrite( "REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "EnableBalloonTips", 2 )
	;RegWrite( "REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "Start_NotifyNewApps", 1 )
}

;estilo para los botones.
GuiButtonStyle(hWnd, Type := 1, Round := 0) { ;https://github.com/AHK-just-me/Class_ImageButton
	;------------------------------------------------------------------------------------------------------------------------------
	if (Type = 1) { ;estilo blanco y celeste #1
		Normal := [0, 0x80F0F0F0,, 0xD3000000, Round,, 0x800099CC, 1]
		Foco := [0, 0x8033B5E5,, 0x00FFFFFF, Round,, 0x800099CC, 1]
		Precionado := [0, 0x801A9CCB,, 0x00FFFFFF, Round,, 0x800099CC, 1]
		Deshabilitado := [0, 0x80F0F0F0,, 0x00DFDFDF, Round,, 0x80A7A7A7, 1]
		Fallido := [0, 0x80F0F0F0,, 0xD3000000, Round,, 0x800099CC, 1]
		Tab := [0, 0x80F0F0F0,, 0xD3000000, Round,, 0x800099CC, 1]
	;------------------------------------------------------------------------------------------------------------------------------
	} else if (Type = 2) { ;estilo grises, negros y blancos #1
		Normal := [7, 0x00383838, 0x00757575, 0x00CCCCCC, Round]
		Foco := [7, 0x00383838, 0x00858585, 0x00FFFFFF, Round]
		Precionado := [7, 0x00383838, 0x00AAAAAA, 0x00FFFFFF, Round]
		Deshabilitado := [7, 0x00AAAAAA, 0x00AAAAAA, 0x00FFFFFF, Round]
	} else if (Type = 3) { ;boton cerrar #1
		Normal := [0, 0x1CA7EF,, 0xCCCCCC]
		Foco := [0, 0xFF7171,, 0xffffff]
		Precionado := [0, 0xFF0000,, 0xffffff]
	} else if (Type = 4) { ;boton minimizar #1 (gris y blanco)
		Normal := [0, 0x1CA7EF,, 0xCCCCCC]
		Foco := [0, 0xC0C0C0,, 0xffffff]
		Precionado := [0, 0x808080,, 0xffffff]
	} else if (Type = 5) { ;boton verde #1
		Normal := [3, 0x46cc9b, 0x228731, "White", 4]
		Foco := [3, 0x5bf0b9, 0x35bd47, "White", 4]
		Precionado := [3, 0x228731, 0x46cc9b, "White", 4]
		Deshabilitado := [0, 0xF0F0EE,, 0xCACBC2, 4,, 0xCACBC2, 1]
	} else if (Type = 6) { ;boton rojo #1
		Normal := [3, 0xFF4A4A, 0xCC0000, "White", 4]
		Foco := [3, 0xFF6A6A, 0xFF2424, "White", 4]
		Precionado := [3, 0xEA0000, 0x9B0000, "White", 4]
		Deshabilitado := [0, 0xF0F0EE,, 0xCACBC2, 4,, 0xCACBC2, 1]
	} else if (Type = 7) { ;fondo celeste, texto blanco
		Normal := Deshabilitado := [0, 0x1CA7EF,, 0xffffff]
	} else if (Type = 8) { ;botones celeste y blanco
		Normal := [0, 0x1CA7EF,, 0xffffff]
		Foco := [0, 0x6AB5FF,, 0xffffff]
		Precionado := [0, 0x808080,, 0xffffff]
		Deshabilitado := [0, 0x80F0F0F0,, 0x00DFDFDF, 0,, 0x80A7A7A7, 1]
	} else if (Type = 9) { ;boton minimizar #2 (celeste y blanco)
		Normal := [0, 0x182E46,, 0xffffff,,, 0x4E668C, 1]
		Foco := [0, 0xFF7171,, 0xffffff,,, 0x4E668C, 1]
		Precionado := [3, 0xFF0000, 0xFF7171, 0xffffff,,, 0x4E668C, 1]
	}
   ;------------------------------------------------------------------------------------------------------------------------------
   return ImageButton.Create(hWnd, Normal, Foco, Precionado, Deshabilitado, Fallido, Tab)
}

;color para los controles
;conversor de colores: http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
;Sintaxis: GuiControlColor( [control], [color del texto], [color de fondo] )
GuiControlColor( ControlId, TextColor := "Black", BackgroundColor := "White", Force := 0 ) {
	if Force
		CtlColors.Detach( ControlId )
	CtlColors.Change( ControlId, BackgroundColor, TextColor )
}

;establece texto por defecto a un control de edicion (edit)
;Sintaxis: AttachEditControlText( [control hwnd], [texto] )
AttachEditControlText(hWnd, Text) {
	return SendMessage(hWnd, 0x1501,, 1, "Str", Text)
}

;establece un cursor cuando el mouse se posiciona sobre un control
;Sintaxis: AttachCursorControl( [Control HWND], [Tipo de cursor (ver funcion)] )
AttachCursorControl(Control, CursorType) { ;http://ahkscript.org/boards/viewtopic.php?p=48060#p48060
	;tipos de cursores
	static Hand := 32649 ;mano
	static Arrow := 32512 ;flecha normal
	static AppStarting := 32650 ;flecha normal + reloj de arena (cargando)
	static CrossHair := 32515 ;punto de mira (cruz)
	static Help := 32651 ;flecha y signo de interrogación
	static Edit := 32513 ;barra vertical de edición
	static no := Slashed := 32648 ;bloqueado (círculo)
	static SizeAll := 32642 ;ajustar tamaño (norte, sur, este, oeste)
	static SizeNESW := 32643 ;ajustar tamaño (noreste, sudoeste)
	static SizeNS := 32645 ;ajustar tamaño (norte, sur)
	static SizeNWSE := 32642 ;ajustar tamaño (noroeste, sudeste)
	static SizeEWE	:= 32644 ;ajustar tamaño (este, oeste)
	static UpArrow := 32516 ;flecha hacia arriba
	static Wait := 32514 ;reloj de arena (cargando)
	;tipo de cursor a establecer
	CursorType := %CursorType% ? %CursorType% : Arrow
	;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648391%28v=vs.85%29.aspx
	return hCursor := DllCall("User32.dll\LoadCursorW", "Ptr", 0, "Int", CursorType)
		, hFunc := Func("AttachCursorControl_Internal").Bind( Control, hCursor )
		, OnMessage( 0x0200, hFunc )
}
AttachCursorControl_Internal(Control, hCursor) {
	MouseGetPos,,,, MouseControlHWND, 2
	if (Control = MouseControlHWND)
		DllCall("User32.dll\SetCursor", "Ptr", hCursor)
}

GuiControlGetHwnd(ControlId) {
	GuiControlGet, hWnd, HWND, %ControlId%
	return hWnd ? hWnd : ControlId
}

;Sintaxis: GuiControlMove( [control], [X|Y|W|H], [¿redibujar?] )
GuiControlMove(ControlId, XYWH, Redraw := 0) {
	GuiControl, % Redraw ? "MoveDraw" : "Move", %ControlId%, %XYWH%
	return !ErrorLevel
}

GuiControlRedraw(ControlId*) {
	Loop, % ControlId.MaxIndex()
		GuiControl, MoveDraw, % ControlId[ A_Index ]
	return !ErrorLevel
}

GuiControlShow(ControlId*) {
	Loop, % ControlId.MaxIndex()
		GuiControl, Show, % ControlId[ A_Index ]
	return !ErrorLevel
}

GuiControlHide(ControlId*) {
	Loop, % ControlId.MaxIndex()
		GuiControl, Hide, % ControlId[ A_Index ]
	return !ErrorLevel
}

;cambiar fuente de un control
;GuiFont( [control], [opciones], [fuente] )
;OPCIONES: c[color] | s[tamaño] | w[negrita 1~1000 nor=400 neg=700] | q[calidad 1~5]
GuiControlSetFont(hWnd, Type, Font) {
   Gui, Font, %Type%, %Font%
   GuiControl, Font, %hWnd%
}

;habilitar/deshabilitar el arrastre de archivos a la ventana
;Sintaxis: GuiDragAndDrop( [GUI_HWND], [0|1] )
GuiDragAndDrop(hWnd, Mod := 1) {
   Gui, % hWnd ":" (Mod ? "+" : "-") "E0x10"
}

;obtener el texto de un control
GuiControlGetText(hWnd) {
   ControlGetText, Text,, ahk_id %hWnd%
   return Text
}

GuiControlGetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	GuiControlGet, pos, pos, %hWnd%
	i := {}, i.w := i.Width := Width := posW
	i.h := i.Height := Height := posH
	i.x := x := posX, i.y := y := posY
	return i
}

;obtener el tipo de control
GuiControlType(hWnd) {
   return WinGetClass( hWnd )
}

GuiControlIsVisible(hWnd) {
   GuiControlGet, OutputVar, Visible, %hWnd%
   return OutputVar
}

GuiControlIsEnabled(hWnd) {
   GuiControlGet, OutputVar, Enabled, %hWnd%
   return OutputVar
}

GuiMove(hWnd := 0) {
	PostMessage, 0xA1, 2, 0,, % "ahk_id " (hWnd ? hWnd : IsWindow( -1 ))
}

SB_GetText(hWnd, PartN := 1) {
	StatusBarGetText, Text, %PartN%, ahk_id %hWnd%
	return Text
}


































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: LISTA DE IMÁGENES (ImageList) ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;elimina una lista de imágenes 
;Sintaxis: IL_Destroy( [ID] )
IL_Destroy(ImageList) {
	i := DllCall("Comctl32.dll\ImageList_Destroy", "Ptr", ImageList)
	return i, ErrorLevel := !i
}

;elimina una imagen de una lista de imágenes
;Sintaxis: IL_Remove( [ID], [Posición] )
;NOTA: si el segundo parametro es 0, elimina todas las imágenes
IL_Remove(ImageList, Pos := 0) {
	i := DllCall("ComCtl32.dll\ImageList_Remove", "Ptr", ImageList, "Int", Pos - 1)
	return i, ErrorLevel := !i
}

;crea una lista de imágenes 
;Sintaxis: IL_Create( [cantidad inicial], [aumento al pasar el limite], [¿iconos grandes?] )
IL_Create( InitialCount := 2, GrowCount := 5, LargeIcons := 0 ) {
	;el ancho predeterminada de un icono, en píxeles
	static SM_CXICON := DllCall("User32.dll\GetSystemMetrics", "Int", 11)
	
	;el ancho recomendado de un icono pequeño, en píxeles
	static SM_CXSMICON := DllCall("User32.dll\GetSystemMetrics", "Int", 49)
	
	;la altura predeterminada de un icono, en píxeles
	static SM_CYICON := DllCall("User32.dll\GetSystemMetrics", "Int", 12)
	
	;la altura recomendada de un icono pequeño, en píxeles
	static SM_CYSMICON := DllCall("User32.dll\GetSystemMetrics", "Int", 50)
	
	cx := LargeIcons ? SM_CXICON : SM_CXSMICON
	cy := LargeIcons ? SM_CYICON : SM_CYSMICON
	;crear la lista de imagenes
	i := DllCall("Comctl32.dll\ImageList_Create", "UInt", cx ;el ancho en píxeles de cada imagen
		, "UInt", cy ;la altura en píxeles de cada imagen .
		, "UInt", 0x00000001|0x00000020 ;opciones
		, "Int", InitialCount ;el número de imágenes que la lista de imágenes contiene inicialmente
		, "Int", GrowCount) ;el número de iconos por el que la lista crecerá cada ves que se supere el limite
	return i, ErrorLevel := !i
}

;crea un duplicado de una lista de imágenes existente
;Sintaxis: IL_Duplicate( [ID] )
IL_Duplicate(ImageList) {
	i := DllCall("Comctl32.dll\ImageList_Duplicate", "Ptr", ImageList)
	return i, ErrorLevel := !i
}

;recupera el número de imágenes en una lista de imágenes
;Sintaxis: IL_GetCount( [ID] )
IL_GetCount(ImageList) {
	i := DllCall("ComCtl32.dll\ImageList_GetImageCount", "Ptr", ImageList)
	return i, ErrorLevel := !i
}

;recupera las dimensiones de las imágenes en una lista de imágenes
;NOTA: todas las imágenes tienen las mismas dimensiones
;Sintaxis: IL_GetSize( [ID], [Ancho (pixeles)], [Alto (pixeles)] )
IL_GetSize(ImageList, ByRef Width := "", ByRef Height := "") {
	i := DllCall("ComCtl32.dll\ImageList_GetIconSize", "Ptr", ImageList, "IntP", Width, "IntP", Height)
	s := {}, s.h := s.Height := Height, s.w := s.Width := Width
	return s, ErrorLevel := !i
}

























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: CONTROL ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener posicion
;Sintaxis: ControlGetPos( [ID], [control], [x], [y], [ancho], [alto] )
ControlGetPos( hWnd, Control, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "" ) {
	ControlGetPos, x, y, Width, Height, %Control%, ahk_id %hWnd%
	i := {}, i.w := i.Width := Width, i.h := i.Height := Height, i.x := x, i.y := y
	return i
}

;enviar pulsaciones de teclas a un control
;Sintaxis: ControlSend( [ID], [Control], [Teclas], [Repeticiones], [retraso (ms)] )
ControlSend( hWnd, Control, Keys, Count := 1, Delay := -2 ) {
	if !(ok := 0) AND (Count <= 1) {
		ControlSend, %Control%, %Keys%, ahk_id %hWnd%
		return !ErrorLevel, Sleep( Delay )
	}
	Loop, %Count%
		ok += ControlSend( hWnd, Control, Keys,, A_Index = Count ? -2 : Delay )
	return ok, ErrorLevel := ok = Count ? 0 : 1
}

ControlHide(hWnd, ControlId*) {
	Loop, % ControlId.MaxIndex()
		Control, Hide,, ControlId[ A_Index ], ahk_id %hWnd%
	return !ErrorLevel
}

ControlShow(hWnd, ControlId*) {
	Loop, % ControlId.MaxIndex()
		Control, Show,, ControlId[ A_Index ], ahk_id %hWnd%
	return !ErrorLevel
}

ControlSendRaw( hWnd, Control, Keys, Count := 1, Delay := 0) {
	return ControlSend( hWnd, Control, "{raw}" Keys, Count, Delay )
}

;establece foco en un control
;Sintaxis: ControlFocus( [Control], [ID] )
ControlFocus( Control, hWnd ) {
	Control := ControlGetHwnd( Control, hWnd )
	CurrentThreadId := ProcessExist( -2 )
	WinGetPID( hWnd, WinThreadId )
	DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 1)
	return i := DllCall("User32.dll\SetFocus", "Ptr", Control)
		, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 0)
		, ErrorLevel := !i
}

ControlGetHwnd(Control, hWnd) {
	ControlGet, ControlHwnd, hWnd,, %Control%, ahk_id %hWnd%
	return ControlHwnd ? ControlHwnd : Control
}

;establecer texto
;Sintaxis: ControlSetText( [Control], [Texto], [ID] )
ControlSetText(Control, NewText, hWnd) {
	return SendMessage(ControlGetHwnd(Control, hWnd), 0x000C,,, "Str", NewText)
}

;obtener texto
;Sintaxis: ControlGetText( [Control, [ID] )
ControlGetText(Control, hWnd) {
	Control := ControlGetHwnd( Control, hWnd )
	TextSize := SendMessage(Control, 0x000E)
	TextSize := VarSetCapacity(IpText, (TextSize+1) * 2) / 2
	SendMessage(Control, 0x000D, "UInt", TextSize, "Str", IpText)
	return IpText
}































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: MOUSE/CURSOR Y TECLADO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;desplazamiento acelerado, más rápido gire la rueda, más líneas se desplazará por tic
;Sintaxis: MouseAutoWheelSpeed( [TimeOut (ms)], [Boost], [Limit], [ToolTip] )
;DESCRIPCION - PARÁMETROS:
	;TimeOut: tiempo fuera en el que se resetea el desplazamiento, en milisegundos
	;Boost: si se desplaza una distancia larga en una sola sesión, aplicar factor de impulso adicional (0=desactivado)
	;Limit: velcidad máxima (espesificar 0 para desactivar)
	;ToolTip: espesificar 1 (o el tiempo fuera) para mostrar la velocidad de dezplazamiento como ToolTip
;NOTA: devuelve la velocidad actual (la misma que se muestra con ToolTip activado)
;EJEMPLO: WheelUp::MouseAutoWheelSpeed(,,, 1)
MouseAutoWheelSpeed(TimeOut := 500, Boost := 30, Limit := 60, ToolTip := 0) {
	static d := 0, i := 0 ;http://www.autohotkey.com/board/topic/48426-accelerated-scrolling-script/
	t := A_TimeSincePriorHotkey, ToolTip := !(ToolTip>-1)?0:(ToolTip=1?TimeOut:ToolTip)
	TimeOut := TimeOut>0?TimeOut:500, Boost := Boost>-1?Boost:30
	if (A_PriorHotkey=A_ThisHotkey&&t<TimeOut&&Limit>0) {
		d++
		v := t<80&&t>1?(250.0/t)-1:1
		if (Boost>1&&d>Boost) {
			z := v>i?(i:=v):(v:=i)
			v *= d/Boost
		}
		v := v>1?(v>Limit?Limit:Floor(v)):1
		if ToolTip
			ToolTip("×" v,,, -ToolTip)
		return MouseClick( A_ThisHotkey,,, v )
	} else {
		d := i := 0
		if ToolTip
			ToolTip("×" 1,,, -ToolTip)
		return MouseClick(A_ThisHotkey)
	}
}

;clics o mantiene pulsado un botón del ratón, o girar la rueda del ratón
;Sintaxis: MouseClick( [boton/rueda], [xpos], [ypos], [repeticiones], [velocidad de movimiento (x,y)] )
MouseClick(WhichButton, x := "", y := "", ClickCount := 1, Speed := 0, DU := "", R := "") {
	Loop, %ClickCount%
		MouseClick, %WhichButton%, %x%, %y%,, %Speed%, %DU%, %R%
	return ClickCount
}

;Envia pulsaciones de teclado clics del ratón a la ventana activa.
;se aplica a: Send, SendInput, SendRaw
;Sintaxis: Send( [Texto], [¿Repetir?], [Retraso en cada repeticion (ms)] )
Send(Keys, Count := 1, Delay := -2) {
	if !(ok := 0) AND (Count <= 1) {
		SendInput, %Keys%
		return !ErrorLevel, Sleep( Delay )
	}
	Loop, %Count%
		ok += Send( Keys,, A_Index = Count ? -2 : Delay )
	return ok, ErrorLevel := ok = Count ? 0 : 1
}
SendInput(Keys, Count := 1, Delay := 0) {
	return Send( Keys, Count, Delay )
}

SendRaw(Keys, Count := 1, Delay := 0) {
	return Send( "{raw}" Keys, Count, Delay )
}

;espera por una tecla a ser precionada o liberada
;Sintaxis: KeyWait( [tecla], [opciones], [tiempo fuera en segundos] )
;OPCIONES:
	;D = espera a que la tecla sea precionada
	;[Vacío] (defecto) = espera a que la tecla sea liberada por el usuario
KeyWait(KeyName, Options := "", TimeOut := 0) {
	KeyWait, %KeyName%, % Options (TimeOut ? " T" TimeOut : "")
	return !ErrorLevel
}

;Activa o desactiva la función de rastros del mouse
;Sintáxis: MouseTrails( [Número o dejar vacio para recuperar el estado actual.] )
;Nota: especifique un número mayor a 1 para activar. para desactivar especifique 0 o 1
;Ejemplos: Mouse.Trails( 10 ) | Mouse.Trails( 0 ) | Mouse.Trails(  )
MouseTrails(N := "") {
	if (N != "")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005D, "UInt", N, "Str", 0, "UInt", 0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005E, "UInt", 0, "UIntP", N, "UInt", 0)
	return N
}

;cambiar el cursor. Sintáxis: MouseSetCursor( [Tipo / Opcion], [Tipo / Cursor] )
MouseSetCursor(T := "R", C := "") { ;http://ahkscript.org/boards/viewtopic.php?f=5&t=6860
	if (T = "R") AND (C = "") { ;restaurar los cursores del sistema. Cursor("R")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x57, "UInt", 0, "UInt", 0, "UInt", 0) ;DllCall("User32.dll\DestroyCursor", "Ptr", hCursor)
	} else if (T) AND (FileExist(C)) { ;cargar cursor desde archivo. Cursor(32512, "Mi Cursor.ani/.cur")
		return DllCall("User32.dll\SetSystemCursor", "UInt", DllCall("User32.dll\LoadCursorFromFile", "Str", C), "Int", T) ;DllCall("GetCursorInfo", "Uint", &ci) || hCursor := NumGet(ci,8)
	} else if (T) AND (C) { ;cargar cursor del sistema. Cursor(32512, 32645)
		return DllCall("User32.dll\SetSystemCursor", "UInt", DllCall("User32.dll\LoadCursor", "UInt", 0, "Int", T), "Int", C) ;DllCall("User32.dll\SetCursor", "Ptr", hCursor, "Ptr")
	}
	return 0
}

;cambia o recupera la velocidad actual del mouse
;Sintáxis: MouseSpeed( [establecer velocidad / dejar vacio] )
MouseSpeed(Vel := "") {
	if (Vel := RegExReplace(Vel, "[^0-9]"))
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x71, "UInt", 0, "UInt", Vel > 20 ? 20 : Vel < 1 ? 1 : Vel, "UInt", 0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x70, "UInt", 0, "UIntP", Vel, "UInt", 0)
	return Vel
}

;recupera/cambia el número de líneas para desplazarse cuando se mueve la rueda ratón verticalmente
MouseScrollLines(Lines := -1) {
	if (Lines >= 0)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x69, "UInt", Lines, "UInt", 0, "UInt", 0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x68, "UInt", 0, "UIntP", Lines, "UInt", 0)
	return Lines
}

;establece/recupera el tiempo (ms) de doble clic para el ratón
;Sintaxis: MouseDoubleClick( [milisegundos (1~5000)] )
MouseDoubleClick(ms := -1) {
	if (ms >= 0)
		return DllCall("User32.dll\SetDoubleClickTime", "UInt", ms)
	return DllCall("User32.dll\GetDoubleClickTime")
}

;Invierte o restaura los botones izquierdo y derecho del ratón
;Sintaxis: MouseSwap( 0|1 )
MouseSwap(fSwap) {
	return DllCall("User32.dll\SwapMouseButton", "Int", fSwap)
}

;Mueve el cursor a las coordenadas de pantalla especificadas
;MouseSetPos / CursorSetPos
MouseSetPos(x := "", y := "", Speed := "", R := 0) {
	if (Speed != "")
		return MouseMove( x, y, Speed, R )
	if (x = "") OR (y = "")
		CursorGetPos(x_, y_)
	return DllCall("User32.dll\SetCursorPos", "Int", x = "" ? x_ : x, "Int", y = "" ? y_ : y)
}
CursorSetPos(x := "", y := "", Speed := 0, R := 0) {
	return MouseSetPos(x, y, Speed, R)
}
MouseMove(x, y, Speed := "", R := -1) {
	MouseMove, %x%, %y%, % Speed > -1 ? Speed : A_DefaultMouseSpeed, % R ? "R" : ""
	return !ErrorLevel
}

;recupera la posicion del cursor
;MouseGetPos / CursorGetPos
MouseGetPos(ByRef x := "", ByRef y := "", ByRef  Win := "", ByRef Control := "", Mode := 0) {
	if !IsByRef(Control)&&!IsByRef(Win)
		MouseGetPos, x, y,,, %Mode%
	else if IsByRef(Control)&&!IsByRef(Win)
		MouseGetPos, x, y,, Control, %Mode%
	else if !IsByRef(Control)&&IsByRef(Win)
		MouseGetPos, x, y, Win,, %Mode%
	else
		MouseGetPos, x, y, Win, Control, %Mode%
	i := {}, i.x := x, i.y := y, i.Win := i.hWnd := Win, i.Control := i.ctrl := Control, i.Mode := Mode
	return i
}

;recupera la posición del cursor, en coordenadas de pantalla
;Sintaxis: CursorGetPos( [x], [y], [ventana (out)], [control (out)] )
CursorGetPos(ByRef x := "",ByRef y := "", ByRef Win := "", ByRef Control := "") {
	VarSetCapacity( lpPoint, 8 + A_PtrSize, 0 ), i := {}
	r := DllCall("User32.dll\GetCursorPos", "Ptr", &lpPoint)
	x := i.x := NumGet( lpPoint, 0, "Int"), y := i.y := NumGet( lpPoint, 4, "Int")
	if IsByRef( Win ) OR IsByRef( Control ) {
		VarSetCapacity( POINT, 8 + A_PtrSize, 0 )
		NumPut( x, POINT, 0, "Int" ), NumPut( y, POINT, 4, "Int" )
		Win := DllCall("User32.dll\WindowFromPoint", "Int64", NumGet(POINT, 0, "Int64"))
		Control := IsByRef( Control ) ? WinGetClass( Win ) : ""
	}
	return i, ErrorLevel := !r
}

;muestra/oculta el cursor
;Sintaxis: CursorShow( [Estado (0|1)], [Modo (0|1)], [Reestablecer (segundos)], [¿esperar?] )
;REESTABLECER: tiempo fuera en el que el cursor se muestra/oculta (dependiedo el estado espesificado)
;EJEMPLO: CursorShow(0,, 5, 1), ExitApp()
CursorShow(State, Mode := 0, TimeOut := 0, WaitTimeOut := 0) {
	;--------------------------------------------------------------------------------------------------------------
	static hCursor, hCursorImage, Cursor, LastState, LastMode
	static CursorShow := Func("CursorShow").Bind(-1)
	if (State=-1)
		return i := CursorShow( !LastState, LastMode ), ErrorLevel := !i
	;--------------------------------------------------------------------------------------------------------------
	if (TimeOut > 0) { ;alternar: State=0|1, Mode=0|1, TimeOut>0
		if !CursorShow( LastState:=State, LastMode:=Mode )
			return 0, ErrorLevel := 1
		if WaitTimeOut
			Sleep(TimeOut*1000)
		else
			return SetTimer(CursorShow, -(TimeOut*1000))
		return i := CursorShow( !State, Mode ), ErrorLevel := !i
	} ;--------------------------------------------------------------------------------------------------------------
	if Mode ;solo afecta a las ventanas creadas por el script: State=0|1, Mode=1, TimeOut=0
		Loop {
			NewDisplayCounter := DllCall("User32.dll\ShowCursor", "Int", State)
			if (State&&(NewDisplayCounter>=0))||(!State&&(NewDisplayCounter<=-1))
				return 1, ErrorLevel := 0
			if (NewDisplayCounter=OldDisplayCounter)||(State&&(NewDisplayCounter<OldDisplayCounter))
			||(!State&&(NewDisplayCounter>OldDisplayCounter))
				return 0, ErrorLevel := 1
			OldDisplayCounter := NewDisplayCounter
		}
	;--------------------------------------------------------------------------------------------------------------
	if State ;restaura los cursores: State=1, Mode=0, TimeOut=0
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x57, "UInt", 0, "UInt", 0, "UInt", 0)
	VarSetCapacity( AndMask, 32 * 4, 0xFF ), VarSetCapacity( XorMask, 32 * 4, 0 ), i := 0
	Loop, Parse, % "32650,32512,32515,32649,32651,32513,32641,32648,32640,32646,32643,32645,32642,32644,32516,32514", `,
	{
		if !Cursor {
			hCursor := hCursorImage := []
			hCursor[A_Index] := DllCall("User32.dll\CreateCursor", "Ptr", 0, "Int", 0, "Int", 0
				, "Int", DllCall("User32.dll\GetSystemMetrics", "Int", 13)
				, "Int", DllCall("User32.dll\GetSystemMetrics", "Int", 14)
				, "Ptr", &AndMask, "Ptr", &XorMask)
			hCursorImage[A_Index] := DllCall("User32.dll\CopyImage", "Ptr", hCursor[A_Index], "UInt", 2, "Int", 0, "Int", 0, "UInt", 0)
		}
		i += DllCall("User32.dll\SetSystemCursor", "Ptr", hCursorImage[A_Index], "UInt", A_LoopField)
	}
	return Cursor := i, ErrorLevel := !i
} ;--------------------------------------------------------------------------------------------------------------































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
SysGet(Subcommand, Param3 := "") {
	SysGet, OutputVar, %Subcommand%, %Param3%
	return OutputVar ;DllCall("User32.dll\GetSystemMetrics", "Int", Subcommand)
}

;Opciones de apagado
;Sinraxis: Shutdown( [Código], [¿Forzar?] )
;CÓDIGOS
	;1 = Apagar | 2 = Reiniciar | 3 = Cerrar sesion | 4 = Power down
	;5 = Suspender | 6 = Hibernar
	;7 = Apagar monitor | 8 = Encender monitor | 9 = Poner el monitor en bajo consumo
Shutdown(Code, Force := 0) {
	if Between( Code, 5, 6 ) {
		Code := Code = 5 ? 0 : 1
		return DllCall("PowrProf.dll\\SetSuspendState", "int", Code, "int", Force, "int", 0)
	} else if Between( Code, 7, 9 ) {
		Code := Code=7?2:Code=8?-1:1
		hDesktop := DllCall("User32.dll\FindWindowW", "Str", "Progman", "Ptr", 0)
		return SendMessage(hDesktop, 0x112, "UInt", 0xF170,, Code)
	} else if Between( Code, 1, 4 ) {
		Code := Code = 1 ? 0x00000001 : Code = 2 ? 0x00000002 : Code = 3 ? 0 : 0x00000008
		Code := Force ? Code|0x00000004 : Code
		return DllCall("User32.dll\ExitWindowsEx", "UInt", Code, "UInt", 0)
	}
	return 0
}

;establecer fecha
;EJEMPLO: MsgBox % (i := {}) (i.Year := 2050) SetSystemTime( i )
SetSystemTime(Time) {
	VarSetCapacity(SYSTEMTIME, 16), i := GetSystemTime()
	, NumPut(Time.Year != "" ? Time.Year : i.Year, SYSTEMTIME,  0, "UShort") ;año = Year
	, NumPut(Time.Mon != "" ? Time.Mon : i.Mon, SYSTEMTIME,  2, "UShort") ;mes = Mon
	, NumPut(Time.WD != "" ? Time.WD : i.WD, SYSTEMTIME,  4, "UShort") ;día de la semana = WD
	, NumPut(Time.Day != "" ? Time.Day : i.Day, SYSTEMTIME,  6, "UShort") ;día  = Day
	, NumPut(Time.Hour != "" ? Time.Hour : i.Hour, SYSTEMTIME,  8, "UShort") ;hora = Hour
	, NumPut(Time.Min != "" ? Time.Min : i.Min, SYSTEMTIME, 10, "UShort") ;minutos = Min
	, NumPut(Time.Sec != "" ? Time.Sec : i.Sec, SYSTEMTIME, 12, "UShort") ;segundos = Seg
	, NumPut(Time.MS != "" ? Time.MS : i.MS, SYSTEMTIME, 14, "UShort") ;milisegundos = MS
	return DllCall("kernel32.dll\SetSystemTime", "Ptr", &SYSTEMTIME)
}
SetLocalTime(Time) {
	VarSetCapacity(SYSTEMTIME, 16), i := GetLocalTime()
	, NumPut(Time.Year != "" ? Time.Year : i.Year, SYSTEMTIME,  0, "UShort") ;año = Year
	, NumPut(Time.Mon != "" ? Time.Mon : i.Mon, SYSTEMTIME,  2, "UShort") ;mes = Mon
	, NumPut(Time.WD != "" ? Time.WD : i.WD, SYSTEMTIME,  4, "UShort") ;día de la semana = WD
	, NumPut(Time.Day != "" ? Time.Day : i.Day, SYSTEMTIME,  6, "UShort") ;día  = Day
	, NumPut(Time.Hour != "" ? Time.Hour : i.Hour, SYSTEMTIME,  8, "UShort") ;hora = Hour
	, NumPut(Time.Min != "" ? Time.Min : i.Min, SYSTEMTIME, 10, "UShort") ;minutos = Min
	, NumPut(Time.Sec != "" ? Time.Sec : i.Sec, SYSTEMTIME, 12, "UShort") ;segundos = Seg
	, NumPut(Time.MS != "" ? Time.MS : i.MS, SYSTEMTIME, 14, "UShort") ;milisegundos = MS
	return DllCall("kernel32.dll\SetLocalTime", "Ptr", &SYSTEMTIME)
}

;obtener fecha
;EJEMPLO: GetSystemTime().Year
GetSystemTime() { ;sistema
	VarSetCapacity(lpSystemTime, 16, 0), NumPut(16, lpSystemTime, "UShort")
	ErrorLevel := !DllCall("kernel32.dll\GetSystemTime", "Ptr", &lpSystemTime)
	i := {}, i.Year := NumGet(lpSystemTime, 0, "UShort") ;año = Year
		, i.Mon := NumGet(lpSystemTime, 2, "UShort") ;mes = Mon
		, i.WD := NumGet(lpSystemTime, 4, "UShort") ;día de la semana = WD
		, i.Day := NumGet(lpSystemTime, 6, "UShort") ;día  = Day
		, i.Hour := NumGet(lpSystemTime, 8, "UShort") ;hora = Hour
		, i.Min := NumGet(lpSystemTime, 10, "UShort") ;minutos = Min
		, i.Sec := NumGet(lpSystemTime, 12, "UShort") ;segundos = Seg
		, i.MS := NumGet(lpSystemTime, 14, "UShort") ;milisegundos = MS
	return i
}
GetLocalTime() { ;local
	VarSetCapacity(lpSystemTime, 16, 0), NumPut(16, lpSystemTime, "UShort")
	ErrorLevel := !DllCall("kernel32.dll\GetLocalTime", "Ptr", &lpSystemTime)
	i := {}, i.Year := NumGet(lpSystemTime, 0, "UShort") ;año = Year
		, i.Mon := NumGet(lpSystemTime, 2, "UShort") ;mes = Mon
		, i.WD := NumGet(lpSystemTime, 4, "UShort") ;día de la semana = WD
		, i.Day := NumGet(lpSystemTime, 6, "UShort") ;día  = Day
		, i.Hour := NumGet(lpSystemTime, 8, "UShort") ;hora = Hour
		, i.Min := NumGet(lpSystemTime, 10, "UShort") ;minutos = Min
		, i.Sec := NumGet(lpSystemTime, 12, "UShort") ;segundos = Seg
		, i.MS := NumGet(lpSystemTime, 14, "UShort") ;milisegundos = MS
	return i
}

;Recupera información sobre el uso actual del sistema de memoria tanto física como virtual.
;EJEMPLO: MsgBox % Sys.GlobalMemoryStatusEx().Load " %"
SysGlobalMemoryStatusEx() { ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366589%28v=vs.85%29.aspx
	VarSetCapacity(MEMORYSTATUSEX, 64, 0), NumPut(64, MEMORYSTATUSEX, "UInt")
	ErrorLevel := !DllCall("kernel32.dll\GlobalMemoryStatusEx", "Ptr", &MEMORYSTATUSEX)
	i := {}, i.Lenght := NumGet(MEMORYSTATUSEX, 0, "UInt") ; El tamaño de la estructura, en bytes
		, i.Load := NumGet(MEMORYSTATUSEX, 4, "UInt") ;número entre 0 y 100 que especifica el porcentaje aproximado de la memoria física que está en uso
		, i.TotalPhys := NumGet(MEMORYSTATUSEX, 8, "UInt64") ;cantidad de memoria física real, en bytes
		, i.AvailPhys := NumGet(MEMORYSTATUSEX, 16, "UInt64") ;cantidad de memoria física disponible actualmente, en bytes
		, i.TotalPageFile := NumGet(MEMORYSTATUSEX, 24, "UInt64") ;límite de memoria comprometida actual para el sistema o el proceso actual, en bytes
		, i.AvailPageFile := NumGet(MEMORYSTATUSEX, 32, "UInt64") ;cantidad máxima de memoria que el proceso actual puede usar, en bytes.
		, i.TotalVirtual := NumGet(MEMORYSTATUSEX, 40, "UInt64") ;El tamaño de la parte del modo usuario del espacio de direcciones virtuales del proceso de llamada, en bytes
		, i.AvailVirtual := NumGet(MEMORYSTATUSEX, 48, "UInt64") ; La cantidad de memoria sin reservas y no comprometido actualmente en la parte del modo usuario del espacio de direcciones virtuales del proceso de llamada, en bytes
		;, i.AvailExtendedVirtual := NumGet(MEMORYSTATUSEX, 56, "UInt64") ;Reservado. Este valor es siempre 0.
		;, i.RAM := (a:=Get( A_ThisFunc ).RAM) ? a : DllCall("Kernel32.dll\GetPhysicallyInstalledSystemMemory", "UInt64*", TotalMemoryInKilobytes)  ;cantidad de RAM instalada físicamente en el equipo, en kilobytes
	return i
}

;sistema operativo: información de la versión
SysGetVersion() { ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff561910%28v=vs.85%29.aspx
	if !Get( A_ThisFunc, i )
		VarSetCapacity(RTL_OSVIEX, 284, 0), NumPut(284, RTL_OSVIEX, 0, "UInt")
		DllCall("ntdll.dll\RtlGetVersion", "Ptr", &RTL_OSVIEX), i := {}
		;i.OSVersionInfoSize := NumGet(RTL_OSVIEX, 0, "UInt")
		i.MajorVersion := NumGet(RTL_OSVIEX, 4, "UInt")
		i.MinorVersion := NumGet(RTL_OSVIEX, 8, "UInt")
		i.BuildNumber := NumGet(RTL_OSVIEX, 12, "UInt")
		i.PlatformId := NumGet(RTL_OSVIEX, 16, "UInt")
		i.CSDVersion := StrGet(&RTL_OSVIEX + 20, 128, "UTF-16") ;SP
		i.ServicePackMajor := NumGet(RTL_OSVIEX, 276, "UShort")
		i.ServicePackMinor := NumGet(RTL_OSVIEX, 278, "UShort")
		i.SuiteMask := NumGet(RTL_OSVIEX, 280, "UShort")
		i.ProductType := NumGet(RTL_OSVIEX, 282, "UChar" )
	return i ? i : Set( A_ThisFunc, i )
}

;registra para recibir notificaciones de cambio de sesión
;Sintaxis: RegisterSessionNotification( [estado], [sesion], [funcion que recibe las notificaciones] )
;Estado: 1 = activar | 0 = desactivar || Sesion: 1 = todas las sesiones | 0 = solo la sesion actual
;Notificaciones: http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
RegisterSessionNotification(Status, Session := 1, Func := "") { 
	if Status&&IsFunc(Func)&&DllCall("wtsapi32.dll\WTSRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd, "UInt", Session)
        return 1, OnMessage(0x02B1, "WM_WTSSESSION_CHANGE"), WM_WTSSESSION_CHANGE(0,0,Func), ErrorLevel := 0
    else if DllCall("wtsapi32.dll\WTSUnRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd)
		return 1, OnMessage(0x02B1, ""), ErrorLevel := 0
    return 0, Func := "", ErrorLevel := 1
} ;http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
WM_WTSSESSION_CHANGE(wParam, lParam, SetFunc := "*") {
	static Func
	static code := {0x1: "WTS_CONSOLE_CONNECT", 0x2: "WTS_CONSOLE_DISCONNECT", 0x4: "WTS_REMOTE_CONNECT"
		, 0x4: "WTS_REMOTE_DISCONNECT", 0x5: "WTS_SESSION_LOGON", 0x6: "WTS_SESSION_LOGOFF"
		, 0x7: "WTS_SESSION_LOCK", 0x8: "WTS_SESSION_UNLOCK", 0x9: "WTS_SESSION_REMOTE_CONTROL"}
	return true, i:=SetFunc!="*"?(Func:=SetFunc):%Func%(code[wParam])
} ;https://msdn.microsoft.com/library/aa383828%28vs.85,en-us%29

;recupera la ruta completa de una carpeta WIN_V+
SHGetKnownFolderPath(GUID) {
	if !Get( GUID, i )
		VarSetCapacity(CLSID, 16, 0), VarSetCapacity(ppszPath, 261 * 2)
		, DllCall("Ole32.dll\CLSIDFromString", "WStr", GUID, "Ptr", &CLSID)
		, DllCall("Shell32.dll\SHGetKnownFolderPath", "Ptr", &CLSID, "UInt", 0, "Ptr", 0, "PtrP", &ppszPath), Path := ppszPath
	return i ? i : Set( GUID, RTrim( StrGet(&ppszPath), "\" ) )
		, x := i ? "" : DllCall("Ole32.dll\CoTaskMemFree", "Ptr", &Path)
}

;recupera la ruta completa de una carpeta WIN_XP+
SHGetFolderPath(CSIDL) {
	if !Get( CSIDL, i )
		VarSetCapacity(pszPath, 261 * 2)
		, DllCall("Shell32.dll\SHGetFolderPathW", "Ptr", 0, "Int", CSIDL, "Ptr", 0, "UInt", 0, "Ptr", &pszPath)
	return i ? i : Set( CSIDL, RTrim( StrGet(&pszPath), "\" ) )
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA: VARIABLES ::::::::::::::::::::::::::::::::::
;NOTA: el valor que devuelve queda guardado en memoria, esto hace que la próxima vez se obtenga al instante.
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Recupera la ruta a la raíz del directorio del usuario actual
A_UserProfile() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, EnvGet( "USERPROFILE" ) )
}

;Recupera la ruta a la raíz del directorio que contiene los datos del programa compartidos por todos los usuarios.
A_AllUsersProfile() {
	if !Get( A_ThisFunc, i )
		DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;Recupera la ruta de acceso al directorio raíz donde se almacenan los perfiles de usuario.
A_Profiles() {
	if !Get( A_ThisFunc, i )
		DllCall("Userenv.dll\GetProfilesDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Userenv.dll\GetProfilesDirectoryW", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;Recupera la ruta de acceso a la raíz del perfil de usuario predeterminado.
A_DefaultUserProfile() {
	if !Get( A_ThisFunc, i )
		DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2)
		, DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera el nombre del usuario actual
A_UserName() {
	if !Get( A_ThisFunc, i )
		DllCall("Advapi32.dll\GetUserNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Advapi32.dll\GetUserNameW", "Str", lpBuffer, "UInt*", uSize + 1)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera el dominio del usuario actual
A_UserDomain() {
	if !Get( A_ThisFunc, i )
		DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", lpBuffer, "UInt*", uSize + 1)
	return i ? i : Set( A_ThisFunc, StrSplit( lpBuffer, "\" )[1] )
}

;Recupera/Establece el nombre NetBIOS del equipo local.
;Este nombre se estableció al inicio del sistema, cuando el sistema lo lee desde el registro.
A_ComputerName(lpComputerName*) {
	if lpComputerName.MaxIndex()
		return DllCall("Kernel32.dll\SetComputerNameW", "Str", lpComputerName[1])
	if !Get( A_ThisFunc, i )
		DllCall("kernel32.dll\GetComputerNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetComputerNameW", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta del directorio de sistema utilizado por WOW64.
;NOTA: Este directorio no está presente en Windows de 32 bits.
A_SysDir64() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta del directorio de sistema.
;El directorio del sistema contiene los archivos del sistema, como las bibliotecas y los controladores de vínculos dinámicos.
A_SysDir() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetSystemDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemDirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta del directorio compartido de Windows en un sistema multi-usuario.
A_SysWinDir() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta de acceso del directorio de Windows.
A_WinDir() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetWindowsDirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;Archivos Temporales
A_Temp() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetTempPathW", "UInt", 0, "Ptr", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetTempPathW", "UInt", uSize + 1, "Str", lpBuffer)
	return i ? i : Set( A_ThisFunc, StrLPath( lpBuffer ) )
}

;recupera/establece el directorio de trabajo
A_WorkingDir(WorkingDir*) {
	if WorkingDir.MaxIndex()
		return SetWorkingDir( WorkingDir[1] )
	return GetWorkingDir()
}

;recupera la ruta a la consola de windows (cmd.exe)
A_ComSpec() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, EnvGet( "ComSpec" ) )
}

;recupera el idioma por defecto del sistema
A_Language() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, Format("{:04X}", DllCall("GetSystemDefaultUILanguage", "UShort")) )
}

;recupera el directorio de Archivos De Programa
A_ProgramFiles() {
	CSIDL_PROGRAM_FILES := 0x0026
	return SHGetFolderPath( CSIDL_PROGRAM_FILES )
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio del usuario actual 
A_Programs() {
	CSIDL_PROGRAMS := 0x0002
	return SHGetFolderPath( CSIDL_PROGRAMS )
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio para todos los usuarios
A_ProgramsCommon() {
	CSIDL_COMMON_PROGRAMS := 0X0017
	return SHGetFolderPath( CSIDL_COMMON_PROGRAMS )
}

;directorio de sistema de archivos que contiene los datos de aplicación para el usuario actual
A_AppData() {
	CSIDL_APPDATA := 0x001a
	return SHGetFolderPath( CSIDL_APPDATA )
}

;directorio de sistema de archivos que contiene los datos de aplicación para todos los usuarios
A_AppDataCommon() {
	CSIDL_COMMON_APPDATA := 0x0023
	return SHGetFolderPath( CSIDL_COMMON_APPDATA )
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio del usuario actual
A_Desktop() {
	CSIDL_DESKTOPDIRECTORY := 0x0010
	return SHGetFolderPath( CSIDL_DESKTOPDIRECTORY )
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio para todos los usuarios
A_DesktopCommon() {
	CSIDL_COMMON_DESKTOPDIRECTORY := 0x0019
	return SHGetFolderPath( CSIDL_COMMON_DESKTOPDIRECTORY )
}

;ruta completa y el nombre de la carpeta del menú Inicio del usuario actua
A_StartMenu() {
	CSIDL_STARTMENU := 0x000b
	return SHGetFolderPath( CSIDL_STARTMENU )
}

;ruta completa y el nombre de la carpeta del menú Inicio para todos los usuarios
A_StartMenuCommon() {
	CSIDL_COMMON_STARTMENU := 0x0016
	return SHGetFolderPath( CSIDL_COMMON_STARTMENU )
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio del usuario actual
A_Startup() {
	CSIDL_STARTUP := 0x0007
	return SHGetFolderPath( CSIDL_STARTUP )
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio para todos los usuarios
A_StartupCommon() {
	CSIDL_COMMON_STARTUP := 0x0018
	return SHGetFolderPath( CSIDL_COMMON_STARTUP )
}

A_MyDocuments() {
	CSIDL_PERSONAL := 0x0005
	return SHGetFolderPath( CSIDL_PERSONAL )
}

A_DocumentsCommon() {
	CSIDL_COMMON_DOCUMENTS := 0x002e
	return SHGetFolderPath( CSIDL_COMMON_DOCUMENTS )
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de música
A_MyMusic() {
	CSIDL_MYMUSIC := 0x000d
	return SHGetFolderPath( CSIDL_MYMUSIC )
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de imagen
A_MyPictures() {
	CSIDL_MYPICTURES := 0x0027
	return SHGetFolderPath( CSIDL_MYPICTURES )
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de vídeo
A_MyVideo() {
	CSIDL_MYVIDEO := 0x000e
	return SHGetFolderPath( CSIDL_MYVIDEO )
}

;ancho del monitor actual
A_ScreenWidth() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", 0)
}

;tamaño de la zona de trabajo en el monitor de pantalla principal.
;el área de trabajo es la parte de la pantalla que no está oculta por la barra de tareas o las barras de herramientas de escritorio de aplicaciones.
;Sintaxis: A_MonitorWorkArea( [xpos], [ypos], [ancho], [alto] )
A_MonitorWorkArea(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 8 * 2, 0), i := {}
	r := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0030, "UInt", 0, "Ptr", &RECT, "UInt", 0)
	i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	i.w := i.Width := Width := NumGet(RECT,  8, "Int") - x
	i.h := i.Height := Height := NumGet(RECT, 12, "Int") - y
	return i, ErrorLevel := !r
}

;alto del monitor actual
A_ScreenHeight() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", 1)
}

;ruta completa al script
A_ScriptFullPath() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;directorio del script
A_ScriptDir() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;nombre del script
A_ScriptName() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;devuelve 1 si el script se está ejecutando como administrador
A_IsAdmin() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress1() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress2() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress3() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress4() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;directorio de sistema de archivos que contiene accesos directos a los documentos usados recientemente del usuario
A_Recent() {
	CSIDL_RECENT := 0x0008
	return SHGetFolderPath( CSIDL_RECENT )
}

;directorio de sistema de archivos que contiene Enviar a elementos de menú
A_SendTo() {
	CSIDL_SENDTO := 0x0009
	return SHGetFolderPath( CSIDL_SENDTO )
}

A_Time(Delimiter := "") {
	return A_Year Delimiter A_Mon Delimiter A_DD Delimiter A_Hour Delimiter A_Min Delimiter A_Sec
}

A_Cursor() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_OSVersion() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_OSType() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_TickCount(ByRef ElapsedTime := "") {
	static Time
	return _Time := DllCall("Kernel32.dll\GetTickCount")
		, ElapsedTime := _Time - Time, Time := _Time
}

A_LastError(SetLastError*) {
	if SetLastError.MaxIndex()
		return SetLastError( SetLastError[1] )
	return GetLastError()
}

A_DetectHiddenWindows() {
	return A_DetectHiddenWindows="On"
}

;ESPECIALES ######################################
;espacio
A_Space() {
	return Chr( 32 )
}

;tabulación
A_Tab() {
	return Chr( 9 )
}

;comilla ( " )
A_Quote() {
	return Chr( 34 )
}

;obtiene un array con los parámetros usados para ejecutar el script
;EJEMPLO: MsgBox( A_Args()[1] "`n" A_Args()[2] "`n" A_Args()[3] "`n" A_Args()[4] "`n" A_Args()[5] "`n`nTotal: " A_Args()[0] )
A_Args() { ;http://ahkscript.org/boards/viewtopic.php?t=4357 || By SKAN
	if Get( A_ThisFunc, Args )
		return Args
	CommandLineString := DllCall("Kernel32.dll\GetCommandLineW", "Str"), Args := [], Skip := A_IsCompiled ? 1 : 2
	pArgs := DllCall("Shell32.dll\CommandLineToArgvW", "WStr", CommandLineString, "PtrP", nArgs) 
	Loop, %nArgs% {
		if (A_Index > Skip)
			hArgs := NumGet( (A_Index - 1) * A_PtrSize + pArgs )
			, Args[A_Index - Skip] := StrGet( hArgs, "UTF-16" )
	}
	return Args, Args[0] := nArgs - Skip, DllCall("Kernel32.dll\LocalFree", "Ptr", pArgs)
		, Set( A_ThisFunc, Args )
}
;######################################














































/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  ::::::::::::::::::::::::::::::::::::::::::::: VENTANAS ::::::::::::::::::::::::::::::::::
---------------------------------------------------------------------------------------------------------------------------------------------------------------
NOTA: las funciones solo aceptan el ID de la ventana (mas rápido), excepto algunas como IsWindow() (opcional).
NOTA 2: para el titulo o ahk_xxx usar WinExist( .. ) o IsWindow(, [clase], [proceso/pid], [titulo]).
EJEMPLO: WinCenter( WinExist("ahk_exe notepad.exe") )
*/
;comprueba si la ventana no responde
WinHugh(hWnd) {
	return i := DllCall("User32.dll\IsHungAppWindow", "Ptr", hWnd)
		, ErrorLevel := !i
}

;comprueba si la ventana está habilitada
WinEnabled(hWnd) {
	return DllCall("User32.dll\IsWindowEnabled", "UInt", hWnd)
}
IsWinEnabled(hWnd) {
	return WinEnabled( hWnd )
}

;comprueba si la ventana existe
;Sintaxis: IsWindow( [ID], [clase], [proceso/pid], [título] )
;NOTA: dejar vacio para obtener el ID de la ventana activa
;EJEMPLO: MsgBox % IsWindow(,, "notepad.exe" )
IsWindow(hWnd*) { 
	;si no espesifica ningún parametro, devuelve el ID de la ventana activa
	if !hWnd.MaxIndex()
		return i := DllCall("User32.dll\GetForegroundWindow"), ErrorLevel := !i
	;si no se espesifica un ID válido, se busca una ventana que coincida con la/el clase/proceso/pid/titulo espesificado
	if !hWnd[1]&&(hWnd[2]||hWnd[3]||hWnd[4]) {
		Loop, Parse, % WinEnum(), `n
		{
			if hWnd[2]&&(WinGetClass(A_LoopField)!=hWnd[2])
				continue
			if hWnd[4]&&(WinGetTitle(A_LoopField)!=hWnd[4])
				continue
			if hWnd[3]&&(_wpname(A_LoopField,hWnd[3])!=hWnd[3])
				continue
			return A_LoopField, ErrorLevel := 0
		}
	}
	if !hWnd[1]||!DllCall("User32.dll\IsWindow", "Ptr", hWnd[1])
	||(hWnd[2]&&(WinGetClass(hWnd[1])!=hWnd[2]))
	||(hWnd[4]&&(WinGetTitle(hWnd[1])!=hWnd[4]))
	||(hWnd[3]&&(_wpname(hWnd[1],hWnd[3])!=hWnd[3]))
		return 0, ErrorLevel := 1
	return hWnd[1], ErrorLevel := 0
}

;comprueba si la ventana es visible
WinVisible(hWnd) {
	return i := DllCall("User32.dll\IsWindowVisible", "Ptr", hWnd)
		, ErrorLevel := !i
}

;comprueba si la ventana está minimizada
WinMin(hWnd) {
	return i:=DllCall("User32.dll\IsIconic", "Ptr", hWnd)
		, ErrorLevel := !i
}

;comprueba si la ventana está maximizada
WinMax(hWnd) {
	return i := DllCall("User32.dll\IsZoomed", "Ptr", hWnd)
		, ErrorLevel := !i
}

;devuelve 1 si la ventana: existe, no esta maximizada/minimizada, es visible
WinNormal(hWnd) {
	if !IsWindow(hWnd)||WinMin(hWnd)||WinMax(hWnd)||!WinVisible(hWnd)
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;comprueba si es una ventana hija de otra
;Sintaxis: WinChild( [ID ventana padre], [ID ventana hija] )
WinChild(hWnd, ChWnd) {
	return DllCall("User32.dll\IsChild", "Ptr", hWnd, "Ptr", ChWnd)
}

;comprueba si la ventana está activa
;Sintaxis: IsWinActive( [ID], [clase], [proceso/pid], [titulo] )
;NOTA: equivale a: WinActive( "Título ahk_id ID ahk_class CLASS ahk_exe PROCESS.EXE ahk_pid PID" )
IsWinActive(hWnd := "", Class := "", ProcessName := "", Title := "") {
	ActiveWindowId := IsWindow()
	if (!Class&&!ProcessName&&!ActiveWindowId&&!Title)
	||(!hWnd&&!Class&&!ProcessName&&!Title)
	||(hWnd&&(ActiveWindowId!=hWnd))
	||(Class&&(WinGetClass(hWnd?hWnd:ActiveWindowId)!=Class))
	||(Title&&(WinGetTitle(hWnd?hWnd:ActiveWindowId)!=Title))
	||(ProcessName&&(_wpname(hWnd,ProcessName,ActiveWindowId) != ProcessName))
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;obtiene una lista con todas las ventanas de nivel superior en la pantalla
;W8+: sólo ventanas de nivel superior de las aplicaciones de escritorio
;Sintaxis: WinEnum( [ID], [¿incluir ventanas ocultas?] )
;NOTA: espesificar un ID para obtener una lista con todas las ventanas hijas de la ventana espesificada
WinEnum(hWnd := "", DetectHiddenWindows := 1) {
	global EnumWindowsProc_WindowList_WinEnumFunction := ""
	global EnumWindowsProc_WindowList_WinEnumFunction2 := DetectHiddenWindows
	static EnumAddress := RegisterCallback("EnumWindowsProc", "Fast", 2)
	if hWnd
		DllCall("User32.dll\EnumChildWindows", "Ptr", hWnd, "Ptr", EnumAddress, "Ptr", 0)
	else
		DllCall("User32.dll\EnumWindows", "Ptr", EnumAddress, "Ptr", 0)
	return EnumWindowsProc_WindowList_WinEnumFunction
}
EnumWindowsProc(hWnd, lParam) {
    global EnumWindowsProc_WindowList_WinEnumFunction
	global EnumWindowsProc_WindowList_WinEnumFunction2
	if EnumWindowsProc_WindowList_WinEnumFunction2||(!EnumWindowsProc_WindowList_WinEnumFunction2&&WinVisible(hWnd))
		EnumWindowsProc_WindowList_WinEnumFunction .= (EnumWindowsProc_WindowList_WinEnumFunction?"`n":"") hWnd
    return true
}

;minimiza todas las ventanas
;Sintaxis: WinMinimizeAll( [¿forzar?] )
;NOTA: si se usa forzar, usar WinMinimizeAllUndo(1) para restaurarlas
	;para dar foco al escritorio usar ShowDesktop()
WinMinimizeAll(Force := 0) {
	static Array, ActiveWindow
	if (Force="?"||Force="*")
		return Force="?"?Array:ActiveWindow
	ActiveWindow := IsWindow()
	if Force {
		Array := "", Array := [], ok := Count := 0
		Loop, Parse, % WinEnum(), `n
			if !WinMin(A_LoopField)&&WinVisible(A_LoopField) {
				Count++
				if WinMinimize(A_LoopField)
					ok++, Array[ok] := A_LoopField
			}
		return ok, ErrorLevel := ok=Count?0:1
	}
	if !(hWindow := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0))
		return ComObjCreate( "shell.application" ).MinimizeAll()
	return DllCall("User32.dll\PostMessageW", "Ptr", hWindow, "UInt", 0x0111, "UInt", 419, "Ptr", 0)
}

;restaura todas las ventanas
;Sintaxis: WinMinimizeAllUndo( [¿forzar?] )
;NOTA: si se usa forzar, restaura solo las ventanas minimizadas por WinMinimizeAll(1)
WinMinimizeAllUndo(Force := false) {
	if Force {
		ok := Count := 0
		for Index, hWnd in WinMinimizeAll("?") {
			if WinMin(hWnd)&&WinVisible(hWnd)
				ok += WinRestore(hWnd)?1:0, Count++
		}
		return ok, WinActivate(WinMinimizeAll("*")), ErrorLevel := ok=Count?0:1
	}
	if !(hWindow := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0))
		return ComObjCreate( "shell.application" ).UndoMinimizeALL()
	return DllCall("User32.dll\PostMessageW", "Ptr", hWindow, "UInt", 0x0111, "UInt", 416, "Ptr", 0)
}

;Invoca un elemento de menú de la barra de menú de la ventana especificada
;Sintaxis: WinMenuSelectItem( [ID], [Menu Principal], [Submenus*] )
;EJEMPLO: WinMenuSelectItem( IsWindow(), "Archivo", "Abrir..." )
;VER: MenuGetItemList()
WinMenuSelectItem( hWnd, Menu, Submenu* ) { ;AHKv1 --> WinMenuSelectItem()
	return MenuSelect( hWnd, Menu, Submenu* ) ;AHKv2 --> MenuSelect()
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;centrar ventana, opcional posicionarla arriba/abajo/izquierda/derecha
;Sintaxis: WinCenter( [ID], [Top|Bottom|Right|Left], [¿obviar barra de tareas?], [¿centrar?] )
;EJEMPLO:
	;WinMinimizeAll(), Run("notepad.exe"), Sleep(500), i := WinExist( "ahk_exe notepad.exe" ), WinActivate( i, 1 )
	;MsgBox % "Centrar Ventana: " WinCenter( i ) " - " i
	;MsgBox % "Centrar Ventana (Omitir Barra De Tareas): " WinCenter( i,, 1 )
	;MsgBox % "Centrar Ventana, Arriba: " WinCenter( i, "Top" )
	;MsgBox % "Centrar Ventana, Derecha: " WinCenter( i, "Right" )
	;MsgBox % "Posicionar Ventana Abajo: " WinCenter( i, "Bottom",, 0 )
	;MsgBox % "Posicionar Ventana A La Izquierda: " WinCenter( i, "Left",, 0 )
	;MsgBox % "Posicionar Ventana, Arriba-Derecha: " WinCenter( i, "Top" ) WinCenter( i, "Right",, 0 )
WinCenter(hWnd, Mode := 0, ByWorkArea := 0, Center := 1) {
	if WinMax( hWnd )
		return 0, ErrorLevel := 3
	WinGetPos( hWnd,,, width, height )
	ypos := (Mode="T")||(Mode="Top")?0
		: (Mode="B")||(Mode="Bottom")?A_MonitorWorkArea().h-height
		: (Center?((ByWorkArea?A_MonitorWorkArea().h:A_ScreenHeight)/2)-(height/2):"")
	xpos := (Mode="L")||(Mode="Left")?0
		: (Mode="R")||(Mode="Right")?A_MonitorWorkArea().w-width
		: (Center?((ByWorkArea?A_MonitorWorkArea().w:A_ScreenWidth)/2)-(width/2):"")
	return i := WinMove( hWnd, xpos, ypos )
		ErrorLevel := !i
}

;parpadea la ventana especificada. no cambia el estado activo de la ventana.
;Sintaxis: WinFlash( [ID], [opciones], [veces que parpadea la ventana], [velocidad de parpadeo en milisegundos] )
;Opciones (se pueden sumar para combinar):
	;0 = parar (defecto).
	;1 = solo afecta al titulo de la ventana
	;2 = solo afecta al boton de la barra de tareas
	;12 = hasta que la ventana esté activa
WinFlash(hWnd, dwFlags := 0, uCount := 0, dwTimeout := 0) {
	cbSize := VarSetCapacity(FLASHWINFO, A_PtrSize = 4 ? 20 : 32, 0) 
	NumPut(cbSize, FLASHWINFO, 0, "UInt")
	NumPut(hWnd, FLASHWINFO, 4, "Ptr")
	NumPut(dwFlags+(uCount=0?4:0), FLASHWINFO, 8, "UInt")
	NumPut(uCount>0?uCount:0, FLASHWINFO, A_PtrSize = 4 ? 12 : 16, "UInt")
	NumPut(dwTimeout>0?dwTimeout:0, FLASHWINFO, A_PtrSize = 4 ? 16 : 24, "UInt")
	return DllCall("User32.dll\FlashWindowEx", "Ptr", &FLASHWINFO)
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;redibujar la ventana
;Sintaxis: WinRedraw( [ID] )
WinRedraw(hWnd) {
	return i := DllCall("User32.dll\InvalidateRect", "Ptr", hWnd, "Ptr", 0, "Int", 1)
		, DllCall("User32.dll\UpdateWindow", "Ptr", hWnd), ErrorLevel := !i
}

;Permite producir efectos especiales al mostrar u ocultar ventanas
;Sintaxis: WinAnimate( [ID], [El tiempo que toma para reproducir la animación , en milisegundos], [Tipo de animación] )
;TIPOS DE ANIMACIÓN (se pueden combinar):
	;S = Mostrar | H = Ocultar | C = Centrar
	;1 = Desvanecer | 2 = Diapositiva (combinar con 3/4 y/o 5/6)
	;3 = Izquierda A Derecha | 4 = Derecha A Izquierda
	;5 = Arriba Abajo | 6 = Abajo Arriba
;Nota: cuando se usa la opcion 'S' (mostrar), a veces es necesario redibujar la ventana, usar WinRedraw().
WinAnimate(hwnd, Time := 200, Mode := "S1") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632669%28v=vs.85%29.aspx
	static List := {"S" : 0x00020000, 1 : 0x00080000, "C" : 0x00000010, "H" : 0x00010000, 3 : 0x00000001, 4 : 0x00000002, 2 : 0x00040000, 5 : 0x00000004, 6 : 0x00000008}
	return DllCall("User32.dll\AnimateWindow", "Ptr", hwnd, "UInt", Time, "UInt", _cstr(List, Mode, "~", "+"))
}

;minimizar ventana al área de notificacion con animación
;Sintaxis: WinMinimizeToTray( [ID], [¿Mostrar?] )
;EJEMPLO: ver WinTitleAnimate()
WinMinimizeToTray(hWnd, Show := 0) {
	static Array := []
	if Show {
		if (Show = 2)
			MenuIcon("Tray")
		WinShow( hWnd )
		return WinTitleAnimate( hWnd, Array[hWnd].x, Array[hWnd].y, Array[hWnd].w, Array[hWnd].h )
			, WinMove( hWnd, Array[hWnd].x, Array[hWnd].y )
	}
	MenuIcon("Tray", 1), Array[hWnd] := WinGetPos(hWnd)
	hTray := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0)
	WinGetPos( hTray, txpos, typos, twsize, thsize)
	ControlGetPos( hTray, "TrayNotifyWnd1", nxpos, nypos, nwsize, nhsize )
	SW:=A_ScreenWidth,SH:=A_ScreenHeight,xpos:=SW-nhsize,ypos:=SH-nhsize,P:=((typos>(SH/3))?("B"):(txpos>(SW/3))
	? ("R"):((txpos<(SW/3))&&(thsize<(SH/3)))?("T"):("L")),((P="L")?(xpos:=nxpos+twsize):(P="T")?(ypos:=nypos+thsize):) 
	return WinTitleAnimate( hWnd, xpos, ypos, nhsize, nhsize, "MHi" )
}

;permite producir una animacion para el titulo de la ventana
;Sintaxis: WinTitleAnimate( [ID], [x], [y], [ancho], [alto], [Opciones] )
;OPCIONES: puede incluir una, dos o las tres
	;Hide /Hi = ocultar ventana antes de producir el efecto
	;Move / M = mover ventana antes de producir el efecto
	;Show / S = mostrar ventana al terminar la animación
;EJEMPLO:
	;MenuIcon( "Tray" )
	;WinMinimizeAll(), Run("notepad.exe"), Sleep(500), i := WinExist("ahk_exe notepad.exe"), WinActivate(i,1)
	;WinMove(i,,,300,300), WinCenter(i,"Bottom"), WinCenter(i,"Right",, 0), Sleep(500), WinTitleAnimate(i,0,0,,,"HiMS")
	;Sleep(1000), WinTitleAnimate(i,50,50,,, "HiMS"), Sleep(1000), WinMinimizeToTray(i), Sleep(1000)
	;WinMinimizeToTray(i,2), Sleep(1000), ExitApp()
WinTitleAnimate(hWnd, X := "", Y := "", W := "", H := "", Flag := 0) {
	;desde: posicion actual
	VarSetCapacity( FRECT, 8 * 2, 0 )
	WinGetPos( hWnd, fxpos, fypos, fwsize, fhsize)
	NumPut( fxpos, FRECT, 0, "Int" ), NumPut( fypos, FRECT, 4, "Int" )
	NumPut( fwsize + fxpos, FRECT, 8, "Int" ), NumPut( fhsize + fypos, FRECT, 12, "Int" )
	;hacia: posicion nueva
	VarSetCapacity( TRECT, 8 * 2, 0 )
	NumPut( x = "" ? fxpos : x, TRECT, 0, "Int" ), NumPut( y = "" ? fypos : y, TRECT, 4, "Int" )
	NumPut( W = "" ? fwsize+fxpos : W+X, TRECT, 8, "Int" ), NumPut( H = "" ? fhsize+fypos : H+Y, TRECT, 12, "Int" )
	;opciones
	if InStr( Flag, "Hi" )
		WinHide( hWnd )
	if InStr( Flag, "M" )
		WinMove( hWnd, x = "" ? fxpos : x, y = "" ? fypos : y )
	;---
	return i := DllCall("User32.dll\DrawAnimatedRects", "Ptr", hWnd, "Int", 0x3, "Ptr", &FRECT, "Ptr", &TRECT)
		, x := InStr( Flag, "S" ) ? WinShow( hWnd ) : ""
		, ErrorLevel := !i
}

;mover ventana
;Sintaxis: WinMove( [ID], [x], [y], [ancho], [alto], [¿redibujar?] )
WinMove(hWnd, x := "", y := "", Width := "", Height := "", bRepaint := 1) {
	if (x=""||y=""||Width=""||Height="")
		WinGetPos( hWnd, x_, y_, w_, h_ )
	x := x=""?x_:x, y := y=""?y_:y, Width := Width=""?w_:Width, Height := Height=""?h_:Height
	return i := DllCall("User32.dll\MoveWindow", "Ptr", hWnd, "Int", x, "Int", y, "Int", Width, "Int", Height, "Int", bRepaint)
		, ErrorLevel := !i
}

;cerrar ventana
;Sintaxis: WinClose( [ID], [Segundos a esperar], [¿Forzar?] )
;NOTA: espesificar 0 segundos para esperar indefinidamente
WinClose(hWnd, Seconds := -1, Force := 0) {
	if Force {
		WinGetPID( hWnd, WinThreadId )
		hThread := DllCall("Kernel32.dll\OpenThread", "UInt", 0x0001, "UInt", 0, "UInt", WinThreadId)
		return i := DllCall("Kernel32.dll\TerminateThread", "Ptr", hThread, "UInt", 0)
			, DllCall("Kernel32.dll\CloseHandle", "Ptr", hThread)
			, ErrorLevel := !i, WinWaitClose( hWnd, Seconds )
	}
	return i := DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x0002, "Ptr", 0, "Ptr", 0)
		, ErrorLevel := !i, WinWaitClose( hWnd, Seconds )
}
WinKill(hWnd, Seconds := -1) {
	return WinClose( hWnd, Seconds, 1 ) ? 1
		: DllCall("User32.dll\EndTask", "Ptr", hWnd, "Int", 0, "Int", 1)
}

;minimiza la ventana
;Sintaxis: WinMinimize( [ID], [¿Forzar?] )
WinMinimize(hWnd, Force := 0) {
	if Force
		DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x112, "UInt", 0xF020, "Ptr", 0)
	static SW_FORCEMINIMIZE := 11, SW_MINIMIZE := 6
	nCmdShow := Force = 2 ? SW_FORCEMINIMIZE : SW_MINIMIZE
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;maximiza la ventana
;Sintaxis: WinMaximize( [ID], [¿Forzar?] )
WinMaximize(hWnd, Force := 0) {
	if Force
		DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x112, "UInt", 0xF030, "Ptr", 0)
	static nCmdShow := SW_MAXIMIZE := 3
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;restaura la ventana a su tamaño y posicion original
;Sintaxis: WinRestore( [ID], [¿Forzar?] )
WinRestore(hWnd, Force := 0) {
	if Force
		DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x112, "UInt", 0xF120, "Ptr", 0)
	static nCmdShow := SW_RESTORE := 9
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;oculta la ventana
;NOTA: para ocultar la ventana solo en la barra de tareas usar WinTaskBarRemove()
WinHide(hWnd) {
	static nCmdShow := SW_HIDE := 0
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;habilita la ventana
;Sintaxis: WinEnable( [ID], [¿Activar?], [¿Esperar? (seg)] )
WinEnable(hWnd, Activate := 0, WaitActive := -1) {
	return i := DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", 1)
		, a := Activate ? WinActivate( hWnd ) : ""
		, ErrorLevel := !i, WinWaitActive( hWnd, WaitActive )
}

;deshabilita la ventana
WinDisable(hWnd) {
	return i := !DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", 0)
		, ErrorLevel := !i
}

;muestra la ventana
;Sintaxis: WinShow( [ID], [¿Activar?], [¿Esperar? (segundos)] )
WinShow(hWnd, Activate := 0, WaitActive := -1) {
	static nCmdShow := SW_SHOW := 5
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, a := Activate ? WinActivate( hWnd ) : ""
		, WinWaitActive( hWnd, WaitActive )
		, ErrorLevel := !i
}

;activa la ventana
;NOTA: si la ventana está minimizada, las restaura a su tamaño y posicion original
;Sintaxis: WinActivate( [ID], [¿Esperar? (segundos)], [¿Forzar?] )
WinActivate(hWnd, WaitActive := -1, Force := 0) {
	if WinMin( hWnd )
		WinRestore( hWnd )
	if Force {
		CurrentThreadId := ProcessExist( -2 )
		WinGetPID( hWnd, WinThreadId )
		DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 1)
		return i := DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
			, DllCall("User32.dll\BringWindowToTop", "Ptr", hWnd)
			, DllCall("User32.dll\SetFocus", "Ptr", hWnd)
			, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 0)
			, ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
	}
	return i := DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
		, ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;obtener posicion de la ventana
;Sintaxis: WinGetPos( [ID], [xpos], [ypos], [ancho], [alto], [modo] )
;MODOS:
	;0 (defecto) = obtiene el ancho y alto de la ventana entera
	;1 = excluir los bordes de la ventana
	;+2 = convierte en coordenadas de pantalla
WinGetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "", Mode := 0) {
	VarSetCapacity(WRECT, 8 * 2, 0), i := {}
	h := DllCall("User32.dll\GetWindowRect", "Ptr", hWnd, "Ptr", &WRECT)
	if (Mode=1||Mode=3)
		VarSetCapacity(CRECT, 8 * 2, 0)
		, h := DllCall("User32.dll\GetClientRect", "Ptr", hWnd, "Ptr", &CRECT)
	if (Mode=2||Mode=3)
		DllCall("User32.dll\ClientToScreen", "Ptr", hWnd, "Ptr", &WRECT)
		, DllCall("User32.dll\ClientToScreen", "Ptr", hWnd, "Ptr", &CRECT)
	i.x := x := NumGet(WRECT, 0, "Int"), i.y := y := NumGet(WRECT, 4, "Int")
	i.h := i.Height := Height := NumGet(Mode=1||Mode=3?CRECT:WRECT, 12, "Int") - (Mode=1||Mode=3?0:y)
	i.w := i.Width := Width := NumGet(Mode=1||Mode=3?CRECT:WRECT,  8, "Int") - (Mode=1||Mode=3?0:x)
	return i, ErrorLevel := !h
}

;obtiene el ancho y alto de los bordes de la ventana
WinGetBorder(hWnd, ByRef Width := "", ByRef Height := "") {
	WinGetPos( hWnd,,, Width, Height ), WinGetPos( hWnd,,, Width2, Height2, 1 )
	i.w := i.Width := Width := Width - Width2, i.h := i.Height := Height := Height - Height2
	return i, ErrorLevel := !h
}

;obtiene el estilo de la ventana
;para convertirlo a hexadecimal: Hex( Style, 8, 1 )
WinGetStyle(hWnd) { ;0x40000 = resize
	if !(Style := DllCall("User32.dll\GetWindowLongPtrW", "Ptr", hWnd, "Int", -16))
		Style := DllCall("User32.dll\GetWindowLongW", "Ptr", hWnd, "Int", -16)
	return Style, ErrorLevel := !Style
}

;obtiene el estilo extendido de la ventana
;para convertirlo a hexadecimal: Hex( ExStyle, 8, 1 )
WinGetExStyle(hWnd) {
	if !(ExStyle := DllCall("User32.dll\GetWindowLongPtrW", "Ptr", hWnd, "Int", -20))
		ExStyle := DllCall("User32.dll\GetWindowLongW", "Ptr", hWnd, "Int", -20)
	return ExStyle, ErrorLevel := !ExStyle
}

;establecer estilo
;Sintaxis: WinSetStyle( [ID], [+-^Estilo] )
;Estilo: +(añadir) -(quitar) ^(alternar) || defecto es +(añadir)
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600%28v=vs.85%29.aspx
WinSetStyle(hWnd, Style) {
	Style := _mnum(WinGetStyle(hWnd), Style)
	if ErrorLevel||(!DllCall("User32.dll\SetWindowLongPtrW", "Ptr", hWnd, "Int", -16, "Int", Style)
	&&!DllCall("User32.dll\SetWindowLongW", "Ptr", hWnd, "Int", -16, "Int", Style))
			return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;establecer estilo extendido
;Sintaxis: WinSetExStyle( [ID], [+-^Estilo] )
;Estilo: +(añadir) -(quitar) ^(alternar) || defecto es +(añadir)
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543%28v=vs.85%29.aspx
WinSetExStyle(hWnd, ExStyle) {
	ExStyle := _mnum(WinGetExStyle(hWnd), ExStyle)
	if ErrorLevel||(!DllCall("User32.dll\SetWindowLongPtrW", "Ptr", hWnd, "Int", -20, "Int", ExStyle)
	&&!DllCall("User32.dll\SetWindowLongW", "Ptr", hWnd, "Int", -20, "Int", ExStyle))
			return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;Recupera el titulo de la ventana especificada.
;Sintaxis: WinGetTitle( [ID] )
WinGetTitle(hWnd) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633520%28v=vs.85%29.aspx
	nMaxCount := DllCall("User32.dll\GetWindowTextLengthW", "Ptr", hWnd)
	nMaxCount := VarSetCapacity( lpString, (nMaxCount + 1) * 2, 0 ) / 2
	i := DllCall("User32.dll\GetWindowTextW", "Ptr", hWnd, "Str", lpString, "Int", nMaxCount)
	return lpString, ErrorLevel := !i
}

;Recupera el nombre de la clase a la que pertenece la ventana especificada.
WinGetClass(hWnd) {
	nMaxCount := VarSetCapacity( lpClassName, (256 + 1) * 2, 0 ) / 2
	i := DllCall("User32.dll\GetClassNameW", "Ptr", hWnd, "Str", lpClassName, "Int", nMaxCount)
	return lpClassName, ErrorLevel := !i
}

;recupera el PID, opcional ThreadId/ProcessName/ProcessPath
;Sintaxis: WinGetPID( [ID], [ThreadId (salida)], [Proceso (salida)], [Proceso Ruta (salida)] )
;EJEMPLO: MsgBox % "Pid: " WinGetPid(IsWindow(),,,i) "`nCompanyName: " FileGetInfo(i,"CompanyName") "`nRuta: " i
WinGetPID(hWnd, ByRef ThreadId := "", ByRef ProcessName := "", ByRef ProcessPath := "") {
	VarSetCapacity( lpdwProcessId, A_PtrSize * 2, 0 )
	ThreadId := DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "Ptr", &lpdwProcessId)
	return ProcessId := NumGet( lpdwProcessId, 0, "Ptr" )
		, ProcessName := IsByRef( ProcessName ) ? ProcessName( ProcessId ) : ""
		, ProcessPath := IsByRef( ProcessPath ) ? ProcessPath( ProcessId ) : ""
		, ErrorLevel := !ThreadId
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;establecer el titulo de la ventana espesificada
;Sintaxis: WinSetTitle( [ID], [Titulo] )
WinSetTitle(hWnd, NewTitle := "") {
	return i := DllCall("User32.dll\SetWindowTextW", "Ptr", hWnd, "Str", NewTitle)
		, ErrorLevel := !i
}

WinSetBottom( hWnd ) {
	WinSet, Bottom,, ahk_id %hWnd%
	return !ErrorLevel
}

;cambia el icono de la ventana
;Sintaxis: WinSetIcon( [ID], [Icono/DLL/Ejecutable], [Índice] )
WinSetIcon(hWnd, lpszExeFileName, nIconIndex := 0) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632643%28v=vs.85%29.aspx
	static WM_SETICON := 0x0080, ICON_SMALL := 0, ICON_BIG := 1
	if !(hIcon := DllCall("Shell32.dll\ExtractIconW", "Ptr", A_ScriptHwnd, "Str", lpszExeFileName, "UInt", nIconIndex))
		return 0, ErrorLevel := 2
	SendMessage(hWnd, 0x0080,,,, hIcon), SendMessage(hWnd, 0x0080,, 1,, hIcon)
	if ErrorLevel
		return, DllCall("User32.dll\DestroyIcon", "Ptr", hIcon)
	return 1, ErrorLevel := 0
}

;establece la ventana padre de una ventana
WinSetParent(hWndChild, hWndNewParent) {
	return i := DllCall("User32.dll\SetParent", "Ptr", hWndChild, "Ptr", hWndNewParent)
		, ErrorLevel := !i
}

WinSetTransparent( hWnd, Transparent ) {
	WinSet, Transparent, %Transparent%, ahk_id %hWnd%
	return !ErrorLevel
}

WinSetRegion( hWnd, Region ) {
	WinSet, Region, %Region%, ahk_id %hWnd%
	return !ErrorLevel
}

;establece la ventana siempre al frente
;Sintaxis: WinSetAlwaysOnTop( [ID], [0|1] )
WinSetAlwaysOnTop(hWnd, State := 1) {
	return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", State ? -1 : -2, "Int", 0, "Int", 0 "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
}

;registrar eventos para una ventana
;Sintaxis: WinSetEventHook( [ID], [Funcion], [Evento menor], [Evento mayor] )
;Sintaxis (eliminar): WinSetEventHook( [hEvent] )
;EVENTOS: https://msdn.microsoft.com/en-us/library/windows/desktop/dd318066%28v=vs.85%29.aspx
;EJEMPLO:
	;WinSetEventHook( WinExist("ahk_exe notepad.exe"), "WinEventProc", EVENT_OBJECT_LOCATIONCHANGE := 0x800B )
	;WinEventProc(hWinEventHook, Event, hWnd, idObject, idChild, dwEventThread, dwmsEventTime) {
	;	if hWnd
		;	MsgBox % "Título: " WinGetTitle( hWnd )
		;		. "`nClase: " WinGetClass( hWnd )
		;		. "`nEvento: " Event
	;	return
	;}
WinSetEventHook(hWnd, Func := "", EventMin := "", EventMax := "") {
	if !Func ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd373640%28v=vs.85%29.aspx
		return i := DllCall("User32.dll\UnhookWinEvent", "Ptr", hWnd), ErrorLevel := !i
	if !IsWindow( hWnd ) OR !IsFunc( Func )
		return 0, ErrorLevel := 2
	WINEVENT_OUTOFCONTEXT := 0x0, WINEVENT_SKIPOWNPROCESS := 0x2
	EventMax := EventMax ? EventMax : EventMin, WinGetPID( hWnd, WinThreadId )
	return i := DllCall("User32.dll\SetWinEventHook", "UInt", EventMin, "UInt", EventMax, "Ptr", 0, "Ptr", RegisterCallback( Func )
		, "UInt", 0, "UInt", WinThreadId, "UInt", WINEVENT_OUTOFCONTEXT|WINEVENT_SKIPOWNPROCESS)
		, ErrorLevel := !i
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;espera a que la ventana no exista
;Sintaxis: WinWaitClose( [ID], [segundos], [clase], [proceso/pid], [titulo] )
WinWaitClose(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWindow(hWnd, Class, ProcessName, Title)
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que una ventana se active
;Sintaxis: WinWaitActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if IsWinActive(hWnd, Class, ProcessName, Title)
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que una ventana pierda el foco
;Sintaxis: WinWaitNotActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitNotActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWinActive(hWnd, Class, ProcessName, Title)
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que una ventana exista
;Sintaxis: WinWait( [Título], [Segundos], [clase], [proceso/pid], [ID] )
WinWait(Title := "", Seconds := 0, Class := "", ProcessName := "", hWnd := "") {
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if IsWindow( hWnd, Class, ProcessName, Title)
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}





































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: MENÚS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener una lista con todos los elementos de los menús de la ventana
;Sintaxis: MenuGetItemList( [ID] )
;NOTA: sólo funciona con aplicaciones que utilizan menús estándar de Windows
;EJEMPLO: ver uso de LoopParse con RegExMatch() en: SelectMenuItem()
MenuGetItemList(hWnd, hMenu := 0, Prefix := "") { ;http://ahkscript.org/boards/viewtopic.php?p=48401#p48401
	hMenu := hMenu ? hMenu : DllCall("User32.dll\GetMenu", "Ptr", hWnd)
	Count := DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
	Loop, %Count% {
		sSize := DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Ptr", 0, "Int", 0, "UInt", 0x00000400)
		sSize := VarSetCapacity( lpString, (sSize + 1) * 2 ) / 2
		if !DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Str", lpString, "Int", sSize, "UInt", 0x00000400)
			continue
		lpString := StrReplace(lpString, "&")
		ItemId := DllCall("User32.dll\GetMenuItemID", "Ptr", hMenu, "Int", A_Index-1)
		if (itemID = -1) AND (hSubMenu := DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", A_Index-1)) {
			List .= MenuGetItemList( "", hSubMenu, Prefix lpString " > " ) "`n"
			continue
		}
		List .= ItemId "`t" Prefix RegExReplace( lpString, "`t.*" ) "`n"
	}
	return RTrim( List, "`n" )
}

;ejecuta un comando del menu de la ventana
;Sintaxis: MenuSelectItem( [ID], [ID del Menú], [Nombre del Menú] )
;NOTA: espesificar ' > ' para submenús
;Ejemplo: MenuSelectItem( IsWindow(),, "Archivo > Abrir..." )
;VER: MenuGetItemList()
MenuSelectItem(hWnd, MenuItemId := "", MenuItemName := "") {
	if (MenuItemName != "") {
		Loop, Parse, % MenuGetItemList( hWnd ), `n, `r
		{
			RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
			if (MenuItemName = MenuItem2) {
				MenuItemId := MenuItem1
				break
			}
		}
		if (MenuItemId = "")
			Loop, Parse, % MenuGetItemList( hWnd ), `n, `r
			{
				RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
				if InStr(MenuItem2, MenuItemName) {
					MenuItemId := MenuItem1
					break
				}
			}
	}
	return DllCall("User32.dll\SendNotifyMessageW", "Ptr", hWnd, "UInt", 0x111, "Ptr", MenuItemId, "Ptr", 0)
}

;Invoca un elemento de menú de la barra de menú de la ventana especificada
;Sintaxis: MenuSelect( [ID], [Menu Principal], [Submenus*] )
;EJEMPLO: MenuSelect( IsWindow(), "Archivo", "Abrir..." )
;VER: MenuGetItemList(), MenuSelectItem()
MenuSelect( hWnd, Menu, Submenu*) {
	if !Submenu.MaxIndex()
		return MenuSelectItem( hWnd,, Menu )
	Loop, % Submenu.MaxIndex()
		_Submenu .= " > " Submenu[A_Index]
	return MenuSelectItem( hWnd,, Menu _Submenu )
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;comprueba si es un menú válido
IsMenu(hMenu) {
	return DllCall("User32.dll\IsMenu", "Ptr", hMenu)
}

;redibujar el menú de la ventana.
;Sintaxis: MenuRedraw( [ID] )
MenuRedraw(hWnd) {
	return DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd)
}

;añadir menú a un menú existente
;Sintaxis: MenuAdd( [Menú], [Item], [Etiqueta|:SubMenú|Función] )
;NOTA: especificar solo el Menú (primer parámetro) para agregar un separador
;EJEMPLO:
	;MenuAdd(), MenuAdd(, "Salir", Func("ExitApp"))
	;MenuAdd( "i", "Salir Menu", Func("MenuCheck").Bind("i", "Salir Menu", -1))
	;MenuAdd(, "Prueba Menu", ":i")
	;MenuIcon( "Tray", "shell32.dll", 4 )
	;MenuIcon( "i", "Salir Menu", "shell32.dll", 16 )
	;MenuColor( "i", "Green" ), MenuColor( "Tray", "Red" )
	;MenuDefault( "Tray", "Salir" )
	;MenuClick( 2 )
	;MenuCheck( "i", "Salir Menu" )
MenuAdd(MenuName := "Tray", MenuItemName := "", Label := "") {
	if (Label = " ")
		return
	Label := Label ? Label : Func( A_ThisFunc ).Bind( "",, A_Space )
	if (MenuItemName = "")
		try Menu, %MenuName%, Add
	else
		try Menu, %MenuName%, Add, %MenuItemName%, %Label%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;cambiar color
;Sintaxis: MenuColor( [Menú], [Color] )
MenuColor(MenuName, Color, Single := 1) {
	Single := Single ? "Single" : ""
	try Menu, %MenuName%, Color, %Color%, %Single%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;cambiar/quitar icono
;Sintaxis (Tray): MenuColor( [Menú], [Icono], [Indice] )
;Sintaxis (Otros): MenuColor( [Menú], [Item], [Icono], [Indice], [Ancho] )
;NOTAS: 
	;Tray: para ocultar el icono del área de notificacion: omitir el parametro 2 (Icono)
	;Tray: para mostrar el icono del área de notificacion: establecer el parametro 2 en 1
	;Otros: para quitar el icono de un item: obviar el parametro 3 (Icono)
MenuIcon(MenuName, MenuItemName := "", Icon := 0, IconNumber := 1, IconWidth := "") {
	if (MenuName = "Tray") {
		if MenuItemName {
			if (MenuItemName = 1)
				try Menu, Tray, Icon
			else
				try Menu, Tray, Icon, %MenuItemName%, %Icon%, 1
		} else
			try Menu, Tray, NoIcon
		catch
			return 0, ErrorLevel := 1
	} else {
		if Icon
			try Menu, %MenuName%, Icon, %MenuItemName%, %Icon%, %IconNumber%, %IconWidth%
		else
			try Menu, %MenuName%, NoIcon, %MenuItemName%
		catch
			return 0, ErrorLevel := 1
	}
	return 1, ErrorLevel := 0
}

;clic(s) por defecto para mostrar el menú (área de notificacion)
;Sintaxis: MenuClick( [1|2] )
MenuClick(ClickCount) {
	try Menu, Tray, Click, %ClickCount%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;item por defecto del menu (resaltado en negrita)
;Sintaxis: MenuDefault( [Menú], [Item] )
MenuDefault(MenuName, MenuItemName) {
	try Menu, %MenuName%, Default, %MenuItemName%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;añadir/quitar/alternar marca de verificacion
;Sintaxis: MenuCheck( [Menu], [Item], [-1(alternar)|0(quitar)|1(añadir)] )
MenuCheck(MenuName, MenuItemName, Check := 1) {
	if (Check = 1)
		try Menu, %MenuName%, Check, %MenuItemName%
	else if !Check
		try Menu, %MenuName%, UnCheck, %MenuItemName%
	else
		try Menu, %MenuName%, ToggleCheck, %MenuItemName%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}







































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SONIDO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Silenciar
;Sintáxis: Mute( [Opcion] )
;OPCIONES:
	;0 = restaurar
	;1 = silenciar
	;2 = alternar
	;[vacio] = devuelve 1 si esta silenciado
SoundMute(Mode := -1) {
	if (Mode = -1)
		return SoundGet(, "MUTE" ) = "On" ? 1 : 0
	return SoundSet( Mode = 2 ? "+1" : Mode,, "MUTE" )
}

;obtener volumen 
SoundGet(ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundGet, OutputVar, %ComponentType%, %ControlType%, %DeviceNumber%
	return OutputVar
}

;establecer volumen
SoundSet(Percent, ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundSet, %Percent%, %ComponentType%, %ControlType%, %DeviceNumber%
	return !ErrorLevel
}

SoundBeep( dwFreq, dwDuration) {
	return DllCall("Kernel32.dll\Beep", "UInt", dwFreq, "UInt", dwDuration)
}

SoundPlay( Filename, Wait := "") {
	SoundPlay, %Filename%, %Wait%
	return !ErrorLevel
}













































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SERVICIOS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;cambiar modo de inicio del servicio.
;Sintaxis: ServiceSet( [servicio], [boot | system | auto | manual | disable] )
ServiceSet(IpName, StartMode := "") {
	static StartupModes := {"boot": 0x00000000, "system": 0x00000001, "auto": 0x00000002, "manual": 0x00000003, "disable": 0x00000004}
	hService := ServiceOpen( IpName,, 0x0002 ) ;SERVICE_NO_CHANGE := 0xffffffff | SERVICE_CHANGE_CONFIG := 0x0002
	if StartupModes[StartMode]
		return i := DllCall("Advapi32.dll\ChangeServiceConfigW", "Ptr", hService, "UInt", 0xffffffff, "UInt", StartupModes[StartMode]
		, "UInt", 0xffffffff, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	return 0, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := 1
}

;recupera la informacion del servicio
;Sintaxis: ServiceGetDescription( [servicio], [Fast|Slow] )
ServiceGetDescription(IpName, Mode := "Fast") {
	if (Mode="F"||Mode="Fast") { ;Fast: lee desde el registro (recomendado)
		return RegRead("HKLM\SYSTEM\CurrentControlSet\Services\" IpName, "Description")
	} else if (Mode="S"||Mode="Slow") { ;Slow: abre el servicio para leer la descripcion (mas lento)
		hService := ServiceOpen( IpName,, 0x0001 )
		DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", 0, "UInt", 0, "UIntP", pcbBytesNeeded)
		cbBufSize := VarSetCapacity(SERVICE_DESCRIPTION, pcbBytesNeeded * 2, 0) / 2
		i := DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", &SERVICE_DESCRIPTION, "UInt", cbBufSize, "UIntP", 0)
		return StrGet(NumGet(SERVICE_DESCRIPTION, 0, "Ptr"), cbBufSize, "UTF-16")
			, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	}
	return 0, ErrorLevel := 1
}

;establece la informacion del servicio
;Sintaxis: ServiceSetDescription( [servicio], [descripcion] )
ServiceSetDescription(IpName, Description := "", Mode := "Slow") {
	Description := Trim(StrReplace(Description, A_Tab, A_Space))
	if (Mode="F"||Mode="Fast") { ;Fast: establece desde el registro (no recomendado, puede dar problemas con permisos)
		return RegWrite("HKLM\SYSTEM\CurrentControlSet\Services\" IpName, "Description", Description)
	} else if (Mode="S"||Mode="Slow") { ;Slow: abre el servicio para establecer la descripcion (recomendado)
		hService := ServiceOpen( IpName,, 0x0002 )
		VarSetCapacity(SERVICE_DESCRIPTION, StrLen(Description), 0)
		NumPut(&Description, SERVICE_DESCRIPTION, 0, "Ptr")
		return i := DllCall("Advapi32.dll\ChangeServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", &SERVICE_DESCRIPTION)
			, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	}
	return 0, ErrorLevel := 1
}

;pausar
ServicePause(IpName) {
	hService := ServiceOpen( IpName,, 0x0040 )
	VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000002, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;reanudar servicio
ServiceContinue(IpName) {
	hService := ServiceOpen( IpName,, 0x0040 )
	VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000003, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;eliminar
ServiceDelete(IpName) {
	hService := ServiceOpen( IpName,, 0x00010000 )
	return i := DllCall("Advapi32.lib\DeleteService", "Ptr", hService)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !i
}

;iniciar
ServiceStart(IpName) {
	if (ServiceInfo(IpName).StartMode = "disable")
		ServiceSet( IpName, "manual" )
	hService := ServiceOpen( IpName,, 0x0010 )
	return i := DllCall("Advapi32.dll\StartServiceW", "Ptr", hService, "UInt", 0, "Ptr", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !i
}

;detener
ServiceStop(IpName) {
	hService := ServiceOpen( IpName,, 0x0020 )
	VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000001, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;obtiene el estado
;Sintaxis: ServiceStatus( [servicio] )
;EJEMPLO: MsgBox % ServiceStatus("spooler").State
ServiceStatus(IpName) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms685996%28v=vs.85%29.aspx
	static s1 := "STOPPED", s2 := "START_PENDING", s3 := "STOP_PENDING", s4 := "RUNNING", s5 := "CONTINUE_PENDING", s6 := "PAUSE_PENDING", s7 := "PAUSED"
	static t1 := "KERNEL_DRIVER", t2 := "FILE_SYSTEM_DRIVER", t16 := "OWN_PROCESS", t32 := "SHARE_PROCESS", t100 := "INTERACTIVE_PROCESS"
	hService := ServiceOpen( IpName,, 0x0004 ), i := {}
	cbBufSize := VarSetCapacity(SERVICE_STATUS_PROCESS, A_PtrSize=4?36:44, 0), VarSetCapacity(pcbBytesNeeded, 4)
	r := DllCall("Advapi32.dll\QueryServiceStatusEx", "Ptr", hService, "UInt", 0, "Ptr", &SERVICE_STATUS_PROCESS, "UInt", cbBufSize, "UIntP", &pcbBytesNeeded)
	i.Type := (x:=NumGet(&SERVICE_STATUS_PROCESS, 0, "UInt"))?t%x%:t%x%
	i.State := (x:=NumGet(&SERVICE_STATUS_PROCESS, 4, "UInt"))?s%x%:s%x%
	i.ControlsAccepted := NumGet(&SERVICE_STATUS_PROCESS, 8, "UInt")
	i.ExitCode := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 12 : 16, "UInt")
	i.SpecificExitCode := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 16 : 24, "UInt")
	i.CheckPoint := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 20 : 28, "UInt")
	i.WaitHint := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 24 : 32, "UInt")
	i.ProcessId := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 28 : 36, "UInt")
	i.Flags := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 32 : 40, "UInt") ;1=system process (always be running)
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !r
}

;obtener informacion
;Sintaxis: ServiceInfo( [servicio] )
;EJEMPLO:
	;for k, v in ServiceInfo( "spooler" )
	;	MsgBox % k ": " v
ServiceInfo(IpName) {
	static m0 := "BOOT", m1 := "SYSTEM", m2 := "AUTO", m3 := "MANUAL", m4 := "DISABLE"
	hService := ServiceOpen( IpName,, 0x0001 )
	DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", 0, "UInt", 0, "UIntP", pcbBytesNeeded)
	cbBufSize := VarSetCapacity(QUERY_SERVICE_CONFIG, pcbBytesNeeded>0?pcbBytesNeeded:8000, 0) 
	DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", &QUERY_SERVICE_CONFIG, "UInt", cbBufSize, "UIntP", 0)
	i := {}, i.Type := NumGet(&QUERY_SERVICE_CONFIG, 0, "UInt") 
		, i.StartType := a:=NumGet(&QUERY_SERVICE_CONFIG, 4, "UInt"), i.StartMode := m%a%
		, i.ErrorControl := NumGet(&QUERY_SERVICE_CONFIG, 8, "UInt")
		, i.PathName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 12 : 16, "UInt") )
		, i.OrderGroup := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 16 : 24, "UInt") ) 
		, i.TagId := NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 20 : 28, "UInt")
		, i.Dependencies := NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 24 : 32, "Ptr")
		, i.StartName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 28 : 36, "UInt") ) 
		, i.DisplayName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 32 : 40, "UInt") ) 
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := i.StartType=""?1:0
}

;comprueba si existe el servicio
;Sintaxis: ServiceExist( [servicio], [Fast|Slow] )
;Test (Fast vs Slow): MsgBox % "Fast: " _fspdtestex(999, "ServiceExist", "Spooler") "`nSlow: " _fspdtestex(999, "ServiceExist", "Spooler", "S")
ServiceExist(lpDisplayName, Mode := "Fast") {
	if (Mode="F"||Mode="Fast") ;Fast: comprueba si existe desde el registro. (recomendado)
		return i:=RegExist("HKLM\SYSTEM\CurrentControlSet\Services\" lpDisplayName)
	if (Mode="S"||Mode="Slow") ;Slow: abre y cierra el servicio para comprobar si existe. (mas lento)
		return i:=DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", ServiceOpen(lpDisplayName)), ErrorLevel:=!i
	return 0, ErrorLevel := 1
}

;abre un servicio para modificar/leer datos/configuracion
;Sintaxis: ServiceOpen( [servicio], [acceso para SCManager], [acceso para el servicio], [SCManager (salida)] )
ServiceOpen(lpDisplayName, SCManagerAccess := 0xF003F, ServiceAccess := 0xF01FF, ByRef hSCManager := "") {
	hSCManager := DllCall("AdvApi32.dll\OpenSCManagerW", "Ptr", 0, "Ptr", 0, "UInt", SCManagerAccess) 
	DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Str", lpDisplayName, "Ptr", 0, "UIntP", lpcchBuffer)
	VarSetCapacity(lpServiceName, lpcchBuffer * 2)
	lpServiceName := DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Str", lpDisplayName, "Str", lpServiceName, "UIntP", lpcchBuffer) ? lpServiceName : lpDisplayName
	return i := DllCall("Advapi32.dll\OpenServiceW", "Ptr", hSCManager, "Str", lpServiceName, "UInt", ServiceAccess)
		, x:=IsByRef(hSCManager)?"":DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hSCManager)
		, ErrorLevel := !i
}




























































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: UNIDADES ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;expulsar/retraer unidad de CD/DVD/USB
;Sintaxis: DriveEject( [unidad], [¿cerrar?] )
;NOTA: el script no avanza hasta que la unidad se cierre
DriveEject(IpDrive, Close := 0) { 
	IpDrive := StrLeft( Trim(IpDrive) ) ":"
	IpType := DriveGetType( IpDrive )
	if (IpType = "CDROM") {
		Drive, Eject, %IpDrive%, %Close%
		return !ErrorLevel
	} ;By SKAN: http://ahkscript.org/boards/viewtopic.php?f=6&t=4491
	hDrive := DllCall("Kernel32.dll\CreateFileW", "Str", "\\?\" IpDrive, "UInt", 0, "UInt", 0, "UInt", 0, "UInt", 3, "UInt", 0, "Ptr", 0)
	nOutBufferSize := VarSetcapacity( STORAGE_DEVICE_NUMBER, 8 + A_PtrSize, 0 )
	IpR := DllCall("Kernel32.dll\DeviceIoControl", "Ptr", hDrive, "UInt", 0x2D1080, "Ptr", 0, "UInt", 0, "Ptr", &STORAGE_DEVICE_NUMBER, "UInt", nOutBufferSize, "UIntP", 0, "Ptr", 0 )  
	DllCall("Kernel32.dll\CloseHandle", "Ptr", hDrive)
	IpType := NumGet(STORAGE_DEVICE_NUMBER, "UInt")
	If (IpType = 0x00000007) OR (IpType = 7)
		sPHDRV := "\\\\.\\PHYSICALDRIVE" NumGet(STORAGE_DEVICE_NUMBER, 4, "UInt")
	queryEnum := ComObjGet("winmgmts:").ExecQuery("Select * from Win32_DiskDrive WHERE DeviceID='" sPHDRV "' AND InterfaceType='USB'" )._NewEnum()
	If !queryEnum[ DRV ]
		return 0, ErrorLevel := 1
	nDID := 0, nVT := 1
	DllCall("CfgMgr32.dll\CM_Locate_DevNodeW", "PtrP", nDID, "Str", DRV.PNPDeviceID, "UInt", 0)
	DllCall("CfgMgr32.dll\CM_Get_Parent", "PtrP", nDID, "UInt", nDID, "UInt", 0)
	ulNameLength := VarSetCapacity( VAR, 520, 0 ) / 2
	while % ( nDID and nVT and A_Index < 4 ) 
		DllCall("CfgMgr32.dll\CM_Request_Device_EjectW", "UInt", nDID, "PtrP", nVT, "Str", VAR, "UInt", ulNameLength, "UInt", 0 )
	return nVT ? (ErrorLevel := 1) - 1 : (ErrorLevel := 0) + 1
}

;obtener tipo de unidad: ERROR, Unknown, Removable, Fixed, Network, CDROM, RAMDisk
;Sintaxis: DriveGetType( [Unidad] )
;ErrorLevel: 0(sin errores) | 1(error) | 2(la unidad no existe)
DriveGetType(IpDrive) {
	static T0 := "Unknown", T1 := "ERROR", T2 := "Removable", T3 := "Fixed", T4 := "Network", T5 := "CDROM", T6 := "RAMDisk"
	IpDrive := StrLeft( Trim(IpDrive) ) ":"
	IpType := DllCall("Kernel32.dll\GetDriveTypeW", "Str", IpDrive)
	return T%IpType% ? T%IpType% : IpType, ErrorLevel := T%IpType% = "ERROR" ? 2 : T%IpType% ? 0 : 1
}

;cambiar etiqueta de la unidad
DriveSetLabel(IpDrive, lpVolumeName := "") {
	IpDrive := StrLeft( Trim(IpDrive) ) ":\"
	return DllCall("Kernel32.dll\SetVolumeLabelW", "Str", IpDrive, "Str", lpVolumeName)
}

;establece un nombre + icono para la unidad en el registro
;Sintaxis: DriveRegSet( [unidad], [nombre], [icono] )
;NOTAS: 
	;los cambios solo se ven afectados por el SO actual
	;para quitar el icono/nombre poner -1
DriveRegSet(IpDrive, Label := "", Icon := "") {
	IpDrive := StrLeft( Trim(IpDrive) ), ok := 0
	if (Icon = -1) ;quitar icono: -1
		ok += RegDelete( "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultIcon" )
	else if (Icon != "") ;establecer icono si no es [vacio]
		ok += RegWrite(, "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultIcon",, Icon )
	if (Label = -1) ;quitar nombre: -1
		ok += RegDelete( "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultLabel" )
	else if (Label != "") ;establecer nombre si no es [vacio]
		ok += RegWrite(, "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultLabel",, Label)
	return ok
}

;obtener informacion de la unidad: Nombre, Sistema de archivos y Número de serie
;Sintaxis: DriveGetInfo( [Unidad], [Nombre (out)], [sistema de archivos (out)], [número de serie (out)] )
;Ejemplo: MsgBox % DriveGetInfo( "C:\" ).Label
;NOTAS: 
	;el número de serie es el signado por el sistema cuando se le dá formato a la unidad; no por el fabricante.
	;si el nombre es [vacio], se intenta obtener desde el registro 'DriveIcons\[unidad]\DefaultLabel'
DriveGetInfo(IpDrive, ByRef lpVolumeNameBuffer := "", ByRef lpFileSystemNameBuffer := "", ByRef lpVolumeSerialNumber := "") {
	IpDrive := StrLeft( Trim(IpDrive) ) ":\", i := {}
	nVolumeNameSize := VarSetCapacity( lpVolumeNameBuffer, 261 * 2, 0 ) / 2 ;label
	nFileSystemNameSize := (VarSetCapacity( lpFileSystemNameBuffer, 60 * 2, 0 ) + 200 + 1) / 2 ;filesystem
	lpMaximumComponentLength := (VarSetCapacity( lpVolumeSerialNumber, 60 * 2, 0 ) - 60) / 2 ;serial
	DriveIcons := "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" StrLeft( IpDrive ) "\DefaultLabel"
	hR := DllCall("Kernel32.dll\GetVolumeInformationW", "Str", IpDrive, "Str", lpVolumeNameBuffer, "UInt", nVolumeNameSize ;Label
	, "Ptr", &lpVolumeSerialNumber, "Ptr", lpMaximumComponentLength ;SerialNumber
	, "Ptr", 0, "Str", lpFileSystemNameBuffer, "UInt", nFileSystemNameSize) ;FileSystem
	i.Label := i.L := lpVolumeNameBuffer != "" ? lpVolumeNameBuffer : RegRead( DriveIcons ) ;nombre de la unidad
	i.FileSystem := i.FS := lpFileSystemNameBuffer ;tipo del sistema de archivos
	i.SerialNumber := i.SN := NumGet( lpVolumeSerialNumber, 0, "UIntP" ) ;número de serie
	return i
		, lpVolumeSerialNumber := i.SerialNumber ;serial
		, lpVolumeNameBuffer := i.Label ;label
		, ErrorLevel := !hR
}

;recupera la cantidad de espacio libre en Bytes (por defecto)
;Sintaxis: DriveSpaceFree( [unidad], [KB|MB|GB] )
DriveSpaceFree(IpDrive, Units := 0) {
	static uKB := uK := 1024, uMB := uM := 1024**2, uGB := uG := 1024**3
	IpDrive := StrLeft( Trim(IpDrive) ) ":\"
	VarSetCapacity( lpFreeBytesAvailable, 8 * 2, 0)
	hR := DllCall("Kernel32.dll\GetDiskFreeSpaceExW", "Str", IpDrive, "UInt64", &lpFreeBytesAvailable, "UInt64", 0, "UInt64", 0)
	lpFreeBytesAvailable := u%Units% ? NumGet(lpFreeBytesAvailable, 0, "UInt64") / u%Units% : NumGet(lpFreeBytesAvailable, 0, "UInt64")
	return lpFreeBytesAvailable, ErrorLevel := !hR
}
















































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: MONITOR ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
PixelGetColor(x := "", y := "", AltSlowRGB := 0) {
	if (x="")||(y="")
		MouseGetPos( x_, y_ )
	PixelGetColor, OutputVar, % x=""?x_:x, % y=""?y_:y, %AltSlowRGB%
	return OutputVar
}

;obtiene/establece el gama del monitor
;Sintaxis: MonitorGamma( [1~255 N125] )
MonitorGamma(dwNewGamma := "") {
	hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
	if (dwNewGamma="") {
		VarSetCapacity(lpRamp, 1536, 0)
		i := DllCall("Gdi32.dll\GetDeviceGammaRamp", "Ptr", hDC, "Ptr", &lpRamp)
		return NumGet(lpRamp, 2, "UShort") - 128
			, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), ErrorLevel := !i
	}
	Loop, % (VarSetCapacity(GB, 1536) / 6)
		NumPut((i:=((dwNewGamma+128)*(A_Index-1)))>65535?65535:i, GB, 2*(A_Index-1), "UShort") 
	DllCall("RtlMoveMemory", "Ptr", &GB +  512, "Ptr", &GB, "Ptr", 512)
	DllCall("RtlMoveMemory", "Ptr", &GB + 1024, "Ptr", &GB, "Ptr", 512)
	return i := DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC, "Ptr", &GB)
		, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), ErrorLevel := !i
}

;obtiene informacion de un monitor
;Sintaxis: MonitorInfo( [monitor], [número], [nombre] ]
MonitorInfo(hMonitor := 0, MonitorNumber := 0, MonitorName := 0) {
	if !hMonitor&&(MonitorNumber||MonitorName) {
		for hMonitor, Monitor in MonitorEnum() {
			if MonitorNumber&&(Monitor.Num!=MonitorNumber)
				continue
			if MonitorName&&(Monitor.Name!=MonitorName)
				continue ;i := [],i[hMonitor]:=Monitor, return i
			Monitor["HMON"] := hMonitor
			return Monitor, ErrorLevel := !Monitor
		}
		return 0, ErrorLevel := 1
	}
	cbSize := VarSetCapacity(MONITORINFOEX, 52 * 2, 0)
	NumPut( cbSize, MONITORINFOEX, 0, "UInt")
	DllCall("User32.dll\GetMonitorInfoW", "Ptr", hMonitor, "Ptr", &MONITORINFOEX)
		MonName := StrGet(&MONITORINFOEX + 40, 32)
		MonNum := RegExReplace(MonName, ".*(\d+)$", "$1")
		return {Name: (Name := StrGet(&MONITORINFOEX + 40, 32))
			, Num: RegExReplace(Name, ".*(\d+)$", "$1")
			, Left: NumGet(MONITORINFOEX, 4, "Int")
			, Top: NumGet(MONITORINFOEX, 8, "Int") 
			, Right: NumGet(MONITORINFOEX, 12, "Int") 
			, Bottom: NumGet(MONITORINFOEX, 16, "Int") 
			, WALeft: NumGet(MONITORINFOEX, 20, "Int") 
            , WATop: NumGet(MONITORINFOEX, 24, "Int") 
            , WARight: NumGet(MONITORINFOEX, 28, "Int") 
            , WABottom: NumGet(MONITORINFOEX, 32, "Int") 
            , Primary: NumGet(MONITORINFOEX, 36, "UInt")}
}

;obtiene una lista de monitores e informacion
;EJEMPLO:
	;Gui, Add, ListView, w660 r10 Grid, HMON|Num|Name|Primary|Left|Top|Right|Bottom|WALeft|WATop|WARight|WABottom
	;for HMON, M In MonitorEnum()
	;   LV_Add(, HMON, M.Num, M.Name, M.Primary, M.Left, M.Top, M.Right, M.Bottom, M.WALeft, M.WATop, M.WARight, M.WABottom)
	;Loop, % LV_GetCount("Column")
	;   LV_ModifyCol(A_Index, "AutoHdr")
	;Gui, Show
MonitorEnum(hMonitor := "") {
	static MonitorEnumProc := RegisterCallback("MonitorEnumProc", "Fast", 4)
	static Monitors := {}
	if !hMonitor&&(Monitors:={}) {
		i := DllCall("User32.dll\EnumDisplayMonitors", "Ptr", 0, "Ptr", 0, "Ptr", MonitorEnumProc, "Ptr", &Monitors)
		return Monitors, ErrorLevel := !i
	}
	return Monitors[hMonitor], ErrorLevel := !Monitors.HasKey(hMonitor)
}
MonitorEnumProc(HMON, HDC, PRECT, ObjectAddr) {
	Monitors := Object(ObjectAddr)
	Monitors[HMON] := MonitorInfo(HMON)
	return true
}

;Monitor: cambia el brillo, contraste y gama
;Sintaxis: MonSet( [brillo], [contraste], [gama] )
MonSet(dwNewBrightness := "", dwNewContrast := "", dwNewGamma := "") {
	;gama
	if (dwNewGamma != "") {
		hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
		Loop, % (VarSetCapacity(GB, 1536) / 6) {
			Number := (dwNewGamma + 128) * (A_Index - 1)
			Number := Number > 65535 ? 65535 : Number
			OffSet := 2 * (A_Index - 1)
			NumPut( Number, GB, OffSet, "UShort") 
		}
		DllCall("RtlMoveMemory", "Ptr", &GB +  512, "Ptr", &GB, "Ptr", 512)
		DllCall("RtlMoveMemory", "Ptr", &GB + 1024, "Ptr", &GB, "Ptr", 512)
		DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC, "Ptr", &GB)
		DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	}
	;brillo y contraste
	if (dwNewBrightness != "") OR (dwNewContrast != "") {
		hMonitor := DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", 0x00000002)
		DllCall("Dxva2.dll\GetNumberOfPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UIntP", pdwNumberOfPhysicalMonitors)
		VarSetCapacity(PHYSICAL_MONITOR, (A_PtrSize + 256) * pdwNumberOfPhysicalMonitors, 0)
		DllCall("Dxva2.dll\GetPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
		hPhysicalMonitor := NumGet(PHYSICAL_MONITOR, 0, "UPtr")
		if (dwNewBrightness != "")
			DllCall("Dxva2.dll\SetMonitorBrightness", "Ptr", hPhysicalMonitor, "UInt", dwNewBrightness)
		if (dwNewContrast != "")
			DllCall("Dxva2.dll\SetMonitorContrast", "Ptr", hPhysicalMonitor, "UInt", dwNewContrast)
		DllCall("Dxva2.dll\DestroyPhysicalMonitors", "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
	}
}

;Monitor: obtener el brillo, contraste y gama
;Sintaxis: MonGet( [brillo (out)], [contraste (out)], [gama (out)] )
MonGet(ByRef pdwCurrentBrightness := "", ByRef pdwCurrentContrast := "", ByRef pdwCurrentGamma := "") {
	i := {}
	;gama
	if IsByRef( pdwCurrentGamma ) {
		hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
		VarSetCapacity(lpRamp, 1536, 0)
		DllCall("Gdi32.dll\GetDeviceGammaRamp", "Ptr", hDC, "Ptr", &lpRamp)
		i.CurrentGamma := pdwCurrentGamma := NumGet(lpRamp, 2, "UShort") - 128
		DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	}
	;brillo y contraste
	if IsByref( pdwCurrentBrightness ) OR IsByref( pdwCurrentContrast ) {
		hMonitor := DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", 0x00000002)
		DllCall("Dxva2.dll\GetNumberOfPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UIntP", pdwNumberOfPhysicalMonitors)
		VarSetCapacity(PHYSICAL_MONITOR, (A_PtrSize + 256) * pdwNumberOfPhysicalMonitors, 0)
		DllCall("Dxva2.dll\GetPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
		hPhysicalMonitor := NumGet(PHYSICAL_MONITOR, 0, "UPtr")
		if IsByref( pdwCurrentBrightness )
			DllCall("Dxva2.dll\GetMonitorBrightness", "Ptr", HPMON, "UIntP", pdwMinimumBrightness, "UIntP", pdwCurrentBrightness, "UIntP", pdwMaximumBrightness, "UInt")
		if IsByref( pdwCurrentContrast )
			DllCall("Dxva2.dll\GetMonitorContrast", "Ptr", HPMON, "UIntP", pdwMinimumContrast, "UIntP", pdwCurrentContrast, "UIntP", pdwMaximumContrast, "UInt")
		i.MinBrightness := pdwMinimumBrightness
		i.MaxBrightness := pdwMaximumBrightness
		i.CurrentBrightness := pdwCurrentBrightness
		i.MinContrast := pdwMinimumContrast
		i.MaxContrast := pdwMaximumContrast
		i.CurrentContrast := pdwCurrentContrast
		DllCall("Dxva2.dll\DestroyPhysicalMonitors", "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
	}
	return i
}

#Include <ImageButton_Class>
#Include <CtlColors_Class>
#Include <Gdip>
