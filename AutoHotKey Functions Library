/*
FUNCIONES  AUTOHOTKEY UNICODE 32 & 64 BITS.
-------------------------------------------------------------------------
SO: WIN_XP, WIN_V, WIN_7, WIN_8, WIN_8.1,  WIN_10
AHK/SO Arquitectura: 32-Bits / 64-Bits
SO BASE: MS Windows 10 Enterprise 32 bits (10.0, compilación 10586)
Funciones:
	• Archivos
	• Carpetas
	• Cadena
	• Criptografía
	• Procesos
	• Internet
	• Gui & Dialogos
	• Gui controles
	• Registro
	• Control
	• Mouse & Teclado
	• Sistema y Configuración
	• Ventanas
	• Servicios
	• Unidades
	• Sonido
	• Monitor
	• Números & Operaciones Matemáticas
	• Menús
	• Ejecutar
	• Barra de tareas
	• Device Context
	• Escritorio & Explorador & Menu Inicio & Papelera De Reciclaje
	• Estructuras
	• Notificaciones
	• Fuentes & Colores & Recursos & DLL
	• Nombres y Rutas de Archivos
	• Objetos
	• Tareas programadas
	• Administración de memoria
	• Gdiplus (GDI+)
	• Portapapeles
	• Administración de Energía
	• Pipe
	• Usuarios
	• Autorización y Seguridad
	• Dispositivos y Aplicaciones Predeterminadas
	• Otros (funciones variadas)
Clases (evitar sobreescribirlas, como por ejemplo, usandolas como simples variables, IVirtualDesktopManager:=1):
	• IVirtualDesktopManager
	• __gsvalue
Link (reporta problemas o sugerencias para nuevas funciones): http://ahkscript.org/boards/viewtopic.php?f=42&t=5535
AutoHotKey: 1.1.21.01+
Actualizado: AHK1.1.22.09 U32 & U64 || Domingo, 10 de enero de 2016
Historial De Cambios: https://github.com/flipeador/AutoHotKey/blob/master/AutoHotKey%20Functions%20Library%20~%20Change%20Log
Notas:
	• si utiliza MUCHO las funciones que utilizan Gdip, iniciarlo antes usando GdiplusStartup().
	• ver INCLUDE al final para links a funciones y clases necesarias.
	• algunas funciones no soportan todos los SO espesificados arriba, esto es indicado en la funcion, Ej: WIN_V+
	• para obtener la descripción de A_LastError, usar GetLastError(description_out).
	• algunas funciones posiblemente no funcionen correctamente en la version de 64-Bits de AHK, reportar problemas.
Codificación: UTF-8 BOM
Windows System Error Codes (exit codes) Description: http://www.symantec.com/connect/articles/windows-system-error-codes-exit-codes-description
Windows Data Types For AHK: https://github.com/flipeador/AutoHotKey/blob/master/Windows%20Data%20Types%20for%20AHK
*/ ;flipeador@gmail.com ################################################################################################
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
; ::::::::::::::::::::::::::::::::::::::::::::: FUNCIONES APARTE (para uso interno) ::::::::::::::::::::::::::::::::::																							   #
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
_mnum(f,s,r:=true){
	return i:=(_:=StrLeft(s:=Trim(s)))!="-"&&_!="+"&&_!="^"?(r?s:(f&s?f:f+s))
	: ((s:=StrTrimLeft(s))?(_="-"?(f&s?f-s:f):_="^"?(f&s?f-s:f+s):(f&s?f:f+s)):f)
	, ErrorLevel := i=f||!f||!s
}_cstr(a,z,m,i){
	_:=i="+"||i="-"||i="|"?0:""
	for k, v in a
		x:=(m="&"?z&v:m="="?z=v:m="~"?InStr(z, k):0)?(m="~"?v:k):(i="-"?0:i="+"?0:i="|"?0:"")
		, x:=i="."?(_.=x):i="|"?(_|=x):i="-"?(_-=x):i="+"?(_+=x):""
	return _, ErrorLevel := _=""
}_cpath(p, ByRef c:=""){
	return c:=(StrLen(i:=GetFullPathName(p))=2?i "\":i)
}_getpid(h,z*){
	if z.MaxIndex() {
		p:=z[1],x:=z[2],i:=z[3]
		if (p) && (InStr(p,"."))
			WinGetPID(h?h:x,, i)
		else if (p)
			i := WinGetPID(h?h:x)
		return i
	} return __gsvalue.LastProcessId := ((InStr(h,".")||h=-1||h=-2)?ProcessExist(h):h=-3?__gsvalue.LastProcessId:h)
}_gethwnd(ByRef h,ByRef c:=""){
	if IsByRef(h)
		__gsvalue.LastWindowId:=h:=(h=-1?IsWindow():h=-2?MouseGetPos(,, true)[3]:h=-3?__gsvalue.LastWindowId:h)
	if IsByRef(c)
		__gsvalue.LastControlId:=c:=(c=-1?ControlExist(h,ControlGetFocus(h)):c=-2?MouseGetPos(,,, true,2)[4]:c=-3?__gsvalue.LastControlId:ControlExist(h,c))
}_vas(obj,ByRef txt){
	for k,v in obj
		if (v=txt)
			return false
	return true
}_variant(ByRef var,type:=0,val:=0){
	return (VarSetCapacity(var,8+2*A_PtrSize)+NumPut(type,var,0,"short")+NumPut(val,var,8,"ptr"))*0+&var
}_vt(p,n){
	return NumGet(NumGet(p+0,"ptr")+n*A_PtrSize,"ptr")
}
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;####################################################################################################################
































;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------  ------------   FUNCIONES	-------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->

;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ARCHIVOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;--------------------------------------------------------------------------------------------------------------------------------------------------
;General
;--------------------------------------------------------------------------------------------------------------------------------------------------
;copiar archivo(s)
;Sintaxis 1: FileCopy( [archivo], [destino\nombre.ext], [¿sobreescribir?] )
;Sintaxis 2: FileCopy( [directorio\*.*], [destino], [¿sobreescribir?])
FileCopy(Source, Dest := "", Overwrite := false) {
	FileCopy, %Source%, %Dest%, %Overwrite%
	return !ErrorLevel
}

;copiar archivo, opcional llamar a una funcion con información mientras se copia
;Sintaxis: FileCopyEx( [archivo], [archivo destino], [¿sobreescribir?], [funcion], [opciones] )
;Parámetros:
	;Archivo Destino: espesificar el archivo destino, si espesifica un valor vacío, se crea en el directorio de trabajo actual.
		;Nota: el directorio de trabajo actual puede ser cambiado con «SetWorkingDir, [path]» y recuperado con «A_WorkingDir»
	;Función: espesificar una funcion a la cual llamar mientras se copia
		;Parámetros que recibe la función:
			;TotalBytes = tamaño total del archivo a copiar, en bytes
			;BytesWritten = bytes totales actualmente escritos
			;Percent = indica el porcentaje completado, un número entre 1.00~100 inclusive
		;Notas:
			;la funcion es llamada cada 1MB copiado
			;si la funcion devuelve 0 (false), el copiado es cancelado
			;si la función devuelve 1 (true), el copiado es reanudado
			;si la funcion devuelve 2, la función no recibe mas mensajes (no es llamada)
			;si la función devuelve 3, la función es pausada hasta que devuelva 1
	;Opciones: espesificar un array.
		;Sintaxis: [NoCopyAttrib=0, NoCopyTime=0]
		;Array:
			;NoCopyAttrib = establecer en verdadero para no copiar los atributos
			;NoCopyTime = establecer en verdadero para no copiar la fecha MCA
		;Nota: solo se aplica si el archivo fué copiado correctamente (ErrorLevel=0)
;ErrorLevel:
	;0 = se han copiado todos los datos correctamente (los bytes escritos coinciden con los bytes originales del archivo fuente)
	;1 = el archivo no se ha terminado de copiar correctamente (el tamaño no coincide)
	;2 = el archivo destino ya existe y el tercer parámetro es falso
	;3 = operación cancelada
	;4 = error al abrir el archivo fuente o no se ha podido crear el archivo destino
;Ejemplo:
	;Result := FileCopyEx(A_SysDir() "\imageres.dll", A_Desktop "\~imageres.dll",, "InfoCopy")
	;Progress, Off
	;MsgBox % "Return: " Result "`nErrorLevel: " ErrorLevel
	;ExitApp
	;InfoCopy(TotalBytes, BytesWritten, Percent) {
	;	Progress, % Percent, %Percent%  `% Completado...`nBytes Totales: %TotalBytes%`nBytes Escritos: %BytesWritten%
	;	if GetKeyState("w") ;parar copiado precionando la "w"
	;		return 0
	;	Sleep 250 ;250ms de retraso por 1MB, quitar para ver el tiempo de copiado real.
	;}
FileCopyEx(Filename, Dest := "", OverWrite := false, Func := "", Flags := "") {
	SplitPath, Filename, ffn ;, dir, ext, fn, drive
	Dest := Dest=""?A_WorkingDir "\" ffn:GetFullPathName(Dest)
	if !(OverWrite) && (FileExist(Dest)) 
		return false, ErrorLevel := 2
	if !(IsObject(sf:=FileOpen(Filename, "r-wd"))) || !(IsObject(df:=FileOpen(Dest, "w-rwd", sf.Encoding)))
		return false, sf.Close(), ErrorLevel := 4
	RemainingBytes := Bytes := sf.Length, Count := Floor(Bytes/1000000), df.Length := Count?1000000:Bytes, TotalBytesWritten := 0
	Loop, % (Count?Count+1:1) {
		if (RemainingBytes>999999) { ;bytes a escribir >=1MB (1000000 bytes)
			VarSetCapacity(Data, 1000000), sf.RawRead(Data, 1000000) ;leer 1MB
			, TotalBytesWritten := TotalBytesWritten+df.RawWrite(Data, 1000000) ;escribir 1MB
		} else { ;bytes a escribir <1MB
			VarSetCapacity(Data, RemainingBytes), sf.RawRead(Data, RemainingBytes) ;leer bytes restantes
			, TotalBytesWritten := TotalBytesWritten+df.RawWrite(Data, RemainingBytes) ;escribir bytes restantes
			, VarSetCapacity(Data, 0)
			if !(Count) && (IsFunc(Func)) && (%Func%(Bytes, TotalBytesWritten, 100)=0)
				return TotalBytesWritten=Bytes, sf.Close(), df.Close(), ErrorLevel := 3
			break
		} RemainingBytes := RemainingBytes-1000000, VarSetCapacity(Data, 0), df.Length := TotalBytesWritten
		if (IsFunc(Func)) {
			Percent(10000, TotalBytesWritten / Bytes, Percent)
			if ((fReturn:=%Func%(Bytes, TotalBytesWritten, RemainingBytes>999999?Percent:100))=false) {
				return false, sf.Close(), df.Close(), ErrorLevel := 3
			} else if (fReturn=2) {
				Func := ""
			} else if (fReturn=3) {
				while !(%Func%(Bytes, TotalBytesWritten, RemainingBytes>999999?Percent:100)=1)
					Sleep, 1000
	}}} sf.Close(), df.Close()
	if (Ok:=(TotalBytesWritten=Bytes)) {
		if !(Flags[1]) ;CopyAttrib
			FileSetAttrib("+" FileGetAttrib(Filename), Dest)
		if !(Flags[2]) ;CopyTime
			FileSetTime(FileGetTime(Filename, "MCA"), Dest)
	} return Ok, ErrorLevel := !Ok
}

;reciclar
;Sintaxis: FileRecycle( [archivo] )
FileRecycle(Filename) {
	FileRecycle, %Filename%
	return !ErrorLevel
}

;eliminar archivo(s)
;Sintaxis: FileDelete( [archivo], [¿operar en subcarpetas?] )
;ErrorLevel: array que contiene los archivos que no se puedieron eliminar (0 si se eliminaron todos).
;Return: array que contiene los archivos eliminados (0 si no se eliminó ninguno).
FileDelete(Filename, Recurse := false) {
	if  !(Recurse) && !(InStr(Filename, "*")) && !(InStr(Filename, "?")) {
		Filename := GetFullPathName(Filename)
		if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" Filename)) {
			FileSetAttrib, -R, %Filename%
			if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" Filename))
				return false, ErrorLevel := [Filename]
		} return [Filename], ErrorLevel := false
	} Result := [], Error := []
	Loop, Files, %Filename%, % (Recurse?"FR":"F")
	{	 if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" A_LoopFileFullPath)) {
			FileSetAttrib, -R, %A_LoopFileFullPath%
			if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" A_LoopFileFullPath))
				Error.Push(A_LoopFileFullPath)
			else Result.Push(A_LoopFileFullPath)
		} else Result.Push(A_LoopFileFullPath)
	} return (Result.MaxIndex()?Result:false), ErrorLevel := (Error.MaxIndex()?Error:false)
}

;eliminar archivo al reiniciar
FileRDelete(Filename) {
	Filename := GetFullPathName(Filename)
	return r:=DllCall("Kernel32.dll\MoveFileExW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0x4), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365240%28v=vs.85%29.aspx

;eliminar archivo de forma segura
;Sintaxis: FileSecureDelete( [archivo], [pasadas] )
FileSecureDelete(Filename, Passes := 1) {
	static v := 100000000
	if !(IsObject(obj:=FileOpen(Filename, "rw-rwd"))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "rw-rwd")))
			return false, ErrorLevel := true
	} Bytes := (((Length:=obj.Length)<v)?Length:v), Bytes2 := Mod(Length, v), c := Floor(Length / v)
	Loop, % (Passes) {
		VarSetCapacity(Buffer, Bytes, A_Index)
		Loop, % (c)
			obj.RawWrite(Buffer, Bytes)
		VarSetCapacity(Buffer, Bytes2, A_index), obj.RawWrite(Buffer, Bytes2)
	} obj.Close(), VarSetCapacity(Buffer, 0)
	return FileDelete(Filename)
}

;mover archivo
;Sintaxis: FileMove( [archivo], [destino], [sobreescribir] )
FileMove(FileName, Dest, OverWrite := false) {
	FileMove, %FileName%, %Dest%, %OverWrite%
	return !ErrorLevel
}

;renombrar archivo
;Sintaxis: FileRename( [archivo], [nuevo nombre], [¿sobreescribir?] )
FileRename(FileName, NewName, OverWrite := false) {
	SplitPath, FileName,, DirName
	if !(OverWrite) && (FileExist(DirName "\" NewName))
		return false, ErrorLevel := 2
	FileMove, %FileName%, %DirName%\%NewName%, % !!(OverWrite)
	return !ErrorLevel
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Diálogos
;--------------------------------------------------------------------------------------------------------------------------------------------------
;dialogo para seleccionar archivos
;Sintaxis: FileSelect( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
;Opciones:
	;M = permitir seleccionar varios archivos
		;Return: File1`nFile2`nFile3`nEtc
	;3 = el archivo debe existir
FileSelect(RootDirFilename := "", Filter := "", Options := 3, Prompt := "") {
	try FileSelectFile, OutputVar, %Options%, %RootDirFilename%, %Prompt%, %Filter%
	catch
		FileSelectFile, OutputVar, %Options%,, %Prompt%, %Filter%
	if (InStr(Options, "M")) {
		Loop, Parse, % OutputVar, `n, `r
			if (A_Index=1)
				Path := A_LoopField
			else Files .= Path "\" A_LoopField "`n"
		OutputVar := RTrim(StrReplace(Files, "\\", "\"), "`n")
	} return OutputVar
}

;dialogo para guardar archivo
;Sintaxis: FileSave( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
FileSave(RootDirFilename := "", Filter := "", Options := 24, Prompt := "") {
	try FileSelectFile, OutputVar, S%Options%, %RootDirFilename%, %Prompt%, %Filter%
	catch
		FileSelectFile, OutputVar, S%Options%,, %Prompt%, %Filter%
	return OutputVar
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Obtener
;--------------------------------------------------------------------------------------------------------------------------------------------------
;obtener fecha de creacion, modificacion y/o último acceso
FileGetTime(Filename, WhichTime := "M") {
	OutputVar := []
	Loop, Parse, % WhichTime
	{	FileGetTime, Time, %Filename%, %WhichTime%
		if !(Time="")
			OutputVar.Push(Time)
	} return OutputVar.MaxIndex()=1?OutputVar[1]:OutputVar
}

;obtener version 
;Sintaxis: FileGetVersion( [archivo] )
FileGetVersion(Filename) {
	FileGetVersion, OutputVar, %Filename%
	return OutputVar
}

;obtener tamaño del archivo, en bytes.
;Sintáxis: FileGetSize( [archivo], [KB|MB|GB], [decimales] )
FileGetSize(FileName, Units := "", Places := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	FileGetSize, FileSize, %FileName%
	FileSize := _[Units]?FileSize/_[Units]:FileSize
	return Places=""?FileSize:Round(FileSize, Places)
}

;obtener atributos de un archivo o carpeta
;Sintaxis: FileGetAttrib( [Archivo/Carpeta] )
;ATRIBUTOS: ver FileSetAttrib()
FileGetAttrib(lpFileName, ByRef hAttrib := "", ByRef _cpath := "") {
	static List := {"R": 0x1, "A": 0x20, "S": 0x4, "H": 0x2, "N": 0x80, "D": 0x10, "O": 0x1000, "C": 0x800, "T": 0x100, "E": 0x4000, "V": 0x10000}
	if ((hAttrib:=DllCall("Kernel32.dll\GetFileAttributesW", "Str", "\\?\" _cpath(lpFileName, _cpath)))=-1)
		return false, ErrorLevel := true
	return _cstr(List, hAttrib, "&", "."), ErrorLevel := false
}

;obtener informacion de un acceso directo
;Sintaxis: FileGetShortcut( [acceso directo], [comando], [directorio de trabajo], [parámetros], [descripcion], [icono], [índice], [modo de inicio] )
;Modo de inicio: 1 = normal | 2 = maximizado | 3 = minimizado
;Nota: si el archivo espesificado no es un acceso directo válido, devuelve el archivo espesificado.
FileGetShortcut(ShortcutFile, ByRef OutTarget := "", ByRef OutDir := "", ByRef OutArgs := "", ByRef OutDescription := "", ByRef OutIcon := "", ByRef OutIconNum := "", ByRef OutRunState := "") {
	FileGetShortcut, %ShortcutFile%, OutTarget, OutDir, OutArgs, OutDescription, OutIcon, OutIconNum, OutRunState
	return ErrorLevel?ShortcutFile:(OutTarget?OutTarget:ShortcutFile)
}

;obtiene informacion sobre un archivo
;Sintaxis: FileGetInfo( [archivo], [tipo de informacion] )
;EJEMPLOS:
	;MsgBox % FileGetInfo( comspec ).CompanyName
	;MsgBox % FileGetInfo( comspec, "FileDescription" )
FileGetInfo(FileName, InfoType := "") {
	static InfoList := ["Comments","InternalName","ProductName","CompanyName","LegalCopyright","ProductVersion"
		,"FileDescription","LegalTrademarks","PrivateBuild","FileVersion","OriginalFilename","SpecialBuild"]
	InfoSize := DllCall("Version.dll\GetFileVersionInfoSizeW", "Str", FileName, "Ptr", 0)
	if (ErrorLevel)
		InfoSize := DllCall("Version.dll\GetFileVersionInfoSizeExW", "UInt", 0x01, "Str", FileName, "Ptr", 0)
	VarSetCapacity(InfoData, InfoSize * 2, 0)
	, DllCall("Version.dll\GetFileVersionInfoW", "Str", FileName, "UInt", 0, "UInt", InfoSize, "Ptr", &InfoData)
	if (ErrorLevel)
		DllCall("Version.dll\GetFileVersionInfoExW", "UInt", 0x01, "Str", FileName, "UInt", 0, "UInt", InfoSize, "Ptr", &InfoData)
	DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\VarFileInfo\Translation", "PtrP", aInfoData, "PtrP", InfoSize+1)
	, Lang := NumGet(aInfoData+0, "UShort"), CodePage := NumGet(aInfoData+2, "UShort"), Lang_CodePage := Format("{:04X}{:04X}", Lang, CodePage)
	if InfoType {
		DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\StringFileInfo\" Lang_CodePage "\" InfoType, "PtrP", aInfoData, "PtrP", InfoSize)
		return StrGet(aInfoData, InfoSize)
	} FileInfo := {}
	for Index, InfoType in InfoList
		if DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\StringFileInfo\" Lang_CodePage "\" InfoType, "PtrP", aInfoData, "PtrP", InfoSize)
			FileInfo[InfoType] := StrGet(aInfoData, InfoSize)
	return FileInfo
} FileGetInfo2(Filename, ValidatePath := 0) {
	Filename := ValidatePath ? GetValidPathName(Filename) : Filename
	if !IsFile( Filename )
		return "", ErrorLevel := 1
	Filename := RegExReplace(Filename, "\\+", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Datafile WHERE Name = '" Filename "'")
		i.AccessMask := a.AccessMask, i.Archive := a.Archive, i.Caption := a.Caption, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod, i.CreationClassName := a.CreationClassName, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName, i.CSName := a.CSName, i.Description := a.Description, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName, i.Encrypted := a.Encrypted, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension, i.FileName := a.FileName, i.FileSize := a.FileSize, i.FileType := a.FileType, i.Writeable := a.Writeable
		, i.FSCreationClassName := a.FSCreationClassName, i.FSName := a.FSName, i.Hidden := a.Hidden, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount, i.LastAccessed := a.LastAccessed, i.LastModified := a.LastModified, i.ManuFacturer := a.Manufacturer
		, i.Name := a.Name, i.Path := a.Path, i.Readable := a.Readable, i.Status := a.Status, i.System := a.System, i.Version := a.Version
	return i, ErrorLevel := !i.Name
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Establecer
;--------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: FileSetTime( [fecha], [archivo], [M|C|A], [0(F)|1(FD)|2(D)], [0|1(R)] )
FileSetTime(Time := "", FilePattern := "", WhichTimeMCA := "M", OperateOnFolders := false, Recurse := false) {
	if IsObject(Time)
		for k, v in Time
			FileSetTime, %v%, %FilePattern%, % k=1?"M":k=2?"C":k=3?"A":k, %OperateOnFolders%, %Recurse%
	else Loop, Parse, % WhichTimeMCA
		FileSetTime, %Time%, %FilePattern%, %A_LoopField%, %OperateOnFolders%, %Recurse%
	return !ErrorLevel
}

;cambiar atributo(s) a carpetas y archivos.
;Sintaxis: FileSetAttrib( [+/- atributos], [archivo], [modo] )
;Modo: F = incluir archivos | D = incluir directorios | R = incluir subdirectorios.
;Nota: devuelve el número de archivos/carpetas modificadas
;Atributos (ejemplo: R-SH+A): 
	;R = solo lectura (modificable)
	;A = archivo | modificado (modificable)
	;S = sistema (modificable)
	;H = oculto (modificable)
	;N = normal (modificable, único)
	;D = directorio | carpeta
	;O = fuera de linea (modificable)
	;C = comprimido
	;T = temporal (modificable)
	;E = encriptado
	;V = virtual
;Ejemplo:
	;MsgBox % FileSetAttrib("+RS", A_Desktop "\file.txt")
	;MsgBox % FileSetAttrib("-R+H", A_Desktop "\file.txt")
	;MsgBox % FileSetAttrib("-HS", A_Desktop "\file.txt")
FileSetAttrib(Attributes, FilePattern, Mode := "FD", Recurse := "") {
	;static l := {R: 0x1, A: 0x20, S: 0x4, H: 0x2, N: 0x80, O: 0x1000, T: 0x100}
	;if (Recurse=0) || (Recurse=1) {
		FileSetAttrib, %Attributes%, %FilePattern%, % (InStr(Mode, "D")||Mode=1), % (Recurse||InStr(Mode, "R"))
		return !ErrorLevel
	;} if !(ok:=0) && !(_wildc(FilePattern, Recurse)) {
	;	FileGetAttrib(FilePattern, hAttrib, lpFileName)
	;	Loop, Parse, % Attributes,, %A_Space%%A_Tab%
	;		if (l[A_LoopField])
	;			hAttrib := _mnum(hAttrib, Mode l[A_LoopField], false)
	;		else Mode := A_LoopField="-"||A_LoopField="^"?A_LoopField:""
	;	return i := DllCall("Kernel32.dll\SetFileAttributesW", "Str",  "\\?\" lpFileName, "UInt", hAttrib), ErrorLevel := !i
	;} Loop, Files, %FilePattern%, %Mode%
	;	ok += FileSetAttrib(Attributes, A_LoopFileLongPath), i := A_Index
	;return ok, ErrorLevel := (ok!=i)
}

;crear acceso directo
;Sintaxis: FileCreateShortcut( [comando], [acceso directo], [parámetros], [descricpion], [icono], [tecla de acceso], [índice], [modo de inicio] )
;Modo de inicio: 1 = normal | 2 = maximizado | 3 = minimizado
;Nota: espesificar A_Tab ("	") en el 4to parametro (descripcion) para establecer la descripcion por defecto del archivo.
FileCreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := "", ShortcutKey := "", IconNumber := 1, RunState := 1) {
	Description := Description=A_Tab?FileGetInfo(Target, "FileDescription"):Description
	FileCreateShortcut, %Target%, %ShortcutFile%, %WorkingDir%, %Args%, %Description%, %IconFile%, %ShortcutKey%, %IconNumber%, %RunState%
	return !ErrorLevel
}

;establecer seguridad para el archivo/carpeta
;Sintaxis: FileSetSecurity( [archivo], [Usuario], [permisos], [opciones], [acceso] )
;Parámetros:
	;Archivo: espesificar el archivo o carpeta a modificar
	;Usuario: espesificar el SID del usuario que hereda los permisos o Dominio\Usuario. si no se espesifica usa el usuario actual
		;Nota: para obtener una lista de usuarios con información, usar UserAccountsEnum()
	;Permisos: espesificar el acceso deseado
		;0x1F01FF = CONTROL TOTAL (F)
		;0x120089 = LECTURA (R)
		;0x120116 = ESCRITURA (W)
		;0x1200a0 = EJECUCIÓN (X)
		;0x00010000 = ELIMINACIÓN (D)
		;0x1301BF = MODIFICACIÓN (M)
	;Opciones:
		;0 = directorios
		;1 = directorios y archivos
		;2 = directorios y sub-directorios
		;3 = directorios, sub-directorios y archivos
	;Acceso: https://msdn.microsoft.com/en-us/library/windows/desktop/aa772244(v=vs.85).aspx
		;0 = permitir
		;1 = denegar
;Notas:
	;los permisos se pueden ver haciendo clic en propiedades del archivo, pestaña seguridad.
	;los permisos pueden ser cambiados con ICACLS en CMD: icacls [archivo] /grant *[usuario]:([permisos, letra],WDAC)
	;la función establece el propietario, ya que se requiere para cambiar los permisos
	;el proceso invocador debe tener permisos de administrador para modificar los permisos
;Ejemplo:
	;MsgBox % "Tomar Posesión: " FileSetOwner(A_SysDir() "\calc.exe") ;primero tomar posesión
	;MsgBox % "Control Total: " FileSetSecurity(A_SysDir() "\calc.exe") ;segundo modificar los permisos
;Return: 0|1
;ErrorLevel: 0|1
FileSetSecurity(Path, Trustee := "", AccessMask := 0x1F01FF, Flags := 1, AccesFlag := 0) { ;WIN_V+
	Trustee := Trustee=""?A_UserNameEx():Trustee, Path := GetFullPathName(Path)
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Path, 1, 1)
	, Owner := oADsSecurityDescriptor.Owner
	if !(Trustee=Owner) && !(Owner="") && !(Trustee="")
		FileSetOwner(Path, Trustee)
	oDiscretionaryAcl := oADsSecurityDescriptor.DiscretionaryAcl
	, oAccessControlEntry := ComObjCreate("AccessControlEntry")
	, oAccessControlEntry.Trustee := Trustee
	, oAccessControlEntry.AccessMask := AccessMask
	, oAccessControlEntry.AceFlags := Flags
	, oAccessControlEntry.AceType := AccesFlag
	, oDiscretionaryAcl.AddAce(oAccessControlEntry)
	, oADsSecurityUtility.SetSecurityDescriptor(Path, 1, oADsSecurityDescriptor, 1)
}

;establecer el propietario
;Sintaxis: FileSetOwner( [archivo], [usuario] )
;Parámetros:
	;Usuario: espesificar el dominio\usuario o el SID del usuario. por defecto usa el usuario actual.
FileSetOwner(Path, Owner := "") {
	Owner := Owner=""?A_UserNameEx():Owner
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Path:=GetFullPathName(Path), 1, 1)
	, oADsSecurityDescriptor.Owner := Owner
	, oADsSecurityUtility.SetSecurityDescriptor(Path, 1, oADsSecurityDescriptor, 1)
}

;obtiene el dominio y nombre de usuario propietario
;Sintaxis: FileGetOwner( [archivo] )
;Return: dominio\usuario
FileGetOwner(Path) { ;WIN_V+
	oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(GetFullPathName(Path), 1, 1)
	return oADsSecurityDescriptor.Owner
}

;permite que un administrador recupere el acceso a un archivo que anteriormente le era denegado, convirtiendo al administrador en el propietario del archivo.
;Sintaxis: FileTakeOwn( [archivo], [¿Recurse?], [AdminGroup] )
;Parámetros:
	;Archivo: espesificar el archivo o carpeta a la cual tomar posesión. puede usar el comodín «*»
	;Recurse: 0|1. indica si se debe operar en sub-directorios.
	;AdminGroup: concede la posesión al grupo de administradores en vez del usuario actual
;Notas:
	;esta función establece el propietario del archivo espesificado al usuario actual o al grupo de administradores
	;esta información se puede ver y cambiar en las propiedades del archivo, seguridad, opciones avanzadas.
	;el proceso invocador debe tener permisos de administrador para modificar el propietario
;Return: 0|1
;ErrorLevel: 0|1
FileTakeOwn(File, Recurse := false, AdminGroup := false) { ;WIN_V+
	File := GetFullPathName(File)
	CMD("takeown.exe /F " Chr(34) File Chr(34) (AdminGroup?" /A":"") (Recurse?" /R":""))
	return !ErrorLevel
} ;https://technet.microsoft.com/es-es/library/cc753024(v=ws.10).aspx

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Escribir
;--------------------------------------------------------------------------------------------------------------------------------------------------
;escribir en un archivo (añadir)
;Sintáxis: FileAppend( [Texto], [*Archivo], [codificación] )
FileAppend(Text, Filename, Encoding := "") {
	FileAppend, %Text%, %Filename%, %Encoding%
	if (ErrorLevel) {
		FileSetAttrib, -R, %Filename%
		FileAppend, %Text%, %Filename%, %Encoding%
	} return !ErrorLevel
}

;añadir texto a una linea espesífica.
;Sintáxis: FileAppendLine( [Texto], [Archivo], [Número de linea], [codificación], [L (añadir a la izquierda)] )
FileAppendLine(Text, Filename, LineNum, Encoding := "", Pos := "") {
	if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding)))
			return false, ErrorLevel := true
	} _ := obj.Read(), Lines := StrSplit(_, "`n", "`r").MaxIndex()
	if ((Lines?Lines:0)<LineNum) {
		Loop, % (LineNum-(Lines?Lines:0))
			_ .= "`n"
	} Loop, Parse, % _, `n, `r
		NewText .= (A_Index=1?"":"`n") (Pos="L"?"":A_LoopField) (A_Index=LineNum?Text:"") (Pos="L"?A_LoopField:"")
	obj.Length := StrLen(NewText), obj.Seek(0)
	return (bytes:=obj.Write(NewText)), ErrorLevel := !(bytes)
}

;escribir en un archivo (mismo efecto que eliminar el archivo y volver a crearlo).
;Sintáxis: FileWrite( [Texto], [Archivo], [codificación] )
;Return: 0(ERROR) | [archivo](OK)
FileWrite(Text, Filename, Encoding := "") {
	if !(IsObject(obj:=FileOpen(Filename, "w`n-rwd", Encoding))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "w`n-rwd", Encoding)))
			return false, ErrorLevel := true
	} obj.Length := StrLen(Text), Bytes := obj.Write(Text)
	return Filename, ErrorLevel := obj.Length!=Bytes
}

;escribir en una linea espesifica (reemplazar linea entera).
;Sintáxis: FileWriteLine( [Texto], [Archivo], [Número de linea], [codificación], [¿eliminar linea?] )
FileWriteLine(Text, Filename, LineNum, Encoding := "", DeleteLine := false) {
	if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding)))
			return false, ErrorLevel := true
	} _ := obj.Read(), Lines := StrSplit(_, "`n", "`r").MaxIndex()
	if ((Lines?Lines:0)<LineNum) {
		Loop, % (LineNum-(Lines?Lines:0))
			_ .= "`n"
	} Loop, Parse, % _, `n, `r
		NewText .= (DeleteLine&&(A_Index=LineNum))?"":((A_Index=1?"":"`n") (A_Index=LineNum?Text:A_LoopField))
	obj.Length := StrLen(NewText), obj.Seek(0)
	return (bytes:=obj.Write(NewText)), ErrorLevel := !(bytes)
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Leer
;--------------------------------------------------------------------------------------------------------------------------------------------------
;leer archivo
;Sintáxis: FileRead( [Archivo], [codificación] )
FileRead(Filename) {
	try FileRead, OutputVar, %Filename%
	catch
		return OutputVar
	return OutputVar
}

;leer texto en la línea espesificada.
;Sintaxis: FileReadLine( [Archivo], [Linea] )
FileReadLine(FileName, LineNum, Encoding := "") {
	if !(IsObject(obj:=FileOpen(Filename, "r`n-wd", Encoding)))
		return false, ErrorLevel := true
	Loop, % (LineNum-1)
		obj.ReadLine()
	return obj.ReadLine(), ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Otros
;--------------------------------------------------------------------------------------------------------------------------------------------------
;comprueba si es archivo
;Sintaxis: IsFile( [archivo] )
IsFile(Filename, ByRef FullPathName := "") {
	if IsByRef(FullPathName)
		FullPathName := GetFullPathName(Filename)
	return (!InStr(i:=FileExist(Filename),"D")&&i)
}

;comparar dos versiones 
;Sintaxis: VersionCompare( [version1], [version2], [resultado] )
;Resultado: +(ver1 > ver2) | -(ver1 < ver2) | =(ver1 = ver2)
;Return: 0(Ver1 = Ver2) | 1(Ver1 > Ver2) | 2(Ver1 < Ver2)
VersionCompare(version1, version2, ByRef OutputVar := "") {
	if !(v2:=Trim(RegExReplace(version2, "[^0-9.]"), "."))
		return true, OutputVar := "+"
	if !(v1:=Trim(RegExReplace(version1, "[^0-9.]"), "."))
		return 2, OutputVar := "-"
	vA := StrSplit(v1, "."), vB := StrSplit(v2, ".")
	Loop, % (vA.MaxIndex()>vB.MaxIndex()?vA.MaxIndex():vB.MaxIndex()) {
		if (vA.MaxIndex()<A_Index)
			vA[A_Index] := 0
		if (vB.MaxIndex()<A_Index)
			vB[A_Index] := 0
		if (vA[A_Index]>vB[A_Index])
			return true, OutputVar := "+"
		if (vB[A_Index]>vA[A_Index])
			return 2, OutputVar := "-"
	} return false, OutputVar := "="
} FileVersionCompare(v1, v2) {
	return VersionCompare(v1, v2)
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=5959

;Comparar 2 archivos
;Sintaxis: FileCompare( [archivo 1], [archivo 2] )
;Return:
	;1 = archivo1 > archivo2
	;0 = archivo1 = archivo2
	;-1 = archivo1 < archivo2
;ErrorLevel: 0|1(return "")
;Nota: si los archivos tienen el mismo tamaño, ejecuta una comparación binaria
FileCompare(File1, File2) {
	if !IsObject(oF1:=FileOpen(File1, "r")) || !IsObject(oF2:=FileOpen(File2, "r"))
		return "", oF1.Close(), ErrorLevel := true
	if !(oF1.Length=oF2.Length)
		return oF1.Length>oF2.Length?1:-1, oF1.Close(), oF2.Close(), ErrorLevel := false
	oF1.RawRead(Source1, oF1.Length), oF2.RawRead(Source2, oF2.Length)
	return CompareMemory(Source1, Source2), oF1.Close(), oF2.Close()
}

;separa un nombre de archivo o URL en su nombre, directorio, la extensión y la unidad.
;Sintaxis: SplitPath( [Nombre / URL], [nombre.ext], [directorio], [extension], [nombre], [unidad] )
SplitPath(InputVar, ByRef OutFileName := "", ByRef OutDir := "", ByRef OutExtension := "", ByRef OutNameNoExt := "", ByRef OutDrive := "") {
	SplitPath, InputVar, OutFileName, OutDir, OutExtension, OutNameNoExt, OutDrive
	i := {}, i.FileName := (i.FN:=OutFileName), i.Dir := OutDir, i.Ext := (i.Extension:=OutExtension), i.Name := OutNameNoExt, i.Drive := OutDrive
	return i
}

FileFNPath(Filename, Start := "(", End := ")") {
	Filename := GetFullPathName(Filename), SplitPath(Filename, FullName, Dir, Ext, Name)
	, Filename := Dir "\" Name, Ext := Ext=""?"":"." Ext
	Loop {
		if FileExist((tmppath?tmppath:Filename) Ext)
			tmppath := tmppath?StrReplace(tmppath, Start (A_Index-1) End, Start A_Index End):Filename Start true End
		else return (tmppath?tmppath:Filename) Ext
}}

;esperar a que un archivo exista o no
;Sintaxis: FileWait( [archivo], [segundos], [¿esperar a que no exista?] )
FileWait(FileName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	FileName := GetFullPathName(FileName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsFile(FileName))||(!NotExist&&IsFile(FileName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
}}

;leer/escribir/eliminar en archivos .ini
IniRead(Filename := "", Section := "", Key := "", OutputVar := " ") {
	static _
	if (Key!=""&&Section!="")
		IniRead, OutputVar, % (_:=((Filename="")?_:Filename)), %Section%, %Key%, %OutputVar%
	else if (Key=""&&Section!="")
		IniRead, OutputVar, % (_:=((Filename="")?_:Filename)), %Section%
	else IniRead, OutputVar, % (_:=((Filename="")?_:Filename))
	return OutputVar
} IniWrite(Value := "", Filename := "", Section := "", Key := "") {
	static _
	if (Key="")
		IniWrite, %Value%, % (_:=((Filename="")?_:Filename)), %Section%
	else IniWrite, %Value%, % (_:=((Filename="")?_:Filename)), %Section%, %Key%
	return !ErrorLevel
} IniDelete(Filename := "", Section := "", Key := "") {
	static _
	if (Key="")
		IniDelete, % (_:=((Filename="")?_:Filename)), %Section%
	else IniDelete, % (_:=((Filename="")?_:Filename)), %Section%, %Key%
	return !ErrorLeveL
}

;crear acceso directo
;Sintaxis: CreateShortcut( [archivo al que hace referencia], [acceso directo], [directorio de trabajo], [argumentos], [descripcion], [icono], [tecla], [inicio] )
;Icono: espesificar el icono o un Array con el icono y el indice [Icono, Indice].
;Tecla: tecla de método abreviado.
;Inicio: modo de inicio. 1 = Normal (defecto). 3 = Maximizado. 7 = Minimizado.
;Nota: si el acceso directo ya existe, lo sobreescribe.
;Return: devuelve la ruta al nuevo acceso directo o cero si falló
CreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := -1, ShortcutKey := "", RunState := 1) {
	SplitPath, ShortcutFile,,, Ext
	ShortcutFile .= Ext="lnk"?"":".lnk"
	try WshShell := ComObjCreate("WScript.Shell")
	, oShellLink := WshShell.CreateShortcut(GetFullPathName(ShortcutFile))
	, oShellLink.TargetPath := Target, oShellLink.Arguments := Args
	, oShellLink.WorkingDirectory := WorkingDir, oShellLink.Description := Description
	, oShellLink.IconLocation := (IsObject(IconFile)?(IconFile[1] ", " (IconFile[2]>0?IconFile[2]-1:0)):(((IconFile=-1)?Target:IconFile) ", 0"))
	, oShellLink.Hotkey := ShortcutKey, oShellLink.WindowStyle := RunState=3?3:RunState=7?7:1, oShellLink.Save
	catch
		return false, ErrorLevel := true
	return ShortcutFile, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/xk6kst2k%28v=vs.84%29.aspx

;Sintaxis: CreateFile( [archivo], [acceso], [acceso compartido], [SECURITY_ATTRIBUTES], [accion], [opciones y atributos], [TEMPLATEFILE])
;Accesos: Read=0x80000000 | Write=0x40000000 | EXECUTE=0x20000000 | ALL=0x10000000
;Accesos compartido: Read=1 | Write=2 | DELETE=4 | ALL=7 | 0
;SECURITY_ATTRIBUTES: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
;Accion: CREATE_ALWAYS=2 | CREATE_NEW=1 | OPEN_ALWAYS=4 | OPEN_EXISTING=3 | TRUNCATE_EXISTING=5
CreateFile(Filename, DesiredAccess := 0x10000000, ShareMode := 7, SecurityAttributes := 0, CreationDisposition := 2, FlagsAndAttributes := 0, TemplateFile := 0) {
	hFile := DllCall("Kernel32.dll\CreateFileW", "Ptr", &Filename, "UInt", DesiredAccess, "UInt", ShareMode
	, "Ptr", SecurityAttributes, "UInt", CreationDisposition, "UInt", FlagsAndAttributes, "Ptr", TemplateFile, "Ptr")
	return hFile, ErrorLevel := !hFile
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx

;Sintaxis: WriteFile( [hFile], [data], [bytes], [bytes out], [OVERLAPPED] )
;OVERLAPPED: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684342(v=vs.85).aspx
WriteFile(hFile, Buffer, Bytes := 0, ByRef BytesOut := 0, ByRef Overlapped := 0) {
	r := DllCall("Kernel32.dll\WriteFile", "Ptr", hFile, "Ptr", Buffer, Bytes?"UInt":"Ptr", Bytes, "UIntP", BytesOut, "Ptr", Overlapped, "UInt")
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx

ReadFile(hFile, ByRef OutputVar, Bytes, ByRef BytesRead := "", ByRef Overlapped := 0) {
	r := DllCall("Kernel32.dll\ReadFile", "Ptr", hFile, "Ptr", OutputVar, "UInt", Bytes, "PtrP", BytesRead, "Ptr", Overlapped)
	return r, ErrorLevel := !r
}

;abrir un directorio en el explorador de windows y seleccionar archivo(s)
;Sintaxis: OpenFolderAndSelectItems( [directorio], [archivos, espesificar un array para varios archivos], [opciones] )
;Opciones:
	;0x0001 = selecciona un archivo y poner su nombre en el modo de edición. solo válido para un archivo.
	;0x0002 = selecciona el archivo(s) en el escritorio en lugar de en una ventana del Explorador de Windows. si el escritorio se oculta detrás de las ventanas abiertas, no se hará visible
;Ejemplo: MsgBox % OpenFolderAndSelectItems(A_WinDir, ["explorer.exe", "hh.exe", "nonexistsfile.ext"]) "`n" ErrorLevel
;Nota: archivos inválidos se omiten (no existen)
OpenFolderAndSelectItems(DirName, Files, Flags := 0x0) {
	if !(DirExist(DirName)) || !(Files:=GetValidArrayFiles(Files,, DirName "\"))
		return false, ErrorLevel := 2
	DllCall("Ole32.dll\CoInitialize", "Ptr", 0), VarSetCapacity(PidlArray, Files.MaxIndex() * A_PtrSize, 0), FolderPidl := ParseDisplayName(DirName)
	for k, v in Files
		NumPut(ParseDisplayName(DirName "\" v), PidlArray, (k - 1) * A_PtrSize, "Ptr")
	r := DllCall("Shell32.dll\SHOpenFolderAndSelectItems", "Ptr", FolderPidl, "UInt", Files.MaxIndex(), "Ptr", &PidlArray, "UInt", Flags)
	for k, v in Files
		DllCall("Ole32.dll\CoTaskMemFree", "Ptr", NumGet(PidlArray, (k - 1) * A_PtrSize), "Ptr")
	return !r, DllCall("Ole32.dll\CoTaskMemFree", "Ptr", FolderPidl), DllCall("Ole32.dll\CoUninitialize"), ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762232(v=vs.85).aspx















































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: USUARIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PRINCIPALES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;enumera todos los usuarios con información
;Sintaxis: UserAccountsEnum( [opciones] )
;Parámetros:
	;Opciones: espesificar las condiciones de busqueda
		;Sintaxis:  [espacio]WHERE [que] = '[igual a]' [ AND|OR...]
;Ejemplo:
	;for k, v in UserAccountsEnum()
	;	MsgBox % k "#`n" v.Domain "\" v.Name
UserAccountsEnum(Options := "") {
	List := []
	for this in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM Win32_UserAccount" Options) {
		Info := {}
		Loop, Parse, % "AccountType|Caption|Description|Disabled|Domain|FullName|InstallDate|LocalAccount"
		. "|Lockout|Name|PasswordChangeable|PasswordExpires|PasswordRequired|SID|SIDType|Status", |
			Info[A_LoopField] := this[A_LoopField]
		List.Push(Info)
	} return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa394507(v=vs.85).aspx

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES SECUNDARIAS
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtiene información del usuario actual y la mantiene en la memoria para acelerar el resultado
;Ejemplo: MsgBox % "Dominio\Usuario: " GetCurrentUserInfo().Domain "\" GetCurrentUserInfo().Name "`nSID: " GetCurrentUserInfo().SID
;Notas:
	;otra forma de obtener el SID, es usando cmd.
		;Link: http://www.windows-commandline.com/get-sid-of-user/
		;Ejemplo: wmic useraccount where (name='%username%' and domain='%userdomain%') get sid
GetCurrentUserInfo() {
	static CurrentUserInfo
	if !(CurrentUserInfo)
		if !(CurrentUserInfo:=UserAccountsEnum(" WHERE Name = '" A_UserName "' AND Domain = '" A_UserDomain() "'")[1])
			CurrentUserInfo := UserAccountsEnum(" WHERE Name = '" A_UserName "'")[1]
	return CurrentUserInfo
} 





































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: EJECUTAR & HANDLES ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;EJECUTAR
;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;ejecutar en un proceso aparte
;Sintaxis: RunProcess( [parámetros], [opciones], [WorkingDir], [codificación], [ExitCode (out)], [¿esperar?] )
;Parámetros:
	;Parámetros: espesificar la ruta a un archivo y los parámetros.
		;Sintaxis: [archivo] [param 1] [param 2] [param 3] [etc...]
	;Opciones: espesificar opciones para la creacion del proceso y prioridad
		;Opciones de creación: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx
			;0x08000000 = el proceso es una aplicación de consola, que se ejecuta sin una ventana.
			;0x00000004 = el proceso se crea en un estado de suspención
		;Prioridades: https://msdn.microsoft.com/en-us/library/windows/desktop/ms683211(v=vs.85).aspx
			;0x00000100 = tiempo real
			;0x00000080 = alta
			;0x00008000 = por encima de lo normal
			;0x00000020 = normal
			;0x00004000 = por debajo de lo normal
			;0x00000040 = baja
		;Nota: sumar valores para combinar. ver link para mas opciones de creación
	;WorkingDir: espesificar el directorio de trabajo. si no se espesifica, usa el del proceso invocador
	;Codificación: espesificar la codificación para el texto salida, por defecto usa CP437
	;ExitCode: devuelve el código de salida
	;Esperar: 0|1. determina si se debe esperar que el proceso finalize. por defecto = 1
;Return: resultado en la codifiación espesificada
;ErrorLevel: 0|1
RunProcess(Param, CreationFlags := 0, WorkingDir := 0, Encoding := "CP437", ByRef ExitCode := "", WaitClose := true) {
	CreatePipe(hReadPipe, hWritePipe), SetHandleInformation(hWritePipe, 0x00000001)
	, Size := VarSetCapacity(STARTUPINFO, A_PtrSize=4?68:104, 0), NumPut(Size, STARTUPINFO, 0, "UInt")
    , NumPut(0x100, STARTUPINFO, A_PtrSize=4?44:60, "UInt"), NumPut(hStdInRd, STARTUPINFO, A_PtrSize=4?56:80, "Ptr")
    , NumPut(hWritePipe, STARTUPINFO, A_PtrSize=4?60:88, "Ptr"), NumPut(hWritePipe, STARTUPINFO, A_PtrSize=4?64:96, "Ptr")
	, this := CreateProcess(, Param,,,, CreationFlags,, WorkingDir, &STARTUPINFO), CloseHandle(hWritePipe), Size := VarSetCapacity(Buff, 4095)
	if (WaitClose)
		while ReadFile(hReadPipe, &Buff, Size, Bytes)
			OutputVar .= StrGet(& Buff, Bytes, Encoding)
	return OutputVar, ExitCode := GetExitCodeProcess(this.handle), CloseHandle(this.handle, hReadPipe), ErrorLevel := !this.handle
}

;ejecutar archivo, abrir carpeta/URL
;Sintáxis: Run( [Archivo], [directorio de trabajo], [opciones], [PID] )
Run(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	Run, % Target, % WorkingDir, % "UseErrorLevel " Options, OutputVarPID
	return ErrorLevel?0:(OutputVarPID?OutputVarPID:true)
}

;ejecutar archivo (esperar)
;Sintáxis: RunWait( [Archivo], [directorio de trabajo], [opciones], [PID] )
RunWait(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	RunWait, % Target, % WorkingDir, % "UseErrorLevel " Options, OutputVarPID
	return ErrorLevel?0:(OutputVarPID?OutputVarPID:true)
}

;abrir propiedades de un archivo/carpeta
;Sintaxis: Properties( [archivo/carpeta], [esperar (segundos)], [¿AlwaysOnTop?] )
;Notas: 
	;• para esperar indefinidamente, espesificar 0 (segundo parametro)
	;• cuando se espesifica tiempo fuera, primero busca y cierra todas las demás ventanas
		;de propiedades abiertas por el proceso actual; ya que sino, esperaría a que todas las
		;ventanas se cierren, y solo queremos esperar la que espesificamos para el archivo.
;Ejemplo: Properties(comspec, false, true), ExitApp()
Properties(Target, WaitClose := -1, AlwaysOnTop := false) {
	if !FileExist(Target)
		return 0, ErrorLevel := 2
	if (WaitClose>-1) {
		CurrentProcessId := ProcessExist()
		, WinCloseEx(, "#32770", CurrentProcessId, true)
		, Run("Properties " Chr(34) Target Chr(34))
		, hWnd := WinWait(, 5, "#32770", CurrentProcessId)
		if (AlwaysOnTop)
			WinSet(hWnd, "+AlwaysOnTop")
		return WinWaitClose(hWnd, WaitClose)
	} r := Run("Properties " Chr(34) Target Chr(34))
	if (AlwaysOnTop&&(hWnd:=WinWait(, 5, "#32770", ProcessExist())))
		WinSet(hWnd, "+AlwaysOnTop")
	return hWnd?hWnd:r, ErrorLevel := !r
}

;ejecuta un comando en la consola y devuelve el resultado
;Sintaxis: CMD( [cmd], [codificación], [código de salida (out)], [¿agregar directorio a la carpeta del sistema al inicio?]] )
;Ejemplo: MsgBox % CMD("dir " A_WinDir, "CP437")
;Nota: el directorio de trabajo por defecto es C:\Windows\System32
CMD(Script, Encoding := "CP437", ByRef ExitCode := "") {
	return RunProcess(A_ComSpec() A_Space "/c" A_Space Script, 0x08000000+0x00000080, A_SysDir(), Encoding, ExitCode)
}

;ejecutar script .vbs
;Sintaxis: VBS( [script], [código de salida (out)] )
;Ejemplo: VBS("WScript.Echo " Chr(34) "AHK" A_AhkVersion Chr(34))
;Nota: cambiar Wscript.exe por Cscript.exe para el modo consola
VBS(Script, ByRef ExitCode := "") {
	Filename := FileWrite(Script, A_Temp "\~wscript.vbs")
	return ExitCode, CMD("Wscript.exe " Chr(34) Filename Chr(34),, ExitCode)
}

;ejecutar script
;Sintaxis: ExecScript( [script], [parámetros], [aplicación] )
;Ejemplo: ExecScript("MsgBox E.X.A.M.P.L.E")
ExecScript(Script, Params := "", Filename := "") {
	SplitPath, Filename, Name
	Name .= A_Year A_Mon A_DD A_Hour A_Min A_Sec
	Filename := (Filename=""?A_AhkPath " /CP65001":Trim(Filename)) A_Space Chr(34) "\\.\pipe\" Name Chr(34)
	, Pipe1 := CreateNamedPipe(Name, 2), Pipe2 := CreateNamedPipe(Name, 2)
	, ComObjCreate("WScript.Shell").Exec(Trim(Filename) A_Space Trim(Params))
	, ConnectNamedPipe(Pipe1), CloseHandle(Pipe1), r := ConnectNamedPipe(Pipe2)
	, FileOpen(Pipe2, "h", "UTF-8").Write(Script), CloseHandle(Pipe2)
	return r, ErrorLevel := !r
}

;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;HANDLE
;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CloseHandle(HANDLE*) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx
	Error := ErrorLevel, Ok := 0
	Loop, % (HANDLE.MaxIndex())
		Ok += !!DllCall("Kernel32.dll\CloseHandle", "Ptr", HANDLE[A_Index], "UInt")
	return Ok=HANDLE.MaxIndex(), ErrorLevel := Error
}

GetHandleInformation(Handle) { ;Return: HANDLE_FLAG_INHERIT=1 | HANDLE_FLAG_PROTECT_FROM_CLOSE=2 | 0
	r := DllCall("Kernel32.dll\GetHandleInformation", "Ptr", Handle, "UIntP", Flags)
	return Flags, ErrorLevel := !r ;ErrorLevel = 1 => Invalid HANDLE
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724329(v=vs.85).aspx

;establece ciertas propiedades de un objeto HANDLE
;Sintaxis: SetHandleInformation( [HANDLE], [opciones] )
;Parámetros:
	;Opciones:
		;0x00000001 = HANDLE_FLAG_INHERIT
		;0x00000002 = HANDLE_FLAG_PROTECT_FROM_CLOSE
SetHandleInformation(Handle, Flags := 0x00000000) {
	return DllCall("Kernel32.dll\SetHandleInformation", "Ptr", Handle, "UInt", Flags, "UInt", Flags, "UInt")
}













































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: PIPE FUNCTIONS ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365152(v=vs.85).aspx
;#############################################################################################################################################
;crear pipe anónimo
;Sintaxis: CreatePipe( [read handle (out)], [write handle (out)], [atributos], [tamaño] )
;Parámetros:
	;Atributos: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
	;Tamaño: tamaño en bytes para el pipe. dejar en cero para usar el tamaño predeterminado del sistema
;Return: !=0 => OK
CreatePipe(ByRef hReadPipe, ByRef hWritePipe, PipeAttributes := 0, Size := 0) {
	return DllCall("Kernel32.dll\CreatePipe", "PtrP", hReadPipe, "PtrP", hWritePipe, "Ptr", PipeAttributes, "UInt", Size, "UInt")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365152(v=vs.85).aspx

;crear pipe con nombre
;Sintaxis: CreateNamedPipe( [name], [OpenMode], [PipeMode], [MaxInstances], [OutBufferSize], [DefaultTimeOut], [SecurityAttributes] )
;Parámetros:
	;Name: nombre único de no mas de 256 carácteres. puede contener cualquier carácter que no sea una barra invertida
	;OpenMode: modo de apertura
		;:::: modos de acceso ::::
		;0x00000003 = PIPE_ACCESS_DUPLEX
		;0x00000001 = PIPE_ACCESS_INBOUND
		;0x00000002 = PIPE_ACCESS_OUTBOUND
		;:::: opciones ::::
		;0x00080000 = FILE_FLAG_FIRST_PIPE_INSTANCE
		;0x80000000 = FILE_FLAG_WRITE_THROUGH
		;0x40000000 = FILE_FLAG_OVERLAPPED
		;:::: seguridad del modo de acceso ::::
		;0x00040000 = WRITE_DAC
		;0x00080000 = WRITE_OWNER
		;0x01000000 = ACCESS_SYSTEM_SECURITY
	;PipeMode: modo del pipe
		;:::: tipos ::::
		;0x00000000 = PIPE_TYPE_BYTE
		;0x00000004 = PIPE_TYPE_MESSAGE
		;:::: modos de lectura ::::
		;0x00000000 = PIPE_READMODE_BYTE
		;0x00000002 = PIPE_READMODE_MESSAGE
		;:::: modos de espera ::::
		;0x00000000 = PIPE_WAIT
		;0x00000001 = PIPE_NOWAIT
		;:::: modos de control remoto en el cliente ::::
		;0x00000000 = PIPE_ACCEPT_REMOTE_CLIENTS
		;0x00000008 = PIPE_REJECT_REMOTE_CLIENTS
	;MaxInstances: instancias máximas para este pipe 1~100
	;OutBufferSize: número de bytes que se reservan para el búfer de salida.
	;InBufferSize: número de bytes que se reservan para el búfer de entrada.
	;DefaultTimeOut: tiempo fuera, en ms.
	;SecurityAttributes: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
;Return: 0xFFFFFFFF(INVALID_HANDLE_VALUE) | hNamedPipe(HANDLE)
CreateNamedPipe(Name, OpenMode := 0, PipeMode := 0, MaxInstances := 255, OutBufferSize := 0, InBufferSize := 0, DefaultTimeOut := 0, SecurityAttributes := 0) {
	Name := "\\.\pipe\" SubStr(StrReplace(Trim(Name), "`n"), 1, 256)
	return DllCall("Kernel32.dll\CreateNamedPipeW", "Ptr", &Name, "UInt", OpenMode, "UInt", PipeMode
	, "UInt", MaxInstances, "UInt", OutBufferSize, "UInt", InBufferSize, "UInt", DefaultTimeOut, "UPtr", SecurityAttributes, "UPtr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365150(v=vs.85).aspx

;esperar a un pipe con nombre para conectarce con una instancia de un pipe con nombre
;Sintaxis: ConnectNamedPipe( [hNamedPipe], [Overlapped] )
ConnectNamedPipe(hNamedPipe, Overlapped := 0) {
	return DllCall("Kernel32.dll\ConnectNamedPipe", "UPtr", hNamedPipe, "UPtr", Overlapped, "UInt")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365146(v=vs.85).aspx





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CARPETAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;eliminar directorio
;Sintaxis: DirDelete( [carpeta], [¿eliminar archivos y subcarpetas?] )
DirDelete(DirName, Recurse := false) {
	FileRemoveDir, %DirName%, %Recurse%
	return !ErrorLevel
} DirRemove(DirName, Recurse := false) {
	FileRemoveDir, %DirName%, %Recurse%
	return !ErrorLevel
}

;vaciar directorio sin eliminarlo
;Sintaxis: DirEmpty( [directorio], [¿incluir subdirectorios?] )
;Return: array que contiene los archivos y carpetas eliminados (0 si no se eliminó nada).
;ErrorLevel: array que contiene los archivos y carpetas que no se puedieron eliminar (0 si se eliminó todo).
DirEmpty(DirName, Recurse := false) {
	Error := [], OutputVar := []
	Loop, Files, %DirName%\*.*, FD
	{	if IsFile(A_LoopFileFullPath) {
			if !(FileDelete(A_LoopFileFullPath))
				Error.Push(A_LoopFileFullPath)
			else OutputVar.Push(A_LoopFileFullPath)
		} else {
			if !(DirDelete(A_LoopFileFullPath, Recurse))
				Error.Push(A_LoopFileFullPath)
			else OutputVar.Push(A_LoopFileFullPath)
	}} return OutputVar.MaxIndex()?OutputVar:false, ErrorLevel := Error.MaxIndex()?Error:false
}

;eliminar directorio de forma segura
;Sintáxis: DirSecureDelete( [directorio], [pasadas] )
DirSecureDelete(DirName, Passes := 1) {
	Loop, Files, % RTrim(DirName, "\") "\*.*", FR
		FileSecureDelete(A_LoopFileFullPath, Passes)
	return DirDelete(DirName, true)
}

;renombrar directorio
;Sintaxis: Rename( [directorio], [nuevo nombre], [¿eliminar si ya existe una carpeta con el mismo nombre?], [¿eliminar si la carpeta no está vacía?] )
DirRename(Dirname, NewName, OverWrite := false, Recurse := false) {
	SplitPath, Dirname,, Dir
	if (FileExist(Dir "\" NewName)) {
		if !(OverWrite)
			return false, ErrorLevel := 2
		if !(DirDelete(Dir "\" NewName, Recurse))
			return false, ErrorLevel := 3
	} FileMoveDir, %Dirname%, %Dir%\%NewName%, R
	return !ErrorLevel
}

;mover directorio
;Sintaxis: DirMove( [directorio], [destino], [opciones], [¿eliminar si el directorio no está vacio?] )
;Opciones: 1 = sobreescribir archivos | 2 = eliminar destino antes de copiar.
DirMove(DirName, Dest, OverWrite := false, Recurse := true) {
	if (OverWrite=2)
		DirDelete(Dest, Recurse)
	FileMoveDir, %DirName%, %Dest%, % ((OverWrite="R")?"R":!!(OverWrite))
	return !ErrorLevel
}

;copiar directorio
;Sintaxis: DirCopy( [directorio], [destino], [opciones] )
;Opciones: 1 = sobreescribir archivos | 2 = eliminar destino antes de copiar.
DirCopy(Source, Dest, OverWrite := false) {
	if (OverWrite=2)
		DirDelete(Dest, true)
	FileCopyDir, % RTrim(Source, "\"), % RTrim(Dest, "\"), % OverWrite?true:false
	return !ErrorLevel
}

;crear carpeta
;Sintaxis: DirCreate( [directorio], [¿crear subdirectorios?], [eliminar antes si existe 0|1], [atributos] )
DirCreate(DirName, Recurse := true, Remove := "", Attrib := "") {
	if (Remove=0) || (Remove=1)
		DirRemove(DirName, Remove)
	if (Recurse) {
		FileCreateDir, %DirName%
		if (Attrib)
			FileSetAttrib, %Attrib%, %DirName%
		return !ErrorLevel
	} return r:=DllCall("Kernel32.dll\CreateDirectoryW", "Str", "\\?\" DirName, "Ptr", 0), ErrorLevel := !r
}

;dialogo: seleccionar carpeta
;Sintaxis: DirSelect( [Directorio], [Opciones/VentanaID], [Título] )
DirSelect(StartingFolder := "", Options := 1,  Prompt := "") {
	try FileSelectFolder, OutputVar, %StartingFolder%, %Options%, %Prompt%
	catch
		FileSelectFolder, OutputVar,, %Options%, %Prompt%
	if (Options=1) && !(OutputVar)
		ErrorLevel := true
	return RTrim(OutputVar, "\")
}

;comprueba si es carpeta
;Sintaxis: IsDir( [carpeta] )
IsDir(DirName, ByRef FullPathName := "") {
	if IsByRef(FullPathName)
		FullPathName := GetFullPathName(DirName)
	return InStr(FileExist(DirName),"D")
} IsFolder(DirName, ByRef FullPathName := "") {
	return IsByRef(FullPathName)?IsDir(DirName, FullPathName):IsDir(DirName)
}

;comprueba si el directorio existe, quita \ al final, si lo tiene.
DirExist(ByRef Path) {
	Path := Trim(RegExReplace(Trim(Path), "\\+$"))
	return InStr(FileExist(Path), "D")?Path:""
}

;abrir carpeta con explorer.exe
;Sintaxis: DirOpen( [carpeta], [abrir en una nueva ventana] ) 
DirOpen(Dir, NewWindow := false) {
	if !DirExist(Dir)
		return false, ErrorLevel := true
	return Run(A_WinDir "\explorer.exe " (NewWindow?"/n,":"") Chr(34) Dir Chr(34))
}

;obtiene informacion sobre un directorio
;EJEMPLO: MsgBox % DirGetInfo( A_WinDir ).CSName
DirGetInfo(Dirname, ValidatePath := 0) {
	if !DirExist( Dirname )
		return "", ErrorLevel := 1
	Dirname := StrReplace(Dirname, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Directory WHERE Name = '" Dirname "'")
		i.AccessMask := a.AccessMask, i.Archive := a.Archive, i.Caption := a.Caption, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod, i.CreationClassName := a.CreationClassName, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName, i.CSName := a.CSName, i.Description := a.Description, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName, i.Encrypted := a.Encrypted, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension, i.FileName := a.FileName, i.FileType := a.FileType, i.LastAccessed := a.LastAccessed
		, i.FSName := a.FSName, i.InstallDate := a.InstallDate, i.InUseCount := a.InUseCount, i.FileSize := a.FileSize, i.Hidden := a.Hidden
		, i.LastModified := a.LastModified, i.Name := a.Name, i.Path := a.Path, i.Readable := a.Readable, i.Status := a.Status
		, i.System := a.System, i.Version := a.Version, i.Writeable := a.Writeable, i.FSCreationClassName := a.FSCreationClassName
	return i, ErrorLevel := !i.Name
}

;esperar a que un directorio exista o no
;Sintaxis: DirWait( [directorio], [segundos], [¿esperar a que no exista?] )
DirWait(DirName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	DirName := GetFullPathName(DirName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsDir(DirName))||(!NotExist&&IsDir(DirName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
}}

;obtener tamaño de un directorio
;Sintaxis: DirGetSize( [directorio], [KB|MB|GB], [¿incluir subcarpetas?] )
DirGetSize(DirName, Units := "", Recurse := true) {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	Size := 0
	Loop, Files, %DirName%\*.*, % Recurse?"FR":"F"
		Size += A_LoopFileSize
	return _[Units]?Size/_[Units]:Size, ErrorLevel := !IsFolder(DirName)
}





















































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: NÚMEROS & OPERACIONES MATEMÁTICAS ::::::::::::::::::::::::::::::::::
Links:
	• http://ahkscript.org/boards/viewtopic.php?t=3925
	• https://dl.dropboxusercontent.com/u/186419968/html/BaseConversion/index.html
	• https://raw.githubusercontent.com/aviaryan/autohotkey-scripts/master/Functions/Maths.ahk
Funciones que aceptan números infinitos (nota: debe expresar el número como string si tiene mas de 18 cifras):
	• Divide()
	• MulDiv() (solo si se usa 18 cifras o mas en cualquiera de los parámetros)
	• Power()
	• Prefect()
	• Greater()
	• Add()
	• Multiply()
	• BitShiftLeft()
	• BitShiftRight()
#############################################################################################################################################
*/
;multiplica dos valores y luego divide el resultado por un tercer valor. el resultado final se redondea al entero más cercano=>Places=0
;Sintaxis: MulDiv( [multiplicando], [multiplicador], [deniminador], [decimales=0] )
MulDiv(Number, Numerator, Denominator := 1, Places := 0) {
	if (StrLen(Number)>=18) || (StrLen(Numerator)>=18) || (StrLen(Denominator)>=18)
		return RoundEx(Divide(Multiply(Number, Numerator), Denominator, Places), Places)
	return Round((Number*Numerator)/Denominator, Places)
	;multiplica dos valores de 32 bits y luego divide el resultado de 64 bits por un tercer valor de 32 bits. el resultado final se redondea al entero más cercano
	;return DllCall("Kernel32.dll\MulDiv", "Int", Number, "Int", Numerator, "Int", Denominator, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa383718(v=vs.85).aspx

;elevar un numero (potenciación)
;Sintaxis: Power( [base], [exponente] )
;Ejemplo: MsgBox % Power(99, 999) ;99^999
Power(Base, Exponent) {
	SLB := StrLen(Base), VarSetCapacity(B, SLB, 0)
	Loop, Parse, % Base
		NumPut(A_LoopField, B, SLB - A_Index, "UChar")
	VarSetCapacity(P, SLB, 0), MoveMemory(&P, &B, PL:=SLB)
	Loop, % (Exponent - 1) {
		V := 0, VarSetCapacity(R, RL := PL + SLB + 1, 0)
		Loop, %SLB% { ; multiply
			If (I := NumGet(B, A_Index - 1, "UChar")) {
				Loop, %PL%
					N := NumGet(R, J := A_Index + V - 1, "UChar") + (NumGet(P, A_Index - 1, "UChar") * I)
					, NumPut(SubStr(N, 0), R, J++, "UChar")
					, NumPut(NumGet(R, J, "UChar") + SubStr("0" . N, -1, 1), R, J, "UChar")
			} V++
		} VarSetCapacity(P, RL, 0), MoveMemory(&P, &R, PL:=RL)
		while !NumGet(P, PL - 1, "UChar") ; remove trailing zeroes
			PL--
	} VarSetCapacity(V, RL, 0)
	Loop, %RL%
		V .= NumGet(R, --RL, "UChar")
	return LTrim(V, "0")
} ;http://ahkscript.org/boards/viewtopic.php?p=49693#p49693

;convierte cualquier número a la forma perfecta, es decir, elimina ceros adicionales y agrega requeridos.
Prefect(n) {
	if InStr((n:=(InStr(n:=RTrim(n, "+-"), "-")&&(l:=true))?SubStr(n, 2):n), ".") {
		if !((n:=Trim(n, "0"))="*") && (Substr(n,1,1) == ".")
			n := "0" n
		if (SubStr(n, 0)==".")
			n := Substr(n, 1, -1)
		return (l?"-":"") n
	} else return Trim(n, "0")?((l?"-":"") LTrim(n, "0")):0
}

;redondear un número
;Sintaxis: RoundEx( [num], [decimales] )
RoundEx(n, d := 0) {
	if InStr(n, ".") {
		if ((f:=StrLen(n)-(Instr(n, ".")=0?StrLen(n):InStr(n, ".")))>d) {
			if ((s:=Substr(n, Instr(n, ".")+d+1, 1))>=5)
				Loop, % (d-1)
					z .= "0"
		n := Add(Substr(n, 1, Instr(n, ".")+d), (s >= 5) ? "0." z "1" : "0")
	} else {
		Loop, % (d - f)
			z .= "0"
		n .= z
	} return, Rtrim(n, ".")
} else return n
}

;multiplicar
;Sintaxis: Multiply( [num 1], [num 2] )
Multiply(num1, num2) {
	ps := (mnum2:=InStr(num2, "-"))?0:1, ps := (mnum1:=InStr(num1, "-"))?!ps:ps, num1 := SubStr(num1, mnum1?2:1), num2 := Substr(num2, mnum2?2:1)
	, dec := (dot1:=InStr(num1, "."))?StrLen(num1)-dot1:0, dec := (dot2:=InStr(num2, "."))?dec+StrLen(num2)-dot2:dec, num1 := StrReplace(num1, ".")
	Loop, % StrLen(num2:=StrReplace(num2, "."))
		tnum2 .= SubStr(num2, 1-A_Index, 1)
	num2 := tnum2, pr := "0"
	Loop, Parse, % num2
	{ rw := "0", zr := ""
		if (A_LoopField) {
			Loop, %A_LoopField%
				rw := Add(rw, num1)
		} else Loop, % (StrLen(num1)-1)
			rw .= "0"
		Loop, % (A_Index-1)
			zr .= "0"
		rw .= zr, pr := Add(pr, rw)
	} return (ps?"":"-") (dec?Prefect(SubStr(pr, 1, StrLen(pr)-dec) "." SubStr(pr, 1-dec)):pr)
}

;comprueba si num1>num2
;Sintaxis: IsGreater( [num 1], [num 2], [valor a devolver si los números son iguales = 0] )
Greater(n1, n2, teq := false) {
	if !((l2:=InStr(n2, "-"))="*") && ((!(l1:=InStr(n1, "-")) && l2) || (l1 && !l2))
		return (!l1&&l2)?true:false
	if ((e1:=(d1:=InStr(n1:=Prefect(n1), "."))?StrLen(n1)-d1:0)>(e2:=(d2:=InStr(n2:=Prefect(n2), "."))?StrLen(n2)-d2:0))
		Loop, % (e1-e2)
			n2 .= "0"
	else if (e2 > e1)
		Loop, % (e2-e1) 
			n1 .= "0"
	if ((z1:=StrLen(n1:=StrReplace(n1, ".")))>(z2:=StrLen(n2:=StrReplace(n2, "."))))
		return l1?0:1
	else if (z2>z1)
		return l1?1:0
	else Loop {
			if ((h1:=SubStr(n1, A_Index, 1))>(h2:=Substr(n2, A_index, 1)))
				return l1?0:1
			else if (h2>h1)
				return l1?1:0
			else if (A_Index=z1)
				return teq
}}

;sumar
Add(number1, number2) {
	count := (InStr(n2:=number2, "--")?2:InStr(number2, "-")?1:0) + (InStr(n1:=number1, "-")?1:0)
	, number1 := StrReplace(number1, "-"), number2 := StrReplace(number2, "-")
	if ((dec1:=(p1:=InStr(number1, "."))?StrLen(number1)-p1:0)>(dec2:=(p2:=InStr(number2, "."))?StrLen(number2)-p2:0)) && !((dec:=dec1)="*")
		Loop, % (dec1 - dec2)
			number2 .= "0"
	else if (dec2 > dec1) && !((dec:=dec2)="*")
		Loop, % (dec2 - dec1) 
			number1 .= "0"
	else dec := dec1
	if ((l1:=StrLen(number1:=StrReplace(number1, ".")))>=(l2:=StrLen(number2:=StrReplace(number2, "."))))
		Loop, % (l1 - l2)
			number2 := "0" number2
	else Loop, % (l2 - l1)
		number1 := "0" number1
	if !((n:=StrLen(number1))="*") && !(count=1) && !(count=3) {
		Loop {
			digit := SubStr(number1,1 - A_Index, 1) + SubStr(number2, 1 - A_index, 1) + (carry ? 1 : 0)
			if (A_index==n) && !((sum:=digit sum)="*")
				break
			carry := digit>9?true:false, digit := carry?SubStr(digit, 0, 1):digit, sum := digit sum
		} sum := ((InStr(n2, "-")&&InStr(n1, "-"))?"-":"") sum
	} else {
		if !(numbercompare:=Greater(number1, number2, true))
			mid := number2, number2 := number1, number1 := mid
		Loop {
			digit := SubStr(number1,1 - A_Index, 1) - SubStr(number2, 1 - A_index, 1) + (borrow ? -1 : 0)
			if (A_index==n) && !((digit:=StrReplace(digit, "-"))="*") && !((sum:=digit sum)="*")
				break
			borrow := InStr(digit, "-")?true:false, digit := borrow?(digit+10):digit, sum := digit sum
		} sum := (InStr(n2, "--")?(numbercompare?"-":""):InStr(n2, "-")?(numbercompare?"":"-"):InStr(n1, "-")?(numbercompare?"-":""):"") sum
	} sum := sum=="-"?0:sum, sum := (dec&&sum)?SubStr(sum, 1,StrLen(sum) - dec) "." SubStr(sum, 1 - dec):sum
		return Prefect(sum)
}

;dividir
;Sintaxis: Divide( [num 1], [num 2], [decimales] )
Divide(n1, n2, l := 6){
	p := InStr(n1, "-")?(InStr(n2, "-")?true:false):(InStr(n2, "-")?false:true)
	if !((n1:=Prefect(n1:=StrReplace(n1, "-")))="*") && !(n2:=Prefect(n2:=StrReplace(n2, "-")))
		return
	d := z := InStr(n2, ".")?(StrLen(n2)-InStr(n2, ".")+(InStr(n1, ".")?-(StrLen(n1)-InStr(n1, ".")):0)+0):(InStr(n1, ".")?-(StrLen(n1)-InStr(n1, ".")):0), x1 := StrLen(k1:=(n1:=LTrim(n1:=StrReplace(n1, "."), "0")))
	Loop, % (x2:=StrLen(k2:=(n2:=LTrim(n2:=StrReplace(n2, "."), "0")))) + l
		n1 .= "0"
	cl := 0, z := z - x2 - l, t := false, n1f := x1 + x2 + l
	while !(n1="") {
		if !(_t:=n:=0) && !(bl:="") && !((w:=t?SubStr(n1, 1, x2+1):SubStr(n1, 1, x2))="*") && Greater(w, n2, true) && !((j:=w)="*") {
			Loop, 10 {
				t_%A_index% := Multiply(n2, A_index)
				if !(Greater(j, t_%A_index%, true)) && !((n:=t?x2+1:x2)="*") {
					_t := A_index - 1, bl := t_%_t%
					break
			}	} r .= _
		} else if !((j:=SubStr(n1, 1, x2+1))="*") {
			Loop, 10 {
				t_%A_index% := Multiply(n2, A_index)
				if !(Greater(j, t_%A_index%, true)) && !((n:=x2+1)="*") {
					_t := A_index - 1 , bl := t_%_t%
					break
			}	} r .= cl=0?"":_ "0"
		} r .= _t, cl += (n - StrLen(m)), m := Add(j, "-" bl), n1 := (m:=m=0?"":m) SubStr(n1, n + 1)
		if Greater("0", m, true) && !(_k:="") {
			Loop, % StrLen(n1)
				_k .= "0"
			if (n1==_k) && !((n1:=SubStr(n1, 1, -1))="*") && !((n1:="1" n1)="*") && !((r:=Multiply(r, n1))="*")
				break
		} if (_t=0)
			break
		if !(_:="") && !(t:=false) && (m=="") {
			Loop
				if (InStr(n1, "0") == 1)
					_ .= "0" , n1 := Substr(n1, 2) , cl+=1
				else break
		} if (StrLen(m)==x2)
		t := true
		else Loop, % (x2 - StrLen(m) - 1)
			_ .= "0"
	} if (z<0) {
		e := Format("{:0.16e}", SubStr(k1,1,15) / SubStr(k2,1,15)), d := Format("{:0.16e}", d + StrLen(SubStr(k1,16)) - StrLen(SubStr(k2,16))), d := InStr(e, "-")?d - SubStr(e,-1) + 1:d + SubStr(e,-1) + 1
		if (d > 0)
			r := SubStr(r, 1, d) "." SubStr(r, d + 1)
		else if (d < 0){
			Loop, % Abs(d)
				_e .= "0"
			r := "0." _e r
		} else r := "0." r
	} else if (n:="1") {
		Loop, % z
			n .= "0"
		r := Multiply(Prefect(r), n)
	} return (p?"":"-") RoundEx(Prefect(r), d<0?Abs(d)+l:l)
}

BitShiftLeft(Value, Bit, BitwiseAnd := "") { ;MsgBox % (54992<<0xC) "`n" BitShiftLeft(54992, 0xC) 
	return (BitwiseAnd=""?RoundEx(Multiply(Value, Power(2, Bit))):RoundEx(Multiply(Value, Power(2, Bit)))&BitwiseAnd)
} BitShiftRight(Value, Bit, BitwiseAnd := "") { ;MsgBox % (54992>>0xC) "`n" BitShiftRight(54992, 0xC)
	return (BitwiseAnd=""?RoundEx(Divide(Value, Power(2, Bit))):RoundEx(Divide(Value, Power(2, Bit)))&BitwiseAnd)
}

;evalúa una expresión
;Sintaxis: Eval( [expresión] )
;Nota: acepta números poco mas grandes que AHK pero no infinitos
;Ejemplos: 
	;MsgBox % Eval("99999999999999999284888*2")
	;MsgBox % Eval("999^99")
	;MsgBox % Eval("2>1 AND 3>2 AND -2<99")
	;MsgBox % Eval("19 mod 7") 
	;MsgBox % Eval("Cos(2) + Sin(34.55) - Tan(33.077) * Exp(2) - Abs(1) - Sgn(Sqr(0.1))")
	;MsgBox % "0x" Eval("Hex(29399823)")
;Funciones Soportadas (Hex, Int): http://www.tutorialspoint.com/vbscript/vbscript_number_mathematical_functions.htm
;Operadores Soportados (+, -): http://www.tutorialspoint.com/vbscript/vbscript_operators.htm
;Return: resultado o vacío si hubo un error
;ErrorLevel: 0|1
Eval(Exp) {
	try wscript := ComObjCreate("ScriptControl")
	, wscript.Language := "VBScript"
	, OutputVar := wscript.Eval(Exp)
	catch ;ERROR?
		return "", ErrorLevel := true
	return OutputVar, ErrorLevel := false
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;obtiene el mayor numero
;Sintaxis: Max( [números separados por coma] )
;Ejemplo: MsgBox % Max( 7, 9, 0, -11, 6, 3, 5, 8 ) "`n" Max("5,2,8,-44,7")
Max(n*) {
	n := ((n.MaxIndex()=1)?StrSplit(n[1], ",", A_Space A_Tab):n), _ := n[1]
	Loop, % (n.MaxIndex())
		_ := ((_<n[A_Index+1])?n[A_Index+1]:_)
	return _
}

;obtiene el menor numero
;Sintaxis: Min( [números separados por coma] )
;Ejemplo: MsgBox % Min( 7, 9, 0, 222, -0.2 ) "`n" Min("5,2,8,-44,7")
Min(n*) {
	n := ((n.MaxIndex()=1)?StrSplit(n[1], ",", A_Space A_Tab):n), _ := n[1]
	Loop, % (n.MaxIndex())
		_ := ((_>n[A_Index+1])?((n[A_Index+1]="")?_:n[A_Index+1]):_)
	return _
}

LOWORD(l) {
    return (l & 0xffff)
} HIWORD(l, Extract := true) {
    return (Extract?((l >> 16) & 0xffff):(l << 16))
} LOBYTE(w) {
    return (w & 0xff)
} HIBYTE(w, Extract := true) {
    return (Extract?((w >> 8) & 0xff):((w << 8) & 0xff))
}

;MsgBox % RNum(0) "," RNum(10) "," RNum(5) ;0-5
;MsgBox % RNum(1) "," RNum(4) ;1~4
;MsgBox % RNum(6) "," RNum(9) ;6~9
;MsgBox % RNumEx(0) "," RNumEx(10) "," RNumEx(5) ;0-5
;MsgBox % RNumEx(1) "," RNumEx(3) ;1~3
;MsgBox % RNumEx(4) "," RNumEx(6) ;4~6
;MsgBox % RNumEx(7) "," RNumEx(9) ;7~9
RNum(Num, Min := 1, Max := 9, ms := 5) {
	return between(ln:=StrRight(Num), Min, Max)?(ms=""||ln!=ms?(StrLen(Num)=1?(ln<ms?0:Num+(10-ln)):(ms=""?StrTrimRight(Num) 0:(ln<ms?StrTrimRight(Num) 0:Num+(10-ln)))):Num):Num
} RNumEx(n) {
	if (StrLen(n)=1) && (n!=0) && (n!=5) {
		n := n=1||n=2||n=3?0:n=4||n=5||n=6?5:n+(10-n)
	} else {
		if ((l:=StrRight(n))!=0) && (l!=5) {
			n := (l=1||l=2||l=3?StrTrimRight(n) 0:l=4||l=5||l=6?StrTrimRight(n) 5:n+(10-l))
	}} return n
}

Abs64(Num) {
	return DllCall("msvcrt.dll\_abs64", "Int64", Num) ;Abs() --> DllCall("msvcrt.dll\_abs", "Int", Num)
} ;https://msdn.microsoft.com/en-us/library/kw1ee768.aspx

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;if [value] between [low] [high]
;comprueba si un número esta contenido entre otros dos valores (inclusive)
;Sintaxis: Between( [número], [valor menor], [valor mayor], [valores a excluir*] ) 
;Valores a excluir: valores separados por coma (si es alguno de estos valores devuelve 0)
Between(value, low, high, nval*) {
	nval := ((nval.MaxIndex()=1)?StrSplit(nval[1], ",", A_Space A_Tab):nval)
	Loop, % (nval.MaxIndex())
		if (value=nval[A_Index])
			return false
	return ((value>=low)&&(value<=high))
}

;si el número es par devuelve 1, caso contrario 0 (impar)
IsEven(num) {
	return !(num&1) ;Mod(num, 2)
}

;determina si es Número
;Sintaxis: IsNumber( [número], [carácteres no permitidos separados por coma] )
;EJEMPLO: MsgBox % IsNumber(-23.02) "`n" IsNumber("*1") "`n" IsNumber(-1) "`n" IsNumber(0xF,"*") "`n" IsNumber(+1)
IsNumber(num, IfChars := "*,x") {
	return ((Contains(num,IfChars)||((num+0)=""))?false:true)
}

IsPrime(N) {
  Loop, % Floor(Sqrt(N))
    If (A_Index > 1 && !Mod(N, A_Index))
      Return false
  return true
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir a hexadecimal
;Sintaxis: Hex( [número], [max num], [¿mayúscula?], [prefijo] )
Hex(Int, Length := 0, May := false, Prefix := "0x") {
	return Format(Prefix "{:" ((Length>0)?0 LTrim(Length,0):"") (May?"X":"x") "}", Int)
}

;convertir a Unsigned Integer
;Sintaxis: Int( [número], [¿Signed?] )
Int(hex, Signed := false) {
	return Format("{:" (Signed?"d":"u") "}", hex)
} HexToInt(hex, Signed := false) {
	return Format("{:" (Signed?"d":"u") "}", hex)
}

;convertir a Float
;Sintaxis: Float( [valor], [max.decimales] )
Float(num, Type := "0.2") {
	return Format("{:" Type (RegExReplace(Type, "[^fegaEGA]")?"":"f") "}", num)
}

;convertir a RGB | extraer rojo, verde, azul
;Sintaxis: RGB( [color], [rojo (salida)], [verde (salida)], [azul (salida)] )
;Ejemplos:
	;MsgBox % RGB(8454016)
	;MsgBox % "R: " RGB(0x80FF80,, G, B) ", G: " G ", B: " B
	;MsgBox % "R: " RGB("#DECAFE",, G, B) ", G: " G ", B: " B
RGB(Color := "", ByRef R := "", ByRef G := "", ByRef B := "") {
	if (Color="") {
		DllCall("msvcrt.dll\sprintf", "Str", V:="000000", "Str", "#%06X", "UInt", (R<<16)+(G<<8)+B)
		return V
	} if (IsByRef(R)) || (IsByRef(G)) || (IsByRef(B)) {
		if (InStr(Color, "#")) {
			NumPut("0x" SubStr(Color, -5), V:="000000")
			return R := NumGet(V,2,"UChar"), G := NumGet(V,1,"UChar"), B := NumGet(V,0,"UChar")
		} Color := Hex(Color, 6)
		return R := (Color & 0xFF), G := ((Color & 0xFF00) >> 8), B := ((Color & 0xFF0000) >> 16)
	} Color := (Color & 255) << 16 | (Color & 65280) | (Color >> 16), Color := SubStr(Color, 1)
	return Hex(Color, 6, true)
} ;R := ((Color & 0xFF0000) >> 16), G := ((Color & 0xFF00) >> 8), B := (Color & 0xFF)

;convertir RGB a BGR
RGBToBGR(rgb) {
 	return Hex(((rgb & 255) << 16) | (((rgb >> 8) & 255) << 8) | (rgb >> 16), 6, true)
}   

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir twips a píxeles
TwipToPixel(Twip, Round := false, Places := 0) {
	Twips := (Twip * (1.0 / 1440.0) * A_ScreenDPI)
	return (Round?Round(Twips, Places):Twips)
} ;https://es.wikipedia.org/wiki/Twip

;convertir pixeles a twips
PixelToTwip(Pixel, Round := false, Places := 0) {
	Pixels := (Pixel / (1.0 / 1440.0) / A_ScreenDPI)
	return (Round?Round(Pixels, Places):Pixels)
} ;https://es.wikipedia.org/wiki/Píxel

;convertir entero a hexadecimal
IntToHex(Int, Prefix := "0x") {
	h := 8.000000
	while (h--)
		n := ((Int >> (h * 4)) & 0xf), v .= n>9?Chr(0x37+n):n
		, v .= h=0&&(h//(8/4))=0?A_Space:""
	return Prefix v
}

;convertir binario a hexadecimal
BinToHex(Bin, Prefix := "0x") {
	static h := "0123456789ABCDEF"
	d := 0, l := StrLen(Bin)
   Loop, Parse, % Bin,, %A_Space%%A_Tab%`n
	{ d += (d + A_LoopField)
		If ((A_Index&3)=(l&3))
			x := x SubStr(h, d+1, 1), d := 0
   } return Prefix x
}

;convertir binario a octal
BinToOct(Bin) {
    i := Oct := Dec := 0
    while (Bin != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		} Dec += Mod(Bin, 10) * z
        i++
        Bin /= 10
    } i := 1
    while (Dec != 0) {
        Oct += Mod(Dec, 8) * i
        Dec /= 8
        i *= 10
    } return Oct
}

;convertir binario a decimal
BinToDec(Bin) {
    i := Dec := 0
    while (Bin != 0) {
        rem := Mod(Bin, 10)
		Bin /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		} Dec += rem * z
		i++
    } return Dec
}

;convertir binario a string
;Ejemplo: MsgBox % BinToStr("01000010 01101001 01101110 01010100 01101111 01010011 01110100 01110010")
BinToStr(Bin) {
	Bin := RegExReplace(Bin, "[^0-1]") ;extraer 0 y 1
	Loop {
		if (v:=128) && !(a:=0) && !(StrLen(b:=SubStr(Bin, -7))=8)
			break
		Loop, Parse, % b
			a := A_LoopField=1?(a+v):a, v /= 2
		OutputVar := Chr(a) OutputVar, Bin := SubStr(Bin, 1, -8)
	} return OutputVar
}

;convertir string a binario
;Ejemplo: MsgBox % StrToBin("StrToBin") "`n" StrToBin("StrToBin", "")
StrToBin(String, Prefix := " ") {
	Loop, Parse, % String
	{ v := 128, b := Asc(A_LoopField)
		Loop, 8
			b := (l:=(Log(b-v)=""))?b:(b-v), OutputVar .= l?0:1, v /= 2
		OutputVar .= Prefix
	} return Trim(OutputVar)
}

;convertir decimal a binario
DecToBin(Dec) {
    Bin := !(i:=1)
    while (Dec != 0) {
        rem := Mod(Dec, 2)
        Dec /= 2
        Bin += rem * i
        i *= 10
	} return Bin
}

;convertir decimal a hexadecimal
DecToHex(Dec) {
    VarSetCapacity(s, 66, 0)
    , value := DllCall("msvcrt.dll\_wcstoui64", "Str", 119, "UInt", 0, "UInt", Dec, "CDECL Int64")
    , DllCall("msvcrt.dll\_i64tow", "Int64", value, "Str", s, "UInt", 16, "CDECL")
    return s
}

;convertir decimal a octal
DecToOct(Dec) {
    Oct := !(i:=1)
    while (Dec > 0) {
        rem := Mod(Dec, 8)
        Dec /= 8
        Oct += rem * i
        i *= 10
    } return Oct
}

;convertir octal a decimal
OctToDec(Oct) {
    i := Dec := 0
    while (Oct != 0) {
        rem := Mod(Oct, 10)
        Oct /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		} Dec += rem * z
        i++
    } return Dec
}

;convertir octal a binario
OctToBin(Oct) {
    i := Dec := Bin := 0
    while (Oct != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		} Dec += Mod(Oct, 10) * z
        i++
        Oct /= 10
    } i := 1
    while (Dec != 0) {
        Bin += Mod(Dec, 2) * i
        Dec /= 2
        i *= 10
    } return Bin
}

;convertir hexadecimal a decimal
HexToDec(Hex) {
    VarSetCapacity(s, 66, 0)
    , value := DllCall("msvcrt.dll\_wcstoui64", "Str", 77, "UInt", 0, "UInt", Hex, "CDECL Int64")
    , DllCall("msvcrt.dll\_i64tow", "Int64", value, "Str", s, "UInt", 10, "CDECL")
    return s
}

;convertir hexadecimal a string
;Ejemplo: MsgBox % HexToStr("0x53 0x74 0x72 0x54 0x6f 0x48 0x65 0x78") "`n" HexToStr("537472546f486578") "`n" HexToStr("0x530x740x720x540x6f0x480x650x78")
HexToStr(Hex) {
	Hex := RegExReplace(StrReplace(Hex, "0x"), "[^0-9a-zA-Z]") ;extraer números y letras y quitar prefijo 0x (si lo tiene)
	Loop, Parse, % Hex 
	{ h .= A_LoopField
		if (StrLen(h)=2)
			OutputVar .= Chr(DllCall("msvcrt.dll\_wcstoui64", "WStr", h, "Ptr", 0, "Int", 16, "CDECL Int64")), h := ""
	} return OutputVar
}

;convertir hexadecimal a RGB
;Sintaxis: HexToRGB( [hex], [R (salida)], [G (salida)], [B (salida)] )
HexToRGB(Hex, ByRef R := "", ByRef G := "", ByRef B := "") {
    H := InStr(Hex, "0x")?Hex:(InStr(Hex, "#")?"0x" SubStr(Hex, 2):"0x" Hex)
	return (R := (H & 0xFF0000) >> 16) "," (G := (H & 0xFF00) >> 8) "," (B := (H & 0xFF))
}

;convertir RGB a hexadecimal
;Sintaxis 1: RGBToHex( [rojo], [verde], [azul], [prefijo] )
;Sintaxis 2: RGBToHex( [RGB],,, [prefijo] )
RGBToHex(R, G := "", B := "", Prefix := "0x") {
	if (G="") || (B="")
		RGB(R, R, G, B)
    VarSetCapacity(Hex, 34, 0)
    , DllCall("Shlwapi.dll\wnsprintf", "Str", Hex, "Int", 17, "Str", "%016I64X", "UInt64", (R << 16) + (G << 8) + B, "Int")
    return Prefix SubStr(Hex, StrLen(Hex) - 6 + 1)
}

;convertir RGB a entero
;Sintaxis 1: RGBToInt( [rojo], [verde], [azul] )
;Sintaxis 2: RGBToInt( [RGB] )
RGBToInt(R, G := "", B := "") {
	return Int(RGBToHex(R, G, B))
}

;convertir cadena de carácteres a hexadecimal
;MsgBox % StrToHex("StrToHex") "`n" StrToHex("StrToHex", "")
StrToHex(Str, Prefix := " 0x") {
    Loop, Parse, % Str
	{	DllCall("msvcrt.dll\_i64tow_s", "Int64", Asc(A_LoopField), "WStr", l, "UInt", VarSetCapacity(l, 65, 0), "Int", 16, "CDECL")
		if (ErrorLevel) || (l="")
			DllCall("msvcrt.dll\_i64tow", "Int64", Asc(A_LoopField), "WStr", l, "Int", 16, "CDECL")
		OutputVar .= Prefix l
	} return Trim(OutputVar)
} ;https://msdn.microsoft.com/en-us/library/0we9x30h.aspx

;Convierte una cadena que representa un número decimal o hexadecimal a un entero
StrToInt(String, Flags := 0x1) {
	DllCall("shlwapi.dll\StrToIntEx", "Ptr", &String, "Int", Flags, "Int*", Ret)
	return Ret
}

;Convierte una cadena que representa un valor decimal o hexadecimal a un entero de 64 bits
StrToInt64(String, Flags := 0x1) {
	DllCall("shlwapi.dll\StrToInt64Ex", "Ptr", &String, "Int", Flags, "Int64*", Ret)
	return Ret
}

;convertir Float a Integer.
FloatToInt(Float) {
	return DllCall("MulDiv", "Float", Float, "Int", 1, "Int", 1, "UInt")
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir tiempo. hora, minuto, segundo, milisegundo, dias, mes, año.
;Sintaxis: ConvertTime( [tiempo], [de], [a], [decimales 0~14] )
;Uso: ConvertTime( [h:m:s|hora|min|sec|ms|dia|mes|año], [time|hour|min|sec|ms|day|mon|year], [hour|min|sec|ms|day|mon|year] )
;EJEMPLOS (ver funcion): MsgBox % ConvertTime( 0xFFF, "ms", "sec", 0 )
ConvertTime(time, from, to, Places := 2) {
	;--------------------------------------------------------------------------------------------------------------------------------
	;tiempo: ConvertTime( "01:60:3600", "time", "hour" ) ;1hora 60min 3600seg = 3horas
	if (from = "time")
		RegExMatch(time, "(?<h>\d+):(?<m>\d+):(?<s>\d+)", _)
		, time_hour := _h+(_m/60)+(_s/3600), time_min := (_h*60)+_m+(_s/60)
		, time_sec := (_h/3600)+(_m*60)+_s, time_ms := (_h*3600000)+(_m*60000)+(_s*1000)
		, time_day := (_h/24)+(_m/1440)+(_s/86400), time_mon := (_h/730.484398)+(_m/43829.0639)+(_s/2629743.83)
		, time_year := (_h/8765.81277)+(_m/525948.766)+(_s/31556926)
	;--------------------------------------------------------------------------------------------------------------------------------
	;milisegundos: ConvertTime( 60000, "ms", "min" ) ;60000ms = 1min
	else if (from = "ms")
		ms_hour := time/3600000, ms_min := time/60000, ms_sec := time*0.001
		, ms_day := time/86400000, ms_mon := time/2629743830, ms_year := time/31556926000
	;--------------------------------------------------------------------------------------------------------------------------------
	;segundos: ConvertTime( 3600, "sec", "min" ) ;3600seg = 60minutos
	else if (from = "sec")
		sec_hour := time/3600, sec_min := time/60, sec_ms := time*1000
		, sec_day := time/86400, sec_mon := time/2629743.83, sec_year := time/31556926
	;--------------------------------------------------------------------------------------------------------------------------------
	;minutos: ConvertTime( 1, "min", "sec" ) ;1min = 60seg
	else if (from = "min")
		min_hour := time/60, min_sec := time*60, min_ms := time*60000
		, min_day := time/1440, min_mon := time/43829.0639, min_year := time/525948.766
	;--------------------------------------------------------------------------------------------------------------------------------
	;horas: ConvertTime( 2, "hour", "min" ) ;2horas = 120min
	else if (from = "hour")
		hour_min := time*60, hour_sec := time*3600, hour_ms := time*3600000
		, hour_day := time/24, hour_mon := time/730.484398, hour_year := time/8765.81277
	;--------------------------------------------------------------------------------------------------------------------------------
	;días: ConvertTime( 1, "day", "hour" ) ;1dia = 24horas
	else if (from = "day")
		day_hour := time*24, day_min := time*1440, day_sec := time*86400, day_ms := time*86400000
		, day_mon := time/30, day_year := time/365.242199
	;--------------------------------------------------------------------------------------------------------------------------------
	;mes: ConvertTime( 1, "mon", "hour" ) ;1mes = 730,48horas
	else if (from = "mon")
		mon_hour := time*730.484398, mon_min := time*43829.0639, mon_sec := time*2629743.83, mon_ms := time*2629743830
		, mon_day := time*30, mon_year := time/12
	;--------------------------------------------------------------------------------------------------------------------------------
	;año: ConvertTime( 1, "year", "mon" ) ;1año = 12meses
	else if (from = "year")
		year_hour := time*8765.81277, year_min := time*525948.766, year_sec := time*31556926, year_ms := time*31556926000
		year_day := time*365.242199, year_mon := time*12
	;--------------------------------------------------------------------------------------------------------------------------------
	return Round(%from%_%to%, Places)
}

;añadir marca decimal a un numero (coma o punto, por defecto: automatico dependiendo del idioma del sistema)
;Sintaxis 1: GetNumberFormat( [número], [codigo de idioma, punto o coma] )
;Sintaxis 2 (WIN_V+): GetNumberFormatEx( [número], [cadena de idioma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;Cadenas de idioma: https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
;EJEMPLO: MsgBox % GetNumberFormat(1000000.99, ".") "`n" GetNumberFormatEx(1024.75, "en-US")
GetNumberFormat(Number, Locale := 0x0400) {
	Locale := Locale="."?0x0456:Locale=","?0x0409:!Locale?0x0400:Locale
	, Size := DllCall("Kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Ptr", 0, "Int", 0)
    , VarSetCapacity(OutputVar, Size * 2)
	, r := DllCall("Kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Str", OutputVar, "Int", Size)
    return OutputVar
} GetNumberFormatEx(Number, Locale := "!x-sys-default-locale") { ;WIN_V+ (recomendado)
	Size := DllCall("Kernel32.dll\GetNumberFormatEx", "Ptr", &Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Ptr", 0, "Int", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, r := DllCall("Kernel32.dll\GetNumberFormatEx", "Ptr", &Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Str", OutputVar, "Int", Size)
	return OutputVar
} ;http://ahkscript.org/boards/viewtopic.php?p=56005#p56005

;Formatea una serie de números como una cadena de moneda para un entorno local especificado
;Sintaxis 1: GetCurrencyFormat( [cadena], [código de idioma] )
;Sintaxis 2 (WIN_V+): GetCurrencyFormatEx( [cadena], [cadena de idioma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;Cadenas de idioma: https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
;EJEMPLO: MsgBox % GetCurrencyFormat(0.99) "`n" GetCurrencyFormatEx(2.75, "en-US")
GetCurrencyFormat(String, Locale := 0x0400) {
	Size := DllCall("Kernel32.dll\GetCurrencyFormatW" , "UInt", Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Ptr", 0, "Int", 0) 
	, VarSetCapacity(OutputVar, Size * 2,  0)
	, r := DllCall("Kernel32.dll\GetCurrencyFormatW" , "UInt", Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Str", OutputVar, "Int", Size)
    return OutputVar, ErrorLevel := !r
} GetCurrencyFormatEx(String, Locale := "!x-sys-default-locale") { ;WIN_V+ (recomendado)
	Size := DllCall("Kernel32.dll\GetCurrencyFormatEx" , "Ptr", &Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Ptr", 0, "Int", 0) 
	, VarSetCapacity(OutputVar, Size * 2,  0)
	, r := DllCall("Kernel32.dll\GetCurrencyFormatEx" , "Ptr", &Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Str", OutputVar, "Int", Size)
    return OutputVar, ErrorLevel := !r
} ;http://ahkscript.org/boards/viewtopic.php?p=56005#p56005

;saca el promedio
NumAverage(num*) {
	Sum := 0, num := num.MaxIndex()=1?StrSplit(num[1], ",", A_Space A_Tab):num
	Loop, % num.MaxIndex()
		Sum += num[A_Index]
	return Sum/(num.MaxIndex()+0.0)
}

;genera un número pseudo-aleatorio
;Sintaxis 1: Random( [min (-2147483648)], [max (2147483647)], [1~4294967295] )
;Sintaxis 2: RandomEx( [min], [max], [decimales] )
Random(Min := -2147483648, Max := 2147483647, NewSeed := 0) {
	if (NewSeed) {
		Random,, %NewSeed%
		return NewSeed
	} Random, RandNum, %Min%, %Max%
	return RandNum
} RandomEx(Min, Max, Round := 0, Bits := 52) {
    DllCall("Advapi32.dll\CryptAcquireContextW", "Ptr*", hProv:=0, "Ptr", 0, "Ptr", 0, "UInt", 1, "UInt", 0xF0000000|0x40)
    , Bytes := Ceil(Bits/8), VarSetCapacity(Data, Bytes)
    , DllCall("Advapi32.dll\CryptGenRandom", "Ptr", hProv, "UInt", Bytes, "Ptr", &Data)
    , NumPut(((0xff >> (7-Mod(Bits-1, 8))) & NumGet(Data, Bytes-1, "UChar")), Data, Bytes-1, "UChar")
    , DllCall("Advapi32.dll\CryptReleaseContext", "Ptr", hProv, "UInt", 0)
	, r := ((NumGet(Data, 0, "UInt64") / 0xfffffffffffff) * (Max - Min)) + Min
    return (Round>-1)?Round(r, Round):r
} ;http://www.autohotkey.com/board/topic/70530-random-number-crypt-secure-rand-numberbuffer/

;determinar el porcentaje
;Sintaxis: Percent( [numero], [procentaje], [porcentaje (salida)], [decimales] )
;Ejemplo: MsgBox % "100 menos su 10%: " Percent(100, 10, Percent) "`n10% de 100: " Percent
;Return: devuelve la resta resultante del numero espesificado y el porncentaje espesificado de ese valor.
;3er Parámetro: devuelve el porcentaje espesificado para el valor espesificado.
Percent(num, Percent, ByRef OutputPercent := "", Places := 2) {
	return Float(num-(i:=(num/100)*Percent), "0." Places), OutputPercent := IsByRef(OutputPercent)?Round(i, Places):""
}

;descomposición prima
Factor(n, Delimiter := "`n") {
    if (n=1)
        return
    f := 2
	while (f<=n) {
        if (Mod(n, f)=0)
            return f Delimiter Factor(n/f)
        f++
}} ;http://rosettacode.org/wiki/Prime_decomposition#AutoHotkey

;convertir radian a grado sexagesimal/centesimal
;Sintaxis: RadianToDegree( [radianes], [¿centesimal?] )
;Ejemplo: MsgBox % RadianToDegree(120) "`n" RadianToDegree(120, true) ;6875.493542 | 7639.437268
RadianToDegree(Radians, Centesimal := false) {
	if (Centesimal)
		return Radians*63.6619772368 ;200/pi | 200/3.14159265359 = 63.6619772368
	return Radians*57.2957795131 ;180/pi | 180/3.14159265359 = 57.2957795131
}

;convertir grado sexagesimal/centesimal a radian
;Sintaxis: RadianToDegree( [grados], [¿centesimal?] )
;MsgBox % DegreeToRadian(6875.493542) "`n" DegreeToRadian(7639.437268, true) ;120 | 120
DegreeToRadian(Degrees, Centesimal := false) {
	if (Centesimal)
		return Degrees*0.01570796326 ;pi/200 | 3.14159265359/200 = 0.01570796326
	return Degrees*0.01745329251 ;pi/180 | 3.14159265359/180 = 0.01745329251
}























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: GDIPLUS ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/ms533971(v=vs.85).aspx
;Funciones extraidas de «Gdip standard library v1.45 by tic»: http://ahkscript.org/boards/viewtopic.php?t=6517
;Notas: 
	;• antes de usar cualquier funcion de abajo: usar GdiplusStartup()
	;• cuando ya no necesite usarlas: usar GdiplusShutdown()
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES NECESARIAS ~ INICIO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;inicializar Windows GDI+
;Sintaxis: GdiplusStartup( [hModule (out)] )
;hModule: distinto de cero si es la primera vez que se inicia o despues de ejecutar GdiplusShutdown()
GdiplusStartup(ByRef hModule := "") {
	static hToken
	if (hModule="*") || (hModule="?") || (hToken)
		return hToken := hModule="*"?0:hToken, hModule := 0
	Error := ErrorLevel, hModule := GetModuleHandle("gdiplus.dll")?0:LoadLibrary("gdiplus.dll")
	, VarSetCapacity(l, A_PtrSize=8?24:16, 0), l := Chr(1)
	, DllCall("gdiplus.dll\GdiplusStartup", "PtrP", hToken, "Ptr", &l, "Ptr", 0)
	return hToken, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/ms534077(v=vs.85).aspx

;limpia los recursos utilizados por Windows GDI+
;Sintaxis: GdiplusShutdown( [hToken], [0|1] )
;hToken: HANDLE que devuelve GdiplusStartup, opcional si se inicio con GdiplusStartup.
GdiplusShutdown(hToken := 0, hModule := true) {
	if (hModule) {
		Error := ErrorLevel, DllCall("gdiplus.dll\GdiplusShutdown", "Ptr", hToken?hToken:GdiplusStartup("?"))
		if (hModule:=GetModuleHandle("gdiplus.dll"))
			FreeLibrary(hModule)
		ErrorLevel := Error, GdiplusStartup("*")
}} ;https://msdn.microsoft.com/en-us/library/ms534076(v=vs.85).aspx

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GdipCreateBitmapFromStream(pStream) {
	DllCall("gdiplus.dll\GdipCreateBitmapFromStream", "Ptr", pStream, "PtrP", pBitmap)
	return pBitmap
} ;GdipCreateBitmapFromStream

GdipCreateHBitmapFromBitmap(pBitmap, Background := 0xFFFFFFFF) {
	DllCall("gdiplus.dll\GdipCreateHBITMAPFromBitmap", "Ptr", pBitmap, "PtrP", hBitmap, "UInt", _getcolor(Background))
	return hBitmap
} ;https://msdn.microsoft.com/en-us/library/ms536295(v=vs.85).aspx

GdipCreateBitmapFromHBitmap(hBitmap, Palette := 0) {
	DllCall("gdiplus.dll\GdipCreateBitmapFromHBITMAP", "Ptr", hBitmap, "Ptr", Palette, "PtrP", pBitmap)
	return pBitmap
} ;https://msdn.microsoft.com/en-us/library/ms536314(v=vs.85).aspx

;obtener Bitmap desde el Portapapeles
;Return:
	;0 = ERROR
	;pBitmap = OK
;ErrorLevel:
	;-2 = no se ha encontrado ningun Bitmap
	;-1 = no se ha podido abrir el portapapeles
	;0 = OK
	;1 = error al obtener el hBitmap desde el portapapeles
	;2 = error al obtener pBitmap desde hBitmap.
GdipCreateBitmapFromClipboard() {
	if !OpenClipboard()
		return false, ErrorLevel := -1
	if !IsClipboardFormatAvailable(8)
		return false, ErrorLevel := -2, CloseClipboard()
	if !(hBitmap:=GetClipboardData(2))
		return false, ErrorLevel := true, CloseClipboard()
	CloseClipboard()
	if !(pBitmap:=GdipCreateBitmapFromHBitmap(hBitmap))
		return false, ErrorLevel := 2
	return pBitmap, ErrorLevel := false, DeleteObject(hBitmap)
}

GdipDisposeImage(pBitmap) {
	DllCall("gdiplus.dll\GdipDisposeImage", "Ptr", pBitmap)
}

GdipCreateBitmap(Width, Height, PixelFormat := 0x26200A) {
	DllCall("gdiplus.dll\GdipCreateBitmapFromScan0", "Int", Width, "Int", Height, "Int", 0, "Int", PixelFormat, "Ptr", 0, "PtrP", pBitmap)
	return pBitmap
} ;https://msdn.microsoft.com/en-us/library/ms536315(v=vs.85).aspx

GdipGraphicsFromImage(pBitmap) {
	DllCall("gdiplus.dll\GdipGetImageGraphicsContext", "Ptr", pBitmap, "PtrP", pGraphics)
	return pGraphics
}

GdipSetImageAttributesColorMatrix(Matrix) {
	VarSetCapacity(ColourMatrix, 100, 0), Matrix := RegExReplace(RegExReplace(Matrix
	, "^[^\d-\.]+([\d\.])", "$1", "", 1), "[^\d-\.]+", "|"), Matrix := StrSplit(Matrix, "|")
	Loop, 25
		Matrix := (Matrix[A_Index]!="")?Matrix[A_Index]:!Mod(A_Index-1, 6)
		, NumPut(Matrix, ColourMatrix, (A_Index-1)*4, "Float")
	DllCall("gdiplus.dll\GdipCreateImageAttributes", "PtrP", ImageAttr)
	, DllCall("gdiplus.dll\GdipSetImageAttributesColorMatrix", "Ptr", ImageAttr, "Int", 1, "Int", 1, "Ptr", &ColourMatrix, "Ptr", 0, "Int", 0)
	return ImageAttr
}

GdipGetImageWidth(pBitmap) {
   DllCall("gdiplus.dll\GdipGetImageWidth", "Ptr", pBitmap, "UIntP", Width)
   return Width
}

GdipGetImageHeight(pBitmap) {
   DllCall("gdiplus.dll\GdipGetImageHeight", "Ptr", pBitmap, "UIntP", Height)
   return Height
}

GdipDisposeImageAttributes(ImageAttr) {
	return DllCall("gdiplus.dll\GdipDisposeImageAttributes", "Ptr", ImageAttr)
}

GdipDrawImage(pGraphics, pBitmap, dx := "", dy := "", dw := "", dh := "", sx := "", sy := "", sw := "", sh := "", Matrix := 1) {
	if ((Matrix&1)="")
		ImageAttr := GdipSetImageAttributesColorMatrix(Matrix)
	else if !(Matrix=1)
		ImageAttr := GdipSetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")
	if (sx sy sw sh="") {
		if (dx dy dw dh="") {
			sx := dx := sy := dy := 0
			, sw := dw := GdipGetImageWidth(pBitmap)
			, sh := dh := GdipGetImageHeight(pBitmap)
		} else {
			sx := sy := 0
			, sw := GdipGetImageWidth(pBitmap)
			, sh := GdipGetImageHeight(pBitmap)
	}} himgr := DllCall("gdiplus.dll\GdipDrawImageRectRect", "Ptr", pGraphics, "Ptr", pBitmap, "Float", dx, "Float", dy
	, "Float", dw, "Float", dh, "Float", sx, "Float", sy, "Float", sw, "Float", sh, "Int", 2, "Ptr", ImageAttr, "Ptr", 0, "Ptr", 0)
	if (ImageAttr)
		GdipDisposeImageAttributes(ImageAttr)
	return himgr
}

GdipDeleteGraphics(pGraphics) {
	return DllCall("gdiplus.dll\GdipDeleteGraphics", "Ptr", pGraphics)
}

GdipCreateBitmapFromFile(File, Index := 1, IconSizes := "256|128|64|48|32|16") {
	SplitPath, File,,, Ext
	if (Ext="exe") || (Ext="dll") {
		Size := VarSetCapacity(ICONINFO, 16 + (2*A_PtrSize), 0)
		Loop, Parse, % IconSizes, |
		{ 	if !(hIcon:=ExtractIconEx(File, Index, A_LoopField, A_LoopField))
				continue
			if !(DllCall("User32.dll\GetIconInfo", "Ptr", hIcon, "Ptr", &ICONINFO, "Int")) || !(GetObject(c:=NumGet(ICONINFO, 12 + (A_PtrSize-4) + 4), Size, ICONINFO) && c) {
				DestroyIcon(hIcon), hIcon := ""
				continue
			} break
		} if !(hIcon)
			return false
		hbm := CreateDIBSection(Width:=NumGet(ICONINFO, 4, "Int"), -(Height:=NumGet(ICONINFO, 8, "Int"))), hDC := CreateCompatibleDC(), hSelectObj := SelectObject(hDC, hbm)
		if !DrawIcon(hDC,,, hIcon, Width, Height)
			return false, DestroyIcon(hIcon)
		GetObject(hbm, A_PtrSize=8?104:84, dib, 104), Stride := NumGet(dib, 12, "Int"), Bits := NumGet(dib, 20 + (A_PtrSize-4))
		, DllCall("gdiplus.dll\GdipCreateBitmapFromScan0", "Int", Width, "Int", Height, "Int", Stride, "Int", 0x26200A, "Int", Bits, "PtrP", pBitmapOld)
		, pBitmap := GdipCreateBitmap(Width, Height), pGraphics := GdipGraphicsFromImage(pBitmap), GdipDrawImage(pGraphics, pBitmapOld, 0, 0, Width, Height, 0, 0, Width, Height)
		, SelectObject(hDC, obm), DeleteObject(obm), DeleteDC(hDC), GdipDeleteGraphics(pGraphics), GdipDisposeImage(pBitmapOld), DestroyIcon(hIcon)
	} else DllCall("gdiplus.dll\GdipCreateBitmapFromFile", "Ptr", &File, "PtrP", pBitmap)
	return pBitmap
}

;pBitmap To File
;Sintaxis: GdipSaveBitmapToFile( [pBitmap], [archivo], [jpg calidad 0~100], [¿sobreescribir archivo?] )
;Extensiones soportadas: BMP|DIB|RLE|JPG|JPEG|JPE|JFIF|GIF|TIF|TIFF|PNG
;Return: 0|1
GdipSaveBitmapToFile(pBitmap, File, Quality := 100, OverWrite := true) {
	if !(OverWrite) && (FileExist(File))
		return false, ErrorLevel := 5 ;5=el archivo ya existe
	File := GetFullPathName(File), SplitPath(File,, Dir, Ext)
	if !(InVar(Ext, "bmp,dib,rle,jpg,jpeg,jpe,jfif,gif,tif,tiff,png")) 
		return false, ErrorLevel := 4 ;4=extension no soportada
	DllCall("gdiplus.dll\GdipGetImageEncodersSize", "UIntP", Count, "UIntP", Size)
	, VarSetCapacity(ci, Size, 0), DllCall("gdiplus.dll\GdipGetImageEncoders", "UInt", Count, "UInt", Size, "Ptr", &ci)
	if !(Count) && !(Size)
		return false, ErrorLevel := 2 ;2=no se pudo obtener una lista de los codificadores en el sistema
	Loop, %Count% {
		if !(InStr(Str:=StrGet(NumGet(ci, (idx:=(48+7*A_PtrSize)*(A_Index-1))+32+3*A_PtrSize), "UTF-16"), "*." Ext))
			continue
		Codec := &ci+idx
		break
	} if !(DirCreate(Dir)="*") && !(Codec)
		return false, ErrorLevel := 3 ;3=no se pudo encontrar codificador para el formato de archivo especificado
	if !(Quality=75) {
		if !((Quality:=Quality<0?0:Quality>100?100:Quality)="*") && (InVar(Ext, "jpg,jpeg,jpe,jfif")) {
			DllCall("gdiplus.dll\GdipGetEncoderParameterListSize", "Ptr", pBitmap, "Ptr", Codec, "UIntP", Size), VarSetCapacity(EncoderParameters
			, Size, 0), DllCall("gdiplus.dll\GdipGetEncoderParameterList", "Ptr", pBitmap, "Ptr", Codec, "UInt", Size, "Ptr", &EncoderParameters)
			Loop, % NumGet(EncoderParameters, 0, "UInt") {
				elem := (24+A_PtrSize)*(A_Index-1) + 4 + (pad:=A_PtrSize-4)
				if (NumGet(EncoderParameters, elem+16, "UInt")=1) && (NumGet(EncoderParameters, elem+20, "UInt")=6) {
					p := elem+&EncoderParameters-pad-4, NumPut(Quality, NumGet(NumPut(4, NumPut(1, p+0)+20, "UInt")), "UInt")
					break
	}	}	}	} return Error:=!DllCall("gdiplus.dll\GdipSaveImageToFile", "Ptr", pBitmap, "Ptr", &File, "Ptr", Codec, "UInt", p?p:0), ErrorLevel := !Error ;1=error al guardar el archivo
}

GdipGetImageDimensions(pBitmap, ByRef Width := "", ByRef Height := "") {
	if (w:=true) && IsByRef(Width)
		w := !DllCall("gdiplus.dll\GdipGetImageWidth", "Ptr", pBitmap, "UIntP", Width)
	if (h:=true) && IsByRef(Height)
		h := !DllCall("gdiplus.dll\GdipGetImageHeight", "Ptr", pBitmap, "UIntP", Height)
	return h&&w, ErrorLevel := !(h&&w)
}

;Bitmap From Screen
;Sintaxis: GdipBitmapFromScreen( [pantalla], [raster], [hWnd] )
;Pantalla:
	;0 = todas
	;x|y|w|h = coordenadas
GdipBitmapFromScreen(Screen := 0, Raster := 0x00CC0020, hWnd := 0) {
	if (Screen=0) && (Pos:=[])
		Pos[1] := SysGet(76), Pos[2] := SysGet(77), Pos[3] := SysGet(78), Pos[4] := SysGet(79)
	else Pos := StrSplit(Screen, "|", A_Space A_Tab)
	hDC := CreateCompatibleDC(), hbm := CreateDIBSection(Pos[3], Pos[4], hDC), hSelObject := SelectObject(hDC, hbm)
	, hDC2 := GetDC(hWnd, 0, hWnd?3:0), BitBlt(hDC,,, Pos[3], Pos[4], hDC2, Pos[1], Pos[2], Raster)
	, ReleaseDC(0, hDC2), pBitmap := GdipCreateBitmapFromHBITMAP(hbm), SelectObject(hDC, hSelObject)
	return pBitmap, DeleteObject(hbm), DeleteDC(hDC2, hDC)
}

GdipAddPathBeziers(pPath, Points) {
	Points := StrSplit(Points, "|", A_Space A_Tab)
	, VarSetCapacity(Point, Points.MaxIndex() * 8, 0)
	for k, v in Points
		Coord := StrSplit(Points[A_Index], ",", A_Space A_Tab)
		, NumPut(Coord[1], Point, (A_Index-1) * 8, "Float")
		, NumPut(Coord[2], Point, ((A_Index-1) * 8) + 4, "Float")
	return DllCall("gdiplus.dll\GdipAddPathBeziers", "Ptr", pPath, "Ptr", &Point, "Int", Points.MaxIndex())
} ;https://msdn.microsoft.com/en-us/library/ms535620(v=vs.85).aspx

GdipAddPathBezier(pPath, spx := 0, spy := 0, fcpx := 0, fcpy := 0, scpx := 0, scpy := 0, epx := 0, epy := 0) {
	return DllCall("gdiplus.dll\GdipAddPathBezier", "Ptr", pPath, "Float", spx, "Float", spy, "Float", fcpx
	, "Float", fcpy, "Float", scpx, "Float", scpy, "Float", epx, "Float", epy)
} ;https://msdn.microsoft.com/en-us/library/ms535622(v=vs.85).aspx

GdipAddPathLines(pPath, Points) {
	Points := StrSplit(Points, "|", A_Space A_Tab)
	, VarSetCapacity(Point, Points.MaxIndex() * 8, 0)
	for k, v in Points
		Coord := StrSplit(Points[A_Index], ",", A_Space A_Tab)
		, NumPut(Coord[1], Point, (A_Index-1) * 8, "Float")
		, NumPut(Coord[2], Point, ((A_Index-1) * 8) + 4, "Float")
	return DllCall("gdiplus.dll\GdipAddPathLine2", "Ptr", pPath, "Ptr", &Point, "Int", Points.MaxIndex())
} ;https://msdn.microsoft.com/en-us/library/ms535600(v=vs.85).aspx

GdipAddPathLine(pPath, spx, spy, epx, epy) {
	return DllCall("gdiplus.dll\GdipAddPathLine", "Ptr", pPath, "Float", spx, "Float", spy, "Float", epx, "Float", epy)
} ;https://msdn.microsoft.com/en-us/library/ms535603(v=vs.85).aspx

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;funciones de calidad
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GdipSetInterpolationMode(pGraphics, Mode := 7) {
	return DllCall("gdiplus.dll\GdipSetInterpolationMode", "Ptr", pGraphics, "Int", Mode)
}

GdipSetSmoothingMode(pGraphics, Mode := 4) {
   return DllCall("gdiplus.dll\GdipSetSmoothingMode", "Ptr", pGraphics, "Int", Mode)
}

GdipSetTextRenderingHint(pGraphics, Hint := 4) {
	return DllCall("gdiplus.dll\GdipSetTextRenderingHint", "Ptr", pGraphics, "Int", Hint)
}

GdipSetCompositingMode(pGraphics, Mode := 0) {
   return DllCall("gdiplus.dll\GdipSetCompositingMode", "Ptr", pGraphics, "Int", !!Mode)
}
































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ADMINISTRACIÓN DE MEMORIA ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa366781(v=vs.85).aspx#general_memory_functions
;#############################################################################################################################################
;copia un bloque de memoria de un lugar a otro
;Sintaxis: CopyMemory[ [destino], [origen], [bytes] )
CopyMemory(ByRef Destination, Source, Bytes) {
	DllCall("msvcrt.dll\memcpy_s", "Ptr", Destination, "UInt", Bytes, "Ptr", Source, "UInt", Bytes)
}

;mover un bloque de memoria de un lugar a otro
;Sintaxis: MoveMemory[ [destino], [origen], [bytes] )
MoveMemory(ByRef Destination, Source, Bytes) {
	DllCall("msvcrt.dll\memmove_s", "Ptr", Destination, "UInt", Bytes, "Ptr", Source, "UInt", Bytes)
} 

;llena un bloque de memoria con el valor especificado
;Sintaxis: FillMemory( [destino], [bytes], [valor] )
FillMemory(ByRef Destination, Bytes, Fill) {
	DllCall("ntdll.dll\RtlFillMemory", "Ptr", Destination, "UInt", Bytes, "UChar", Fill) 
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff561870(v=vs.85).aspx

;llena un bloque de memoria con ceros
;Sintaxis: ZeroMemory( [destino], [bytes] )
ZeroMemory(ByRef Destination, Bytes) {
	DllCall("ntdll.dll\RtlZeroMemory", "Ptr", Destination, "UInt", Bytes)
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff563610(v=vs.85).aspx

;compara dos bloques de memoria
;Sintaxis: CompareMemory( [mem1], [mem2], [tamaño total, en bytes] )
;Return:
	;1 = mem1 > mem2
	;0 = mem1 = mem2
	;-1 = mem1 < mem2
CompareMemory(Source1, Source2, Size := 0) {
	if !(Size)
		Size1 := VarSetCapacity(Source1), Size2 := VarSetCapacity(Source2), Size := Size1<Size2?Size1:Size2
		, Result := DllCall("msvcrt.dll\memcmp", "UPtr", &Source1, "UPtr", &Source2, "UInt", Size, "CDecl Int")
	else Result := DllCall("msvcrt.dll\memcmp", "UPtr", Source1, "UPtr", Source2, "UInt", Size, "CDecl Int")
	return Result>0?1:Result<0?-1:0, ErrorLevel := ((Result+0)="")
}

;recupera la cantidad de memoria RAM en KB instalada físicamente de tablas de firmware SMBIOS (System Management BIOS) del equipo
;Ejemplo: MsgBox % Round(GetPhysicallyInstalledSystemMemory()/1024, 1) " MB"
;Nota: para recuperar solo la RAM, usar GlobalMemoryStatus().TotalPhys
GetPhysicallyInstalledSystemMemory() { ;WIN_V SP1+
	DllCall("Kernel32.dll\GetPhysicallyInstalledSystemMemory", "Int64P", TotalMemoryInKilobytes)
	return TotalMemoryInKilobytes
}

;recupera información sobre el uso actual de memoria física y virtual del sistema
;Ejemplo: MsgBox % (l:=GlobalMemoryStatus()) "Load: " l.Load " %`nRAM: " Round(l.TotalPhys/(1024**2), 1) " MB"
GlobalMemoryStatus() {
	VarSetCapacity(MEMORYSTATUSEX, 64, 0), NumPut(64, MEMORYSTATUSEX, "UInt")
	r := DllCall("Kernel32.dll\GlobalMemoryStatusEx", "Ptr", &MEMORYSTATUSEX)
	return !r?false:{Load: NumGet(MEMORYSTATUSEX, 4, "UInt") ;número entre 0 y 100 que especifica el porcentaje aproximado de la memoria física que está en uso
	, TotalPhys: NumGet(MEMORYSTATUSEX, 8, "UInt64") ;cantidad de memoria física real, en bytes
	, AvailPhys: NumGet(MEMORYSTATUSEX, 16, "UInt64") ;cantidad de memoria física disponible actualmente, en bytes
	, TotalPageFile: NumGet(MEMORYSTATUSEX, 24, "UInt64") ;límite de memoria comprometida actual para el sistema o el proceso actual, en bytes
	, AvailPageFile: NumGet(MEMORYSTATUSEX, 32, "UInt64") ;cantidad máxima de memoria que el proceso actual puede usar, en bytes.
	, TotalVirtual: NumGet(MEMORYSTATUSEX, 40, "UInt64") ;espacio de direcciones virtuales del proceso de llamada, en bytes
	, AvailVirtual: NumGet(MEMORYSTATUSEX, 48, "UInt64")} ;espacio disponible de direcciones virtuales del proceso de llamada, en bytes
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366589(v=vs.85).aspx

;recupera los límites de tamaño actuales para el conjunto de trabajo de la memoria caché del sistema
;Sintaxis: GetSystemFileCacheSize( [min, en bytes], [max, en bytes], [FILE_CACHE_MAX_HARD_ENABLE=1 | FILE_CACHE_MIN_HARD_ENABLE=4] )
;Ejemplo: MsgBox % GetSystemFileCacheSize(Min, Max, Flags) "`nMin: " Round(Min/(1024**2), 1) " MB" "`nMax: " Round(Max/(1024**2), 1) " MB" "`nFlags: " Flags
GetSystemFileCacheSize(ByRef MinimumFileCacheSize := "", ByRef MaximumFileCacheSize := "", ByRef Flags := "") {
	return DllCall("Kernel32.dll\GetSystemFileCacheSize", "Int64P", MinimumFileCacheSize, "Int64P", MaximumFileCacheSize, "UIntP", Flags)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa965224(v=vs.85).aspx

GlobalLock(hMem) {
	return DllCall("Kernel32.dll\GlobalLock", "Ptr", hMem, "Ptr")
} GlobalAlloc(Bytes, Flags := 0x0002) {
	return DllCall("Kernel32.dll\GlobalAlloc", "UInt", Flags, "UInt", Bytes, "Ptr")
} GlobalReAlloc(hMem, Bytes, Flags := 0x0002) {
	return DllCall("Kernel32.dll\GlobalReAlloc", "Ptr", hMem, "UInt", Bytes, "UInt", Flags, "Ptr")
} GlobalUnlock(hMem) {
	return DllCall("Kernel32.dll\GlobalUnlock", "Ptr", hMem, "UInt")
} GlobalFree(hMem) {
	return DllCall("Kernel32.dll\GlobalFree", "Ptr", hMem, "Ptr")
} GlobalSize(hMem) {
	return DllCall("Kernel32.dll\GlobalSize", "Ptr", hMem, "UInt")
} GlobalDiscard(hMem) {
	return DllCall("Kernel32.dll\GlobalDiscard", "Ptr", hMem, "Ptr")
} GlobalFlags(hMem) {
	return DllCall("Kernel32.dll\GlobalFlags", "Ptr", hMem, "UInt")
}

LocalFree(hMem*) {
	Error := ErrorLevel, Ok := 0
	for k, v in hMem
		Ok += !DllCall("Kernel32.dll\LocalFree", "Ptr", v, "Ptr")
	return Ok=hMem.MaxIndex(), ErrorLevel := Error
}

CreateStreamOnHGlobal(hGlobal, DeleteOnRelease := true) {
	DllCall("ole32.dll\CreateStreamOnHGlobal", "Ptr", hGlobal, "Int", !!DeleteOnRelease, "PtrP", IStream)
	return IStream
}

;cambia el estado de una región de la memoria dentro del espacio de direcciones virtuales de un proceso especificado. la memoria se asigna a cero. 
;Sintaxis: VirtualAlloc( [hProcess], [direccion], [tamaño], [tipo], [protección], [NUMA] )
;hProcess (opcional): HANDLE a un proceso, si no se utiliza, usa el proceso actual.
;Dirección (opcional): dirección de inicio de la región de asignar
;Tamaño: tamaño de la region, en bytes
;Tipo: tipo de asignación de memoria
	;MEM_COMMIT (defecto) = 0x00001000
	;MEM_RESERVE = 0x00002000
	;MEM_RESET = 0x00080000
	;MEM_RESET_UNDO = 0x1000000
	;---------------------------------------------------------
	;MEM_LARGE_PAGES = 0x20000000
	;MEM_PHYSICAL = 0x00400000
	;MEM_TOP_DOWN = 0x00100000
;Protección: la protección de la memoria para la región de páginas que se asignará
	;PAGE_EXECUTE = 0x10
	;PAGE_EXECUTE_READ = 0x20
	;PAGE_EXECUTE_READWRITE = 0x40
	;PAGE_EXECUTE_WRITECOPY = 0x80
	;PAGE_NOACCESS = 0x01
	;PAGE_READONLY = 0x02
	;PAGE_READWRITE (defecto) = 0x04
	;PAGE_WRITECOPY = 0x08
	;PAGE_TARGETS_INVALID = 0x40000000
	;PAGE_TARGETS_NO_UPDATE = 0x40000000
	;---------------------------------------------------------
	;PAGE_GUARD = 0x100
	;PAGE_NOCACHE = 0x200
	;PAGE_WRITECOMBINE = 0x400
;NUMA (opcional): nodo NUMA, donde la memoria física debe residir.
VirtualAlloc(ByRef hProcess := 0, ByRef Address := 0, ByRef Bytes := 0, AllocationType := 0x00001000, Protect := 0x04, Preferred := 0) {
	if !(hProcess) ;VirtualAlloc
		return DllCall("Kernel32.dll\VirtualAlloc", "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt", Protect, "UInt")
	if !(Preferred) ;VirtualAllocEx + hProcess | else VirtualAllocExNuma + NUMA
		return DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt", Protect, "UInt")
	return DllCall("Kernel32.dll\VirtualAllocExNuma", "Ptr", hProcess, "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt", Protect, "UInt", Preferred, "UInt")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366891(v=vs.85).aspx

;liberar una región de páginas dentro del espacio de direcciones virtuales del proceso espesificado
;Sintaxis: VirtualFree( [hProcess], [direccion], [tamaño, en bytes], [tipo] )
;Tipos:
	;MEM_DECOMMIT = 0x4000
	;MEM_RELEASE (defecto) = 0x8000
VirtualFree(hProcess := 0, Address := 0, Bytes := 0, AllocationType := 0x8000) {
	Error := ErrorLevel
	if !(hProcess) ;VirtualFree | else VirtualFreeEx + hProcess
		return DllCall("Kernel32.dll\VirtualFree", "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt"), ErrorLevel := Error
	return DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt"), ErrorLevel := Error
}









































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: DEVICE CONTEXT FUNCTIONS ::::::::::::::::::::::::::::::::::
;Notas:
	;usar DeleteDC para: CreateDC, CreateIC, CreateCompatibleDC
	;usar ReleaseDC para: GetDC
;#############################################################################################################################################
;crea un contexto de dispositivo (DC, device context) para un dispositivo utilizando el nombre especificado
;Sintaxis: CreateDC( [nombre], [nombre del dispositivo de salida], [data] )
;Return: hDC
CreateDC(Driver := "DISPLAY", Device := "", InitData := 0) {
	if (Driver="DISPLAY") && !(Device="") && !(Device=Driver) ;si Driver="DISPLAY" -> Device="" o Device="DISPLAY"
		Device := ""
	return DllCall("Gdi32.dll\CreateDC", "Ptr", Driver=""?0:&Driver, "Ptr", Device=""?0:&Device, "Ptr", 0, "Ptr", InitData, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/dd183490(v=vs.85).aspx

CreateCompatibleDC(hWnd := 0) {
	return DllCall("Gdi32.dll\CreateCompatibleDC", "Ptr", hWnd, "Ptr")
}

;recupera la información para el dispositivo especificado
;Sintaxis: GetDeviceCaps( [hDC], [Index], [return type] )
GetDeviceCaps(ByRef hDC := 0, Index := 1, ReturnType := "Int") {
	r := DllCall("Gdi32.dll\GetDeviceCaps", "Ptr", hDC?hDC:(DC:=CreateDC()), "Int", Index, ReturnType)
	if (DC)
		hDC := IsByRef(hDC)?DC:DllCall("Gdi32.dll\DeleteDC", "Ptr", DC, "Int")
	return r
} ;https://msdn.microsoft.com/en-us/library/dd144877(v=vs.85).aspx

GetStockObject(Object, ByRef hDC := 0) {
	if IsByRef(hDC)
		hDC := DllCall("User32.dll\GetDC", "Ptr", hDC?hDC:0, "Ptr")
	return DllCall("Gdi32.dll\GetStockObject", "Int", Object, "Ptr")
}

;Sintaxis: GetDC( [hWnd], [region], [modo] )
;hWnd: ventana_hwnd o 0 para toda la pantalla
;Return: hDC
GetDC(hWnd := 0, RegionClip := 0, Flags := 0) {
	if (RegionClip) || (Flags)
		return DllCall("User32.dll\GetDCEx", "Ptr", hWnd, "Ptr", RegionClip, "UInt", Flags)
	return DllCall("User32.dll\GetDC", "Ptr", hWnd, "Ptr")
}

;Sintaxis: ReleaseDC( [hWnd], [hDC] )
ReleaseDC(hWnd, hDC) {
	return DllCall("User32.dll\ReleaseDC", "Ptr", hWnd, "Ptr", hDC, "Int")
}

;Sintaxis: DeleteDC( [hDC] )
DeleteDC(hDC*) {
	Ok := 0
	Loop, % hDC.MaxIndex()
		Ok += !!DllCall("Gdi32.dll\DeleteDC", "Ptr", hDC[A_Index], "UInt")
	return Ok=hDC.MaxIndex()
}

;Sintaxis: BitBlt( [destino], [x], [y], [ancho], [alto], [source], [sx], [sy], [raster] )
;Raster: BLACKNESS = 0x00000042 | NOTSRCERASE = 0x001100A6 | NOTSRCCOPY = 0x00330008
	;SRCERASE = 0x00440328 | DSTINVERT = 0x00550009 | PATINVERT = 0x005A0049 | SRCINVERT = 0x00660046
	;SRCAND = 0x008800C6 | MERGEPAINT = 0x00BB0226 | MERGECOPY = 0x00C000CA | SRCCOPY = 0x00CC0020
	;SRCPAINT = 0x00EE0086 | PATCOPY = 0x00F00021 | PATPAINT = 0x00FB0A09 | WHITENESS = 0x00FF0062
	;CAPTUREBLT = 0x40000000 | NOMIRRORBITMAP = 0x80000000
BitBlt(dhdc, dx := 0, dy := 0, dw := 32, dh := 32, shdc := 0, sx := 0, sy := 0, Raster := 0x00CC0020) {
	return DllCall("gdi32.dll\BitBlt", "Ptr", dhdc, "Int", dx, "Int", dy, "Int", dw, "Int", dh, "Ptr", shdc, "Int", sx, "Int", sy, "UInt", Raster, "UInt")
} ;https://msdn.microsoft.com/en-us/library/dd183370(v=vs.85).aspx

StretchBlt(dhdc, dx := 0, dy := 0, dw := 32, dh := 32, shdc := 0, sx := 0, sy := 0, sw := 0, sh := 0, Raster := 0x00CC0020) {
	return DllCall("gdi32.dll\StretchBlt", "Ptr", dhdc, "Int", dx, "Int", dy, "Int", dw, "Int", dh
		, "Ptr", Source, "Int", sx, "Int", sy, "Int", sw, "Int", shdc, "UInt", Raster, "UInt")
}

;Sintaxis: SetStretchBltMode( [hDC], [modo] )
;Modos: STRETCH_ANDSCANS = 0x01 | |STRETCH_ORSCANS = 0x02 | STRETCH_DELETESCANS = 0x03 | STRETCH_HALFTONE = 0x04
;Return: 0 | modo_anterior
SetStretchBltMode(hDC, Mode := 0x04) {
	Ok := DllCall("gdi32.dll\SetStretchBltMode", "Ptr", hDC, "Int", Mode, "UInt")
	return Ok=87?false:Ok ;ERROR_INVALID_PARAMETER = 87
} ;https://msdn.microsoft.com/en-us/library/dd145089(v=vs.85).aspx

;actualiza la posición, el tamaño, la forma, el contenido y la translucidez de una ventana de capas.
;Sintaxis: UpdateLayeredWindow( [hWnd], [hDC], [x], [y], [ancho], [alto], [color] )
UpdateLayeredWindow(hWnd, hDC, x := "", y := "", Width := "", Height := "", Alpha := 255) {
	if !((x+0)="") && !((y+0)="")
		VarSetCapacity(POINT, 8), NumPut(x, POINT, 0, "Int"), NumPut(y, POINT, 4, "Int"), l := true
	if (Width="") || (Height="")
		WinGetPos(hWnd,,, _w, _h), Width := (Width+0)=""?_w:Width, Height := (Height+0)=""?_h:Height
	VarSetCapacity(SIZE, 8), NumPut(Width, SIZE, 0, "Int"), NumPut(Height, SIZE, 4, "Int")
	return DllCall("User32.dll\UpdateLayeredWindow", "Ptr", hWnd, "Ptr", 0, "Ptr", l?&POINT:0
		, "Ptr", &SIZE, "Ptr", hDC, "Ptr", 0, "Ptr", 0, "UIntP", Alpha<<16|1<<24, "UInt", 0x00000002)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633556(v=vs.85).aspx






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: FUENTES & COLORES & RECURSOS & DLL ::::::::::::::::::::::::::::::::::
;Recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff468901(v=vs.85).aspx
	;Parámetros:
		;hModule = LoadLibrary("C:\File.exe", 0x2)
		;HANDLE = BeginUpdateResource()
		;hResData = FindResource()
		;hResLoad = LoadResource()
		;Info/data/lpResLock = LockResource() / Binary DATA
	;Ejemplo de uso: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648008(v=vs.85).aspx#_win32_Updating_Resources
;#############################################################################################################################################
;recupera un HANDLE que puede ser utilizado por la función UpdateResource para agregar, eliminar o reemplazar los recursos en un módulo binario.
;Sintaxis: BeginUpdateResource( [archivo], [¿eliminar recursos existentes?] )
;Return: HANDLE
BeginUpdateResource(FileName, DeleteExistingResources := false) {
	return r:=DllCall("Kernel32.dll\BeginUpdateResourceW", "Ptr", &FileName, "Int", !!DeleteExistingResources, "Ptr"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648030(v=vs.85).aspx

;aplica o descarta los cambios hechos antes de una llamada a UpdateResource
;Sintaxis: EndUpdateResource( [HANDLE], [¿descartar cambios?] )
;Return: 0|1
EndUpdateResource(hModule, Discard := false) {
	return r:=DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hModule, "Int", !!Discard, "Int"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648032(v=vs.85).aspx

;EndUpdateResource() + BeginUpdateResource()
;Sintaxis: ReUpdateResource( [HANDLE], [archivo], [¿descartar cambios?], [¿eliminar recursos existentes?] )
;Return: HANDLE
ReUpdateResource(ByRef hModule, FileName, Discard := false, DeleteExistingResources := false) {
	EndUpdateResource(hModule, Discard)
	return hModule := BeginUpdateResource(FileName, DeleteExistingResources)
}

;recupera un HANDLE que se puede utilizar para obtener un puntero al primer byte del recurso especificado en la memoria
;Sintaxis: LoadResource( [hModule], [hResInfo] )
;Return: hResLoad
LoadResource(hModule, hResInfo) {
	return DllCall("Kernel32.dll\LoadResource", "Ptr", hModule, "Ptr", hResInfo, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648046(v=vs.85).aspx

;recupera un puntero al recurso especificado en la memoria
;Sintaxis: LockResource( [hResLoad] )
;Return: Pointer / ResLock / data / info
LockResource(hResLoad) {
	return r:=DllCall("Kernel32.dll\LockResource", "Ptr", hResLoad, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648047(v=vs.85).aspx

;determina la ubicación del recurso con el tipo, nombre y lenguaje espesificado en el módulo especificado
;Sintaxis: FindResource( [hModule], [nombre del recurso], [tipo de recurso], [lenguaje ID] )
;Tipos de recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx
;Nombre del recurso: espesifica el nombre o un array [dllcall_type str/ptr, nombre].
;Return: hResInfo
FindResource(hModule, ResName, ResType, Language := "") {
	ResName := IsObject(ResName)?ResName:[(ResName+0)=""?"Str":"Ptr", ResName]
	, ResType := IsObject(ResType)?ResType:[(ResType+0)=""?"Str":"Ptr", ResType]
	if (Language="")
		r := DllCall("Kernel32.dll\FindResourceW", "Ptr", hModule, ResName[1], ResName[2], ResType[1], ResType[2], "Ptr")
	else r := DllCall("Kernel32.dll\FindResourceExW", "Ptr", hModule, ResName[1], ResName[2], ResType[1], ResType[2], "UInt", Language, "Ptr")
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648043(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx

;agrega, elimina o sustituye un recurso en un archivo ejecutable portable (PE)
;Sintaxis: UpdateResource( [HANDLE], [tipo de recurso], [nombre del recurso], [lenguaje ID], [&binarydata\file\str], [bytes|modo] )
;Tipos de recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx
;Nombre del recurso: espesifica el nombre o un array [dllcall_type str/ptr, nombre]
;Modos:
	;File = añadir archivo. el 5to parámetro debe hacer referencia a un archivo existente o un array [archivo, codificación]
	;Str = añadir texto. el 5to parámetro debe contener el texto o un array [texto, codificación]
;Ejemplo 1: añadir texto en RC_DATA (10), usar un archivo válido.
	;Dll_CreateEmpty(File:=A_Desktop "\test_file.dll")
	;hFile := BeginUpdateResource(File), Text := "Texto a añadir"
	;MsgBox % UpdateResource(hFile, 10, ">My Resource Name<",, Text, "Str")
	;EndUpdateResource(hFile) ;terminar.
	;hResInfo := FindResource(hModule:=LoadLibrary(File, 0x2), ">My Resource Name<", 10) ;leer texto añadido -->
	;Data := LockResource(LoadResource(hModule, hResInfo))
	;MsgBox % StrGet(Data, SizeOfResource(hModule, hResInfo), "UTF-8")
	;FreeLibrary(hModule) ;<--
;Ejemplo 2: añadir archivo en RC_DATA (10), usar un archivo válido.
	;Dll_CreateEmpty(File:=A_Desktop "\test_file.dll")
	;hFile := BeginUpdateResource(File), File := ComSpec
	;MsgBox % UpdateResource(hFile, 10, ">CMD<",, File, "File")
	;EndUpdateResource(hFile)
;Return: 0|1
UpdateResource(hModule, ResType, ResName, Language := 0x0C00, Data := 0, Bytes := "*") {
	if !(Data=0) && (Bytes="*") && !(Bytes:=StrPut(Data)) ;calcular tamaño si se espesifico DATA pero no los bytes
		return false, ErrorLevel := true
	else if (Bytes="File") ;añadir archivo
		l := FileOpen(IsObject(Data)?Data[1]:Data, "r", Data[2]), l.RawRead(Bin, Bytes:=l.Length), l.Close(), Data := &Bin
	else if (Bytes="Str") ;añadir texto
		StrPutVar(IsObject(Data)?Data[1]:Data, Bin, Data[2]?Data[2]:"UTF-8", 1,, Bytes), Data := &Bin
	ResName := IsObject(ResName)?ResName:[(ResName+0)=""?"Str":"Ptr", ResName]
	, ResType := IsObject(ResType)?ResType:[(ResType+0)=""?"Str":"Ptr", ResType]
	, Bytes := IsObject(Bytes)?Bytes:[(Bytes+0)=""?"Ptr":"UInt", Bytes]
	, r:=DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hModule, ResType[1], ResType[2], ResName[1], ResName[2], "UShort", Language, "Ptr", Data, Bytes[1], Bytes[2], "UInt")
	return r, VarSetCapacity(Data, 0), VarSetCapacity(Bin, 0), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648049(v=vs.85).aspx

;recupera el tamaño, en bytes, del recurso espesificado
;Sintaxis: SizeofResource( [hModule, hResInfo] )
;Return: Bytes
SizeofResource(hModule, hResInfo) {
	return r:=DllCall("Kernel32.dll\SizeofResource", "Ptr", hModule, "Ptr", hResInfo, "UInt"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648048(v=vs.85).aspx

CreateResourceIndexer(projectRoot, extensionDllPath) { ;WIN_10+
	r:=DllCall("Mrmsupport.dll\CreateResourceIndexer", "WStr", projectRoot, "WStr", extensionDllPath, "PtrP", resourceIndexer, "UInt")
	return resourceIndexer, ErrorLevel := r ;S_OK = 0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/mt219668(v=vs.85).aspx

DestroyResourceIndexer(resourceIndexer) { ;WIN_10+
	return true, DllCall("Mrmsupport.dll\DestroyResourceIndexer", "PtrP", resourceIndexer), ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/mt219670(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES QUE TRABAJAN CON LAS ANTERIORES
;-------------------------------------------------------------------------------------------------------------------------------------------------
;añadir icono, reemplaza si existe
;Sintaxis: InsertIconResource( [HANDLE], [icono], [ID], [lenguaje ID] )
InsertIconResource(hModule, Icon, ID, Language := 0x0C00) {
	if !(hFile:=FileOpen(Icon, "r"))
		return false, ErrorLevel := 2
	VarSetCapacity(Data, 8, 0), hFile.RawRead(Data, 6)
	if !(NumGet(Data, 0, "UShort")=0) || !(NumGet(Data, 2, "UShort")=1)
		return false, ErrorLevel := 3
	IGs := VarSetCapacity(IG, 6 + (Count:=NumGet(Data, 4, "UShort"))*14, 0)
	, NumPut(NumGet(Data, 0,"Int64"), IG, 0, "Int64"), IGe := &IG + 6
	Loop, % (Count) {
		thisID := (ID - 1) + A_Index, hFile.RawRead(IGe+0, 12), NumPut(thisID, IGe+12, 0, "UShort")
		, imgOffset := hFile.ReadUInt(), oldPos := hFile.Pos, hFile.Pos := imgOffset
		, ICDs := VarSetCapacity(ICD, NumGet(IGe+8, 0, "UInt")),  hFile.RawRead(ICD, ICDs)
		, hFile.Pos := oldPos, UpdateResource(hModule, 3, thisID, Language, &ICD, ICDs), IGe += 14
	} return thisID + 1, UpdateResource(hModule, 14, ID, Language, &IG, IGs)
} 

;obtener HANDLE de una imagen en el ejecutable espesificado
;Sintaxis: PictureFromResource( [archivo o hModule], [nombre], [tipo], [color de fondo, RGB o nombre] )
;Ejemplo: usar Ahk2Exe.exe, LOGO.PNG, ResType=10 (RC_DATA)
	;hBitmap := PictureFromResource(RegRead("HKLM\SOFTWARE\AutoHotKey", "InstallDir") "\Compiler\Ahk2Exe.exe", "LOGO.PNG")
	;Gui, Add, Text, x0 y0 w240 h78 +0xE hwndhPicCtrl
	;SendMessage, 0x172, 0, hBitmap,, ahk_id %hPicCtrl%
	;Gui, Show
	;return
PictureFromResource(Exe, ResName, ResType := 10, Background := 0xFFFFFFFF) {
	if (((hModule:=Exe)+0)="") && !(hModule:=LoadLibrary(Exe, 0x2))
		return false, ErrorLevel := true
	hResource := FindResource(hModule, ResName, ResType), Size := SizeofResource(hModule, hResource), hLoadRes := LoadResource(hModule, hResource)
	, hLockRes := LockResource(hLoadRes), hGlobal := GlobalAlloc(Size), hLockGlob := GlobalLock(hGlobal), CopyMemory(hLockGlob, hLockRes, Size)
	, GlobalUnlock(hGlobal), pStream := CreateStreamOnHGlobal(hGlobal), GdiplusStartup(hModule), pBitmap := GdipCreateBitmapFromStream(pStream)
	, hBitmap := GdipCreateHBITMAPFromBitmap(pBitmap, Background), GdipDisposeImage(pBitmap), ObjRelease(pStream), GlobalFree(hGlobal)
	return hBitmap, ErrorLevel := !hBitmap, GdiplusShutdown(, hModule)
}  

;-------------------------------------------------------------------------------------------------------------------------------------------------
;DLL
;-------------------------------------------------------------------------------------------------------------------------------------------------
;crear .DLL vacía
;Sintaxis: Dll_CreateEmpty( [nombre.dll] )
Dll_CreateEmpty(DllFile) {    
	SplitPath, DllFile,,, Ext
	TS := A_NowUTC, DllFile .= Ext="dll"?"":".dll"
	TS -= 1970, S
	VarSetCapacity(Trg, 1536, 0), Numput(TS, Trg, 192)
	Loop, Parse, % "0X5A4DY3CXB8YB8X4550YBCX2014CYCCX210E00E0YD0X7010BYD8X400YE4X1000YE8X1000YECX78A"
		. "E0000YF0X1000YF4X200YF8X10005YFCX10005Y100X4Y108X3000Y10CX200Y114X2Y118X40000Y11CX2000Y120X10"
		. "0000Y124X1000Y12CX10Y140X1000Y144X10Y158X2000Y15CX8Y1B0X7273722EY1B4X63Y1B8X10Y1BCX1000Y1C0X"
		. "200Y1C4X200Y1D4X40000040Y1D8X6C65722EY1DCX636FY1E0X8Y1E4X2000Y1E8X200Y1ECX400Y1FCX42000040", XY
		if Mod(A_Index, 2)
			O := "0x" A_LoopField
		else NumPut("0x" A_LoopField, Trg, O, "UInt")
	if !(hFile:=CreateFile(DllFile, 0x40000000, 2))
		return false, ErrorLevel := 2
	return WriteFile(hFile, &Trg, 1536), CloseHandle(hFile)
}

;añadir «un icono o un conjunto de iconos en un directorio» a una libreria .DLL
;Sintaxis: Dll_InsertIcon( [DLL], [icono o directorio que contiene los iconos], [¿sobreescribir iconos?], [¿incluir iconos en subdirectorios?] )
Dll_InsertIcons(DllFile, Data, Overwrite := false, Recurse := false) {
	if (Overwrite)
		hModule := BeginUpdateResource(DllFile)
	if !(Count:=0) && !(Index:=0) && (IsFile(Data)) {
		Index++
		if !(Overwrite) {
			if (FindResource(hFile:=LoadLibrary(DllFile, 0x2), Index, 14)) {
				Loop
					Index++
				until !(FindResource(hFile, Index, 14))
			} FreeLibrary(hFile), hModule := BeginUpdateResource(DllFile)
		} InsertIconResource(hModule, Data, Index)
		return EndUpdateResource(hModule)
	} else if (IsDir(Data)) {
		Loop, Files, %Data%\*.ico, % Recurse?"FR":"F"
		{ if !(Overwrite) {
			Index++
			if (FindResource(hFile:=LoadLibrary(DllFile, 0x2), Index, 14)) {
				Loop
					Index++
				until !(FindResource(hFile, Index, 14))
			} FreeLibrary(hFile), ReUpdateResource(hModule, DllFile, Count:=0)
			} Count++, InsertIconResource(hModule, A_LoopFileFullPath, Overwrite?A_Index:Index)
			if (Count=40)
				ReUpdateResource(hModule, DllFile, Count:=0)
		} return EndUpdateResource(hModule)
	} return false, ErrorLevel := true
}

;-------------------------------------------------------------------------------------------------------------------------------------------------
;COLORES
;-------------------------------------------------------------------------------------------------------------------------------------------------
;dialogo para elegir color
;Sintaxis: ColorSelect( [ID ventana propietaria], [color], [¿mostrar todos los colores?] )
;Color: espesificar el color por defecto RGB o Nombre
;Notas: 
	;ErrorLevel es 1 si el usuario canceló el diálogo
	;la paleta de colores elegidos por el usuario se guarda en:  %A_AppData%\usercolorpalette.ini
;EJEMPLO: MsgBox % "Color: " ColorSelect(, "Red", true)
ColorSelect(hWnd := 0, Color := "", ShowAll := "") {
	static File := A_AppData "\usercolorpalette.ini"
	Color := RGBToInt(_getcolor(Color)), VarSetCapacity(CUSTOM, 16*A_PtrSize, 0)
	Loop, 16 ;obtener colores
		NumPut(IniRead(File, "Color", A_Index, false), CUSTOM, (A_Index-1)*4, "UInt")
	lStructSize := VarSetCapacity(CHOOSECOLOR, 9*A_PtrSize, 0)
	, NumPut(lStructSize, CHOOSECOLOR, 0, "UInt"), NumPut(hWnd, CHOOSECOLOR, A_PtrSize, "Ptr")
	, NumPut(Color=""?IniRead(File, "Default", "Color", false):Color, CHOOSECOLOR, 3*A_PtrSize, "Ptr")
	, NumPut(&CUSTOM, CHOOSECOLOR, 4*A_PtrSize, "PtrP")
	, NumPut(0x1|0x100|(ShowAll=0?0x4:ShowAll?0x2:0x0), CHOOSECOLOR, 5*A_PtrSize, "UInt")
	, r := DllCall("comdlg32.dll\ChooseColorW", "UPtr", &CHOOSECOLOR, "UInt")
	Loop, 16 ;guardar colores
		IniWrite(NumGet(custom, (A_Index-1)*4, "UInt"), File, "Color", A_Index)
	return RGB(Color:=NumGet(CHOOSECOLOR, 3*A_PtrSize, "UInt")), l:=r?IniWrite(Color, File, "Default", "Color"):l, ErrorLevel := !r
}

;obtiene el color RGB mediante el nombre
;Sintaxis: _getcolor( [color] )
;Nota: si el color no se encuentra, no lo modifica
_getcolor(c) {
	static Colors := {Aqua: "0x00FFFF", Black: "0x000000", Blue: "0x0000FF", Fuchsia: "0xFF00FF", Gray: "0x808080" ;nombres soportados
		, Green: "0x008000", Lime: "0x00FF00", Maroon: "0x800000", Navy: "0x000080", Olive: "0x808000", Purple: "0x800080"
		, Red: "0xFF0000", Silver: "0xC0C0C0", Teal: "0x008080", White: "0xFFFFFF", Yellow: "0xFFFF00"}
	return (Colors[c]="")?c:Colors[c] ;si el color espesificado no esta en «Colors» devuelve el color sin modificar
}

;-------------------------------------------------------------------------------------------------------------------------------------------------
;FUENTES
;Parámetros:
	;hFont: hFont (FontCreate) o dejar vacío (o cero) para usar la fuente por defecto
;-------------------------------------------------------------------------------------------------------------------------------------------------
;enumera todas las fuentes instaladas.
FontEnum(lfCharSet := 1, lfFaceName := "") {
	hDC := GetDC(), VarSetCapacity(LOGFONT, 92, 0), NumPut(lfCharSet, LOGFONT, 23, "UChar")
	if !(lfFaceName="")
		StrCopy(&LOGFONT+28, lfFaceName)
	lpEnumFunc := RegisterCallback("EnumFontFamExProc", "Fast", 4), Param := {List: ""}
	, DllCall("Gdi32.dll\EnumFontFamiliesExW", "Ptr", hDC, "Ptr", &LOGFONT, "Ptr", lpEnumFunc, "Ptr", &Param, "UInt", 0)
	, ReleaseDC(0, hDC), DllCall("Kernel32.dll\GlobalFree", "Ptr", lpEnumFunc)
	return Sort(Param.List, "U")
} EnumFontFamExProc(lpelfe, lpntme, FontType, lParam) {
	Param := Object(lParam), StrCopy(Name, lpelfe+28,, "Str")
	return true, Param.List .= (Param.List?"`n":"") Name
} FontExist(FontName, lfCharSet := 1, lfFaceName := "") {
	Loop, Parse, % FontEnum(lfCharSet, lfFaceName), `n, `r
		if (A_LoopField=FontName)
			return true
	return false
}

;crea una fuente con las caracteristicas espesificadas.
;Sintaxis: FontCreate( [fuente], [tamaño], [negrita], [¿cursiva?], [¿subrayado?], [¿tachado?], [Calidad] )
;Fuente: dejar vacio para usar la fuente por defecto
;Tamaño: dejar en 0 para usar el tamaño por defecto
;Negrita: 0 | 100 | 200 | 300 | 400 (normal) | 500 | 600 | 700 (negrita) | 800 | 900
;Calidad: 
	;DEFAULT_QUALITY = 0 | DRAFT_QUALITY = 1 | PROOF_QUALITY = 2
	;NONANTIALIASED_QUALITY = 3 | ANTIALIASED_QUALITY = 4 | CLEARTYPE_QUALITY = 5
;NOTA: cuando ya no use la fuente, eliminarla con FontDelete()
;Return: hFont
FontCreate(FontName := "", Size := 0, Bold := 400, Italic := false, Underline := false, StrikeOut := false, Quality := 5) {
	Error := ErrorLevel, FontName := FontName?FontName:FontQuery()[1], Size := Size>0?Size:FontQuery()[2]
	return DllCall("Gdi32.dll\CreateFontW", "Int", -MulDiv(Size, GetDeviceCaps(, 90), 72)
		, "Int", 0, "Int", 0, "Int", 0, "Int", Bold,"UInt", !!Italic, "UInt", !!Underline, "UInt", !!StrikeOut
		, "UInt", 1, "UInt", 4, "UInt", 0, "UInt", Quality, "UInt", 0, "Ptr", &FontName), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/dd183499(v=vs.85).aspx

;obtiene información sobre una fuente (hFont)
;Sintaxis: FontQuery( [hFont], [nombre], [tamaño], [negrita], [cursiva], [subrayado], [tachado] )
FontQuery(hFont := 0, ByRef Name := "", ByRef Size := "", ByRef Bold := "", ByRef Italic := "", ByRef Underline := "", ByRef Strike := "") {
	hFont := hFont?hFont:GetStockObject(17), hDC := GetDC(), hSelectObj := SelectObject(hDC, hFont)
	, Size := DllCall("Gdi32.dll\GetTextFace", "Ptr", hDC, "Ptr", 0, "Ptr", 0), VarSetCapacity(Name, (Size>0?Size:(Size:=32)) * 2, 0)
	, DllCall("Gdi32.dll\GetTextFace", "Ptr", hDC, "Ptr", Size, "Str", Name), LogPixelsY := GetDeviceCaps(hDC, 90)
	, VarSetCapacity(TEXTMETRIC, 60, 0), DllCall("Gdi32.dll\GetTextMetricsW", "Ptr", hDC, "Ptr", &TEXTMETRIC)
	, Size := Round((NumGet(TEXTMETRIC, 0, "Int")-NumGet(TEXTMETRIC, 12, "Int"))*72/LogPixelsY)
	, Bold := NumGet(TEXTMETRIC, 28, "Int"), Italic := !!NumGet(TEXTMETRIC, 52, "UChar")
	, Underline := !!NumGet(TEXTMETRIC, 53, "UChar"), Strike := !!NumGet(TEXTMETRIC, 54, "UChar")
	return [Name, Size, Bold, Italic, Underline, Strike], VarSetCapacity(FontName, -1), SelectObject(hDC, hSelectObj), ReleaseDC(0, hDC)
}

;dialogo para seleccionar fuente
;Sintaxis: FontSelect( [hWnd], [fuente], [opciones], [efectos 0|1], [opciones adicionales] )
;Parámetros:
	;hWnd: ventana propietaria
	;Opciones: array que contiene las opciones por defecto a mostrar, en el siguiente orden:
		;Color del texto = RGB o nombre
		;Tamaño, Tamaño Minimo, Tamaño Máximo = separados por coma, tamaño por defecto y Minimo/Máximo permitidos.
		;Negrita = 700 es negrita, 400 es normal.
		;Cursiva = 0|1
		;Subrayado = 0|1
		;Tachado = 0|1
	;Opciones Adicionales: sumar para combinar
		;0x00000200 = mostrar boton Aplicar
		;0x00000004 = mostrar boton Ayuda
		;0x00040000 = mostrar solo fuentes TrueType
		;0x02000000 = mostrar fuentes ocultas
		;0x00000100 (defecto) = habilita el subrayado, tachado y seleccion de color
		;0x00010000 (defecto) = la fuente debe existir
;Return: devuelve un Array con la informacion, en el mismo orden del 3er parametro (opciones). Array[0] contiene la fuente seleccionada
;ErrorLevel: 0|1. 1 si el usuario canceló el dialogo.
;EJEMPLO:
	;FontInfo := FontSelect(, "Arial", ["Lime", "12,10,20", 700, true, true, true])
	;MsgBox %  "Fuente: " FontInfo[0]
	;	. "`nColor: " FontInfo[1]
	;	. "`nTamaño: " FontInfo[2] "`nNegrita: " FontInfo[3] "`nCursiva: " FontInfo[4]
	;	. "`nSubrayado: " FontInfo[5] "`nTachado: " FontInfo[6] "`n`nErrorLevel: " ErrorLevel
FontSelect(hWnd := 0, FontName := "", Options := "", Flags := 0x10100) {
	FontName := FontName?FontName:FontQuery()[1]
	, Color := RGBToInt(_getcolor(Options[1]))
	, Size := StrSplit(Options[2], ",", A_Space A_Tab)
	, MinSize := Size[2], MaxSize := Size[3]
	, Size := Size[1]=""?FontQuery()[2]:Size[1]
	, Bold := Between(Options[3], 0, 900)?Options[3]:400
	, Italic := !!Options[4], Underline := !!Options[5], StrikeOut := !!Options[6]
	, hDC := CreateDC(), LogPixelsY := GetDeviceCaps(hDC, 90), DeleteDC(hDC)
	, Flags := 0x00000041|Flags|(MinSize!=""&&MaxSize!=""?0x00002000:0x00000000) ;0x00000008
    VarSetCapacity(LOGFONT, 92, 0) , NumPut(-MulDiv(Size, LogPixelsY, 72), LOGFONT, 0, "Int")
    , NumPut(Bold, LOGFONT, 16, "Int"), NumPut(Italic, LOGFONT, 20, "UChar")
    , NumPut(Underline, LOGFONT, 21, "UChar"), NumPut(StrikeOut, LOGFONT, 22, "UChar")
	, StrCopy(&LOGFONT+28, FontName), CFSize := VarSetCapacity(CHOOSEFONT, A_PtrSize=8?104:60, 0)
	, NumPut(CFSize, CHOOSEFONT, 0, "UInt"), NumPut(hWnd, CHOOSEFONT, A_PtrSize, "Ptr")
	, NumPut(&LOGFONT, CHOOSEFONT, A_PtrSize=8?24:12, "Ptr")
	, NumPut(Flags, CHOOSEFONT, A_PtrSize=8?36:20, "UInt")
	, NumPut(Color, CHOOSEFONT, A_PtrSize=8?40:24, "UInt")
	;, NumPut(CustData, CHOOSEFONT, A_PtrSize=8?48:28, "UInt")
	;, NumPut(nHook, CHOOSEFONT, A_PtrSize=8?56:32, "UInt")
	, NumPut(MinSize, CHOOSEFONT, A_PtrSize=8?92:52, "Int")
	, NumPut(MaxSize, CHOOSEFONT, A_PtrSize=8?96:56, "Int")
	, Ok := DllCall("comdlg32.dll\ChooseFontW", "Ptr", &CHOOSEFONT, "Int")
	, StrCopy(FontName, &LOGFONT+28,, "Str"), OutPutVar := [], OutPutVar[0] := FontName
	, OutPutVar[1] := RGB(NumGet(CHOOSEFONT, A_PtrSize=8?40:24, "UInt"))
	, OutPutVar[2] := NumGet(CHOOSEFONT, A_PtrSize=8?32:16, "Int")//10
	, OutPutVar[3] := NumGet(LOGFONT, 16, "Int"), OutPutVar[4] := NumGet(LOGFONT, 20, "UChar")
	, OutPutVar[5] := NumGet(LOGFONT,21,"UChar"), OutPutVar[6] := NumGet(LOGFONT, 22, "UChar")
	return OutPutVar, ErrorLevel := !Ok
}

;obtener tamaño dependiendo de la fuente y texto
;Sintaxis: FontGetStringSize( [fuente], [texto], [ancho (out)], [alto (out)], [ajustar ancho y alto] )
;Fuente: espesificar el nombre de una fuente o usar FontCreate()
FontGetStringSize(hFont := 0, String := "", ByRef Width := "", ByRef Height := "", Convert := true) {
	static Size
	hFont := hFont?hFont:DllCall("Gdi32.dll\GetStockObject", "Int", 17)
	, hDC := DllCall("User32.dll\GetDC", "Ptr", 0, "Ptr"), VarSetCapacity(Size, 8, 0)
	, hFont2 := DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont, "Ptr")
    , RC := DllCall("Gdi32.dll\GetTextExtentPoint32W", "Ptr", hDC, "Str", String, "Int", StrLen(String), "Ptr", &Size)
	, DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont2), DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	, Width := NumGet(&Size+0, 0, "Int"), Height := NumGet(&Size+0, 4, "Int")
	if (Convert)
		Width := Width + (NumGet(FontGetMetrics(hFont), 20, "Int")*3)
		, Height := Floor((NumGet(FontGetMetrics(hFont), 0, "Int")*Convert)+(NumGet(FontGetMetrics(hFont),16, "Int")*(Floor(Convert+0.5)-1))+0.5)+8
	return &Size, ErrorLevel := !(RC)
} FontGetMetrics(hFont := 0, ByRef FontSize := "") {
	static TEXTMETRIC
	hFont := hFont?hFont:DllCall("Gdi32.dll\GetStockObject", "Int", 17)
    , hDC := DllCall("User32.dll\GetDC", "Ptr", 0, "Ptr"), VarSetCapacity(TEXTMETRIC, 60, 0)
    , hFont2 := DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont, "Ptr")
	, DllCall("Gdi32.dll\GetTextMetrics", "Ptr", hDC, "Ptr", &TEXTMETRIC)
	, DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont2)
	, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), hp := &TEXTMETRIC
	, FontSize := Round((NumGet(hp+0,0,"Int")-NumGet(hp+0,12,"Int"))*72)
	return &TEXTMETRIC
} FontDelete(hFont*) {
	Error := ErrorLevel, Ok := 0
	Loop, % hFont.MaxIndex()
		Ok += !!DllCall("Gdi32.dll\DeleteObject", "Ptr", hFont[A_Index], "UInt")
	return Ok, ErrorLevel := Error
}






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: STRING ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;convertir String a CLSID
;Sintaxis: CLSIDFromString( ["{string}"], [CLSID (out)] )
CLSIDFromString(Str, ByRef CLSID) {
	VarSetCapacity(CLSID, 0), VarSetCapacity(CLSID, 16, 0)
	return DllCall("Ole32.dll\CLSIDFromString", "WStr", Str, "Ptr", &CLSID, "UInt")=0 ;NOERROR
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680589(v=vs.85).aspx

;convertir CLSID a String
;Sintaxis: StringFromCLSID( [&CLSID] )
;Nota: usar CoTaskMemFree() para liberar la memoria
StringFromCLSID(CLSID) {
	Error := ErrorLevel
	, DllCall("Ole32.dll\StringFromCLSID", "Ptr", CLSID, "PtrP", RCLSID)
	;DllCall("Ole32.dll\CoTaskMemFree", "Ptr", RCLSID)
	return StrGet(RCLSID, "UTF-16"), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683917(v=vs.85).aspx

;Copia un determinado número de caracteres de una cadena de origen en un búfer.
;Sintaxis: StrCopy( [destino (out)], [origen], [tamaño], [destino str/ptr] )
StrCopy(ByRef Dest, Source, Length := 0, Type := "Ptr") {
	if !(Length)
		Length := (Type="Ptr"?StrLen(Source):DllCall("Kernel32.dll\lstrlenW", "UInt", Source))+1
	if (Type="Str")
		VarSetCapacity(Dest, 0), VarSetCapacity(Dest, Length * 2, 0)
	return DllCall("Kernel32.dll\lstrcpynW", Type, Dest, Type="Ptr"?"Str":"Ptr"
	, Source, "Int", Length?Length:DllCall("Kernel32.dll\lstrlenW", "Ptr", Source)+1)
}

;obtiene opciones representadas por carácter(es) y separadas por espacios.
;Sintaxis: SplitFlags( [texto], [opciones], [carácteres*] )
;Opciones: \d = incluir números | \w incluir letras | [\Q carácteres \E]
	;por defecto obtiene: números, letras, puntos, +, -, ^, ~, comas
;NOTAS: 
	;devuelve un Array con las opciones en el mismo orden en que se espesificó;
	;si se espsificó solo 1, devuelve directamente el texto recuperado
	;si no se espesifico nada en el 3er parametro, lo obtiene del 2do
;EJEMPLOS:
	;MsgBox % SplitFlags("c100 x350", "x") "`n" SplitFlags("c100 x350",, "c1")
	;MsgBox % (i:=SplitFlags("c1,00 x35.0002 f+150",, "c", "x", "f")) i[1] "`n" i[2] "`n" i[3]
SplitFlags(String, Options := "\d\Q,.+-^~\E\w", Chars*) {
	Flags := []
	if !(Chars.MaxIndex())
		Chars := [Options], Options := "\d\Q,.+-^~\E\w"
	Loop, % Chars.MaxIndex()
		RegExMatch(String, "i)\Q" Chars[A_Index] "\E\K[" Options "]+", Flag), Flags[A_Index] := Flag
	return Chars.MaxIndex()>1?Flags:Flags[1]
}

;calcula el tamaño de almacenamiento necesario para una cadena en una codificación espesífica, luego codificar y escribir la cadena en el buffer
;Sintaxis: StrPutVar( [string], [OutputVar], [codificación], [restar al tamaño], [sumar al tamaño], [carácteres (out)] )
;Return: devuelve el tamaño, en bytes
StrPutVar(Str, ByRef OutputVar := "", Encoding := "UTF-16", Min := 0, Max := 0, ByRef Length := "") {
	VarSetCapacity(OutputVar, 0), VarSetCapacity(OutputVar, Length:=((StrPut(Str, Encoding)
	* ((Encoding="UTF-16"||Encoding="CP1200")?2:1))-Min)+Max), Bytes := StrPut(Str, &OutputVar, Encoding)
	return IsByRef(OutputVar)?Bytes:OutputVar
}

StrNormalize(String) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd319093%28v=vs.85%29.aspx
    len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", 0, "Int", 0)
    Loop {
        VarSetCapacity(buf, len * 2)
        , len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", &buf, "Int", len)
        if (len >= 0)
            break
        if (A_LastError != 122) ;ERROR_INSUFFICIENT_BUFFER
            return
        len *= -1
    } return RegExReplace(StrGet(&buf, len, "UTF-16"), "\pM")
}

;quitar caracteres de izquierda a derecha
;Sintaxis : StrTrimLeft( [Var], [Limite] )
StrTrimLeft(String, Length := 1) {
	return SubStr(String, Length+1)
}

;quitar caracteres de derecha a izquierda
;Sintaxis : StrTrimRight( [Var], [Limite] )
StrTrimRight(String, Length := 1) {
	return SubStr(String, 1, -Length)
}

;obtener caracteres de izquierda a derecha
;Sintaxis : StrLeft( [Var], [Limite] )
StrLeft(String, Length := 1) {
	return SubStr(String, 1, Length)
}
	
;obtener caracteres de derecha a izquierda
;Sintaxis : StrRight( [Var], [Limite] )
StrRight(String, Length := 1) {
	return SubStr(String, -(Length-1))
}

;If [var] in [ .. ]
;comprueba si el contenido de la variable coincide exactamente con los elementos espesificados
;Sintaxis: InVar( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
InVar(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := false) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (!(CaseSensitive) && (Haystack=A_LoopField)) || ((CaseSensitive) && (Haystack==A_LoopField))
			return true
	return false
}

;If [var] contains [ .. ]
;comprueba si el contenido de la variable coincide exactamente o parcialmente con los elementos espesificados
;Sintaxis: Contains( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
Contains(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := false) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (InStr(Haystack, A_LoopField, !!CaseSensitive))
			return true
	return false
}

;obtener un nombre válido para un archivo
ValidateName(ByRef IpName) {
	return IpName := RegExReplace(IpName, "[\Q*/\:?" Chr(34) "<>|`n\E]")
}

;obtener una ruta válida para un directorio
;EJEMPLOS: 
	;MsgBox % ValidatePath( "\<`n||\ " A_WinDir "\/\ \ *Sys/t<e>m?32\c::md.:exe|`n\\" )
	;MsgBox % SetWorkingDir(A_WinDir) ValidatePath( "\system32\\cmd.:exe\ " )
ValidatePath(ByRef IpPath) {
	IpPath := RegExReplace(IpPath, "[\Q*/?" Chr(34) "<>|`n\E]")
	, IpPath := Trim(IpPath), IpPath := Trim(IpPath, "\"), IpPath := Trim(IpPath)
	, IpDrive := StrLeft(IpPath, 2) 
	if FileExist( IpDrive ) AND InStr(IpDrive, ":")
		IpPath := IpDrive StrReplace( StrTrimLeft( IpPath, 2 ), ":" )
	else
		IpPath := A_WorkingDir "\" StrReplace( IpPath, ":" )
	IpPath := StrReplace(IpPath, "\\", "\"), IpPath := StrReplace(IpPath, " \ ", "\")
	, IpPath := Trim(IpPath), IpPath := Trim(IpPath, "\"), IpPath := Trim(IpPath)
	return IpPath := StrReplace(IpPath, "\\", "\")
}

Sort(VarName, Options := "") {
	Sort, VarName, %Options%
	return VarName
}

;convertir texto en minúscula 
StrLower(String, T := false) {
	return Format(T?"{:T}":"{:L}", String)
}

;comprueba si es minúscula
IsLower(String) {
	if String is LOWER
		return true
	return false
}

;convertir texto en mayúscula
StrUpper(String, T := false) {
	return Format(T?"{:T}":"{:U}", String)
}

;comprueba si es mayúscula
IsUpper(String) {
	if String is UPPER
		return true
	return false
}

;reemplaza variables literales.
;Sintaxis: ReplaceLiteralVar( [Var], [archivo] )
;Ejemplo: MsgBox % ReplaceLiteralVar("Version: %A_FileVersion%`nSystem: %SysDir%`nCopyright: %LegalCopyright%", ComSpec)
ReplaceLiteralVar(String, FileName := false) {
	static _ := []
	static Env, St
	if !Env
		Env := {"HKCU": "Environment", "HKLM": "SYSTEM\ControlSet001\Control\Session Manager\Environment"}
	for k, v in Env
		Loop, Reg, %k%\%v%, V
			String := StrReplace(String, "%" A_LoopRegName "%", _[A_LoopRegName]?_[A_LoopRegName]:(_[A_LoopRegName]:=EnvGet(A_LoopRegName)))
	if !St
		St := {"Temp": (_0:=A_Temp), "ProgramFiles" : (_9:=A_ProgramFiles), "CommonProgramFiles": (i7:=A_ProgramsCommon), "AppData": (i0:=A_AppData), "OS": (_8:=A_OSVersion)
		, "COMPUTERNAME": (i5:=A_ComputerName), "HOMEDRIVE": SubStr(_1:=A_WinDir, 1, 2), "LOCALAPPDATA": (_2:=A_AppDataCommon), "desktop": (i2:=A_Desktop)
		, "WINDIR": _1, "USERNAME": (i4:=A_UserName), "SYSTEMROOT": _1, "PROCESSOR_ARCHITECTURE": A_Is64bitOS?"64":"32", "LOCALAPPDATA": _2
		, "CMDEXTVERSION": A_OSType, "StartMenu": (i3:=A_StartMenu), "MyDocuments": (_3:=A_MyDocuments), "Documents": _3, "Cursor": (i8:=A_Cursor), "SendTo": A_SendTo()
		, "Recent": A_Recent(), "MyVideo": A_MyVideo(), "MyPictures": A_MyPictures(), "MyMusic": A_MyMusic(), "DocumentsCommon": A_DocumentsCommon()
		, "Programs": (i6:=A_Programs), "ComSpec": A_ComSpec(), "SysWinDir": A_SysWinDir(), "SysDir": A_SysDir(), "SysDir64": A_SysDir64(), "DefaultUserProfile": A_DefaultUserProfile()
		, "Profiles": A_Profiles(), "AllUsersProfile": A_AllUsersProfile(), "UserProfile": A_UserProfile(), "UserDomain": A_UserDomain(), "A_Temp": _0, "A_AhkVersion": A_AhkVersion
		, "A_ScriptName": A_ScriptName, "A_ScriptFullPath": A_ScriptFullPath, "A_ScriptFullPath": A_ScriptFullPath, "A_ScriptDir": A_ScriptDir, "A_Space": A_Space, "A_Tab": A_Tab
		, "A_OSVersion": _8, "A_WinDir": _1, "A_ProgramFiles": _9, "A_AppData": i0, "A_Language": A_Language, "A_Desktop": i2, "A_StartMenu": i3, "A_UserName": i4
		, "A_AppDataCommon": _2, "A_ComputerName": i5, "A_StartMenuCommon": A_StartMenuCommon, "A_Programs": i6, "A_ProgramsCommon": i7, "A_Cursor": i8, "A_Startup": A_Startup
		, "A_DesktopCommon": A_DesktopCommon, "A_IsAdmin": A_IsAdmin, "A_StartupCommon": A_StartupCommon, "A_IPAddress4": A_IPAddress4, "A_IPAddress1": A_IPAddress1
		, "A_IPAddress2": A_IPAddress2, "A_IPAddress3": A_IPAddress3, "A_MyDocuments": _3}
	for k, v in St
		String := StrReplace(String, "%" k "%", v)
	Ot := {"CD": A_WorkingDir, "DATE": (_1:=A_DD) "/" (_2:=A_Mon) "/" (_3:=A_Year), "TIME": (_4:=A_Hour) ":" (_5=A_Min) ":" (_6:=A_Sec), "DateTime": _1 "_" _2 "_" _3 "_" _4 "_" _5 "_" _6
	, "A_DDD": A_DDD, "A_DDDD": A_DDDD, "A_MMM": A_MMM, "A_MMMM": A_MMMM, "A_MM": A_MM, "A_YYYY" : A_YYYY, "A_DD": _1, "A_WorkingDir": A_WorkingDir
	, "A_Year": _3, "A_Mon": _2, "A_WDay": A_WDay, "A_YDay": A_YDay, "A_Hour": _4,  "A_YWeek": A_YWeek, "A_Min": _5, "A_Sec": _6, "A_Now": A_Now, "A_MSec": A_MSec
	, "A_LastError": A_LastError, "A_ScreenHeight": A_ScreenHeight, "A_ScreenWidth": A_ScreenWidth}
	for k, v in Ot
		String := StrReplace(String, "%" k "%", v)
	if InStr(String, "%Clipboard%")
		String := StrReplace(String, "%Clipboard%", Clipboard)
	if (FileName) {
		String := StrReplace(String, "%A_FileVersion%", (_1:=FileGetVersion(FileName)))
		, String := StrReplace(String, "%FileVersion%", _1)
		if Contains(String, _2:="%Comments%,%InternalName%,%ProductName%,%CompanyName%,%LegalCopyright%,%FileDescription%,"
			. "%ProductVersion%,%LegalTrademarks%,%PrivateBuild%,%FileVersion%,%OriginalFilename%,%SpecialBuild%") {
			VerInfo := FileGetInfo(FileName)
			Loop, Parse, % _2, `,
				String := StrReplace(String, A_LoopField, VerInfo[StrReplace(A_LoopField, "%")])
	}} return String
}

















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CRIPTOGRAFÍA ::::::::::::::::::::::::::::::::::
;Links:
	;https://autohotkey.com/boards/viewtopic.php?f=6&t=21
	;https://msdn.microsoft.com/en-us/library/windows/desktop/aa380252(v=vs.85).aspx
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;CODIFICAR
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Base32Encode(Decoded, UseHex := 0, Len := 0) { 
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	If (Len = 0)
		Len := StrPut(Decoded, "UTF-8") - 1
		, VarSetCapacity(UTF8, Len, 0)
		, StrPut(Decoded, &UTF8, "UTF-8")
		, BinAddr := &UTF8
	else BinAddr := &Decoded
	VarSetCapacity(Endcoded, Len * 2, 0), I := 0
	while (I < Len) {
		J := N := 0
		S := 40
		Loop, 5
			N += NumGet(BinAddr + I++, "UChar") << (8 * (5 - ++J))
		Until (I >= Len)
		Loop, % Ceil((8 * J) / 5)
			Encoded .= SubStr(Chars, ((N >> (S -= 5)) & 0x1F) + 1, 1)
	} Loop, % ((40 - (J * 8)) // 5)
		Encoded .= "="
	return Encoded
}

Base64Encode(Text) {
	VarSetCapacity(Bin, StrPut(Text, "UTF-8")), nSize := StrPut(Text, &Bin, "UTF-8") - 1
	, DllCall("Crypt32.dll\CryptBinaryToStringW", "Ptr", &Bin, "UInt", nSize, "UInt", 0x40000001, "Ptr", 0, "UInt*", Length)
	, VarSetCapacity(OutputVar, Length * 2)
	, r:=DllCall("Crypt32.dll\CryptBinaryToStringW", "Ptr", &Bin, "UInt", nSize, "UInt", 0x40000001, "Str", OutputVar, "UInt*", Length)
	return OutputVar, ErrorLevel := !r
}

;codificar URL
UriEncode(Uri, Encoding := "CP0") {
	StrPutVar(Uri, Var, Encoding)
	Loop {
		Code := NumGet(Var, A_Index - 1, "UChar")
		If !(Code)
			Break
		If (Code >= 0x30 && Code <= 0x39 ; 0-9
			|| Code >= 0x41 && Code <= 0x5A ; A-Z
			|| Code >= 0x61 && Code <= 0x7A) ; a-z
			Res .= Chr(Code)
		else Res .= "%" . SubStr(Hex(Code + 0x100), -1)
	} return Res
} ;https://autohotkey.com/board/topic/75390-ahk-l-unicode-uri-encode-url-encode-function/

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;DECODIFICAR
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Base32Decode(Encoded, UseHex := 0, ByRef Decoded := "") {
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	, Len := StrLen(Encoded)
	, VarSetCapacity(Decoded, Len * 2, 0)
	, I := J := K := 0
	Loop, Parse, % Encoded
	{ If !(N := InStr(Chars, A_LoopField))
			break
		K += --N << (5 * (8 - ++J))
		If (J = 8) {
			S := 40
			Loop, 5
				NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
			J := K := 0
	}} If (J < 8) {
		S := 40
		Loop, % Ceil((5 * J) / 8)
			NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
	} return IsByRef(Decoded) ? I : StrGet(&Decoded, I, "UTF-8")
}

Base64Decode(Text) {
	DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &Text, "UInt", StrLen(Text), "UInt", 0x1, "Ptr", 0, "UInt*", Length, "Ptr", 0, "Ptr", 0)
	, VarSetCapacity(OutputVar, Length)
	, r:=DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &Text, "UInt", StrLen(Text), "UInt", 0x1, "Str", OutputVar, "UInt*", Length, "Ptr", 0, "Ptr", 0)
	return StrGet(&OutputVar, Length, "UTF-8"), ErrorLevel := !r
}

;decodificar URL
UriDecode(Uri, Enc := "CP0") {
	Pos := 1
	Loop {
		if ((Pos:=RegExMatch(Uri, "i)(?:%[\da-f]{2})+", Code, Pos++))=0)
			break
		VarSetCapacity(Var, StrLen(Code) // 3, 0), Code := SubStr(Code, 2)
		Loop, Parse, % Code, `%
			NumPut("0x" . A_LoopField, Var, A_Index - 1, "UChar")
		Uri := StrReplace(Uri, "%" Code, StrGet(&Var, Enc))
	} return, Uri
} ;https://autohotkey.com/board/topic/75390-ahk-l-unicode-uri-encode-url-encode-function/





















































/*#############################################################################################################################################
  ::::::::::::::::::::::::::::::::::::::::::::: PROCESOS ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
Notas:
	• espesificar -1 para referirse al proceso actual.
	• espesificar -2 para referirse al Thread actual. http://www.rastersoft.com/OS2/CURSO/THREAD.HTM
	• espesificar -3 para referirse al último proceso espesificado.
;Parámetros:
	ID / ProcessName = ID o Nombre del proceso
*/
;devuelve una lista de todos los procesos (PID+Nombre)
;Sintaxis: ProcessEnum( [¿recuperar mas información? ]
;Ejemplo:
	;for k, v in p:=ProcessEnum(true)
		;MsgBox % "#" p.MaxIndex() "`n`n" k "`nNombre: " v.ProcessName "`nPID: " v.ProcessId "`nThreads: " v.Threads
			;. "`nParent: " v.ParentProcessId "`nPrioridad: " v.Priority
ProcessEnum(FullInfo := false) {
	static Priority := {32: "Normal", 64: "Low", 128: "High", 256: "RealTime", 16384: "BelowNormal", 32768: "AboveNormal"}
	Size := VarSetCapacity(PROCESSENTRY32, A_PtrSize=4?296:304, 0), NumPut(Size, PROCESSENTRY32, 0, "UInt")
	, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0, "Ptr")
	, Ok := DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &PROCESSENTRY32, "Int"), List := []
	Loop {
		Info := {}
		, Info.ProcessId := NumGet(PROCESSENTRY32, 8, "UInt")
		, Info.ProcessName := StrGet(&PROCESSENTRY32+(A_PtrSize=4?36:44), 260, "CP0")
		, Info.Threads := NumGet(PROCESSENTRY32, A_PtrSize=4?20:28, "UInt")
		, Info.ParentProcessId := NumGet(PROCESSENTRY32, A_PtrSize=4?24:32, "UInt")
		if (FullInfo)
			hProcess := OpenProcess(Info.ProcessId, 0x0400)
			, Info.Priority := Priority[DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess, "Uint")]
			, CloseHandle(hProcess)
		List.Push(Info)
	} until !DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &PROCESSENTRY32, "Int")
	return Ok?List:false, CloseHandle(hSnapshot), ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx

;Recupera información sobre el uso de memoria del proceso especificado en bytes
ProcessMemoryInfo(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410)
	, Size := VarSetCapacity(memCounters, A_PtrSize=8?72:40), NumPut(Size, memCounters)
	if !(DllCall("Psapi.dll\GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", Size)) {
		memCounters := "", Size := VarSetCapacity(memCounters, A_PtrSize=8?80:44), NumPut(Size, memCounters)
		if !(DllCall("Kernel32.dll\K32GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", Size))
			return false, ErrorLevel := true
	} i := {}, i.PageFaultCount := NumGet(memCounters, 4, "UInt")
		, i.PeakWorkingSetSize := NumGet(memCounters, 8, "Ptr")
		, i.WorkingSetSize := NumGet(memCounters, A_PtrSize = 8 ? 16 : 12, "Ptr") 
		, i.QuotaPeakPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 24 : 16, "Ptr")
		, i.QuotaPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 32 : 20, "Ptr")
		, i.QuotaPeakNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 40 : 24, "Ptr")
		, i.QuotaNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 48 : 28, "Ptr")
		, i.PagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 56 : 32, "Ptr")
		, i.PeakPagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 64 : 36, "Ptr")
		, i.PrivateUsage := NumGet(memCounters, A_PtrSize = 8 ? 72 : 40, "Ptr")
	return i, ErrorLevel := false, CloseHandle(hProcess)
}

;uso de CPU del proceso
ProcessCPULoad(ProcessName) {
		Static oldKrnlTime, oldUserTime, newKrnlTime, newUserTime
		ProcessId := _getpid(ProcessName)
		, oldKrnlTime := newKrnlTime, oldUserTime := newUserTime
		, hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		, DllCall("Kernel32.dll\GetProcessTimes", "Uint", hProcess, "int64P", CreationTime, "int64P", ExitTime, "int64P", newKrnlTime, "int64P", newUserTime) 
		return (((newKrnlTime-oldKrnlTime)+(newUserTime-oldUserTime))/10000000)*100, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;comprueba si el proceso existe
;Sintaxis: ProcessExist( [ProcessName] )
;Return: devuelve el PID o 0 en caso de error
;Notas:
	;epsesificar -1 para obtener el PID del proceso actual.
	;espesificar -2 para obtener el ThreadId del proceso actual.
	;espesificar -3 para obtener el PID del último proceso espesificado/encontrado.
ProcessExist(Proc*) {
	if !(ProcessName:=Trim(Proc[1])) && (Proc.MaxIndex())
		return false, ErrorLevel := true
	;---------------------------------------------------------------------------------------------------------------------
	if (ProcessName = -1) || !(Proc.MaxIndex())
		return DllCall("Kernel32.dll\GetCurrentProcessId")
	if (ProcessName = -2)
		return DllCall("Kernel32.dll\GetCurrentThreadId")
	if (ProcessName = -3)
		return __gsvalue.LastProcessId
	;---------------------------------------------------------------------------------------------------------------------
	Size := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0), NumPut(Size, lppe, 0, "UInt")
	, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
	, DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
	Loop {
		ProcessId := NumGet(lppe, 8, "UInt"), ProcessExe := StrGet(&lppe + (A_PtrSize=4?36:44), 260, "CP0")
		if (ProcessId = ProcessName) || (ProcessExe = ProcessName)
			return __gsvalue.LastProcessId := ProcessId, CloseHandle(hSnapshot), ErrorLevel := false
		if !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
			return false, ErrorLevel := true, CloseHandle(hSnapshot)
}}

;esperar a que el proceso exista
;Sintaxis: ProcessWait( [Proceso], [Segundos a esperar] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no existe; caso contrario devuelve el PID
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWait(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (ProcessId:=ProcessExist(ProcessName))
			return ProcessId, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que el proceso finalize
;Sintaxis: ProcessWaitClose( [Proceso], [Segundos] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no se ha cerrado; caso contrario devuelve 1
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWaitClose(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !ProcessExist(ProcessName)
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}} WaitForSingleObject(ProcessName, Seconds := 0) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032%28v=vs.85%29.aspx
	if (Seconds = -1)
		return false
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00100000)
	, r := DllCall("Kernel32.dll\WaitForSingleObject", "Ptr", hProcess, "UInt", Seconds>0?Seconds:0xFFFFFFFF)
	return (i=0)||(i=-1)?(ProcessId?ProcessId:true):false, ErrorLevel := (i=0)||(i=-1)?false:true, CloseHandle(hProcess)
}

;obtener/establecer prioridad 
;Sintaxis: ProcessPriority( [Nombre o PID], [Prioridad] )
;Prioridades: Low|BelowNormal|Normal|AboveNormal|High|RealTime
;Nota: dejar vacio el segundo parametro para recuperar la prioridad
ProcessPriority(ProcessName, Priority := "") {
	static p := {"Normal": 32, "Low": 64, "High": 128, "RealTime": 256, "BelowNormal": 16384, "AboveNormal": 32768}
	static rs := {32: "Normal", 64: "Low", 128: "High", 256: "RealTime", 16384: "BelowNormal", 32768: "AboveNormal"}
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, p[Priority]=""?0x0400:0x0200)
	if (p[Priority]="")
		return r:=rs[DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess)], CloseHandle(hProcess), ErrorLevel := !r
	return r := DllCall("kernel32.dll\SetPriorityClass", "Ptr", hProcess, "UInt", p[Priority]), CloseHandle(hProcess), ErrorLevel := !r
}

;cerrar proceso(s)
;Sintaxis: ProcessClose( [PID/Nombre*], [segundos], [subprocesos], [código de salida] )
;Pid/Nombre: espesificar el nombre o PID del proceso a cerrar. Adiciónal puede agregar * para serrar todos los procesos que coincidan con el nombre.
;Segundos: espesificar los segundos a esperar a que el proceso cierre. 0 para esperar indefinidamente.
;Sub-Procesos: 
	;1 = terminar el proceso junto con todos los procesos que inició
	;2 = teminar todos los procesos que el proceso espesificado inició
ProcessClose(ProcessName, WaitClose := -1, SubProcess := 0, uExitCode := 0) {
	if (InStr(ProcessName, "*")) { ;terminar procesos que coincidan con el mismo nombre
		ProcessName := StrReplace(ProcessName, "*"), dwSize := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0)
		, NumPut(dwSize, lppe, 0, "UInt"), hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		if (DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe))
			Loop {
				ProcessId := NumGet(lppe, 8, "UInt"), ProcessExe := StrGet(&lppe + (A_PtrSize=4?36:44), 260, "CP0")
				if (ProcessExe=ProcessName)
					hList .= ProcessClose(ProcessId, WaitClose, SubProcess, uExitCode) "`n"
				if !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
					return RTrim(hList, "`n"), CloseHandle(hSnapshot)
	}} ProcessId := _getpid(ProcessName)
	if (SubProcess) { ;termina el proceso junto con todos sus subprocesos
		dwSize := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0), NumPut(dwSize, lppe, 0, "UInt")
		, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		, DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
		Loop {
			Process_ID := NumGet(lppe, 8, "UInt"), Parent := NumGet(lppe, A_PtrSize=4?24:32, "UInt")
			if !(Process_ID=ProcessId) && (Parent=ProcessId)
				hList .= ProcessClose(Process_ID, WaitClose,, uExitCode) "`n"
			if !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
				return SubProcess=1?hList ProcessClose(ProcessId, WaitClose,, uExitCode):RTrim(hList, "`n"), CloseHandle(hSnapshot)
	}} hProcess := OpenProcess(ProcessId, 0x0001), r := DllCall("Kernel32.dll\TerminateProcess", "Ptr", hProcess, "UInt", uExitCode)
	return r?ProcessId:0, ErrorLevel := !r, CloseHandle(hProcess), ProcessWaitClose(ProcessId, WaitClose)
} ;----------------------------------------------------------------------------------------------------------------------------------------------------------------

;recupera la ruta completa al archivo ejecutable del proceso
;Sintaxis: ProcessPath( [ID] )
ProcessPath(ProcessName, ByRef ProcessEName := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410), VarSetCapacity(OutputVar, (260 + 1) * 2, 0)
	if !(r:=DllCall("Psapi.dll\GetModuleFileNameExW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1))
		if !(r:=DllCall("Kernel32.dll\K32GetModuleFileNameExW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1))
			r := DllCall("Kernel32.dll\QueryFullProcessImageNameW", "Ptr", hProcess, "UInt", 1, "Str", OutputVar, "UIntP", 260 + 1)
	return OutputVar, ErrorLevel := !r, CloseHandle(hProcess), ProcessEName := IsByRef(ProcessEName)?ProcessName(ProcessId):""
}

;recupera el nombre del archivo ejecutable del proceso
;Sintaxis: ProcessName( [PID] )
ProcessName(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410), VarSetCapacity(OutputVar, (260 + 1) * 2, 0)
	if !(r:=DllCall("Psapi.dll\GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1))
		r := DllCall("Kernel32.dll\K32GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1)
	return OutputVar, CloseHandle(hProcess)
}

;establece el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessSetWorkingSetSize( [Proceso], [Min], [Max] )
ProcessSetWorkingSetSize(ProcessName, Min := -1, Max := -1) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0100)
	, r := DllCall("Kernel32.dll\SetProcessWorkingSetSize", "Ptr", hProcess, "Ptr", Min, "Ptr", Max)
	return r, ErrorLevel := !r, CloseHandle(hProcess)
}

;obtiene el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessGetWorkingSetSize( [Proceso], [Min (salida)], [Max (salida)] )
ProcessGetWorkingSetSize(ProcessName, ByRef Min := "", ByRef Max := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), i := {}
	, r := DllCall("Kernel32.dll\GetProcessWorkingSetSize", "Ptr", hProcess, "PtrP", Min, "PtrP", Max)
	return r?{Min: Min, Max: Max}:0, ErrorLevel := !r, CloseHandle(hProcess)
}

;habilitar/deshabilitar/eliminar privilegios para el proceso espesificado
;Sintaxis: ProcessAdjustPrivileges( [proceso], [Array o Privilegios separados por coma], [estado], [¿deshabilitar todos los privilegios?] )
;Array: espesificar los privilegios y el estado para cada uno.
	;Sintaxis: [	["privilegio 1", "estado"], ["privilegio 2", "estado"], ["privilegio 3", "estado"], ...	 ]
;Privilegios separados por coma: espesificar los privilegios separados por coma. el estado en el 3er parámetro que se aplica a todos
;Estados: Enable | Disable | Delete. Nota: el 3er parámetro solo es válido cuando se espesifican los privilegios separados por coma
;Deshabilitar todos los privilegios: establecer en verdadero para deshabilitar todos los privilegios. el 2do y 3er parámetro no tienen efecto
;Privilegios: https://msdn.microsoft.com/en-us/library/windows/desktop/bb530716(v=vs.85).aspx
	;Ver LookupPrivilegeName() para una lista con todos los privilegios
;Ejemplo:
	;MsgBox % ProcessAdjustPrivileges("notepad.exe", [["SeDebugPrivilege", "Enable"], ["SeRestorePrivilege", "Enable"]]) ;Array
	;MsgBox % ProcessAdjustPrivileges("notepad.exe", "SeDebugPrivilege,SeRestorePrivilege", "Disable") ;Privilegios separados por coma, uso del 3er parámetro
	;MsgBox % ProcessAdjustPrivileges("notepad.exe",,, true) ;deshabilitar todos los privilegios. NOTA: los privilegios habilitados por defecto no se deshabilitan
;Nota: para comprobar los cambios, puede usar ProcessHacker, doble clic en el proceso, en la pestaña «Token». items en verde oscuro no se pueden deshabilitar.
ProcessAdjustPrivileges(ProcessName, Privileges := "", State := "Enable", DisableAllPrivileges := false) {
	static States := {Enable: 0x00000002, Disable: 0x00000000, Delete: 0x00000004}
	ProcessId := _getpid(ProcessName), Privileges := IsObject(Privileges)?Privileges:StrSplit(Privileges, ",", A_Space A_Tab)
	, hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x00000028), c := 4
	, VarSetCapacity(TOKEN_PRIVILEGES, 16*Privileges.MaxIndex(), 0), NumPut(Privileges.MaxIndex(), TOKEN_PRIVILEGES, 0, "UInt")
	for Index, Info in Privileges {
		NumPut(LookupPrivilegeValue(IsObject(Info)?Info[1]:Info), TOKEN_PRIVILEGES, c, "Ptr")
		, NumPut(States[IsObject(Info)?Info[2]:State], TOKEN_PRIVILEGES, (c:=(c+12))-4, "UInt"), c := c+4
	} DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", hToken, "Int", !!DisableAllPrivileges, "Ptr", &TOKEN_PRIVILEGES, "UInt", 0, "Ptr", 0, "Ptr", 0)
	return !(r:=A_LastError), ErrorLevel := r, CloseHandle(hToken, hProcess) ;AdjustTokenPrivileges --> A_LastError --> ERROR_SUCCESS = 0
} ;https://msdn.microsoft.com/en-us/library/aa375202(VS.85).aspx | https://msdn.microsoft.com/en-us/library/aa379306(v=vs.85).aspx

/* NOTA: NO DEVUELVE EL ESTADO DEL PRIVILEGIO CORRECTAMENTE!
;winnt.h (constantes) = https://source.winehq.org/source/include/winnt.h
;LUID STRUCTURE  =https://msdn.microsoft.com/en-us/library/aa379261(v=vs.85).aspx
;LUID_AND_ATTRIBUTES structure = https://msdn.microsoft.com/en-us/library/aa379263(v=vs.85).aspx
;TOKEN_PRIVILEGES = https://msdn.microsoft.com/en-us/library/aa379630(v=vs.85).aspx
;obtener privilegios del proceso
;Sintaxis: ProcessQueryPrivileges( [ID] )
;Return: [{Nombre, Estado}]
	;Nombre: nombre del privilegio
	;Estados: estado del provilegio
		;Enabled = habilitado
		;Disabled = deshabilitado
		;Default = habilitado por defecto
		;Access = el privilegio se utilizó para obtener acceso a un objeto o servicio
;Ejemplo:
	;for k, v in p:=ProcessQueryPrivileges("notepad.exe")
	;	MsgBox % "#" k " ~ " p.MaxIndex() " ------------`nPrivilegio: " v[1] "`nEstado: " v[2]
ProcessQueryPrivileges(ProcessName) {
	static States := {0x00000002: "Enabled", 0x00000000: "Disabled", 0x00000001: "Default", 0x80000000: "Access"}
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x0008)
	, Ok := GetTokenInformation(hToken, 3, TOKEN_PRIVILEGES), Array := [], Offset := 4
	Loop, % NumGet(TOKEN_PRIVILEGES, 0, "UInt") {
		PrivilegeInfo := {}
		PrivilegeInfo.Name := LookupPrivilegeName(NumGet(TOKEN_PRIVILEGES, Offset, "Int64P"))
		if !(PrivilegeInfo.Name)
			PrivilegeInfo.Name := LookupPrivilegeName(NumGet(TOKEN_PRIVILEGES, Offset:=A_PtrSize, "Int64P"))
		if !(PrivilegeInfo.Name)
			continue
		PrivilegeInfo.State := NumGet(TOKEN_PRIVILEGES, Offset + 8, "UInt") ;*! ESTADO?
		Offset += 12
		;, PrivilegeInfo.Name := LookupPrivilegeName(NumGet(TOKEN_PRIVILEGES, Offset, "Int64P"))
		;, PrivilegeInfo.State := NumGet(TOKEN_PRIVILEGES, Offset + 8, "UInt")
		Array.Push(PrivilegeInfo)
	}
	return Array, CloseHandle(hToken, hProcess), ErrorLevel := !Ok
}
*/

;determina si el proceso tiene privilegios elevados
;Sintaxis: ProcessElevation( [ID] )
;Return: 0|1
ProcessElevation(ProcessName, ByRef Owner := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x0008)
	, GetTokenInformation(hToken, 20, TOKEN_ELEVATION)
	return NumGet(TOKEN_ELEVATION, 0, "UInt"), CloseHandle(hToken, hProcess)
}

;suspender
ProcessSuspend(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0800)
	, DllCall("ntdll.dll\NtSuspendProcess", "Ptr", hProcess)
	return hProcess, CloseHandle(hProcess)
}
	
;reanudar
ProcessResume(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0800)
	, DllCall("ntdll.dll\NtResumeProcess", "Ptr", hProcess)
	return hProcess, CloseHandle(hProcess)
}

;obtiene el SID, opcional también el nombre de usuario y dominio del proceso
;Sintaxis: ProcessGetSid( [proceso], [nombre de usuario (salida)], [dominio (salida)] )
;MsgBox % ProcessGetSid("chrome.exe", un, ud) "`n" un "`n" ud
;ExitApp
ProcessGetSid(ProcessName, ByRef UserName := "", ByRef Domain := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400)
	, hToken := OpenProcessToken(hProcess, 0x00000008)
	, Ok := GetTokenInformation(hToken, 1, TOKEN_USER)
	, pSID := NumGet(TOKEN_USER, 0, "UInt")
	if IsByRef(UserName) || IsByRef(Domain)
		LookupAccountSid(pSID, UserName, Domain)
	;Size := DllCall("Advapi32.dll\GetLengthSid", "Ptr", pSID, "UInt")
	;VarSetCapacity(SID, Size * 2, 0)
	;MsgBox % DllCall("Advapi32.dll\ConvertSidToStringSidW", "Ptr", pSID, "UPtrP", &SID, "UInt")
	return pSID, CloseHandle(hToken, hProcess), ErrorLevel := !Ok
}

;obtener una lista de los Threads del proceso espesificado
;Sintaxis: ProcessThreadList( [ID], [Delimitador] )
;EJEMPLO:
	;for k, v in ProcessThreadList()
		;if (i:=ProcessName(v.ProcessId))
			;MsgBox % "ThreadId: " v.ThreadId ", OwnerProcessId: " v.ProcessId " (" i ")"
ProcessThreadList(ProcessName := "", Delimiter := "`n") {
	ProcessName := _getpid(ProcessName), dwSize := VarSetCapacity(THREADENTRY32, 28, 0)
	, NumPut(dwSize, THREADENTRY32, 0, "UInt"), hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000004, "UInt", 0)
	, DllCall("Kernel32.dll\Thread32First", "Ptr", hSnapshot, "Ptr", &THREADENTRY32)
	Loop {
		th32OwnerProcessID := NumGet(THREADENTRY32, 12, "UInt")
		, th32ThreadID := NumGet(THREADENTRY32, 8, "UInt")
		if (ProcessName) {
			if (ProcessName=th32OwnerProcessID)
				ThreadList .= (A_Index=1?"":Delimiter) th32ThreadID
		} else {
			if !IsObject(ThreadList)
				ThreadList := []
			ThreadInfo := [], ThreadInfo.ThreadId := th32ThreadID
			, ThreadInfo.ProcessId := th32OwnerProcessID, ThreadList.InsertAt( A_Index, ThreadInfo )
		} if !(DllCall("Kernel32.dll\Thread32Next", "Ptr", hSnapshot, "UInt", &THREADENTRY32))
			return ThreadList, ErrorLevel := hSnapshot=-1, CloseHandle(hSnapshot)
}}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES (para uso interno)
;Parámetros:
	;process_id = ProcessExist( [process_name] )
	;hProces = OpenProcess()
	;hThread = OpenThread()
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: OpenProcess( [process_id], [acceso] )
;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx
;Return: hProcess
OpenProcess(ProcessId, DesiredAccess := 0x001F0FFF, InheritHandle := false) { ;0x001F0FFF=ALL
	return DllCall("Kernel32.dll\OpenProcess", "UInt", DesiredAccess, "Int", !!InheritHandle, "UInt", ProcessId, "Ptr")
} 

;Sintaxis: OpenProcessToken( [hProces], [acceso] )
;Accesos:
	;STANDARD_RIGHTS_REQUIRED = 0x000F0000
	;TOKEN_ASSIGN_PRIMARY = 0x0001
	;TOKEN_DUPLICATE = 0x0002
	;TOKEN_IMPERSONATE = 0x0004
	;TOKEN_QUERY = 0x0008
	;TOKEN_QUERY_SOURCE = 0x0010
	;TOKEN_ADJUST_PRIVILEGES = 0x0020
	;TOKEN_ADJUST_GROUPS = 0x0040
	;TOKEN_ADJUST_DEFAULT = 0x0080
	;TOKEN_ADJUST_SESSIONID = 0x0100
OpenProcessToken(hProcess, DesiredAccess := 0xF01FF) { ;0xF01FF=ALL
	DllCall("Advapi32.dll\OpenProcessToken", "Ptr", hProcess, "UInt", DesiredAccess, "UIntP", hToken)
	return hToken
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379295(v=vs.85).aspx

;Sintaxis: OpenThread( [ThreadId], [acceso], [¿InheritHandle?] )
;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms686769(v=vs.85).aspx
	;Constantes: https://www.omniref.com/ruby/gems/windows-pr/0.8.6/symbols/Windows::Thread::THREAD_ALL_ACCESS
;Return: hThread
OpenThread(ThreadId, DesiredAccess := 0x1F03FF, InheritHandle := false) {
	return DllCall("Kernel32.dll\OpenThread", "UInt", DesiredAccess, "Int", !!InheritHandle, "UInt", ThreadId, "Ptr")
}

CreateProcess(ApplicationName := "", ByRef CommandLine := "", ProcessAttributes := 0, ThreadAttributes := 0, InheritHandles := true, CreationFlags := 0x08000000, Environment := 0, CurrentDirectory := "", StartupInfo := 0) {
	VarSetCapacity(PROCESS_INFORMATION, A_PtrSize=4?16:24, 0)
	, r := DllCall("Kernel32.dll\CreateProcessW", "Ptr", ApplicationName=""?0:&ApplicationName, "Ptr", CommandLine=""?0:&CommandLine
	, "Ptr", ProcessAttributes, "Ptr", ThreadAttributes, "Int", !!InheritHandles, "UInt", CreationFlags, "Ptr", Environment, "Ptr", CurrentDirectory=""?0:&CurrentDirectory
	, "Ptr", StartupInfo, "Ptr", &PROCESS_INFORMATION)
	return r?{HANDLE: NumGet(PROCESS_INFORMATION, 0, "Ptr"), hThread: NumGet(PROCESS_INFORMATION, A_PtrSize, "Ptr")
	, ID: NumGet(PROCESS_INFORMATION, A_PtrSize=4?8:16, "Ptr"), ThreadID: NumGet(PROCESS_INFORMATION, A_PtrSize=4?12:24, "Ptr")}:0, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx

;lee datos de un área de memoria en un proceso determinado. toda la zona a leer debe ser accesible o la operación fallará
;Sintaxis: ReadProcessMemory( [hProcess], [BaseAddress], [data (out)], [tamaño, en bytes], [NumberOfBytesRead] )
;BaseAddress: un puntero a la dirección base en el proceso específico a leer
;Data: un puntero a un búfer que recibe el contenido del espacio de direcciones del proceso especificado.
;Tamaño: el número de bytes que se lee desde el proceso especificado
;NumberOfBytesRead: recibe el número de bytes transferidos en el búfer especificado
ReadProcessMemory(hProcess, BaseAddress, Buffer, Bytes := 0, ByRef NumberOfBytesRead := "") {
	BaseAddress := IsObject(BaseAddress)?BaseAddress:["UInt", BaseAddress], Error := ErrorLevel
	if IsByRef(NumberOfBytesRead)
		VarSetCapacity(NumberOfBytesRead, 16, 0)
	Result := DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, BaseAddress[1], BaseAddress[2], "Ptr", Buffer, "UPtr"
	, Bytes>0?Bytes:VarSetCapacity(Buffer), "UPtrP", IsByRef(NumberOfBytesRead)?&NumberOfBytesRead:0, "UInt")
	if IsByRef(NumberOfBytesRead)
		NumberOfBytesRead := NumGet(NumberOfBytesRead, 0, "UPtrP")
	return Result, ErrorLevel := Error
}

;escribe datos en un área de memoria en un proceso especificado. toda la zona a escribir debe ser accesible o la operación fallará
;Sintaxis: WriteProcessMemory( [hProcess], [BaseAddress], [Buffer], [Size], [NumberOfBytesWritten] )
WriteProcessMemory(hProcess, BaseAddress, Buffer, Bytes := 0, ByRef NumberOfBytesWritten := "") {
	BaseAddress := IsObject(BaseAddress)?BaseAddress:["UInt", BaseAddress], Error := ErrorLevel
	if IsByRef(NumberOfBytesWritten)
		VarSetCapacity(NumberOfBytesWritten, 16, 0)
	Result :=  DllCall("Kernel32.dll\WriteProcessMemory", "Ptr", hProcess, BaseAddress[1], BaseAddress[2], "Ptr", Buffer, "UPtr"
	, Bytes>0?Bytes:VarSetCapacity(Buffer), "UPtrP", IsByRef(NumberOfBytesWritten)?&NumberOfBytesWritten:0, "UInt")
	if IsByRef(NumberOfBytesWritten)
		NumberOfBytesWritten := NumGet(NumberOfBytesWritten, 0, "UPtrP")
	return Result, ErrorLevel := Error
}

;recupera el estado de terminación del proceso especificado.
;Sintaxis: GetExitCodeProcess( [hProcess] )
;Permisos necesarios:
	;PROCESS_QUERY_INFORMATION o PROCESS_QUERY_LIMITED_INFORMATION
GetExitCodeProcess(hProcess) {
	Ok := DllCall("Kernel32.dll\GetExitCodeProcess", "Ptr", hProcess, "UIntP", ExitCode, "UInt")
	return ExitCode, ErrorLevel := !Ok
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: AUTORIZACIÓN Y SEGURIDAD ::::::::::::::::::::::::::::::::::
;Parámetros:
	;pSID = pointer a una estructura SID. https://msdn.microsoft.com/en-us/library/windows/desktop/aa379594(v=vs.85).aspx
	;SID = SID STRING
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa375742(v=vs.85).aspx
;#############################################################################################################################################
;obtiene información de un Token
;Sintaxis: GetTokenInformation( [hToken], [TokenInformationClass], [TokenInformation (out)], [ReturnLength] )
;Parámetros:	
	;hToken: usar OpenProcessToken()
	;TokenInformationClass: tipo de información de obtener: https://msdn.microsoft.com/en-us/library/aa379626(v=vs.85).aspx
	;TokenInformation: información
	;ReturnLength: bytes necesarios
;Acceso requerido: 
	;TOKEN_QUERY_SOURCE = para TokenInformationClass-->TokenSource
	;TOKEN_QUERY = para todo lo demás
GetTokenInformation(hToken, TokenInformationClass, ByRef TOKEN_INFORMATION, ByRef ReturnLength := "") {
	DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", TokenInformationClass, "Ptr", 0, "UInt", 0, "UIntP", ReturnLength)
	, VarSetCapacity(TOKEN_INFORMATION, ReturnLength * 2, 0)
	, Ok := DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", TokenInformationClass
		, "Ptr", &TOKEN_INFORMATION, "UInt", ReturnLength, "UIntP", ReturnLength, "UInt")
	return Ok, ErrorLevel := !Ok
}

;obtener LUID de un privilegio
;Sintaxis: LookupPrivilegeValue( [str privilegio] )
;Return: lpLuid
LookupPrivilegeValue(PrivilegeName) {
	Ok := DllCall("Advapi32.dll\LookupPrivilegeValueW", "Ptr", 0, "Ptr", &PrivilegeName, "Int64P", PrivilegeValue, "UInt")
	return PrivilegeValue, ErrorLevel := !Ok
}

;obtener una cadena de carácteres que reprecenta al privilegio
;Sintaxis: LookupPrivilegeName( [lpLuid] )
;Return: String
LookupPrivilegeName(lpLuid) {
	Loop, Parse, % "SeChangeNotifyPrivilege|SeCreateGlobalPrivilege|SeDebugPrivilege|SeShutdownPrivilege|SeSystemtimePrivilege|SeCreatePagefilePrivilege"
		. "|SeImpersonatePrivilege|SeIncreaseQuotaPrivilege|SeTimeZonePrivilege|SeIncreaseBasePriorityPrivilege|SeManageVolumePrivilege|SeRemoteShutdownPrivilege"
		. "|SeCreateSymbolicLinkPrivilege|SeSecurityPrivilege|SeTakeOwnershipPrivilege|SeBackupPrivilege|SeProfileSingleProcessPrivilege|SeRestorePrivilege"
		. "|SeSystemEnvironmentPrivilege|SeSystemProfilePrivilege|SeUndockPrivilege|SeIncreaseWorkingSetPrivilege|SeLoadDriverPrivilege|SeMachineAccountPrivilege", |
		if (lpLuid=LookupPrivilegeValue(A_LoopField))
			return A_LoopField
}

;comprueba si es un SID válido
;Sintaxis: IsValidSid( [pSID] )
IsValidSid(pSID) {
	return DllCall("Advapi32.dll\IsValidSid", "Ptr", pSID, "UInt")
}

;obtiene el nombre de usuario y dominio
;Sintaxis: LookupAccountSid( [pSID], [nombre se usuario (out)], [dominio (out)] )
LookupAccountSid(pSID, ByRef UserName := "", ByRef Domain := "") {
	DllCall("Advapi32.dll\LookupAccountSidW", "Ptr", 0, "Ptr", pSID, "Ptr", 0, "UIntP", SizeN:=0, "Ptr", 0, "UIntP", SizeD:=0, "Ptr", 0)
	, VarSetCapacity(UserName, SizeN * 2, 0), VarSetCapacity(Domain, SizeD * 2, 0)
	return DllCall("Advapi32.dll\LookupAccountSidW", "Ptr", 0, "Ptr", pSID, "Str", UserName, "UIntP", SizeN, "Str", Domain, "UIntP", SizeD, "Ptr", 0, "UInt")
}

FreeSid(pSID) {
	Ok := 0, Error := ErrorLevel
	for k, v in pSID
		Ok += DllCall("Advapi32.dll\FreeSid", "Ptr", v, "Ptr")=0
	return Ok=pSID.MaxIndex(), ErrorLevel := Error
}












































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: INTERNET ::::::::::::::::::::::::::::::::::
;Constantes: https://msdn.microsoft.com/en-us/library/windows/desktop/aa383661(v=vs.85).aspx
;#############################################################################################################################################
;comprobar si una conexión a Internet puede ser establecida
;Sintaxis: InternetCheckConnection( [url] )
;Return: 0|1
InternetCheckConnection(URL := "https://www.google.com/") {
	return !!DllCall("Wininet.dll\InternetCheckConnectionW", "Ptr", &URL, "UInt", 1, "UInt", 0, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa384346(v=vs.85).aspx

;descargar archivo
;Sintaxis: Download( [URL], [Archivo], [¿sobreescribir?], [¿recuperar de la memoria caché cuando sea posible?] )
;Nota: omitir el 2do parámetro para obtener el texto sin crear el archivo.
Download(URL, Filename := "", OverWrite := true, UseCache := false) {
	static param := 0
	param++
	if (Filename="") {
		whr := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, whr.Open("GET", Trim(URL) (UseCache?"":"?f=" param), true), whr.Send(), whr.WaitForResponse()
		return whr.ResponseText
	} if !(OverWrite) && (FileExist(Filename))
		return false, ErrorLevel := 2
	URLDownloadToFile, % Trim(URL) (UseCache?"":"?f=" param), %Filename%
	return !ErrorLevel
}

;comprueba si el equipo está conextado
;Nota: la funcion no comprueba si hay internet o no, usar InternetCheckConnection()
InternetGetConnectedState(Flags := 0x40) {
	return r:=DllCall("Wininet.dll\InternetGetConnectedState", "UInt*", Flags, "UInt", 0, "Int"), ErrorLevel := r?0:A_LastError
}

;obtener tamaño del archivo
;Sintaxis: InternetGetFileSize( [URL], [KB|MB|GB] )
InternetGetFileSize(URL, Units := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	if !(GetModuleHandle("Wininet.dll"))
		hModule := LoadLibrary("Wininet.dll")
	hInternet := InternetOpen(), hInternetUrl := InternetOpenUrl(hInternet, Url)
	if (StrLeft(URL, 4)="ftp:")
		FileSize := DllCall("Wininet.dll\FtpGetFileSize", "Ptr", hInternetUrl, "UIntP", 0)  
	else DllCall("Wininet.dll\HttpQueryInfoW", "Ptr", hInternetUrl, "UInt", 0x20000005, "UIntP", FileSize, "UIntP", 4, "UIntP", 0)
	if (hModule)
		FreeLibrary(hModule)
	return _[Units]?FileSize/_[Units]:FileSize, ErrorLevel := !FileSize, InternetCloseHandle(hInternetUrl, hInternet)
}

;Inicializa la aplicación para el uso de las funciones de WinInet
;Sintaxis: InternetOpen( [nombre de usuario en el protocolo HTTP], [acceso], [nombre del servidor proxi], [nombres de host y/o direcciones IP], [opciones] )
;Accesos: PRECONFIG=0 | DIRECT=1 | PROXY=3 | PRECONFIG_WITH_NO_AUTOPROXY=4
;Opciones: ASYNC=0x10000000 | FROM_CACHE=0x01000000 | OFFLINE=0x01000000
;Return: hInternet (HANDLE)
InternetOpen(Agent := "Microsoft Internet Explorer", AccessType := 4, ProxyName := "", ProxyBypass := "", Flags := 0) {
	return DllCall("Wininet.dll\InternetOpenW", "Ptr", &Agent, "UInt", ProxyName=""?AccessType:(AccessType:=3)
	, "Ptr", AccessType=3?&ProxyName:0, "Ptr", AccessType=3?&ProxyBypass:0, "UInt", Flags, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa385096(v=vs.85).aspx

;abre un recurso especificado por un FTP, HTTP o URL completa
;Sintaxis: InternetOpenUrl( [hInternet], [URL ftp|http|https], [HEADERS], [tamaño], [opciones], [Context] )
;Return: hInternetUrl (HANDLE)
InternetOpenUrl(hInternet, Url, Headers := 0, HeadersLength := 0, Flags := 0x84000000, Context := 0) {
	return DllCall("Wininet.dll\InternetOpenUrlW", "Ptr", hInternet, "Ptr", &Url, "Ptr", Headers, "UInt", HeadersLength, "UInt", Flags, "UInt", Context, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa385098(v=vs.85).aspx

;cerrar HANDLE de internet
;Sintaxis: InternetCloseHandle( [HANDLE 1, HANDLE 2, HANDLE 3, ...] )
InternetCloseHandle(HANDLE*) {
	Error := ErrorLevel, c := 0
	Loop, % (HANDLE.MaxIndex())
		c += !!DllCall("Wininet.dll\InternetCloseHandle", "Ptr", HANDLE[A_Index], "Int")
	return c, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa384350(v=vs.85).aspx

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

;enviar e-mail
;Sintáxis: EmailSend( [email], [contraseña], [email destino], [cuerpo], [asunto] )
;NOTA: para gmail activar el Acceso De Aplicaciones Menos Seguras (emisor): https://www.google.com/settings/security/lesssecureapps
EmailSend(User, Pass, To, Body, Subject := "", CC := "", BCC := "", Attach := "") {
	pmsg := ComObjCreate("CDO.Message")
	, pmsg.From := User
	, pmsg.To := To, pmsg.BCC := BCC, pmsg.CC := CC
	, pmsg.Subject := Subject, pmsg.TextBody := Body
	, sAttach := Attach
	Loop, Parse, % sAttach, `n, `r
		pmsg.AddAttachment(A_LoopField)
	fields := Object()
	, fields.smtpserver := "smtp.gmail.com" ; specify your SMTP server
	, fields.smtpserverport := 465 ; 25
	, fields.smtpusessl := True ; False
	, fields.sendusing := 2 ; cdoSendUsingPort
	, fields.smtpauthenticate := 1 ; cdoBasic
	, fields.sendusername := User
	, fields.sendpassword := Pass
	, fields.smtpconnectiontimeout := 60
	, schema := "http://schemas.microsoft.com/cdo/configuration/"
	, pfld := pmsg.Configuration.Fields
	for field, value in fields
		pfld.Item(schema . field) := value
	pfld.Update()
	try pmsg.Send()
	catch
		return false
	return true
}

Ping(Address, Timeout := 1000, ByRef Data := "", Length := 0, ByRef Result := "", ByRef ResultLength := 0) {
    if ((NumericAddress:=DllCall("ws2_32.dll\inet_addr", "AStr", Address, "UInt"))=0xFFFFFFFF)
		return false, ErrorLevel := 2
	if !GetModuleHandle("icmp.dll")
		hModule := LoadLibrary("icmp.dll")
    if ((hPort:=DllCall("icmp.dll\IcmpCreateFile", "UPtr"))=-1)
		return false, ErrorLevel := 3
    VarSetCapacity(Reply, 278, 0), Count := DllCall("icmp.dll\IcmpSendEcho", "UPtr", hPort, "UInt", NumericAddress
	, "UPtr", &Data, "UShort", Length, "UPtr", 0, "UPtr", &Reply, "UInt", 278, "UInt", Timeout, "UInt")
    If (NumGet(Reply, 4, "UInt")=11001)
		VarSetCapacity(Reply, 278 * Count, 0), DllCall("icmp.dll\IcmpSendEcho", "UPtr", hPort, "UInt", NumericAddress
		, "UPtr", &Data, "UShort", Length, "UPtr", 0, "UPtr", &Reply, "UInt", 278 * Count, "UInt", Timeout)
    If !(NumGet(Reply,4,"UInt")=0)
        return false, ErrorLevel := 4
    l:=DllCall("icmp.dll\IcmpCloseHandle", "UPtr", hPort), ResultLength := VarSetCapacity(Result, NumGet(Reply, 12, "UShort"), 0)
    , MoveMemory(&Result, NumGet(Reply,16), ResultLength), hModule := hModule?FreeLibrary("icmp.dll"):false
    return NumGet(Reply, 8, "UInt"), ErrorLevel := !l
}










































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: DISPOSITIVOS Y APLICACIONES PREDETERMINADAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;IMPRESORAS Y FAXES
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;establecer impresora predeterminada
;Sintaxis: SetDefaultPrinter( [str nombre que puede verse en el panel de control] )
;Return: 0|1
SetDefaultPrinter(Printer := 0) {
	return DllCall("Winspool.drv\SetDefaultPrinterW", "Ptr", &Printer, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd162971(v=vs.85).aspx
 
;obtener impresora predeterminada
;Return: str nombre
;ErrorLevel: 0|1
GetDefaultPrinter() {
	DllCall("Winspool.drv\GetDefaultPrinterW", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, Size * 2, 0)
	, Ok := DllCall("Winspool.drv\GetDefaultPrinterW", "Str", OutputVar, "UIntP", Size, "Int")
	return OutputVar, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd144876(v=vs.85).aspx
 
;enumerar todos los dispositivos de impresora y fax
;Return: [{uint Flags, str Description, str Name, str Comment}]
	;for k, v in EnumPrinters()
	;	MsgBox % "#" k "`nFlags: " v.Flags "`nDescription: " v.Description
	;		. "`nName: " v.Name "`nComment: " v.Comment
EnumPrinters() {
	DllCall("Winspool.drv\EnumPrintersW", "UInt", 0x00000002, "Ptr", 0, "UInt", 1, "Ptr", 0, "UInt", 0, "UIntP", Size, "UIntP", 0)
	, VarSetCapacity(PRINTER_INFO_1, Size * 2, 0)
	, DllCall("Winspool.drv\EnumPrintersW", "UInt", 0x00000002, "Ptr", 0, "UInt", 1, "Ptr", &PRINTER_INFO_1, "UInt", Size, "UIntP", 0, "UIntP", Count)
	Offset := A_PtrSize=4?-16:-28, List := []
	Loop, % Count {
		Info := {}, Offset += A_PtrSize=4?16:28
		, Info.Flags := NumGet(PRINTER_INFO_1, Offset, "UInt")
		, Info.Description := StrGet(NumGet(PRINTER_INFO_1, Offset+A_PtrSize))
		, Info.Name := StrGet(NumGet(PRINTER_INFO_1, Offset+(A_PtrSize*2)))
		, Info.Comment := StrGet(NumGet(PRINTER_INFO_1, Offset+(A_PtrSize*3)))
		, List.Push(Info)
	} return List
}















































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: BARRA DE TAREAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establecer porcentaje de progreso en la barra de tareas
;Sintaxis: TaskBarProgress( [ESTADO], [Ventana ID] )
;ESTADOS: 0~100, Normal, Paused, Indeterminate, Error
;Nota: usar TaskBarProgress(-1) cuando ya no lo necesite
TaskBarProgress(hWnd, State := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=48329#p48329
	static States := {0: 0, l: 1, Indeterminate: 1, n: 2, Normal: 2, e: 4, Error: 4, p: 8, Paused: 8}
	static ppv
	if (hWnd=-1)
		return ObjRelease(ppv), ppv := ""
	if !(ppv)
		ppv := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf}")
	_gethwnd(hWnd)
	if (States[State]="")
		return DllCall(NumGet(NumGet(ppv+0)+9*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "Int64", State * 10, "Int64", 1000)
	return DllCall(NumGet(NumGet(ppv+0)+10*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "UInt", States[State])
} ;https://msdn.microsoft.com/en-us/library/dd391698(v=vs.85).aspx

;quitar/mostrar boton de la ventana en la barra de tareas
;Sintaxis: TaskBarRemove( [ID], [¿mostrar?] )
TaskBarRemove(hWnd, Show := false) {
	_gethwnd(hWnd)
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	, DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (Show?4:5)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd), ObjRelease(hTaskBar)
}

;activa la ventana en la barra de tareas
;TaskBarActivate( [ID], [¿marcar siempre como activo (no visualmente)?] )
TaskBarActivate(hWnd, SetActiveAlt := 0) {
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	, DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (SetActiveAlt?7:6)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd), ObjRelease(hTaskBar)
}

;obtiene posicion de la barra de tareas
;Sintaxis: TaskBarGetPos( [xpos], [ypos], [ancho], [alto] )
TaskBarGetPos(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	return WinGetPos(GetTaskBar(), x, y, Width, Height)
}

;obtiene hWnd de la barra de tareas, opcional: área de notificacion, reloj y boton inicio
;Sintaxis: GetTaskBar( [área de notificacion], [área de notificacion (iconos ocultos)], [reloj], [boton inicio] )
GetTaskBar(ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := FindWindow("Shell_TrayWnd")
	if IsByRef(hNotifArea)||IsByRef(hOverFNotifArea)||IsByRef(hTrayClock) {
		hNotify := FindWindowEx(hTaskBar,, "TrayNotifyWnd")
		, hSyspager := FindWindowEx(hNotify,, "SysPager")
		if !(hNotifArea := FindWindowEx(hSyspager,, "ToolbarWindow32", "User Promoted Notification Area"))
			if !(hNotifArea := FindWindowEx(hSyspager,, "ToolbarWindow32", "Notification Area"))
				hNotifArea := FindWindowEx(hSyspager,, "ToolbarWindow32")
		if IsByRef(hOverFNotifArea)
			hNotifIcon := FindWindow(, "NotifyIconOverflowWindow"), hOverFNotifArea := FindWindowEx(hNotifIcon,, "ToolbarWindow32"
			, "Overflow Notification Area"), hOverFNotifArea := hOverFNotifArea?hOverFNotifArea:hNotifArea
	} if IsByRef(hTrayClock)
		hTrayClock := FindWindowEx(hNotify,, "TrayClockWClass")
	if IsByRef(hStartButton)
		hStartButton := FindWindowEx(hTaskBar,, "Button"), hStartButton := hStartButton?hStartButton:FindWindowEx(hTaskBar,, "Start")
	return hTaskBar
}

;redibujar barra de tareas, área de notificacion, reloj y boton inicio.
TaskBarRedraw(ByRef hTaskBar := "", ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := GetTaskBar(hNotifArea, hOverFNotifArea, hTrayClock, hStartButton)
	return i:=WinRedraw(hTaskBar)+WinRedraw(hNotifArea)+WinRedraw(hOverFNotifArea)+WinRedraw(hTrayClock)+WinRedraw(hStartButton)
		, ErrorLevel := i!=5
}

;obtiene los iconos en el area de notificacion +info.
;Nota: requiere WIN_V+
;Ejemplo:
	;for k, v in TaskBarTrayIconsEnum() {
	;	TaskBarTrayIconHide(v.CMD,, v.Hidden)
	;	MsgBox % "hWnd: " v.hWnd "`nCommand: " v.CMD "`nIcon: " v.Icon "`nMsg: " v.Msg "`nHidden: " v.Hidden "`nID: " v.ID "`nTip: " v.Tip
	;	TaskBarTrayIconHide(v.CMD, false, v.Hidden)
	;}
TaskBarTrayIconsEnum() {
	List := [], GetTaskBar(hNotifArea, hOverFNotifArea)
	Loop, Parse, % (hNotifArea=hOverFNotifArea?hNotifArea:hNotifArea "." hOverFNotifArea), .
	{	Index := A_Index, hProcess := OpenProcess(WinGetPid(A_LoopField), 0x38), pAddress := VirtualAlloc(hProcess,, 20)
        , Size := VarSetCapacity(TBBUTTON, A_PtrSize=4?24:32, 0), VarSetCapacity(v2, Size, 0), s3 := VarSetCapacity(v3, 128 * 2, 0)
		Loop, % SendMessage(A_LoopField, 0x418,,,,, "UIntP") {
			SendMessage(A_LoopField, 0x417, "Int", A_Index-1, "UInt", pAddress), ReadProcessMemory(hProcess, pAddress, &TBBUTTON, Size)
            , Bitmap := NumGet(TBBUTTON, 0, "Int"), Command := NumGet(TBBUTTON, 4, "Int"), Statyle := NumGet(TBBUTTON, 8, "UInt")
			, Data := NumGet(TBBUTTON, A_PtrSize=4?12:16, "Ptr"), String := NumGet(TBBUTTON, A_PtrSize=4?16:24, "Ptr")
			, ReadProcessMemory(hProcess, ["Ptr", Data], &v2, Size), hWnd := NumGet(v2, 0, "Ptr"), ID := NumGet(v2, A_PtrSize)
			, Msg  := NumGet(v2, A_PtrSize=4?8:12), hIcon := NumGet(v2, A_PtrSize=4?20:24, "Ptr"), ReadProcessMemory(hProcess, ["Ptr", String], &v3, s3)
			, List.Push({hWnd: hWnd, CMD: Command, ID: ID, Msg: Msg, Icon: hIcon, Hidden: (Index=2), Tip: StrGet(&v3, s3, "UTF-16")})
		} VirtualFree(hProcess, pAddress), CloseHandle(hProcess)
	} return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb760478%28v=vs.85%29.aspx

;ocultar/mostrar icono en el área de notificación.
;Sintaxis: TaskBarTrayIconHide( [hWnd], [0|1] )
TaskBarTrayIconHide(CMD, Hide := true, Hidden := false) {
	GetTaskBar(hNotifArea, hOverFNotifArea)
	if (Hidden) || !(SendMessage(hNotifArea, 0x404,, CMD, "Int", !!Hide))
		return SendMessage(hOverFNotifArea, 0x404,, CMD, "Int", !!Hide), SendMessage(hOverFNotifArea, 0x1A)
	return true, SendMessage(hNotifArea, 0x1A)
}

;habilitar/deshabilitar icono en el área de notificación.
;Sintaxis: TaskBarTrayIconEnable( [hWnd], [0|1] )
TaskBarTrayIconEnable(CMD, Enable := true, Hidden := false) {
	GetTaskBar(hNotifArea, hOverFNotifArea)
	if (Hidden) || !(SendMessage(hNotifArea, 0x400+1,, CMD, "Int", !!Enable))
		return SendMessage(hOverFNotifArea, 0x400+1,, CMD, "Int", !!Enable)
	return true
}





















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ESCRITORIO & EXPLORADOR & PAPELERA DE RECICLAJE & MENU INICIO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;PAPELERA DE RECICLAJE
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;recupera el tamaño de la papelera de reciclaje (en bytes) y el número de elementos que contiene para una unidad especificada.
;Sintaxis: RecycleBinGetSize( [unidad], [unidades (KB|MB|GB)], [elementos (salida)] )
RecycleBinGetSize(Path, Units := "", ByRef i64NumItems := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	cbSize := VarSetCapacity(SHQUERYRBINFO, A_PtrSize=4?20:36, 0), NumPut(cbSize, SHQUERYRBINFO, 0, "UInt")
	, Result :=  DllCall("Shell32.dll\SHQueryRecycleBinW", "Str", StrLeft(Trim(Path)) ":\", "Ptr", &SHQUERYRBINFO)
	, i64Size := NumGet(SHQUERYRBINFO, 4, "Int64"), i64NumItems := IsByRef(i64NumItems)?NumGet(SHQUERYRBINFO, 12, "Int64"):""
	return _[Units]?i64Size/_[Units]:i64Size, ErrorLevel := Result
}

;vacía la Papelera de reciclaje en la unidad especificada.
;Sintaxis: RecycleBinEmpty( [unidad], [¿ocultar dialgos de confirmacion?], [¿ocultar dialogos de progreso?], [¿no reproducir sonidos?] )
RecycleBinEmpty(Path, NoConfirmation := true, NoProgressUI := true, NoSound := true) {
	r := DllCall("Shell32.dll\SHEmptyRecycleBinW", "Ptr", A_ScriptHwnd, "Str", StrLeft(Trim(Path)) ":\"
	, "UInt", (NoConfirmation?0x00000001:0)|(NoProgressUI?0x00000002:0)|(NoSound?0x00000004:0))
	return !r, ErrorLevel := r
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;EXPLORADOR
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;reiniciar explorador de windows
RestartWindowsExplorer() {
	explorer_path := A_WinDir "\explorer.exe"
	for k, v in ProcessEnum()
		if (v.ProcessName="explorer.exe") && (ProcessPath(v.ProcessId)=explorer_path)
			if !ProcessClose(v.ProcessId, 3)
				return false, ErrorLevel := true
	Run, %explorer_path%, %A_WinDir%, Hide, PID
	return ErrorLevel?false:PID
}

;obtener ruta de la ventana del explorador de windows espesificada
;Sintaxis: GetExplorerWindowPath( [hWnd] )
;ErrorLevel: 
	;0 = Ok
	;1 o 2 = Error
	;3 = es posible que la ruta sea una biblioteca o el quipo, devuelve el nombre
	;4 = la ventana espesificada es inválida
GetExplorerWindowPath(hWnd := -1) {
	static spn := {"Documentos": "Documents", "Música": "Music", "Imágenes": "Pictures", "Juegos": "Games"}
	Class := WinGetClass(hWnd), hWnd := hWnd=-1?IsWindow():hWnd
	if (Class=="Progman") || (Class=="WorkerW")
		return A_Desktop, ErrorLevel := false
	if (Class="CabinetWClass") || (Class="ExploreWClass") {
		for this in ComObjCreate("Shell.Application").Windows {
			if (this.hWnd=hWnd) {
				if (this.LocationURL="") {
					if (this.LocationName="")
						return false, ErrorLevel := true
					;Loop, Files, %A_AppData%\Microsoft\Windows\Libraries\*.*, F
					return this.LocationName, ErrorLevel := this.LocationName=""?2:3
				} return RTrim(StrReplace(UriDecode(LTrim(LTrim(Trim(this.LocationURL), "ftp:///"), "file:///")), "/", "\"), "\")
	}	}	} return false, ErrorLevel := 4
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;MENÚ INICIO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;muestra el menú inicio
ShowStartMenu() {
	return PostMessage(IsWindow(), 0x112, "UInt", 0xF130)
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;ESCRITORIO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;muestra el escritorio y establece foco en él
;Sintaxis: ShowDesktop( [¿esperar? (segundos)], [¿redibujar?] )
ShowDesktop(Wait := -1, Redraw := false) {
	ComObjCreate("shell.application").ToggleDesktop()
	, i := WinActivate(GetDesktop(), Wait, true)
	if (Redraw)
		DesktopRedraw()
	return i, ErrorLevel := !i
}

;obtener hWnd del control SysListView32 del escritorio (control de los iconos)
;Ejemplo: 
	;MsgBox % "hDesktopListView: " GetDesktop(hShellWin, hDesktopWnd, hProgman, hWorkerW) "`nhShellWin: " hShellWin
		;. "`nhDesktopWnd: " hDesktopWnd "`nhProgman: " hProgman "`nhWorkerW: " hWorkerW
GetDesktop(ByRef hShellWin := "", ByRef hDesktopWnd := "", ByRef hProgman := "", ByRef hWorkerW := "") {
	hProgman := FindWindow("Progman")
	if (hShellViewWin:=FindWindowEx(hProgman,, "SHELLDLL_DefView"))
		hDesktopListView := FindWindowEx(hShellViewWin,, "SysListView32")
	if IsByRef(hShellWin)
		hShellWin := DllCall("User32.dll\GetShellWindow")
	if IsByRef(hDesktopWnd) || IsByRef(hWorkerW) || !(hShellViewWin) {
		hDesktopWnd := DllCall("User32.dll\GetDesktopWindow")
		if IsByRef(hWorkerW) || !(hShellViewWin)
			hWorkerW := FindWindowEx(hDesktopWnd,, "WorkerW")
		if !(hShellViewWin) {
			hShellViewWin := FindWindowEx(hWorkerW,, "SHELLDLL_DefView")
			if !(hShellViewWin) && !(hWorkerW2:=0) 
				Loop {
					hWorkerW2 := FindWindowEx(hDesktopWnd, hWorkerW2, "WorkerW")
					hShellViewWin := FindWindowEx(hWorkerW2,, "SHELLDLL_DefView")
				} until !(hWorkerW2) || (hShellViewWin)
			if (hShellViewWin)
				hDesktopListView := FindWindowEx(hShellViewWin,, "SysListView32")
		}
	} return hDesktopListView
}

;redibujar escritorio
DesktopRedraw(ByRef hDesktop := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop()
	return WinRedraw(hDesktop)
}

;obtener cantidad de iconos en el escritorio
DesktopIconCount(ByRef hDesktop := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop()
	return LV_GetItemCount(hDesktop)
}

;obtener una lista con todos los iconos visibles del escritorio
DesktopIconList(ByRef hDesktop := "", ByRef ProcessId := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop(), Count := DesktopIconCount(hDesktop)
	, ProcessId := ProcessId?ProcessId:WinGetPid(hDesktop)
	Loop, %Count%
		List .= LV_GetItemTextEx(hDesktop, A_Index,, ProcessId) "`n"
	return Rtrim(List, "`n")
}

;guardar captura de pantalla
;Sintaxis: SaveScreenshot( [archivo destino], [coordenadas] )
;Archivo destino:  .bmp, .jpg, .png, .tif, .gif
;Coordenadas:
	;--> Array con las coordenadas: [x, y, ancho, alto].
	;--> Toda la pantalla: Screen. Defecto.
	;--> Ventana activa: Window | A. Nota: la ventana debe estar visible.
	;--> Array con el ID de una ventana: ["ID", hWnd]. Nota: la ventana debe estar visible.
;Ejemplos:
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_1.jpg", [0, 0, 500, 350]) ;por coordenadas.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_2.jpg", "Screen") ;pantalla entera.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_3.jpg", "Window") ;ventana activa.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_4.jpg", ["ID", GetTaskbar()]) ;ventana espesificada (barra de tareas).
SaveScreenshot(Filename, Pos := "Screen") {
	GdiplusStartup(hModule), k := 0x0
	if (Pos="Window") || (Pos="A") || (Pos[1]="ID") 
		WinGetPos(k:=IsObject(Pos)?Pos[2]:IsWindow(), x, y, w, h)
	else x := ((Pos="Screen")||(Pos[1]="")||!(Pos[1]>-1))?0:Pos[1], y := ((Pos="Screen")||(Pos[2]="")||!(Pos[2]>-1))?0:Pos[2]
	, w := ((Pos="Screen")||(Pos[3]="")||!(Pos[3]>0))?A_ScreenWidth:Pos[3], h := ((Pos="Screen")||(Pos[4]="")||!(Pos[4]>0))?A_ScreenHeight:Pos[4]
	pBitmap := GdipBitmapFromScreen(x "|" y "|" w "|" h, 0x40000000+0x00CC0020), GdipSetInterpolationMode(pBitmap)
	, GdipSetSmoothingMode(pBitmap), GdipSetTextRenderingHint(pBitmap), GdipSaveBitmapToFile(pBitmap, Filename,, k), GdipDisposeImage(pBitmap)
	return true, GdiplusShutdown(, hModule)
}

;obtiene la posición de los iconos del escritorio.
;Ejemplo: 
	;for k, v in DesktopGetIconsPos()
	;	MsgBox %  "Nombre: " k "`nPosición: " v[1] "x" v[2]
DesktopGetIconsPos(ByRef hDesktop := "", ByRef ProcessId := "") {
	Array := []
	Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
		Pos := LV_GetItemPosEx(hDesktop, A_Index,,, ProcessId)
		, Array[A_LoopField] := [Pos[1], Pos[2]]
	return Array
}

;establece la posición de los iconos del escritorio.
;Ejemplo: guardar y reestablecer la posicion de los iconos
	;DesktopIconsPos := DesktopGetIconsPos(hDesktop, ProcessId)
	;MsgBox mueva un icono en el escritorio!
	;DesktopSetIconsPos(DesktopIconsPos, hDesktop, ProcessId)
	;MsgBox los iconos han sido restaurados a su posición original!
	;ExitApp
DesktopSetIconsPos(IconsPos, ByRef hDesktop := "", ByRef ProcessId := "") {
	i := 0
	Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
	{	if (IconsPos[A_LoopField][1]!="") {
			IconIndex := "", ItemName := A_LoopField
			Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
			{	if (A_LoopField=ItemName) {
					IconIndex := A_Index
					break
			}} if (IconIndex="")
					continue
			i+=LV_SetItemPosEx(hDesktop, IconIndex, IconsPos[A_LoopField][1], IconsPos[A_LoopField][2], ProcessId)
			, r := A_Index
	}} return i=r, ErrorLevel := !(i=r)
}

;cambiar imagen de fondo del escritorio
;Sintaxis: SetDesktopWallpaper( [imagen], [ancho], [alto], [archivo] )
;Ancho / Alto: espesificar las nuevas dimenciones para la imagen o dejar vacío para no modificar
;Archivo: espesificar el archivo donde guardar la imagen a establecer como fondo de escritorio con extension .bmp
SetDesktopWallpaper(Image, Width := "", Height := "", File := "") {
	File := File?File:A_AppData "\Microsoft\Windows\Themes\TranscodedWallpaper.bmp", SplitPath(Image,,, Ext)
	if !(Ext="bmp")
		GdiplusStartup(hModule), ImageConvert(Image, File, Width, Height), GdiplusShutdown(, hModule)
	else FileCopy(Image, File, true)
	return r:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0014, "UInt", 0, "Ptr", &File, "UInt", 0x0001|0x0002), ErrorLevel := !r
}

;obtener ruta de la imagen de fondo del escritorio
;Sintaxis: GetDesktopWallpaper()
GetDesktopWallpaper() {
	VarSetCapacity(OutputVar, 260 * 2, 0)
	, Ok := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0073, "UInt", 260, "Str", OutputVar, "UInt", 0)
	return OutputVar, ErrorLevel := !Ok
}

DesktopGetShellWindows() {
	static SWDesktop
	if !(IsObject(SWDesktop)) {
		ShellWindows := ComObjCreate("Shell.Application").Windows
		VarSetCapacity(_hwnd, 4, 0), SWDesktop := ShellWindows.FindWindowSW(0, "", 8, ComObj(0x4003, &_hwnd), 1)
	} return SWDesktop, ErrorLevel := !IsObject(SWDesktop)
}

;refrezcar escritorio
DesktopRefresh() {
	return IsObject(SWDesktop:=DesktopGetShellWindows()), SWDesktop.Refresh()
}

;obtener elementos seleccionados
;Sintaxis: DesktopSelectedItems( [total], [¿quitar seleccion?] )
;Ejemplo:
	;Loop, Parse, % DesktopSelectedItems(c), `n
	;	MsgBox % A_LoopField
	;MsgBox % "Total: " c
DesktopSelectedItems(ByRef Count := "", Deselect := false) {
	sfv := DesktopGetShellWindows().Document, items := sfv.SelectedItems
    Loop % (Count:=items.Count) {
		List .= (List=""?"":"`n") items.Item(A_Index-1).Name
		if (Deselect)
			sfv.SelectItem(items.Item(A_Index-1), false)
	} return List, ErrorLevel := !IsObject(items)
} ;http://msdn.microsoft.com/en-us/library/dd894076
	
;seleccionar/deseleccionar item
;Sintaxis: DesktopSelectItem( [nombre], [0|1] )
DesktopSelectItem(Name, State := true) {
	sfv := DesktopGetShellWindows().Document, items := sfv.SelectedItems
	return !(ErrorLevel:=!IsObject(items)), sfv.SelectItem(items.Item(Name), !!State)
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;ESCRITORIO VIRTUAL (WIN_10+)
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;determina si la ventana espesificada es visible en el escritorio virtual actual
;Sintaxis: IsWindowOnCurrentVirtualDesktop( [hWnd] )
;Return: 0 | 1
IsWindowOnCurrentVirtualDesktop(hWnd) {
	_gethwnd(hWnd)
	return IVirtualDesktopManager.IsWindowOnCurrentVirtualDesktop(hWnd)
}































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: NOTIFICACIONES & MENSAJES ::::::::::::::::::::::::::::::::::
;Para usar con OnMessage():
	;Links:
		;Keyboard Input Notifications: https://msdn.microsoft.com/en-us/library/windows/desktop/ff468861(v=vs.85).aspx
		;Virtual-Key Codes: https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
	;Uso:
		;Para registrar: OnMessage( [mensaje], [función] )
		;Para anular: OnMessage( [mensaje], "" )
		;Para obtener función: OnMessage( [mensaje] )
	;Notas:
		;la variable A_Gui identifica a la ventana activa sobre la cual se procesa el mensaje
		;los mensajes registrados con OnMessage() solo tienen efecto cuando hay una ventana activa del proceso invocador
;#############################################################################################################################################
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;NOTIFICACIONES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;registra los clics o movimientos del mouse en el icono del área de notificacion
;Sintaxis: RegisterTrayIconClickNotification( [funcion a llamar al hacer clic] )
;Mensajes que recibe la funcion:
	;Parametro 1: Normal | RightClick | DoubleClick | MouseOver
	;Parametro 2: Valor original sin modificar
RegisterTrayIconClickNotification(Func, lParam := "*") {
	static Event := {514: "Normal", 517: "RightClick", 515: "DoubleClick", 512: "MouseOver"}
	static Call
	if (lParam!="*") {
		if IsFunc(Call)
			return %Call%(Event[lParam], lParam), NormalClickCount := 0
	} else if !IsFunc(Func)
		return true, OnMessage(0x404, Call:="")
	else return OnMessage(0x404, A_ThisFunc), Call := Func
}

;registra el estado de la tapa del portatil
;Sintaxis: RegisterPowerSettingNotification( [funcion a llamar cuando la tapa se abra/cierre] )
;Mensajes que recibe la funcion:
	;Parametro 1: Closed | Opened
	;Parametro 2: Mensaje
;EJEMPLO:
	;RegisterPowerSettingNotification("WM_POWERBROADCAST")
	;WM_POWERBROADCAST(wParam, lParam){
	;	SoundBeep, % wParam="Opened"?750:250
	;}
RegisterPowerSettingNotification(Func, lParam := "*") {
	static Call, hPower
	if (lParam!="*") {
		if IsFunc(Call) {
			if (NumGet(lParam+0, 0, "UInt")=0xBA3E0F4D)
				%Call%(Func=0x8013?(Numget(lParam+0, 20, "UChar")?"Opened":"Closed"):"", lParam)
	}} else if !IsFunc(Func) {
		return DllCall("User32.dll\UnregisterPowerSettingNotification", "Ptr", hPower), OnMessage(0x218, Call:="")
	} else {
		VarSetCapacity(GLSC, 16), DllCall("ole32\CLSIDFromString", "WStr", "{BA3E0F4D-B817-4094-A2D1-D56379E6A0F3}", "Ptr", &GLSC)
		return hPower:=DllCall("User32.dll\RegisterPowerSettingNotification", "Ptr", A_ScriptHwnd, "Ptr", &GLSC, "UInt", 0)
			, OnMessage(0x218, A_ThisFunc), Call := Func
}} ;http://ahkscript.org/boards/viewtopic.php?p=51804#p51804

;registra para recibir notificaciones de cambio de sesión
;Sintaxis: RegisterSessionNotification( [estado], [sesion], [funcion que recibe las notificaciones] )
;Estado: 1 = activar | 0 = desactivar || Sesion: 1 = todas las sesiones | 0 = solo la sesion actual
;Notificaciones: http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
;Param1=valor modificado | param2=valor sin modificar
RegisterSessionNotification(Status, Session := 1, Func := "") { ;http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
	if Status&&IsFunc(Func)&&DllCall("wtsapi32.dll\WTSRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd, "UInt", Session)
        return 1, OnMessage(0x02B1, "WM_WTSSESSION_CHANGE"), WM_WTSSESSION_CHANGE(0,0,Func), ErrorLevel := 0
    else if DllCall("wtsapi32.dll\WTSUnRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd)
		return 1, OnMessage(0x02B1, ""), ErrorLevel := 0
    return 0, Func := "", ErrorLevel := 1
} WM_WTSSESSION_CHANGE(wParam, lParam, SetFunc := "*") {
	static Func
	static code := {0x1: "CONSOLE_CONNECT", 0x2: "CONSOLE_DISCONNECT", 0x4: "REMOTE_CONNECT"
		, 0x4: "REMOTE_DISCONNECT", 0x5: "SESSION_LOGON", 0x6: "SESSION_LOGOFF"
		, 0x7: "SESSION_LOCK", 0x8: "SESSION_UNLOCK", 0x9: "SESSION_REMOTE_CONTROL"}
	return true, i:=SetFunc!="*"?(Func:=SetFunc):%Func%(code[wParam], wParam)
} ;https://msdn.microsoft.com/library/aa383828%28vs.85,en-us%29

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;MENSAJES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;SendMessage / PostMessage
;Sintaxis 1: SendMessage( [hWnd], [mensaje], [wType], [wParam (in_out)], [lType], [lParam (in_out)], [ReturnType], [tiempo fuera] )
;Sintaxis 2: PostMessage( [hWnd], [mensaje], [wType], [wParam], [lType], [lParam] )
;Parámetros:
	;hWnd: ID de la ventana a la que enviar el mensaje
	;Mensaje: tipo de mensaje
	;wType: tipo de valor espesificado en wParam. por defecto usa Ptr.
	;wParam: valor wParam dependiendo del mensaje
	;lType: tipo de valor espesificado en lParam. por defecto usa Ptr.
	;lParam: valor lParam dependiendo del mensaje
	;ReturnType: tipo de datos a devolver, necesario dependiendo del mensaje
	;Tiempo Fuera: espesificar el tiempo fuera, en ms. este es el tiempo máximo a esperar para procesar el mensaje si la ventana no responde
;Return: Datos (depende del mensaje)
;ErrorLevel: 0(OK) | 1(ERROR) | 2(LA VENTANA NO RESPONDE. se ha alcanzado el tiempo fuera)
SendMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0, ReturnType := "UPtrP", Timeout := 5000) {
	Error := !DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", Msg
	, wType, wParam, IType, IParam, "UInt", 0x0002, "UInt", Timeout, ReturnType, OutputVar, "UInt")
	return OutputVar, ErrorLevel := Error?(Error+(A_LastError=124)):false ;ERROR_TIMEOUT = 124
} PostMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0) {
	Error := !DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam, "Int")
	return !Error, ErrorLevel := Error
}

WM_COPYDATA(hWnd, dwData := 1, Size := 0, lpData := 0) {
	_gethwnd(hWnd), VarSetCapacity(COPYDATASTRUCT, 3*A_PtrSize, 0)
	, NumPut(dwData, COPYDATASTRUCT, 0, "UPtr")
	, NumPut(Size?Size:((StrLen(lpData)+1)*2), COPYDATASTRUCT, A_PtrSize, "UInt")
	, NumPut(lpData, COPYDATASTRUCT, 2*A_PtrSize, "Ptr")
	return SendMessage(hWnd, 0x4A,, &COPYDATASTRUCT)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649011(v=vs.85).aspx



















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: NOMBRES Y RUTAS DE ARCHIVOS/DIRECTORIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recupera la ruta y el nombre completo del archivo/carpeta especificado.
;Sintaxis: GetFullPathName( [archivo], [carácteres (out)] )
;Nota: el archivo no necesariamente debe existir. si la ruta no es absoluta usa el directorio de trabajo actual
GetFullPathName(Filename, ByRef Length := "") {
	Size := DllCall("Kernel32.dll\GetFullPathNameW", "Str", Filename, "UInt", 0, "Ptr", 0, "PtrP", 0, "UShort"), VarSetCapacity(OutputVar, Size * 2, 0) 
	, Length := DllCall("Kernel32.dll\GetFullPathNameW", "Str", Filename, "UInt", Size, "Str", OutputVar, "PtrP", 0, "UShort")
	return Length?RTrim(OutputVar, "\"):Filename, ErrorLevel := !Length
}

;convierte la ruta especificada a su forma larga
;Sintaxis: GetLongPathName( [ruta], [carácteres (out)] )
GetLongPathName(Filename, ByRef Length := "") {
	Size := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0, "UShort"), VarSetCapacity(OutputVar, Size * 2, 0)
	, Length := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" Filename, "Str", OutputVar, "UInt", Size, "UShort")
	return Length?RTrim(LTrim(OutputVar, "\\?\"), "\"):Filename, ErrorLevel := !Length
}

;convierte la ruta especificada a su forma corta
;Sintaxis: GetShortPathName( [ruta], [carácteres (out)] )
GetShortPathName(Filename, ByRef Length := "") {
	Size := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0, "UShort"), VarSetCapacity(OutputVar, Size * 2, 0)
	, Length := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" Filename, "Str", OutputVar, "UInt", Size, "UShort")
	return Length?RTrim(LTrim(OutputVar, "\\?\"), "\"):Filename, ErrorLevel := !Length
}

;obtiene una ruta valida (solo archivos) removiendo caracteres no permitidos, espacios, parámetros y comillas.
GetValidPathName(Filename) {
	Filename := Trim(RegExReplace(Filename, "[\Q*/?" Chr(34) "<>|`n\E]"))
	if (IsFile(Filename))
		return Filename, ErrorLevel := false
	if IsFile(i:=StrLeft(Filename, InStr(Filename, A_Space)-1))
		return i, ErrorLevel := 0
	Loop, Parse, % Filename, %A_Space%, %A_Tab%
	{ _ .= (A_Index=1?"":" ") A_LoopField 
		if (IsFile(_))
			return _, ErrorLevel := false
	} return Filename, ErrorLevel := true
} 

;recupera la ruta completa de un directorio
;Sintaxis: GetKnownFolderPath( [GUID] )
;GUID:
	;WIN_V+ = https://msdn.microsoft.com/en-us/library/windows/desktop/dd378457%28v=vs.85%29.aspx
	;WIN_XP = https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494(v=vs.85).aspx
		;constantes: https://www.omniref.com/ruby/gems/windows-pr/1.0.0/symbols/Windows::Shell::CSIDL_ADMINTOOLS
;Ejemplo: MsgBox % GetKnownFolderPath(IsWindowsVistaOrGreater()?"{724EF170-A42D-4FEF-9F26-B60E846FBA4F}":0x0030) "`n" ErrorLevel
GetKnownFolderPath(GUID) {
	if (VarSetCapacity(Path, (260 + 1) * 2, 0)) && (IsWindowsVistaOrGreater()) && (VarSetCapacity(CLSID, 16, 0)) {
		DllCall("Ole32.dll\CLSIDFromString", "WStr", GUID, "Ptr", &CLSID)
		, r := DllCall("Shell32.dll\SHGetKnownFolderPath", "Ptr", &CLSID, "UInt", 0, "Ptr", 0, "PtrP", Path)
		return StrGet(Path, 260 + 1, "UTF-16"), DllCall("Ole32.dll\CoTaskMemFree", "Ptr", Path), ErrorLevel := r
	} r := DllCall("Shell32.dll\SHGetFolderPathW", "Ptr", 0, "Int", GUID, "Ptr", 0, "UInt", 0, "Str", Path)
	return Path, ErrorLevel := r ;S_OK = 0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762188(v=vs.85).aspx

;convertir una cadena a un puntero a una lista de identificadores de elemento (PIDL).
;Sintaxis: ParseDisplayName( [ruta] )
;Return: PIDL
ParseDisplayName(Path) {
	r := DllCall("Shell32.dll\SHParseDisplayName", "WStr", Path, "Ptr", 0, "PtrP", Path, "UInt", 0, "UIntP", 0)
	return Path, ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762236(v=vs.85).aspx

;hace la operacion inversa de ParseDisplayName()
;Sintaxis: GetPathFromIDList( [PIDL], [¿usar nombres cortos?] )
;Return: Ruta
GetPathFromIDList(pidl, UsesShortFileNames := false) {
	VarSetCapacity(Path, 260 * 2, 0)
	r := DllCall("Shell32.dll\SHGetPathFromIDListEx", "Ptr", pidl, "WStr", Path, "UInt", 260, "UInt", UsesShortFileNames?0x0001:0x0000)
	return RTrim(Path, "\"), ErrorLevel := !r
}

;convierte una lista de archivos separados por `n o un array (que tambiene puede contener mas arrays con `n) en un nuevo array con archivos válidos con su ruta completa en su forma larga
;Sintaxis: GetValidArrayFiles( [archivos], [¿comprobar si el archivo existe?=1], [espesificar la ruta del archivo si solo se espesificó el nombre], [carácteres totales], [¿remover duplicados?=1] )
;Ejemplo:
	;for Index, File in GetValidArrayFiles( ["a", "b`nc", "d", ["e", ["f`ng", [[[[[["h"]]]]]]]], "i`nj`nk"], false, "C:\" )
		;MsgBox % "#" Index "`n" File
GetValidArrayFiles(Files, Exist := true, Path := "", ByRef Length := "", RemoveDuplicates := true) {
	Items := [], Files := IsObject(Files)?GVAF_GetFiles(Files):StrSplit(Files, "`n", "`r"), Length := 0 ;transformar archivos separados por `n en un array
	for k, v in Files ;buscar en los archivos espesificados
	{	if ((Exist && IsFile(Path v)) || !(Exist)) && !((v:=GetFullPathName(GetLongPathName(Path v)))="") && (Ok:=true) {
			if (RemoveDuplicates) ;¿buscar archivos duplicados?
				for k2, v2 in Items  ;buscar en los archivos añadidos 
					if (v=v2) && !(Ok:=false) ;si se encontro, establece Ok en 0
						break
			if (Ok) ;Ok = 1 => [no se encontraron archivos duplicados]
				Items.Push(v), Length += StrLen(v) ;añadir archivo y sumar carácteres
	}} return Items.MaxIndex()?Items:0, ErrorLevel := Items.MaxIndex()?0:1 ;si se añadieron archivos, devuelve el Array, de lo contrario devuelve 0
} GVAF_GetFiles(Array) { ;obtiene un nuevo array de un array con arrays y `n
	Items := []
	for k, v in Array {
		if IsObject(v) && v.MaxIndex()
			for k, v in GVAF_GetFiles(v)
				Items.Push(v)
		for k2, v2 in StrSplit(v, "`n", "`r")
			Items.Push(v2)
	} return Items
}





























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ADMINISTRACIÓN DE ENERGÍA ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa373163(v=vs.85).aspx
;Parámetros:
	;GUID: espesificar el plan de energia. si no se espesifica, usa el plan activo (en uso actualmente)
		;{a1841308-3541-4fab-bc81-f71556f20b4a} = GUID_MAX_POWER_SAVINGS (economizador)
		;{381b4222-f694-41f0-9685-ff5bb260df2e} = GUID_TYPICAL_POWER_SAVINGS (equilibrado)
		;{8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c} = GUID_MIN_POWER_SAVINGS (alto rendimiento)
	;AC = conectado a la corriente. defecto.
	;DC = con batería
	;Porcentaje = un número entre 1 y 100 inclusive que indican el porcentaje del estado del procesador. dejar vacío para no modificar.
;Notas:
	;para que algunos cambios tengan efecto inmediato, usar PowerSetActivePlan() con el plan modificado
	;para obtener una lista con todos los planes, usar PowerEnumeratePlans()
;#############################################################################################################################################
;recupera el estado de alimentación del sistema
;Sintaxis: GetSystemPowerStatus( [ACLineStatus], [BatteryFlag], [BatteryLifePercent], [SystemStatusFlag], [BatteryLifeTime], [BatteryFullLifeTime] )
;Parámetros:
	;ACLineStatus:  estado de alimentacion C.A (corriente alterna)
		;0 = fuera de linea
		;1 = en linea
		;255 = desconocido
	;BatteryFlag: estado de carga de la batería
		;1 = Alto		>66
		;2 = Bajo		<33
		;4 = Critico	<5
		;8 (o 9?) = Carga
		;128 = sin batería
		;255 = desconocido (no se ha podido leer la información)
	;BatteryLifePercent: porcentaje de carga de la batería, entre 0 y 100; o 255  si el estado es desconocido.
	;SystemStatusFlag: estado de ahorro de batería. WIN_10+
		;1 = ahorro de batería activado. ahorrar energía cuando sea posible.
		;0 = ahorro de batería desactivado
	;BatteryLifeTime: segundos restantes de la duración de la batería; o -1 si se desconoce.
	;BatteryFullLifeTime: segundos restantes para la carga completa de la batería; o -1 si se desconoce.
GetSystemPowerStatus(ByRef ACLineStatus := "", ByRef BatteryFlag := "", ByRef BatteryLifePercent := "", ByRef SystemStatusFlag := "", ByRef BatteryLifeTime := "", ByRef BatteryFullLifeTime := "") {
	VarSetCapacity(SYSTEM_POWER_STATUS, 12, 0), Ok := DllCall("Kernel32.dll\GetSystemPowerStatus", "Ptr", &SYSTEM_POWER_STATUS, "UInt")
	, ACLineStatus := NumGet(SYSTEM_POWER_STATUS, 0, "UChar"), BatteryFlag := NumGet(SYSTEM_POWER_STATUS, 1, "UChar")
	, BatteryLifePercent := NumGet(SYSTEM_POWER_STATUS, 2, "UChar"), SystemStatusFlag := NumGet(SYSTEM_POWER_STATUS, 3, "UChar")
	, BatteryLifeTime := NumGet(SYSTEM_POWER_STATUS, 4, "UInt"), BatteryFullLifeTime := NumGet(SYSTEM_POWER_STATUS, 8, "UInt")
	return Ok, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa372693(v=vs.85).aspx

;cambiar estado minimo y/o maximo del procesador
;Sintaxis: PowerWriteProcessorStateValueIndex( [GUID], [porcentaje minimo], [porcentaje máximo], [AC/DC] )
;Return: 0(ERROR) | 1(OK)
;ErrorLevel: 0(OK) | 1(ERROR)
PowerWriteProcessorStateValueIndex(GUID := "", Min := "", Max := "", Mode := "AC") {
	if !(GUID)
		PowerEnumeratePlans(GUID), GUID := "{" GUID.GUID "}"
	mi := ma := true, CLSIDFromString(GUID, GUID_POWER_SAVING)
	, CLSIDFromString("{54533251-82be-4824-96c1-47b60b740d00}", GUID_PROCESSOR_SETTINGS_SUBGROUP)
	if !(Min="")
		CLSIDFromString("{893DEE8E-2BEF-41E0-89C6-B55D0929964C}", GUID_PROCESSOR_THROTTLE_MINIMUM)
		, mi:=DllCall("PowrProf.dll\PowerWrite" Mode "ValueIndex", "Ptr", 0, "Ptr", &GUID_POWER_SAVING
			, "Ptr", &GUID_PROCESSOR_SETTINGS_SUBGROUP, "Ptr", &GUID_PROCESSOR_THROTTLE_MINIMUM, "UInt", Min, "UInt")=0
	if !(Max="")
		CLSIDFromString("{BC5038F7-23E0-4960-96DA-33ABAF5935EC}", GUID_PROCESSOR_THROTTLE_MAXIMUM)
		, ma:=DllCall("PowrProf.dll\PowerWrite" Mode "ValueIndex", "Ptr", 0, "Ptr", &GUID_POWER_SAVING
			, "Ptr", &GUID_PROCESSOR_SETTINGS_SUBGROUP, "Ptr", &GUID_PROCESSOR_THROTTLE_MAXIMUM, "UInt", Max, "UInt")=0
	return mi&&ma, ErrorLevel := !(mi&&ma)
}

;enumera todos los planes de energía
;Sintaxis: PowerEnumeratePlans( [plan activo] )
;Parámetros:
	;Plan Activo: devuelve un objeto con información del plan activo.
;Return: [index, {GUID, NAME, ¿DEFAULT?}]
;Ejemplo:
	;for k, v in PowerEnumeratePlans()
	;	MsgBox % "#" k "`nGUID: " v.GUID "`nNombre: " v.Name "`nDefecto: " v.Default
PowerEnumeratePlans(ByRef ActivePlan := "") {
	List := {}
	for k, v in StrSplit(CMD("powercfg /l"), ":", A_Space A_Tab)
		if (A_Index>1) {
			Info := {}, Info.GUID := SubStr(Trim(v), 1, 36), Info.Default := !!InStr(v, "*")
			, Info.Name := Trim(StrSplit(SubStr(v, InStr(v, "(")+1), ")")[1]), List.Push(Info)
			if (Info.Default)
				ActivePlan := Info
		} return List
}

;cambia el plan activo
;Sintaxis: PowerSetActivePlan( [GUID] )
PowerSetActivePlan(GUID) {
	CMD("powercfg /s " RegExReplace(GUID, "[^0-9a-zA-Z-]"))
	return !ErrorLevel
}



































































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: PORTAPAPELES ::::::::::::::::::::::::::::::::::
;Notas:
	;• [NECESARIO!] antes de usar cualquier función, debe llamar a OpenClipboard().
	;• [IMPORTANTE!] cuando termine de usar el portapapeles, debe llamar CloseClipboard().
;Parámetros:
	;• Formato / Format = https://msdn.microsoft.com/en-us/library/windows/desktop/ff729168(v=vs.85).aspx
	;• Data / hMem = HANDLE a los datos en el formato espesificado
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES NECESARIAS
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;abre el portapapeles y evita que otras aplicaciones modifiquen el contenido del portapapeles
;Sintaxis: OpenClipboard( [ms a esperar si no se puede abrir, por defecto 1000ms o 1s], [retraso para comprobar, por defecto 50ms] )
;Return: 0|1
OpenClipboard(Wait := 1000, Delay := 50) {
	Error := ErrorLevel
	if !DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd, "Int") {
		Loop
			Sleep, %Delay%
		until (Ok:=DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd, "Int")) || (A_Index=Ceil(Wait/Delay))
		return Ok, ErrorLevel := Error
	} else return true, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649048(v=vs.85).aspx

;cierra el portapapeles
;Sintaxis: OpenClipboard( [ms a esperar si no se puede cerrar, por defecto 1000ms o 1s], [retraso para comprobar, por defecto 50ms] )
;Return: 0|1
CloseClipboard(Wait := 1000, Delay := 50) {
	Error := ErrorLevel
	if !DllCall("User32.dll\CloseClipboard", "Int") {
		Loop
			Sleep, %Delay%
		until (Ok:=DllCall("User32.dll\CloseClipboard", "Int")) || (A_Index=Ceil(Wait/Delay))
		return Ok, ErrorLevel := Error
	} return true, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649035(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;vacía el portapapeles y libera los HANDLES a los datos en el portapapeles
EmptyClipboard() {
	return DllCall("User32.dll\EmptyClipboard", "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649037(v=vs.85).aspx

;establecer texto en el portapapeles (solo válido para Texto y Archivos)
;Sintaxis: SetClipboardText( [texto], [codificación], [modo] )
;Modos (para incluir varios archivos y/o carpetas (si no existen son omitidos), crear un Array o usar `n):
	;Str (defecto): el 1er parámetro es interpretado como texto
	;Copy: el 1er parámetro es interpretado como archivos y carpetas a copiar (mismo efecto que «Copiar» desde el explorador de windows).
	;Cut: el 1er parámetro es interpretado como archivos y carpetas a mover (mismo efecto que «Cortar» desde el explorador de windows)
;Ejemplos:
	;#1 (copiar texto) = OpenClipboard(), SetClipboardText("Hola, øomo estás?"), CloseClipboard()
	;#2 (copiar archivos) = OpenClipboard(), MsgBox(SetClipboardText(ComSpec "`n" A_WinDir "\explorer.exe",, "Copy")), ExitApp()
SetClipboardText(Text, Encoding := "CP0", Mode := "Str") {
	EmptyClipboard() ;necesario vaciar el portapepeles
	if (Mode="Str") { ;Text
		hGlobal := GlobalAlloc(Bytes:=StrLen(Text) + 1), hLockGlob := GlobalLock(hGlobal)
		, StrPut(Text, hLockGlob+0, Bytes, Encoding), GlobalUnlock(hGlobal)
		return r := SetClipboardData(0x1, hGlobal), GlobalFree(hGlobal), ErrorLevel := !r
	} else if (Mode="Copy") || (Cut:=(Mode="Cut")) { ;Copy | Cut
		Files := GetValidArrayFiles(Text,,, Length) ;obtener un array solo con los archivos existentes
		, hGlobal := GlobalAlloc(20 + (Length + Files.MaxIndex() + 1) * 2, 0x42)
		, hLockGlob := GlobalLock(hGlobal), NumPut(20, hLockGlob+0, 0, "UInt") ;DROPFILES
		, NumPut(1, hLockGlob+0, 16, "UInt"), Offset := 0 ;0 = ANSI | 1 = UNICODE
		for k, v in Files ;añadir la ruta de los archivos al bloque de memoria hGlobal
			Offset += StrPut(v, (hLockGlob+20)+Offset, StrLen(v)+1, "UTF-16") * 2 ;=> Encoding = UTF-16 --> *2
		GlobalUnlock(hGlobal), r := SetClipboardData(15, hGlobal) ;establecer archivos
		, hGlobal := GlobalAlloc(4, 0x42), hLockGlob := GlobalLock(hGlobal) ;FillMemory(hLockGlob, 1, Cut?0x02:0x05)
		, NumPut(Cut?0x02:0x05, hLockGlob+0, 0, "UChar"), GlobalUnlock(hGlobal) ;0x02 = cortar | 0x05 = copiar
		, f := SetClipboardData(RegisterClipboardFormat("Preferred DropEffect"), hGlobal) ;establecer modo (copiar o cortar)
		return f&&r, GlobalFree(hGlobal), ErrorLevel := !f||!r ;si se añadieron los archivos y el modo correctamente, devuelve 1 y ErrorLevel=0
	} return false, ErrorLevel := true ;no se espesifico Str, Copy o Cut, devuelve 0 y ErrorLevel=1
}

;obtiene el texto en el portapapeles (solo válido para Texto y Archivos)
GetClipboardText() {
	Format := GetClipboardFormat()
	if (Format.HasKey(15)) { ;Files (CF_HDROP)
		Text := GetClipboardData(15), hLockGlob := GlobalLock(Text)
		if !(Count:=DllCall("Shell32.dll\DragQueryFileW", "Ptr", hLockGlob, "UInt", 0xFFFFFFFF, "Ptr", 0, "UInt", 0)) ;obtiene la cantidad de archivos
			return "", ErrorLevel := true ;ErrorLevel=1 => [no hay archivos]
		Loop, %Count%
			Size := DllCall("Shell32.dll\DragQueryFileW", "Ptr", hLockGlob, "UInt", A_Index-1, "Ptr", 0, "UInt", 0)
			, VarSetCapacity(Name, (Size+1) * 2, 0), DllCall("Shell32.dll\DragQueryFileW", "Ptr", hLockGlob
			, "UInt", A_Index-1, "Str", Name, "UInt", Size + 1), OutputVar .= Name=""?"":Name "`n"
		return RTrim(OutputVar, "`n"), GlobalUnLock(Text), ErrorLevel := OutputVar=""
	} else if (Unicode:=Format.HasKey(13)) || (Format.HasKey(1)) || (OEM:=Format.HasKey(7)) ;Text
		return StrGet(GetClipboardData(Unicode?13:OEM?7:1), Unicode?"UTF-16":"CP0"), ErrorLevel := false
	return "", ErrorLevel := 2 ;ErrorLevel=2 => formato de momento no soportado
}

;enumera los datos disponibles en el portapapeles
;Return:
	;0 = no hay formatos o ha ocurrido un ERROR
	;[] = array con los formatos OK
;ErrorLevel: 0(OK) | N(ERROR, donde N es un número)
EnumClipboardFormats() {
	Formats := [], Format := 0
	Loop {
		Format := DllCall("User32.dll\EnumClipboardFormats", "UInt", Format, "UInt")
		if !(A_LastError=0) ;ERROR_SUCCESS=0
			return false, ErrorLevel := A_LastError
		if (Format)
			Formats.Push(Format)
		else break
	} return Formats, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649038(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES VARIAS
;Notas:
	;para las siguientes funciones no es necesario usar OpenClipboard()
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;espera a que el portapapeles contenga datos
;Sintaxis: ClipWait( [segundos], [¿cualquier tipo de datos?] )
ClipWait(Seconds := -1, AnyFormats := true) {
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (AnyFormats&&DllCall("User32.dll\CountClipboardFormats"))
		||(!AnyFormats&&(DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 1, "Int")
		||DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 15, "Int")))
			return true, ErrorLevel := false
		if (Seconds>=0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 50
}}

;obtener texto seleccionado (usa el portapapeles)
;Sintaxis: GetSelectedText( [¿no reestablecer portapapeles?] )
GetSelectedText(NoRestoreClipboard := false) {
	Error := ErrorLevel
	if !(NoRestoreClipboard)
		Clip := ClipboardAll
	OpenClipboard(), EmptyClipboard(), CloseClipboard(), Sleep(10)
	, Send("{LCTRL DOWN}c{LCTRL UP}"), Sleep(10), ClipWait(1)
	if !(NoRestoreClipboard)
		Text := Clipboard, Clipboard := Clip
	else Text := Clipboard
	return Text, ErrorLevel := Error
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;almacena información con el formato espesificado en el portapapeles
;Sintaxis: SetClipboardData( [formato], [data] )
SetClipboardData(Format, hMem) {
	return DllCall("User32.dll\SetClipboardData", "UInt", Format, "Ptr", hMem, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649051(v=vs.85).aspx

;recupera datos del portapapeles en el formato espesificado
;Sintaxis: GetClipboardData( [formato] )
GetClipboardData(Format) {
	return DllCall("User32.dll\GetClipboardData", "UInt", Format, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649039(v=vs.85).aspx

;obtiene loas formatos actualmente usados en el portapapeles
GetClipboardFormat() {
	Format := {}
	Loop, Parse, % "2|8|17|5|0x0082|0x008E|0x0083|0x0081|14|0x0300|0x03FF|15|16|3|7|0x0080|9|10|0x0200|0x02FF|11|41|6|13|12", |
		if DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", A_LoopField, "Int")
			Format[A_LoopField] := A_LoopField
	return Format
} IsClipboardFormatAvailable(Format) {
	return DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", Format, "Int")
}

;registra un nuevo formato válido para el portapapeles
RegisterClipboardFormat(Format) {
	return DllCall("User32.dll\RegisterClipboardFormatW", "Ptr", &Format, "UInt")
}






































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: OBJETOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;Devuelve una matriz asociativa de objetos COM activos,donde cada tecla es el apodo, artículo o sufijo del objeto.
;Si se especifica un prefijo, sólo los objetos cuyos apodos del elemento que coincida con el prefijo dado son devueltos, y el prefijo se omite de las teclas devueltas.
GetActiveObjects(Prefix := "", CaseSensitive := false) {
    DllCall("ole32.dll\CoGetMalloc", "UInt", 1, "Ptr*", malloc), objects := {}
    , DllCall("ole32.dll\CreateBindCtx", "UInt", 0, "Ptr*", bindCtx)
    , DllCall(NumGet(NumGet(bindCtx+0)+8*A_PtrSize), "Ptr", bindCtx, "Ptr*", rot)
    , DllCall(NumGet(NumGet(rot+0)+9*A_PtrSize), "Ptr", rot, "Ptr*", enum)
    while DllCall(NumGet(NumGet(enum+0)+3*A_PtrSize), "Ptr", enum, "UInt", 1, "Ptr*", mon, "Ptr", 0) = 0
    {	DllCall(NumGet(NumGet(mon+0)+20*A_PtrSize), "Ptr", mon, "Ptr", bindCtx, "Ptr", 0, "Ptr*", pname) 
        , name := StrGet(pname, "UTF-16"), DllCall(NumGet(NumGet(malloc+0)+5*A_PtrSize), "Ptr", malloc, "Ptr", pname)
        if InStr(name, Prefix, CaseSensitive) = 1 {
            DllCall(NumGet(NumGet(rot+0)+6*A_PtrSize), "Ptr", rot, "Ptr", mon, "Ptr*", punk)
            if (pdsp := ComObjQuery(punk, "{00020400-0000-0000-C000-000000000046}"))
                obj := ComObject(9, pdsp, 1), ObjRelease(punk)
            else obj := ComObject(13, punk, 1)
            objects[SubStr(name, StrLen(Prefix) + 1)] := obj
        } ObjRelease(mon)
    } ObjRelease(enum), ObjRelease(rot), ObjRelease(bindCtx), ObjRelease(malloc)
    return objects
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=6494

;registra un objeto como el objeto activo para su clase (permite manejar un script desde otro proceso)
;Sintaxis: RegisterActiveObject( [obj], [CLSID], [opciones], [nombre] )
;CLISD: CLSID del objeto activo o dejar vacio para poner fin a un objeto activo
;Nombre: espesificar un nombre para agregar el CLSID al registro
;Ejemplo:
	;obj := new MyClass("{436cf066-cf70-4ca9-990f-c7083fea8367}", "AHK") ;crear objeto [CLSID, Nombre]
	;x := ComObjActive("{436cf066-cf70-4ca9-990f-c7083fea8367}") ;obtener objeto (usado desde otro proceso/script) -->
	;x.MyFunc("Test!") ;llama a la funcion MyFunc() dentro de la clase MyClass, igual que obj.MyFunc("Test!") <--
	;ExitApp
	;class MyClass {
	;	__New(CLSID, Name) {
	;		RegisterActiveObject(this, CLSID,, Name) ;«this» es el objeto (MyClass)
	;	} MyFunc(String) {
	;		MsgBox %String%
	;	}
	;}
RegisterActiveObject(Object, CLSID := "", Flags := 0, AppId := "") {
	static l := {}
	if !(CLSID) && !((r:=l.Remove(Object))="") ;eliminar objeto activo
		return !(r:=DllCall("OleAut32.dll\RevokeActiveObject", "UInt", r, "Ptr", 0)), ErrorLevel := r
	if !(CLSID) || (I[Object]) || !(VarSetCapacity(c, 16, 0)) 
		return false, ErrorLevel := I[Object]?2:true ;ErrorLevel 2 = el objeto ya se encuentra registrado
	if ((h:=DllCall("Ole32.dll\CLSIDFromString", "WStr", CLSID, "Ptr", &c))<0)
		return false, ErrorLevel := 3 ;ErrorLevel 3 = CLSID inválido
	if ((h:=DllCall("OleAut32.dll\RegisterActiveObject", "Ptr", &Object, "Ptr", &c, "UInt", Flags, "UInt*", r, "UInt"))<0)
		return false, ErrorLevel := Format("0x{:x}", h) ;ErrorLevel X = RegisterActiveObject ERROR
	if !(AppId="") ;agregar al registro con el nombre espesificado (usuario actual)
		RegWrite(, "HKCU\Software\Classes\" AppId,, AppId)
		, RegWrite(, "HKCU\Software\Classes\" AppId "\CLSID",, CLSID)
		, RegWrite(, "HKCU\Software\Classes\CLSID\" CLSID,, AppId)
	return r, ErrorLevel := !r, l[Object] := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221551(v=vs.85).aspx

CreateDIBSection(Width, Height, hDC := 0, bpp := 32, ByRef ppvBits := 0) {
	hDC2 := hDC?hDC:GetDC()
	, VarSetCapacity(BITMAPINFO, 40, 0), NumPut(Width, BITMAPINFO, 4, "UInt")
	, NumPut(Height, BITMAPINFO, 8, "UInt"), NumPut(40, BITMAPINFO, 0, "UInt")
	, NumPut(1, BITMAPINFO, 12, "UShort"), NumPut(0, BITMAPINFO, 16, "UInt")
	, NumPut(bpp, BITMAPINFO, 14, "UShort"), hbm := DllCall("Gdi32.dll\CreateDIBSection"
	, "Ptr", hDC2, "Ptr", &BITMAPINFO, "UInt", 0, "PtrP", ppvBits, "Ptr", 0, "UInt", 0, "Ptr")
	if !(hDC)
		ReleaseDC(0, hDC2)
	return hbm
}

;recupera información para el objeto grafico espesificado
;Sintaxis: GetObject( [objeto], [bytes], [objeto (out)], [var_bytes] )
;var_bytes: establecer capacidad de la variable, si se espesifica el 3er parámetro no debe ser una Adress(&). -1 para usar bytes
;Nota: para calcular el tamaño, dejar el 2do parámetro vacío o en 0
GetObject(Object, Bytes := 0, ByRef OutObject := 0, VarCap := 0) {
	if ((Bytes+0)="") || !(Bytes) || !(Bytes>0) ;calcular tamaño, en bytes
		Bytes := DllCall("Gdi32.dll\GetObjectW", "Ptr", Object, "Int", 0, "Ptr", 0, "UInt")
	if (VarCap) ;OutObject | else &OutObject
		VarSetCapacity(OutObject, 0), VarSetCapacity(OutObject, VarCap=-1?Bytes:VarCap, 0)
	return DllCall("Gdi32.dll\GetObjectW", "Ptr", Object, "Int", Bytes, "Ptr", VarCap?&OutObject:OutObject, "UInt")
} ;https://msdn.microsoft.com/en-us/library/dd144904(v=vs.85).aspx

;Sintaxis: SelectObject( [hDC], [objeto] )
;Return: Object | Value
SelectObject(hDC, Object) {
	return DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", Object, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/dd162957(v=vs.85).aspx

DeleteObject(Object*) {
	Ok := 0, Error := ErrorLevel
	Loop, % Object.MaxIndex()
		Ok += !!DllCall("Gdi32.dll\DeleteObjectW", "Ptr", Object[A_Index], "UInt")
	return Ok=Object.MaxIndex(), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/dd183539(v=vs.85).aspx

;crea un objeto que se puede utilizar para pasar un valor ByRef
;Modo De Uso:
	;ComVar := ComVar() --> crear 
	;ComVar[] --> recupera el valor
	;ComVar[] := Val --> establece el valor.
	;ComVar.ref --> recupera un objeto ByRef para pasar a una función COM
ComVar() {
	static base := {__Get: "ComVarGet", __Set: "ComVarSet", __Delete: "ComVarDel"}
	static ComObjParam := A_AhkVersion<2?"ComObjParameter":"ComObject"
	r := DllCall("OleAut32.dll\SafeArrayAccessData", "Ptr", ComObjValue(arr:=ComObjArray(0xC, 1)), "PtrP", data)
	return {ref: %ComObjParam%(0x400C, data), _: arr, base: base}, ErrorLevel := r
} ComVarGet(cv, p*) {
	if !(p.MaxIndex())
		return cv._[0]
} ComVarSet(cv, v, p*) {
	if !(p.MaxIndex())
		return cv._[0] := v
} ComVarDel(cv) {
	DllCall("OleAut32.dll\SafeArrayUnaccessData", "Ptr", ComObjValue(cv._))
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3964

























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: OTROS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;ejecuta el script como administrador
RunAsAdmin() {
	if !(A_IsAdmin) && (%true%!=A_ScriptFullPath) && (IsWindowsVistaOrGreater()) {
		_ := A_IsCompiled?A_ScriptFullPath:A_AhkPath
		Run, *RunAs "%_%" "%A_ScriptFullPath%" "%A_ScriptFullPath%",, UseErrorLevel
		if !(ErrorLevel)
			ExitApp
		return false
	} return true
} RunAsAdminInit() { ;} ;<-- //RunAsAdmin
	static RunAsAdminInit := RunAsAdminInit()
	ProcessSetPrivilege := ProcessAdjustPrivileges(-1, "SeDebugPrivilege,SeShutdownPrivilege,SeTakeOwnershipPrivilege"
		. ",SeIncreaseBasePriorityPrivilege,SeIncreaseWorkingSetPrivilege,SeLockMemoryPrivilege,SeSecurityPrivilege,SeSystemtimePrivilege"
		. ",SeTakeOwnershipPrivilege,SeTimeZonePrivilege,SeUndockPrivilege")
	ComObjError(false) ;desactivar las notificaciones de errores COM (Component Object Model).
	SetWorkingDir, %A_ScriptDir% ;establece el directorio de trabajo.
	SetBatchLines, -1 ;hace que el script trabaje a la máxima velocidad posible (afecta y es afectada por al uso de CPU).
	SetTitleMatchMode, 2 ;el título de una ventana puede contener «WinTitle» en cualquier lugar dentro para ser valido.
	SendMode, Input ;SendInput es generalmente mas rápido y mas fiable.
	CoordMode, Mouse, Screen
	SetControlDelay, 10 ;establece algunos retrasos para mejorar la fiabilidad y/o velocidad de respuesta entre cada comando. -->
	SetKeyDelay, 10, 10, 10
	SetMouseDelay, 0
	SetWinDelay, 50 ;<--
}

PixelGetColor(x := "", y := "", AltSlowRGB := 0) {
	if (x="")||(y="")
		MouseGetPos(x_, y_)
	PixelGetColor, OutputVar, % (x="")?x_:x, % (y="")?y_:y, %AltSlowRGB%
	return OutputVar
}

;determina si el script ya se está ejecutando en el mismo directorio y con igual nombre.
;Ejemplo de uso:
	;#SingleInstance Off
	;#Persistent
	;MsgBox % Instance()
Instance(Close := false) {
	static hMutex ;ERROR_ALREADY_EXISTS = 183 | ERROR_ACCESS_DENIED = 0x00000005
	if (Close)
		return DllCall("Kernel32.dll\ReleaseMutex", "Ptr", hMutex)+DllCall("Kernel32.dll\CloseHandle", "Ptr", hMutex)
	Name := "_" StrLeft(StrReplace(StrReplace(A_ScriptFullPath, "\"), ":"), 259)
	, hMutex := DllCall("Kernel32.dll\CreateMutexW", "Ptr", 0, "Int", false, "Str", "Local\" Name)
	return A_LastError=183?(hMutex?hMutex:false):false
		, ErrorLevel := hMutex=""?true:(A_LastError=0x00000005?true+1:false)
}

;bloquear mouse y teclado
;Sintaxis: BlockInput( [Enable|Disable] )
BlockInput(OnOff, Delay := 500, DisableTaskManager := true, Suspend := true) {
	static TaskManager
	static BlockInput := Func("BlockInput").Bind("Enable")
	if (OnOff="Enable"||OnOff="Disable") { ;Enable | Disable = bloquear/desbloquear normal
		return DllCall("User32.dll\BlockInput", "Int", OnOff="Enable"?true:false)
	} else if (OnOff=0||OnOff="Off") { ;Off = desbloquear
		SetTimer(BlockInput,  "Off")
		if (DisableTaskManager) {
			if !(TaskManager)
				RegDelete( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger" )
			else RegWrite(, "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger", TaskManager)
		} if (Suspend)
			Suspend, Off
		return DllCall("User32.dll\BlockInput", "Int", false)
	} else if (OnOff=1||OnOff="On") { ;On = bloquear
		if (Suspend)
			Suspend, On
		if (Delay>0)
			SetTimer(BlockInput, Delay)
		if (DisableTaskManager)
			TaskManager := RegRead("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger")
			, RegWrite(, "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger", "Disable")
		return DllCall("User32.dll\BlockInput", "Int", true)
}}

;Define el contenido de la variable de entorno especificada para el proceso actual.
;Sintaxis: EnvAdd( [nombre], [valor], [user|system] )
EnvAdd(lpName, lpValue, Type := "") {
	return Type="User"?RegWrite(, "HKCU\Environment", lpName, lpValue)
		: Type="System"?RegWrite(, "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", lpName, lpValue)
		: DllCall("Kernel32.dll\SetEnvironmentVariableW", "Str", lpName, "Str", lpValue)
}	

;Recupera el contenido de la variable especificada desde el bloque de entorno del proceso invocador
EnvGet(EnvVarName, ByRef UserEnv := "", ByRef SystemEnv := "") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683188%28v=vs.85%29.aspx
	UserEnv := IsByRef(UserEnv)?RegRead("HKCU\Environment", EnvVarName):""
	, SystemEnv := IsByRef(SystemEnv)?RegRead("HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", EnvVarName):""
	, nSize := DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Ptr", 0, "UInt", 0)
	, VarSetCapacity(lpBuffer, nSize * 2, 0) ;max 32767
	, DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Str", lpBuffer, "UInt", nSize)
	return lpBuffer, ErrorLevel := !nSize
}

;Notifica el sistema operativo y todas las aplicaciones que se ejecutan que las variable(s) del sistema han cambiado .
EnvUpdate() {
	return SendMessage(0xFFFF, 0x001A,,, "Str", "Environment")
}

;obtener sugerencias de una palabra vía google
GoogleSuggest(query) { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=7182
	if !query
		return
    i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, i.Open("GET", "http://suggestqueries.google.com/complete/search?output=firefox&q=" query, 1)
		, i.Send(), i.WaitForResponse()
    s := StrReplace(i.ResponseText, Chr(34) ",[" Chr(34), "`r`n")
		, s := StrReplace(s, Chr(34) "," Chr(34), "`r`n"), s := StrReplace(s, Chr(34))
		, s := StrReplace(s, "["), s := StrReplace(s, "]"), s := StrReplace(s, query,,, 1)
	return StrReplace(s, "`r`n",,, 1)
}

;hModule := GetModuleHandle("User32.dll"), hModule := hModule?hModule:LoadLibrary("User32.dll")
;Address := GetProcAddress(hModule, "GetSysColor") ;DllCall("User32.dll\GetSysColor", "Int", 16, "UInt")
;MsgBox % DllCall(Address, "Int", 16, "UInt") ". ErrorLevel: " ErrorLevel "`n`nFreeLibrary: " FreeLibrary(hModule)
GetModuleHandle(DllFile, Flags := 0x00000002) { ;GetModuleHandle( [dll] )
	Error := ErrorLevel
	Ok := DllCall("Kernel32.dll\GetModuleHandleExW", "UInt", Flags, "Str", DllFile, "PtrP", hModule, "UInt")
	return Ok?hModule:false, ErrorLevel := Error
} GetProcAddress(hModule, Function) { ;GetProcAddress( [hModule --> GetModuleHandle()/LoadLibrary()], [func] )
	Error := ErrorLevel
	return DllCall("Kernel32.dll\GetProcAddress", "Ptr", hModule, "AStr", Function, "Ptr"), ErrorLevel := Error
} LoadLibrary(DllFile, Flags := 0x000000) { ;LoadLibrary( [dll] )
	Error := ErrorLevel
	return DllCall("Kernel32.dll\LoadLibraryExW", "Str", DllFile, "UInt", 0, "UInt", Flags, "Ptr"), ErrorLevel := Error
} FreeLibrary(hModule) {
	Error := ErrorLevel
	return DllCall("Kernel32.dll\FreeLibrary", "Ptr", hModule), ErrorLevel := Error
}

;Sintaxis: SetTimer( [Etiqueta], [Período], [Prioridad -2147483648~2147483647] )
SetTimer(Label := "", PeriodOnOffDelete := "On", ThreadPriority := 0, Wait := true) {
	if !(Wait)
		SetTimer, %Label%, -1, %ThreadPriority%
	SetTimer, %Label%, %PeriodOnOffDelete%, %ThreadPriority%
}

;saltar a la etiqueta, hotkey o hotstring espesificada.
;Sintaxis: gosub( [etiqueta], [0|1] )
gosub(Label, Check := true) {
	if (Check&&IsLabel(Label))
		gosub, %Label%
}

;esperar (ms)
;Sintaxis: Sleep( [milisegundos], [¿usar mayor precisión?] )
;Nota: para usar mayor precisión por defecto, usar Sleep( [-2 | -3] )
Sleep(Delay := 0, pc := false) {
	static Frequency, DefaultMode
	if (Delay>=-1) {
		if !(pc) && !(DefaultMode) {
			Sleep, %Delay%
		} else {
			if !Frequency
				DllCall("Kernel32.dll\QueryPerformanceFrequency", "Int64*", Frequency)
			DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Start)
			, Finish := Start+(Frequency*(Delay/1000))
			Loop
				DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Current)
			until (Current >= Finish)
	}} else if (Delay=-2||Delay=-3) ;-2 = QueryPerformanceCounter. -3 = Normal
		DefaultMode := Delay=-2?true:false
}

;reiniciar script
Reload(Force := false, ExitCode := 0) {
	Instance(true)
	if (Force) {
		if A_IsCompiled
			Run, "%A_ScriptFullPath%"
		else Run, "%A_AhkPath%" "%A_ScriptFullPath%"
		ExitApp( Force, ExitCode )
	} Reload
}

;termina el script
;Sintaxis: ExitApp( [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
ExitApp(Force := false, ExitCode := 0) {
	if (Force)
		ProcessClose(ProcessExist(),,, ExitCode)
	ExitApp, %ExitCode% ;DllCall("User32.dll\PostQuitMessage", "Int", 0)
}

;tiempo fuera en el que el script finaliza
;Sintaxis: ExitAppTimer( [segundos], [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
;EJEMPLO:
	;ExitAppTimer(5)
	;Loop {
		;ToolTip % ExitAppTimer()
		;Sleep 100
	;}
ExitAppTimer(Seconds := "", Force := 0, ExitCode := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=46906#p46906
    static ending
	static ExitAppTimer := Func("ExitAppTimer")
    if (Seconds="ExitApp")
        ExitApp(Force, ExitCode)
    if !(Seconds)
        return (ending - A_TickCount) / 1000.0
    SetTimer(ExitAppTimer.Bind("ExitApp", Force, ExitCode), -(Seconds*1000))
    ending := A_TickCount+(Seconds*1000)
}

;recupera el tiempo que ha pasado (ms) desde que el script se inició
GetTickCount(ByRef TickCount := "") {
	return TickCount := DllCall("Kernel32.dll\GetTickCount")
}

;establece el directorio de trabajo.
SetWorkingDir(DirName) {
	return DllCall("kernel32.dll\SetCurrentDirectoryW", "Str", DirName)
}

;obtiene el directorio de trabajo
GetWorkingDir() {
	uSize := VarSetCapacity(lpBuffer, (260 + 1) * 2) / 2
	, DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt*", uSize, "Str", lpBuffer)
	return lpBuffer
}

GetLastError(ByRef FormatMessage := "", dwFlags := 0x1000) {
	return LastError := DllCall("Kernel32.dll\GetLastError")
		, FormatMessage := IsByRef(FormatMessage)?FormatMessage(LastError, dwFlags):""
} SetLastError(num) {
	return DllCall("User32.dll\SetLastErrorEx", "UInt", num, "UInt", 0)
} FormatMessage(dwMessageId := "", dwFlags := 0x1000) {
	dwMessageId := dwMessageId!=""?dwMessageId:GetLastError()
	, nSize := VarSetCapacity(lpBuffer, 2024) - 1524
	, DllCall("Kernel32.dll\FormatMessageW", "UInt", dwFlags, "Ptr", 0, "UInt", dwMessageId, "UInt", 0x800, "Str", lpBuffer, "UInt", nSize, "UInt", 0)
	return lpBuffer
}

FormatTime(Time, Format := "yyyyMMddHmmss") {
	FormatTime, hTime, %Time%, % Format=""?"dd/MM/yyyy (HH:mm:ss tt)":Format
	return hTime
}

;traducir texto vía google translate
;Sintaxis: Translate( [texto], [entrada], [salida] )
;EJEMPLO: MsgBox % Translate("Hello, this is a test", "en", "es")
Translate(String, From := "", To := "") { ;no fiable
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	, url := "https://translate.google.com/translate_a/single?client=t&sl=" From "&tl=" To
	     . "&dt=bd&dt=ex&dt=ld&dt=md&dt=qca&dt=rw&dt=rm&dt=ss&dt=t&dt=at&ie=UTF-8&oe=UTF-8&otf=2&srcrom=0&ssel=0&tsel=3&q=" string
	, i.Open("GET", url, true)
	, i.SetRequestHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko)")
	, i.Send(), i.WaitForResponse()
	return RegExReplace(i.ResponseText, "^.*?" Chr(34) "(.*?)" Chr(34) ".*$")
}

;separar tiempo
;Sintaxis: SplitTime( [YYYYMMDDHH24MISS], [año], [mes], [dia], [hora], [min], [seg], [AM/PM] )
;Nota: devuelve un Array con el tiempo en el siguiente orden: año, mes, día, hora, min, seg, am/pm.
;Ejemplo: MsgBox % (i:=SplitTime()) i[3] "/" i[2] "/" i[1] " (" i[4] ":" i[5] ":" i[6] ")"
SplitTime(Time := "", ByRef Year := "", ByRef Mon := "", ByRef Day := "", ByRef Hour := "", ByRef Min := "", ByRef Sec := "", ByRef Mark := "") {
	FormatTime, Time, %Time%, yyyy,MM,dd,HH,mm,ss,tt
	Time := StrSplit(Time, ",")
	Loop, Parse, % "Year,Mon,Day,Hour,Min,Sec,Mark", `,
		%A_LoopField% := Time[A_Index]
	return Time
}

;obtener color de fondo por defecto usado por autohotkey en las ventanas (gui)
GetGuiDefaultColor() {
	return RGB((((l:=DllCall("User32.dll\GetSysColor","Int",15,"UInt"))>>16)&0xFF)|(l&0x00FF00)|((l&0xFF)<<16))
}

;crear ventana
;Sinstaxis: CreateWindow( [x], [y], [ancho], [alto], [titulo], [estilo], [estilo extendido], [parent], [menu], [clase] )
;Return: devuelve el hWnd
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx
;Estilos exentido: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543(v=vs.85).aspx
CreateWindow(x, y, Width, Height, Caption := "", Style := 0x10cb0000, ExStyle := 0x0, Parent := 0x0, Menu := 0x0, Class := "MDIClient") {
	hWnd := DllCall("User32.dll\CreateWindowExW", "UInt", ExStyle, "Ptr", &Class, "Ptr", &Caption, "UInt", Style
		, "Int", x, "Int", y, "Int", Width, "Int", Height, "Ptr", Parent, "Ptr", Menu, "Ptr", A_ScriptHwnd, "PtrP", 0)
	return hWnd, ErrorLevel := !hWnd
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx

;crear control
;Sintaxis: CreateControl( [hWnd ventana], [clase], [x], [y], [ancho], [alto], [texto], [estilo], [estilo extendido] )
;Return: devuelve el hWnd
;Clases: Button, ComboBox, Edit, ListBox, RichEdit, RICHEDIT_CLASS, SCROLLBAR, STATIC
CreateControl(hWnd, Class, x, y, Width, Height, Caption := "", Style := 0x56000000, ExStyle := 0x0) {
	return CreateWindow(x, y, Width, Height, Caption, Style, ExStyle, hWnd,, Class)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632679(v=vs.85).aspx































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: REGISTRO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
SetRegView(RegView := "Default") {
	SetRegView, %RegView%
}

;leer en el registro
;Sintáxis: RegRead( [Clave\SubClave], [Valor] )
;Nota: para leer el valor por defecto, no espesificar el 2do parámetro.
RegRead(Key, ValueName*) {
	if (ValueName.MaxIndex())
		RegRead, Value, %Key%, % ValueName[1]
	else RegRead, Value, %Key%
	return Value
}

;elimina en el registro
;Sintáxis: RegDelete( [Clave\SubClave], [Valores*] )
;NOTAS: para eliminar el valor por defecto, espesificar un valor vacio
	;para eliminar la clave entera, no espesificar el 2do parámetro.
RegDelete(Key, ValueName*) {
	if !(Key)
		return false, ErrorLevel := true
	if (ValueName.MaxIndex()) {
		hRegKey := RegOpenKey(Key, 0x0002)
		for k, v in ValueName
			Result := DllCall("Advapi32.dll\RegDeleteValueW", "Ptr", hRegKey, "Str", v)
		DllCall("Advapi32.dll\RegCloseKey", "Ptr", hRegKey), ErrorLevel := Result?true:false
	} else RegDelete, %Key%
	return ErrorLevel?false:Key
}

;escribe en el registro
;Sintáxis 1: RegWrite( [Tipo], [Clave\SubClave], [Valor], [Datos] )
;Sintáxis 2: RegWrite( [Clave\SubClave] )
;Tipos: BINARY|DWORD|EXPAND|MULTI|SZ
RegWrite(ValueType := 0, Key := "", ValueName := "", Value*) {
	static ValueTypes := {"REG_BINARY": "REG_BINARY", "BINARY": "REG_BINARY"
		, "REG_DWORD": "REG_DWORD", "DWORD": "REG_DWORD"
		, "REG_EXPAND_SZ": "REG_EXPAND_SZ", "EXPAND": "REG_EXPAND_SZ"
		, "REG_MULTI_SZ": "REG_MULTI_SZ", "MULTI": "REG_MULTI_SZ"
		, "REG_SZ": "REG_SZ", "SZ": "REG_SZ"}
	if !(Type:=ValueTypes[ValueType])
		Key := Key?Key:ValueType, Type := "REG_SZ"
	if !(Key)
		return false
	if (ValueName="") && !(Value.MaxIndex()) 
		RegWrite, %Type%, %Key%
	else if (ValueName="")
		RegWrite, %Type%, %Key%,, % Value[1]
	else if (Value.MaxIndex())
		RegWrite, %Type%, %Key%, %ValueName%, % Value[1]
	else RegWrite, %Type%, %Key%, %ValueName%
	return ErrorLevel?false:Key
}

;importar clave
;sintaxis: RegImport( [Archivo], [¿Esperar?] )
RegImport(FileName, Wait := false) {
	if !IsFile(FileName)
		return false, ErrorLevel := true
	if Wait
		RunWait, %A_WinDir%\regedit.exe -v -s "%FileName%",, UseErrorLevel
	else Run, %A_WinDir%\regedit.exe -v -s "%FileName%",, UseErrorLevel
	return !ErrorLevel
}

;exportar clave
;sintaxis: RegExport( [Clave], [Archivo], [¿Esperar?], [¿reescribir si ya existe el archivo?] )
RegExport(Key, FileName, Wait := false, OverWrite := true) {
	if !(OverWrite) && (FileExist(FileName))
		return false, ErrorLevel := true
	Key := RegFormatKey(Key, true)
	if (Wait)
		RunWait, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%",, UseErrorLevel
	else Run, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%",, UseErrorLevel
	return !ErrorLevel
}

;renombrar una clave
;Sintaxis: RegRenameKey( [clave\subclave], [nuevo nombre], [¿sobreescribir si ya existe una clave con el mismo nombre?] )
;ErrorLevel: 2 = ya existe una clave con el mismo nombre | 3 = el nuevo nombre espesificao no es válido | 4 = la clave a renombrar no es válida
;Ejemplo: RegRenameKey("HKLM\Software\AutoHotKey", "AutoHotKey_Rename")
RegRenameKey(Key, NewName, OverWrite := false) {
	NewName := StrReplace(NewName, "\")
	if (NewName="") || !(InStr(Key, "\"))
		return false, ErrorLevel := NewName=""?3:4
	SplitPath, Key,, BKey
	return RegMoveKey(Key, BKey "\" NewName, OverWrite)
}

;mover clave junto con todos los valores y subclaves
;Sintaxis: RegMoveKey( [clave\subclave], [clave\subclave destino], [¿sobreescribir?] )
;ErrorLevel: 2 = ya existe la clave destino
;Ejemplo: 
	;MsgBox % RegMoveKey("HKLM\Software\AutoHotKey", "HKCU\AutoHotKey") "," ErrorLevel
	;MsgBox % RegMoveKey("HKCU\AutoHotKey", "HKLM\Software\AutoHotKey") "," ErrorLevel
RegMoveKey(Key, KeyDest := "", OverWrite := false) {
	if (RegExistKey(KeyDest)) {
		if !(OverWrite)
			return false, ErrorLevel := 2
		RegDelete(KeyDest)
	} Result := RegCopyKey(Key, KeyDest)
	if (Result)
		return Result, RegDelete(Key), ErrorLevel := !Result
	return false
}

;copiar clave junto con todos los valores, opcional incluir subclaves
;Sintaxis: RegCopyKey( [clave\subclave], [clave\subclave destino], [¿copiar subclaves?=true] )
;Nota: si la clave destino no existe, la crea.
;Ejemplo: RegCopyKey("HKLM\Software\AutoHotKey", "HKCU\AutoHotKey")
RegCopyKey(Key, KeyDest, Recurse := true) { ;KEY_READ = 0x20019 | KEY_ALL_ACCESS = 0xF003F
	hRegKey := RegOpenKey(Key, 0x20019, Result:=false), hRegKeyDest := RegOpenKey(KeyDest,, true)
	if (Recurse) {
		if (IsWindowsVistaOrGreater()) ;if OS Version >= Win V | ERROR_SUCCESS = 0
			Result := DllCall("Advapi32.dll\RegCopyTreeW", "Ptr", hRegKey, "Ptr", 0, "Ptr", hRegKeyDest) ;WIN_V+
		else Result := DllCall("Shlwapi.dll\SHCopyKeyW", "Ptr", hRegKey, "Ptr", 0, "Ptr", hRegKeyDest, "UInt", 0) ;WIN_2000+
	} else {
		Loop, Reg, %Key%, V
			RegWrite(A_LoopRegType, KeyDest, A_LoopRegName, RegRead(Key, A_LoopRegName))
		if (Value:=RegRead(Key))
			RegWrite(, KeyDest,, Value)
	} return !Result, RegCloseKey(hRegKeyDest, hRegKey), ErrorLevel := Result
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379768(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/bb773482(v=vs.85).aspx

;comprueba si existe una clave 
;Sintaxis: RegExistKey( [clave], [¿buscar en subclaves?] )
RegExistKey(Key, Recurse := false) {
	SplitPath, Key, KeyName, BKey
	Loop, Reg, %BKey%, % Recurse?"KR":"K"
		if (A_LoopRegName=KeyName)
			return true, ErrorLevel := false
	return false, ErrorLevel := true
}

;transforma una clave en su forma larga/corta
;Sintaxis: RegFormatKey( [clave], [modo] )
;Modos: 0 = forma corta | 1 = forma larga
RegFormatKey(Key, Mode := 0) {
	static _0 := {"HKEY_CLASSES_ROOT": "HKCR", "HKEY_CURRENT_CONFIG": "HKCC", "HKEY_CURRENT_USER": "HKCU", "HKEY_LOCAL_MACHINE": "HKLM", "HKEY_USERS": "HKU"}
	static _1 := {"HKCR": "HKEY_CLASSES_ROOT", "HKCC": "HKEY_CURRENT_CONFIG", "HKCU": "HKEY_CURRENT_USER", "HKLM": "HKEY_LOCAL_MACHINE", "HKU": "HKEY_USERS"}
	if (p:=InStr(Key:=Trim(Key, "`r`n" A_Space "\" A_Tab), "\"))
		s := StrTrimLeft(Key, p-1), Key := StrLeft(Key, p-1)
	return (Mode?(_1[Key]?_1[Key]:Key):(_0[Key]?_0[Key]:Key)) s
}

;separa una clave en clave, subclave
;Sintaxis: SplitKey( [clave], [clave (salida)], [subclave (salida)] )
SplitKey(_Key, ByRef Key := "", ByRef SubKey := "") {
	_Key := Trim(_Key)
	return (Key:=(KeyPos:=InStr(_Key, "\"))?SubStr(_Key, 1, KeyPos-1):_Key)
		. (SubKey:=Trim(KeyPos?"\" SubStr(_Key, (KeyPos+1)):"", "\"))
}

;devuelve una clave o valor que no exista
;Sintaxis: RegFNKey( [clave], [valor], [inicio], [fin] )
;Ejemplo:
	;RegDelete("HKCU\Lol"),RegDelete("HKCU\Lol(1)"),MsgBox(RegFNKey("HKCU\Lol")),RegWrite("HKCU\Lol"),MsgBox(RegFNKey("HKCU\Lol"))
	;,RegWrite("HKCU\Lol(1)"),MsgBox(RegFNKey("HKCU\Lol")),RegDelete("HKCU\Lol"),RegDelete("HKCU\Lol(1)"),ExitApp()
RegFNKey(Key, Value := "", Start := "(", End := ")") {
	if (Value="") {
		Loop {
			if RegExistKey(tmpkey?tmpkey:Key)
				tmpkey := tmpkey?StrReplace(tmpkey, Start (A_Index-1) End, Start A_Index End):Key Start 1 End
			else return tmpkey?tmpkey:Key
	}} else {
		Loop {
			if RegExistKey(Key, tmpkey?tmpkey:Value)
				tmpkey := tmpkey?StrReplace(tmpkey, Start (A_Index-1) End, Start A_Index End):Value Start 1 End
			else return tmpkey?tmpkey:Value
}}}

;abrir clave en regedit
;Sintaxis: RegOpen( [clave\subclave] )
;Ejemplo: MsgBox % RegOpen("HKLM\SOFTWARE\Classes\*") "," ErrorLevel
RegOpen(Key) {
	if !(RegExistKey(Key:=Trim(Key)))
		return false, ErrorLevel := true
	Key := RegFormatKey(Key, true), ProcessClose("regedit.exe*")
	, RegWrite(, "HKCU\Software\Microsoft\Windows\CurrentVersion\Applets\Regedit", "LastKey", Key)
	Run, %A_WinDir%\regedit.exe
	return !ErrorLevel
	;if !(PID:=ProcessWait("regedit.exe", 5)) ;seleccionar valores --->
	;	return false, ErrorLevel := true
	;Loop, 30 ;3s
	;	Sleep, 100
	;until (ID:=WinExist("ahk_pid " PID))
	;if !(IsWindow(hWnd:=ControlExist(ID, "SysListView321")))
	;	return false, ErrorLevel := true
	;Loop, 50 ;5s
	;	Sleep, 100
	;until ((Count:=LV_GetItemCount(hWnd))>0)
	;if !(Count>1) ;valor defecto + otro(s)
	;	return true, ErrorLevel := false
	;MsgBox % Count ;cantidad de valores en la clave actual {...} <--
}

;abre una clave
;Sintaxis: RegOpenKey( [clave\subclave], [acceso], [¿crear la clave si no existe?] )
;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724878%28v=vs.85%29.aspx
;Claves: HKCR|HKCU|HKLM|HKU|HKPD|HKCC
RegOpenKey(Key, DesiredAccess := 0xF003F, CreateIfNotExist := false) {
	static Keys := {"HKEY_CLASSES_ROOT": 0x80000000, "HKCR": 0x80000000
		, "HKEY_CURRENT_USER": 0x80000001, "HKCU": 0x80000001
		, "HKEY_LOCAL_MACHINE": 0x80000002, "HKLM": 0x80000002
		, "HKEY_USERS": 0x80000003, "HKU": 0x80000003
		, "HKEY_PERFORMANCE_DATA": 0x80000004, "HKPD": 0x80000004
		, "HKEY_CURRENT_CONFIG": 0x80000005, "HKCC": 0x80000005}
	RegView := A_RegView="32"?0x0200:A_RegView="64"?0x0100:0x0000, SplitKey(Key, Key, SubKey)
	if !(Keys[Key]) ;KEY_WOW64_32KEY = 0x0200 | KEY_WOW64_64KEY = 0x0100 | Default = 0x0
		return false, ErrorLevel := true
	if (CreateIfNotExist) ;ERROR_SUCCESS = 0 (RegCreateKeyExW y RegOpenKeyExW devuelven 0 si no hubo errores)
		Result := DllCall("Advapi32.dll\RegCreateKeyExW", "UInt", Keys[Key], "Str", SubKey, "UInt", 0, "Ptr", 0, "UInt", 0, "UInt", DesiredAccess|RegView, "Ptr", 0, "PtrP", hRegKey, "Ptr", 0)
	else Result := DllCall("Advapi32.dll\RegOpenKeyExW", "UInt", Keys[Key], "Str", SubKey, "UInt", 0, "UInt", DesiredAccess|RegView, "PtrP", hRegKey)
	return hRegKey, ErrorLevel := Result 
} RegCloseKey(Key*) {
	Error := ErrorLevel, Ok := 0
	Loop, % (Key.MaxIndex())
		Ok += DllCall("Advapi32.dll\RegCloseKey", "Ptr", Key[A_Index], "UInt")=0 ;ERROR_SUCCESS = 0
	return Ok=Key.MaxIndex(), ErrorLevel := Error
}

;establecer seguridad para la clave
;Sintaxis: RegSetSecurity( [clave\subclave], [usuario], [acceso] )
;Parámetros: ver FileSetSecurity()
;Nota: la función falla si el usuario actual no es el propietario. usar RegSetOwner()
RegSetSecurity(Key, Trustee := "", AccessMask := 0x1F01FF, Flags := 1, AccesFlag := 0) { ;WIN_V+
	Trustee := Trustee=""?A_UserNameEx():Trustee
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key, 3, 1)
	, Owner := oADsSecurityDescriptor.Owner
	if !(Trustee=Owner) && !(Owner="") && !(Trustee="")
		RegSetOwner(Key, Trustee)
	oDiscretionaryAcl := oADsSecurityDescriptor.DiscretionaryAcl
	, oAccessControlEntry := ComObjCreate("AccessControlEntry")
	, oAccessControlEntry.Trustee := Trustee
	, oAccessControlEntry.AccessMask := AccessMask
	, oAccessControlEntry.AceFlags := Flags
	, oAccessControlEntry.AceType := AccesFlag
	, oDiscretionaryAcl.AddAce(oAccessControlEntry)
	, oADsSecurityUtility.SetSecurityDescriptor(Key, 3, oADsSecurityDescriptor, 1)
}

;establecer el propietario
;Sintaxis: RegSetOwner( [clave], [usuario] )
;Parámetros:
	;Usuario: espesificar el dominio\usuario o el SID del usuario. por defecto usa el usuario actual.
RegSetOwner(Key, Owner := "", Recurse := false) {
	Owner := Owner=""?A_UserNameEx():Owner
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key, 3, 1)
	if !(oADsSecurityDescriptor.Owner=Owner)
		oADsSecurityDescriptor.Owner := Owner
		, oADsSecurityUtility.SetSecurityDescriptor(Key, 3, oADsSecurityDescriptor, 1)
	if (Recurse)
		Loop, Reg, %Key%, KR
			oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key:=(A_LoopRegKey "\"
			. (A_LoopRegSubkey=""?"":A_LoopRegSubkey "\") A_LoopRegName), 3, 1)
			, oADsSecurityDescriptor.Owner := Owner
			, oADsSecurityUtility.SetSecurityDescriptor(Key, 3, oADsSecurityDescriptor, 1)
}

;obtiene el dominio y nombre de usuario propietario
;Sintaxis: RegGetOwner( [clave] )
;Return: dominio\usuario
RegGetOwner(Key) { ;WIN_V+
	oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key, 3, 1)
	return oADsSecurityDescriptor.Owner
}





















































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: EDIT CONTROL ::::::::::::::::::::::::::::::::::
NOTAS:
	;para establecer o quitar un estilo, usar WinSetStyle(hWnd, Estilo)
	;para obtener el estilo, usar WinGetStyle(hWnd)
#############################################################################################################################################
*/
;obtiene el número de líneas
;Sintaxis: Edit_GetLineCount( [hWnd] )
;Nota: si no hay texto en el control, devuelve 1. el valor nunca será inferior a 1.
Edit_GetLineCount(hWnd) {
	return SendMessage(hWnd, 0x00BA,,,,, "Int")
}

;obtiene el texto de una linea
;Sintaxis: Edit_GetLineText( [hWnd], [Linea] )
Edit_GetLineText(hWnd, Line := -1) {
	nSize := 32767 ;SendMessage(hWnd, 0x00C1,, Line-1)
	, Line := Line=-1?Edit_GetCurrentLine(hWnd):Line
	, VarSetCapacity(LineText, nSize, 0), NumPut(nSize, LineText, 0, "UShort")
	, SendMessage(hWnd, 0x00C4, "Int", Line-1, "Int", &LineText)
	return LineText 
}

;obtiene el índice de la línea que contiene el índice de caracteres especificado en un control de edición multilínea
;Sintaxis: Edit_GetCurrentLine( [hWnd], [índice] )
;Nota: por defecto obtiene la linea actual.
Edit_GetCurrentLine(hWnd, Line := -1) {
	return SendMessage(hWnd, 0x00C9, "Int", Line=-1?-1:Line-1,,, "Int")+1
}

;obtiene el número de columna en el que reside el cursor (punto de inserción de texto). 
;Sintaxis: Edit_GetColumn( [hWnd], [inicio (salida)], [fin (salida)] )
;Inicio: columna donde empieza la seleccion
;Fin: columna donde termina la seleccion
;Notas: 
	;si no hay texto seleccionado, el 2do y 3er parametro devuelven el mismo resultado.
	;la primera columna es 1.
	;si hay texto seleccionado en el control, devuelve el número de columna donde comienza la selección.
Edit_GetColumn(hWnd, ByRef Starting := "", ByRef End := "") {
	VarSetCapacity(s, 4), VarSetCapacity(e, 4)
	, SendMessage(hWnd, 0x00B0,, &s,, &e)
	, Starting := NumGet(s, 0, "UInt")+1, End := NumGet(e, 0, "UInt")+1
	return Starting
}

;obtiene el hWnd del Edit de un ComboBox. opcional también el del DropDownList
;Sintaxis: Edit_GetComboBox( [hWnd], [ComboBox (salida)], [DropDownList (salida)] )
Edit_GetComboBox(hWnd, ByRef DropDownList := "", ByRef EditRect := "", ByRef DDLRect := "") {
	nSize := VarSetCapacity(COMBOBOXINFO, 40+(A_PtrSize*3), 0)
	, NumPut(nSize, COMBOBOXINFO, 0, "UInt")
	, r:=DllCall("User32.dll\GetComboBoxInfo", "Ptr", hWnd, "Ptr", &COMBOBOXINFO)
	return NumGet(COMBOBOXINFO, 40+A_PtrSize, "UPtr")
		, DropDownList := IsByRef(DropDownList)?NumGet(COMBOBOXINFO, 44+A_PtrSize, "UPtr"):""
		, EditRect := IsByRef(EditRect)?NumGet(COMBOBOXINFO, 28+A_PtrSize, "Ptr"):""
		, DDLRect := IsByRef(DDLRect)?RECT(NumGet(COMBOBOXINFO, 12+A_PtrSize, "Ptr")):""
		, ErrorLevel := !r
}

;obtiene el texto
;Sintaxis: Edit_GetText( [hWnd] )
Edit_GetText(hWnd) {
	nSize := SendMessage(hWnd, 0x000E,,,,, "UInt")
	, VarSetCapacity(Text, (nSize * 2) + 1, 0)
	, SendMessage(hWnd, 0x000D, "UInt", nSize+1,, &Text)
	return Text
}

;recupera informacion de la barra de desplazamiento.
;Sintaxis: Edit_GetScrollBarInfo( [hWnd], [barra], [enabled], [pressed], [offscreen], [visible], [coordenadas] )
;Barra: 0 = horizontal | 1 = vertical (defecto)
;Enabled: la barra está deshabilitada. (0|1)
;Pressed: se pulsa sobre la barra. (0|1)
;OffScreen: la ventana tiene un tamaño tal que la barra no se muestra actualmente. (0|1)
;Visible: indica que la barra existe. (0|1)
Edit_GetScrollBarInfo(hWnd, ScrollBar := 1, ByRef Enabled := "", ByRef Pressed := "", ByRef OffScreen := "", ByRef Visible := "", ByRef RECT := "") {
	VarSetCapacity(SCROLLBARINFO, 60, 0), NumPut(60, SCROLLBARINFO, 0, "UInt")
	return r:=DllCall("User32.dll\GetScrollBarInfo", "Ptr", hWnd
		, "Int", ScrollBar=0?0xFFFFFFFA:ScrollBar=1?0xFFFFFFFB:ScrollBar
		, "Ptr", &SCROLLBARINFO), SBInfo := NumGet(SCROLLBARINFO, 36, "UInt")
	, RECT := IsByRef(RECT)?NumGet(SCROLLBARINFO, 16, "Ptr"):"", Visible := SBInfo&0x8000?false:true, ErrorLevel := !r
	, Pressed := SBInfo&0x8?true:false, OffScreen := SBInfo&0x10000?true:false, Enabled := SBInfo&0x1?false:true
}

;obtiene la señal textual que se muestra por el control de edición
;Sintaxis: Edit_GetCueBannerText( [hWnd] )
Edit_GetCueBannerText(hWnd, nSize := 2048) {
	VarSetCapacity(Text, nSize, 0)
	, SendMessage(hWnd, 0x1502,, &Text, "UInt", nSize)
	return Text
}

;obtiene el carácter de contraseña que se muestra en el control
;Sintaxis: Edit_GetPasswordChar( [hWnd] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_GetPasswordChar(hWnd) {
	SendMessage(hWnd, 0x00D2)
}

;obtiene las coordenadas del control
;Sintaxis: Edit_GetPos( [hWnd], [x], [y], [ancho], [alto] )
Edit_GetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 16, 0)
	, r:=DllCall("User32.dll\GetWindowRect", "Pr", hWnd, "Ptr", &RECT)
    , i := {}, i.w := i.Width := Width := NumGet(RECT, 8, "Int")-NumGet(RECT, 0, "Int")
	, i.h := i.Height := Height := NumGet(RECT, 12, "Int")-NumGet(RECT, 4, "Int")
	, DllCall("User32.dll\ScreenToClient", "Ptr", DllCall("User32.dll\GetParent", "Ptr", hWnd), "Ptr", &RECT)
	, i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	return i, ErrorLevel := !r
}

;obtener ancho de los margenes izquierdo y derecho
;Sintaxis: Edit_GetMargins( [hWnd], [margen izquierdo (out)], [margen derecho (out] )
Edit_GetMargins(hWnd, ByRef Left := "", ByRef Right := "") {
	OutputVar := SendMessage(hWnd, 0x00D4)
	return [Left := OutputVar & 0xffff, Right := OutputVar >> 16]
}

;--------------------------------------------------------------------------------------------------------------------------

;establece el límite de texto
;Sintaxis: Edit_SetLimitText( [hWnd], [limite de caracteres 1~64000] )
Edit_SetLimitText(hWnd, Limit := 64000) {
	return SendMessage(hWnd, 0x00C5,, Limit)
}

;establece la señal textual que se muestra por el control de edición para pedir al usuario para obtener información
;Sintaxis: Edit_SetCueBannerText( [hWnd], [texto], [¿mostrar siempre?] )
;Nota: no se puede establecer en un control de edición multilínea.
Edit_SetCueBannerText(hWnd, Text := "", Flag := false) {
	return SendMessage(hWnd, 0x1501, "Int", Flag,, &Text)
}

;selecciona un rango de caracteres en un control de edición
;Sintaxis: Edit_SetSel( [hWnd], [inicio], [fin] )
;Notas:
	;espesificar -1 en el 1er parametro para deseleccionar todo.
	;espesificar 0 en el 1er parametro y -1 en el 2do para seleccionar todo (defecto).
Edit_SetSel(hWnd, Starting := 0, End := -1) {
	return SendMessage(hWnd, 0x00B1,, Starting>0?Starting-1:Starting,, End>0?End-1:End)
}

;establecer el estilo ReadOnly (el usuario no puede cambiar el texto)
;Sintaxis: Edit_SetReadOnly( [hWnd], [0|1] )
Edit_SetReadOnly(hWnd, State := true) {
	return SendMessage(hWnd, 0x00CF, "Int", State)
}

;muestra un asterisco (*) (o el carácter espesificado) para cada carácter escrito en el control de edición.
;Sintaxis: Edit_SetPasswordChar( [hWnd], [0|1|Carácter] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_SetPasswordChar(hWnd, PassChar := true) {
	return r:=SendMessage(hWnd, 0x00CC,, PassChar=0?0:Asc(PassChar=1?"*":PassChar))
		, WinRedraw(hWnd), ErrorLevel := !r
}

;establece el texto espesificado
;Sintaxis: Edit_SetText( [hWnd], [Texto] )
;Nota: puede usar Edit_ReplaceSelText() como alternativa.
Edit_SetText(hWnd, Text := "") {
	return SendMessage(hWnd, 0x000C,,,, &Text)
}

;establecer ancho de los margenes derecho y/o izquierdo
;Sintaxis: Edit_SetMargins( [hWnd], [margen izquierdo], [margen derecho] )
Edit_SetMargins(hWnd, Left := "", Right := "") {
	if (Left="") || (Right="")
		Edit_GetMargins(hWnd, L, R), Left := Left=""?L:Left, Right := Right=""?R:Right
	return true, SendMessage(hWnd, 0x00D3, "UInt", 0x0001|0x0002,, (Left & 0xffff) + (Right << 16))
}

;establecer icono en el lado izquierdo o derecho
;Sintaxis: Edit_SetIcon( [hWnd], [Icono], [color], [etiqueta al hacer clic en la imagen], [¿lado derecho?] )
;Icono: espesificar el icono o un Array con el [icono, indice]
;Color: espesificar un Array. [color de fondo del Gui, color de fondo del control]
;Return: devuelve un Array. [hWnd de la ventana, hWnd del Picture control] 
;Nota: destruir la ventana cuando se deje de usar. Usar WinDestroy(hWnd de la ventana)  o GuiDestroy
;Ejemplo:
	;Gui, Add, Edit, w300 h21 HWNDhEdit, This is an Edit Control!
	;Gui, Show
	;Info := Edit_SetIcon(hEdit, ["shell32", 32],, "MyLabel")
	;return
	;MyLabel:
	;MsgBox
	;return
	;GuiClose:
	;WinDestroy(Info[1]) ;destruir ventana
	;ExitApp
Edit_SetIcon(hWnd, Icon, Color := "", Label := "", Right := false) {
	Index := IsObject(Icon)?(Icon[2]>1?Icon[2]:1):1, Icon := IsObject(Icon)?Icon[1]:Icon
	, WinGetPos(hWnd,,, w, h, 1), h := h-5, Color := IsObject(Color)?Color:["", "White"]
	try {
		Gui, New, +HWNDID -Caption +Parent%hWnd%
		Gui, %ID%:Color, % Color[1], % Color[2]
		Gui, %ID%:Margin, 0, 0
		Gui, %ID%:Add, Picture, % "HWNDhPic h" h " w" h " Icon" Index (IsLabel(Label)?" g" Label:""), %Icon%
		Gui, %ID%:Show, % "x" (Right?w-h-2:2) " y2 h" h " w" h
	} catch
		return false, WinDestroy(ID), ErrorLevel := true
	return [ID, hPic], WinSetStyle(hWnd, "+" 0x02000000), Edit_SetMargins(hWnd, Right?"":h+4, Right?h+4:""), ErrorLevel := !(ID)
}

;--------------------------------------------------------------------------------------------------------------------------

;comprueba si el control tiene el foco del teclado.
;Sintaxis: Edit_HasFocus( [hWnd], [hWnd del control que tiene el foco (salida)] )
Edit_HasFocus(hWnd, ByRef hWndFocus := "") {
	nSize := VarSetCapacity(GUITHREADINFO, A_PtrSize=4?48:72, 0)
	, NumPut(nSize, GUITHREADINFO, 0, "UInt")
	, DllCall("User32.dll\GetGUIThreadInfo", "Ptr", 0, "Ptr", &GUITHREADINFO)
	, hWndFocus := NumGet(GUITHREADINFO, A_PtrSize=4?12:16, "Ptr")
	return (r:=hWnd=hWndFocus), ErrorLevel := !r
}

;comprueba si el control admite multilinea
;Sintaxis: Edit_IsMultiline( [hWnd] )
Edit_IsMultiline(hWnd) {
	return WinGetStyle(hWnd)&0x0004
}

;comprueba si tiene el estilo ReadOnly (el usuario no puede cambiar el texto)
;Sintaxis: Edit_ReadOnly( [hWnd] )
Edit_ReadOnly(hWnd) {
	return WinGetStyle(hWnd)&0x0800
}

;compruea si tiene el estilo ES_PASSWORD
;Sintaxis: Edit_PasswordChar( [hWnd] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_PasswordChar(hWnd) {
	return WinGetStyle(hWnd)&0x0020
}

;muestra/oculta un globo de informacion asociado con un control de edición
;Sintaxis: Edit_ShowBalloonTip( [hWnd], [Título], [Texto], [Icono] )
;Iconos: Informacion = 1-4 | advertencia = 2-5 | error = 3-6
;Nota: para ocultar, no espesificar ningún parámetro.
Edit_ShowBalloonTip(hWnd, Info*) {
	if !Info.MaxIndex()
		return SendMessage(hWnd, 0x1504)
	Title := Info[1], Text := Info[2], Icon := Info[3]?Info[3]:0
	, nSize := VarSetCapacity(EDITBALLOONTIP, A_PtrSize=4?16:32, 0)
	, NumPut(nSize, EDITBALLOONTIP, 0, "UInt"), NumPut(&Title, EDITBALLOONTIP, A_PtrSize, "Ptr")
	, NumPut(&Text, EDITBALLOONTIP, A_PtrSize*2, "Ptr"), NumPut(Icon, EDITBALLOONTIP, A_PtrSize*3, "Int")
	return SendMessage(hWnd, 0x1503,,,, &EDITBALLOONTIP)
}

;habilita/deshabilita las barras de desplazamiento.
;Sintaxis: Edit_EnableScrollBar( [hWnd], [barra], [modo], [otras opciones, ver nota] )
;Barra: 0 = horizontal | 1 = vertical | 3 = ambas
;Modo: 0 = deshabilitar | 1 = habilitar (defecto)
;Nota: para mas opciones ver: https://msdn.microsoft.com/en-us/library/windows/desktop/bb787579%28v=vs.85%29.aspx
Edit_EnableScrollBar(hWnd, wSBflags, Enable := true, wArrow := -1) {
	return DllCall("User32.dll\EnableScrollBar", "Ptr", hWnd, "UInt", wSBflags
		, "UInt", wArrow=-1?(Enable?0x0:0x3):wArrow)
}

;muestra/oculta las barras de desplazamiento.
;Sintaxis: Edit_ShowScrollBar( [hWnd], [barra], [modo] )
;Barra: 0 = horizontal | 1 = vertical | 3 = ambas
;Modo: 0 = ocultar | 1 = mostrar (defecto)
Edit_ShowScrollBar(hWnd, ScrollBar, Show := true) {
	return DllCall("User32.dll\ShowScrollBar", "Ptr", hWnd, "UInt", ScrollBar, "Int", !!Show)
}

;sustituye el texto seleccionado
;Sintaxis: Edit_ReplaceSelText( [hWnd], [texto] )
Edit_ReplaceSelText(hWnd, Text := "") {
	return SendMessage(hWnd, 0x00C2, "Int", true,, &Text)
}

;eliminar el texto seleccionado
;Sintaxis: Edit_SelClear( [hWnd] )
Edit_SelClear(hWnd) {
	return SendMessage(hWnd, 0x0303)
}

;copiar el texto seleccionado al portapapeles
;Sintaxis: Edit_SelCopy( [hWnd] )
Edit_SelCopy(hWnd) {
	return SendMessage(hWnd, 0x0301)
}

;cortar el texto seleccionado al portapapeles
;Sintaxis: Edit_SelCut( [hWnd] )
Edit_SelCut(hWnd) {
	return SendMessage(hWnd, 0x0300)
}

;pegar el texto del portapapeles
;Sintaxis: Edit_SelPaste( [hWnd] )
Edit_SelPaste(hWnd) {
	return SendMessage(hWnd, 0x0302)
}

;muestra un dialogo para elegir la fuente y la aplica al control
;Sintaxis: Edit_SelectFont( [hWnd], [calidad (ver FontCreate)], [¿redibujar?] )
;EJEMPLO:
	;Gui, Add, Edit, x5 y5 w490 h270 HWNDhWnd +HScroll, Fuente ~ Edit Control, AutoHotKey %A_AhkVersion%
	;Gui, Add, Button, x20 y280 w455 h25 gSelectFont, Cambiar Fuente
	;Gui, Show, w500 h315
	;Gui, +OwnDialogs +AlwaysOnTop ;OwnDialogs impide interactuar con la ventana hasta cerrar el dialogo
	;return
	;GuiClose:
	;ExitApp
	;SelectFont:
	;Edit_SelectFont(hWnd, 5, true)
	;return
Edit_SelectFont(hWnd, Quality := 2, Redraw := false) {
	static Color := [], List := []
	for k, v in List
		if !IsWindow(k)
			FontDelete(v), List.RemoveAt(A_Index)
	FontInfo := FontQuery(ControlGetFont(false, hWnd))
	, FontInfo := FontSelect(DllCall("User32.dll\GetParent", "Ptr", hWnd), FontInfo[1]
		, [Color[hWnd], FontInfo[2], FontInfo[3], FontInfo[4], FontInfo[5], FontInfo[6]])
	if (ErrorLevel)
		return false
	ControlSetColor(false, hWnd, FontInfo[1]), Color[hWnd] := FontInfo[1]
	, hFont := FontCreate(FontInfo[0], FontInfo[2], FontInfo[3]
	, FontInfo[4], FontInfo[5], FontInfo[6], Quality), List[hWnd] := hFont
	return ControlSetFont(false, hWnd, hFont, Redraw)?hFont:false
}






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: BUTTON CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece un icono a un boton
;Sintaxis: BC_SetIcon( [hWnd], [Icono], [opciones] )
;Opciones: espesificar la letra seguida de un valor.
	;W = ancho | H = alto
	;L = margen izquierdo | R = margen derecho
	;T = margen superior | B = margen inferior
	;A = alineación (0 = izquierda, 1 = derecha, 2 = superior, 3 = inferior, 4 = centro)
;Icono: espesificar una lista de imágenes, una imagen o un array [imagen, indice]
	;Indice 1 = Normal
	;Indice 2 = Al posicionar el cursor por encima del boton
	;Indice 3 = Al precionar
	;Indice 4 = Deshabilitado
	;Indice 5 = Defecto (para evitar que el boton quede sin imagen, espesificar la misma imagen que en el indice 1)
;Ejemplo:
	/*
	Gui, Add, Button, HWNDB1 w100 h25, Button1
		BC_SetIcon(B1, A_AhkPath) ;normal
	Gui, Add, Button, HWNDB2 w25
		BC_SetIcon(B2, [A_WinDir "\explorer.exe", 1]) ;Array [imagen, indice]
	ImageList := IL_Create(5, 1, 1) ;usar imagenes grandes
	IL_Add(ImageList, A_Windir "\regedit.exe") ;indice 1 = NORMAL
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 2 = CURSOR
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 3 = CLIC
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 4 = DESHABILITADO
	IL_Add(ImageList, A_Windir "\regedit.exe") ;indice 5 = DEFECTO --> NORMAL
	Gui, Add, Button, HWNDB3 w100 h45
		BC_SetIcon(B3, ImageList, "A4") ;ImageList
	Gui, Show
	return
	GuiClose:
	Exitapp
	*/
BC_SetIcon(hWnd, ImageList, Options := "L2") {
	Flag := SplitFlags(Options, "\d", "w", "h", "l", "t", "r", "b", "a")
	if !(ImageList+0)
		v := IL_CreateEx(1, 1,, Flag[1]>0?Flag[1]:16, Flag[2]>0?Flag[2]:16)
		, IL_Add(v, IsObject(ImageList)?ImageList[1]:ImageList, ImageList[2]>1?ImageList[2]:1), ImageList := v
	VarSetCapacity(BUTTON_IMAGELIST, 20 + A_PtrSize, 0)
	, NumPut(ImageList, BUTTON_IMAGELIST, 0, "Ptr")
	, NumPut(Flag[3]?Flag[3]:0, BUTTON_IMAGELIST, 0 + A_PtrSize, "UInt")
	, NumPut(Flag[4]?Flag[4]:0, BUTTON_IMAGELIST, 4 + A_PtrSize, "UInt")
	, NumPut(Flag[5]?Flag[5]:0, BUTTON_IMAGELIST, 8 + A_PtrSize, "UInt")
	, NumPut(Flag[6]?Flag[6]:0, BUTTON_IMAGELIST, 12 + A_PtrSize, "UInt")
	, NumPut(Flag[7]?Flag[7]:0, BUTTON_IMAGELIST, 16 + A_PtrSize, "UInt")
	return SendMessage(hWnd, 0x1602,,,, &BUTTON_IMAGELIST)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb775975(v=vs.85).aspx

;simula clic en el boton.
;Sintaxis: BC_Click( [hWnd] )
;Nota: la ventana debe estar activa.
BC_Click(hWnd) {
	return SendMessage(hWnd, 0x00F5)
}






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: STATUS BAR CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recuperar el texto
;Sintaxis: SB_GetText( [hWnd], [parte] )
SB_GetText(hWnd, Index := 1) {
	Size := SendMessage(hWnd, 0x040C, "Int", Index-1) & 0xffff ;LOWORD
	, VarSetCapacity(Text, Size * 2, 0)
	, SendMessage(hWnd, 0x040D, "Int", Index-1, "Str", Text)
	return Text
}

;obtener cantidad de partes
;Sintaxis: SB_GetParts( [hWnd] )
SB_GetParts(hWnd) {
	return SendMessage(hWnd, 0x0406)
}

;obtener color de fondo RGB
;Sintaxis: SB_GetBKColor( [hWnd] )
SB_GetBKColor(hWnd) {
	WinSetRedraw(hWnd, false)
	, Color := SB_SetBKColor(hWnd, "Red")
	, SB_SetBKColor(hWnd, Color)
	return Color, WinSetRedraw(hWnd)
}

;-------------------------------------------------------------------------------------------------------------------------------------------

;cambiar color de fondo
;Sintaxis: SB_SETBKCOLOR( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB
;Return: devuelve el color anterior
;Nota: usar -Theme en las opciones al crear el control.
SB_SetBKColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x2001,,, "UInt", RGBToInt(_getcolor(Color))))
}













































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: LISTVIEW CONTROL ::::::::::::::::::::::::::::::::::
;Parámetros:
	;hWnd = hwnd del control
	;Item = Indice. 0 = todos
;#############################################################################################################################################
;obtiene la cantidad de items
LV_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1000+4,,,,, "Int")
}

;elimina item. dejar vacio el segundo parámetro para eliminar todos los items
LV_DeleteItem(hWnd, Item := 0) {
	return SendMessage(hWnd, 0x1000+(Item>0?8:9), "Int", Item>0?Item-1:0)
}

;eliminar columna
LV_DeleteColumn(hWnd, Column := 1) {
	return SendMessage(hWnd, 0x1000+28, "Int", Column-1)
}

;actualiza un item
LV_Update(hWnd, Item) {
	return SendMessage(hWnd, 0x1000+42, "Int", Item-1)
}

;redibujar items
LV_RedrawItem(hWnd, ItemFirst := 0, ItemLast := "") {
	If (ItemFirst > 0)
		ItemLast := ItemLast=""?ItemFirst:ItemLast
	else ItemLast := (ItemFirst:=SendMessage(hWnd, 0x1027))+SendMessage(hWnd, 0x1028)
	return SendMessage(hWnd, 0x1000+21, "Int", ItemFirst-1, "Int", ItemLast-1), DllCall("User32.dll\UpdateWindow", "Ptr", hWnd)
}

;cambiar texto a un item
;Sintaxis: LV_SetItemText( [LV], [texto], [item], [columna] )
LV_SetItemText(hWnd, pszText := "", Item := 1, Column := 1) {
	VarSetCapacity(LVITEM, A_PtrSize=4?60:80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	, NumPut(&pszText, LVITEM, A_PtrSize=4?20:24, "Ptr"), NumPut(StrLen(pszText)+1, LVITEM, A_PtrSize=4?24:32, "Int")
	return SendMessage(hWnd, 0x1000+116, "Int", Item-1,, &LVITEM)
}

;obtener texto de un item
;Sintaxis: LV_GetItemText( [LV], [item], [columna] )
LV_GetItemText(hWnd, Item := 0, Column := 1, MaxChars := 514) {
	VarSetCapacity(LVITEM, A_PtrSize = 4 ? 60 : 72, 0)
	, NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int"), cchTextMax := (VarSetCapacity(pszText, MaxChars, 0) / 2) + 1
	, NumPut(&pszText, LVITEM, A_PtrSize = 4 ? 20 : 24, "Ptr"), NumPut(cchTextMax, LVITEM, A_PtrSize = 4 ? 24 : 32, "Int")
	, TextLength := SendMessage(hWnd, 0x1000+115, "Int", Item-1,, &LVITEM, "UIntP")
	return StrGet(&pszText, TextLength)
} LV_GetItemTextEx(hWnd, Item, Column := 1, ByRef ProcessId := "") {
	ProcessId := ProcessId?ProcessId:WinGetPid(hWnd), hProcess := OpenProcess(ProcessId, 0x0008|0x0010|0x0020)
	, pAddress := VirtualAlloc(hProcess,, A_PtrSize=4?60:80), pAddress2 := VirtualAlloc(hProcess,, cchTextMax:=1024+1)
	, VarSetCapacity(LVITEM, A_PtrSize=4?60:80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	, VarSetCapacity(pszText, cchTextMax * 2, 1), NumPut(pAddress2, LVITEM, A_PtrSize=4?20:24, "Ptr")
	, NumPut(cchTextMax, LVITEM, A_PtrSize=4?24:32, "Int"), WriteProcessMemory(hProcess, pAddress, &lvItem, A_PtrSize=4?60:80)
	, r:=SendMessage(hWnd, 0x1000+115, "Int", Item-1, "UInt", pAddress), ReadProcessMemory(hProcess, pAddress2, &pszText, cchTextMax)
	return pszText, VirtualFree(hProcess, pAddress), VirtualFree(hProcess, pAddress2), CloseHandle(hProcess), ErrorLevel := !r
} ;http://www.autohotkey.com/board/topic/81820-how-to-get-specific-row-text-in-a-syslistview32-easily/

;busca items uno por uno.
;Sintaxis: LV_GetNextItem( [LV], [modo] )
;Modos: F = foco | S = seleccionado
LV_GetNextItem(hWnd, Item := 0, Mode := "") {
	Index := SendMessage(hWnd, 0x1000+12, "Int", Item, "UInt", Mode="S"?0x0002:Mode="F"?0x0001:0x0000)
	return Index, ErrorLevel := Index=-1
}

;establece/quita/alterna estilos extendidos a la ventana.
;Sintaxis: LV_SetExStyle( [hWnd], [+-^Estilos] )
;ESTILOS: https://msdn.microsoft.com/en-us/library/windows/desktop/bb774732(v=vs.85).aspx
	;0x010000 = dibujo vía doble búfer, lo que reduce el parpadeo
	;0x00000004 = activa las casillas de verificación para los elementos (checkbox)
	;0x00000001 = muestra líneas de cuadrícula alrededor de los elementos y subelementos (grid)
LV_SetExStyle(hWnd, ExStyle) {
	Key := SubStr(ExStyle:=Trim(ExStyle), 1, 1), ExStyle := (Key="+"||Key="-"||Key="^")?SubStr(ExStyle, 2):ExStyle
	if (Key="-")
		return SendMessage(hWnd, 0x1036, "UInt", ExStyle)
	if (Key="^")
		return LV_SetExStyle(hWnd, ((LV_GetExStyle(hWnd)&ExStyle)?"-":"") ExStyle)
	return SendMessage(hWnd, 0x1036, "UInt", ExStyle, "UInt", ExStyle)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761165%28v=vs.85%29.aspx
 
;obtener estilo extendido.
;Sintaxis: LV_GetExStyle( [hWnd] )
LV_GetExStyle(hWnd) {
	return SendMessage(hWnd, 0x1037,,,,, "UInt")
}

LV_GetSelected(Col := 1, Type := "F") {
	RowNumber := 0
	while (RowNumber:=LV_GetNext(RowNumber, Type))
		LV_GetText(Text, RowNumber, Col), Result .= Text "`n"
	return RTrim(Result, "`n")
}

;determina si un item es visible
;Sintaxis: LV_IsItemVisible( [ID], [item] )
LV_IsItemVisible(hWnd, Item) {
	return SendMessage(hWnd, 0x10B6, "Int", Item-1)
}

;Establece el espacio entre iconos en la vista de iconos.
;Sintaxis: LV_SetIconSpacing( [ID], [eje x, distancia en pixeles], [eje y, distancia en pixeles] )
LV_SetIconSpacing(hWnd, cx, cy) {
	cx := ((cx<4)&&(cx!=-1))?4:cx, cy := ((cy<4)&&(cy!=-1))?4:cy
	return SendMessage(hWnd, 0x1035,,,, LOWORD(cx)+HIWORD(cy, false))
}

;obtiene el espacio entre iconos en la vista de iconos.
;Sintaxis: LV_GetIconSpacing( [ID], [eje x, distancia en pixeles (salida)], [eje y, distancia en pixeles (salida)] )
LV_GetIconSpacing(hWnd, ByRef cx := "", ByRef cy := "") {
	IcSp := SendMessage(hWnd, 0x1033)
   return [cx:=(IcSp & 0xFFFF), cy:=(IcSp >> 16)]
}

;obtener posicion de un item
;Sintaxis: LV_GetItemPos( [ID], [item], [x (salida)], [y (salida)] )
;Nota: devuelve un Array con la posicion xy.
LV_GetItemPos(hWnd, Item, ByRef x := "", ByRef y := "") {
	VarSetCapacity(POINT, A_PtrSize*2, 0), SendMessage(hWnd, 0x1010,, Item-1,, &POINT)
	return [x:=NumGet(POINT, 0, "Int"), y:=NumGet(POINT, 4, "Int")]
} LV_GetItemPosEx(hWnd, Item, ByRef x := "", ByRef y := "", ByRef ProcessId := "") {
	ProcessId := ProcessId?ProcessId:WinGetPid(hWnd), hProcess := OpenProcess(ProcessId, 0x0008|0x0010|0x0020)
	, pAddress := VirtualAlloc(hProcess,, 0x00001000), SendMessage(hWnd, 0x1000+16, "Int", Item-1,, pAddress)
	, VarSetCapacity(RECT, 16, 0), ReadProcessMemory(hProcess, pAddress, &RECT, 16)
	return [x:=NumGet(RECT, 0, "Int"), y:=NumGet(RECT, 4, "Int")], VirtualFree(hProcess, pAddress), CloseHandle(hProcess)
} ;http://www.autohotkey.com/board/topic/9760-lvm-geticonposition/

;establece la posicion de un item
;Sintaxis: LV_SetItemPos( [ID], [item], [x], [y] )
LV_SetItemPos(hWnd, Item, x := "", y := "") {
	if (x="") || (y="")
		LV_GetItemPos(hWnd, Item, _x, _y)
	return SendMessage(hWnd, 0x100F,, Item-1,, LOWORD(x=""?_x:x)+HIWORD(y=""?_y:y, false))
} LV_SetItemPosEx(hWnd, Item, x := "", y := "", ProcessId := "") {
	if (x="") || (y="")
		LV_GetItemPosEx(hWnd, Item, _x, _y, ProcessId)
	return SendMessage(hWnd, 0x100F,, Item-1,, LOWORD(x=""?_x:x)+HIWORD(y=""?_y:y, false))
}

;obtiene el número de columna en las coordenadas espesificadas.
;Sintaxis: LV_SubItemHitTest( [hWnd], [x], [y] )
;Nota: si no espesifica las coordenadas, por defecto usa las del cursor.
LV_SubItemHitTest(hWnd, x := -1, y := -1, ScreenToClient := false) {
	if !(x>0) || !(y>0)
		CursorGetPos(_x, _y,, ((x=-1)&&(y=-1))?hWnd:(ScreenToClient?hWnd:false))
	, VarSetCapacity(LVHITTESTINFO, 24, 0), NumPut((x>0)?x:_x, LVHITTESTINFO, 0, "Int")
	, NumPut((y>0)?y:_y, LVHITTESTINFO, 4, "Int"), r:=SendMessage(hWnd, 0x1039,,,, &LVHITTESTINFO)
	return (r=-1)?0:NumGet(LVHITTESTINFO, 16, "Int")+1, ErrorLevel := (r=-1)
}

;buscar elementos en el control que contengan el texto expesificado, los demás son eliminados.
;Sintaxis: LV_SearchEx( [items], [texto a buscar], [columnas], [elementos máximos a mostrar], [hWnd del control] )
;Items: espesificar un array con los items en el control. Sintaxis: [["item 1, col 1", "item 1, col 2"], ["item 2, col 1"]]
;Columna: espesificar las columnas en las que buscar separadas por coma. por defecto busca en todas (-1).
;Notas: usar LV_SetExStyle(hWnd, 0x00010000) para reducir el parpadeo. usar SetTimer() para cuando haya muchos items.
;Return: devuelve un array con la cantidad de items encontrados.
/* ::::: EJEMPLO DE USO :::::
Gui, Add, ListView, x0 y0 w585 h180 HWNDhWnd, Nombre|Descripción
Gui, Add, Edit, x0 y185 w585 h25 gFind HWNDFind
Gui, Show, w586 h242, Test LV_SearchEx()
Items := [], LV_SetExStyle(hWnd, 0x00010000), WinSetRedraw(hWnd, false)
Loop, 50 {
	LV_Add(, "Item " A_Index " (" Chr(A_Index) ")", "Descripción " A_Index " (" Chr(A_Index*2) ")")
	Items.Push(["Item " A_Index " (" Chr(A_Index) ")", "Descripción " A_Index " (" Chr(A_Index*2) ")"])
} LV_ModifyCol(1, "AutoHdr"), WinSetRedraw(hWnd)
return
GuiClose:
ExitApp
Find:
LV_SearchEx(Items, ControlGetText(0, Find), -1, -1, hWnd)
return
*/
LV_SearchEx(Items, Text := "", Col := -1, Max := -1, hWnd := "") {
	static Func := Func("LV_SearchExFind")
	if !(LV_GetCount()>40) ||!XXX
		return LV_SearchExFind(Items, Text, Col, Max, hWnd)
	return SetTimer(Func.Bind(Items, Text, Col, Max, hWnd), -350)
} LV_SearchExFind(Items, Text, Col, Max, hWnd) {
	static Func := Func("LV_SearchEx_Find")
	WinSetRedraw(hWnd=""?A_DefaultListView:hWnd, false), LV_Delete(), OuputVar := []
	while (LV_GetCount())
		Sleep, -1
	Loop, % ((Text="")?0:Items.MaxIndex()) {
		if (CurrentItemIndex:=A_Index) && (OuputVar.MaxIndex()>=Max) && (Max!=-1)
			break
		CurrentItemText := IsObject(Items[A_Index])?Items[A_Index]:[Items[A_Index]]
		Loop, % CurrentItemText.MaxIndex() {
			if (Col!=-1) && !(Contains(Col, A_Index, ",", A_Space A_Tab))
				continue
			if (InStr(CurrentItemText[A_Index], Text)) && ((Max=-1) || !(OuputVar.MaxIndex()>=Max)) {
				OuputVar.Push(LV_Add(, Items[CurrentItemIndex]*))
				break
	}}} if !(OuputVar.MaxIndex()) && (Text="") {
		Loop, % (Items.MaxIndex())
			LV_Add(, Items[A_Index]*)
	} return OuputVar, WinSetRedraw(hWnd=""?A_DefaultListView:hWnd)
}

;buscar elemento en el control que contenga el texto expesificado y lo selecciona.
;Sintaxis 1: LV_Search( [texto a buscar], [columnas separadas por coma, por defecto busca en todas], [hWnd control] )
;Return: 0 si no se encontraron items.
;Nota: usar SetTimer() para cuando haya muchos items.
LV_Search(Text, Col := -1) {
	static Func := Func("LV_SearchSelect")
	if (Text="")
		return false
	if !(LV_GetCount()>40) ||!XXX
		return LV_SearchSelect(Text, Col)
	return SetTimer(Func.Bind(Text, Col), -350)
} LV_SearchSelect(Text, Col) {
	return LV_SearchFind(Text, Col, 1) || LV_SearchFind(Text, Col, 0) || LV_SearchFind(Trim(Text), Col, 0)
} LV_SearchFind(Text, Col, CaseSensitive) {
	if !(Count:=LV_GetCount())
		return false
	Loop, % (Count)
		LV_Modify(A_Index, "-Select")
	Loop, % (Count) {
		RowNumber := A_Index
		Loop, % (LV_GetCount("Col")) {
			if !(Col=-1) && !(contains(Col, A_Index, ",", A_Space A_Tab))
				continue
			LV_GetText(CurrentItemText, RowNumber, A_Index)
			if (CurrentItemText="")
				continue
			if (InStr(CurrentItemText, Text, CaseSensitive))
				return RowNumber, LV_Modify(RowNumber, "+Select +Focus Vis")
	}} return false
}

LV_SetItemState(hWnd, Item, State, Set := "*") {
	VarSetCapacity(LVITEM, A_PtrSize=4?60:72, 0), NumPut(0x00000008, LVITEM, 0, "UInt")
	, NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Set="*"?State:Set, LVITEM, 12, "UInt"), NumPut(State, LVITEM, 16, "UInt")
	return SendMessage(hWnd, 0x102B, "Int", Item-1,, &LVITEM)
}





























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: TREEVIEW CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;Obtener item
;Sintaxis: TV_GetNextItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773622%28v=vs.85%29.aspx
;Nota: espesificar 'CARET' para obtener el item seleccionado (3er parametro)
TV_GetNextItem(hWnd, Item := 0, Mode := "NEXT") {
	static Modes := {"CARET": 0x0009, "CHILD": 0x0004, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "LASTVISIBLE": 0x000A, "NEXT": 0x0001
	, "NEXTSELECTED": 0x000B, "NEXTVISIBLE": 0x0006, "PARENT": 0x0003, "PREVIOUS": 0x0002, "PREVIOUSVISIBLE": 0x0007, "ROOT": 0x0000}
	return SendMessage(hWnd, 0x110A, "UInt", Modes[Mode],, Item)
}

;obtiene la cantidad de items
;Sintaxis: TV_GetItemCount( [ID], [Modo] )
;Modos: ALL|SELECTED|VISIBLE
TV_GetItemCount(hWnd, Mode := "ALL") {
	if (Mode="ALL")
		return SendMessage(hWnd, 0x1105)
	else if (Mode="VISIBLE")
		return SendMessage(hWnd, 0x1110)
	else if (Mode="SELECTED") {
		ItemSelectedCount := 0
		while TV_GetNextItem(hWnd,, "NEXTSELECTED")
			ItemSelectedCount++
		return ItemSelectedCount
	} return 0, ErrorLevel := 1
}

;seleccionar item
;TV_SelectItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773736%28v=vs.85%29.aspx
TV_SelectItem(hWnd, Item := 0, Mode := "CARET") {
	static Modes := {"CARET": 0x0009, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "NOSINGLEEXPAND": 0x8000}
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x110B, "UInt", Modes[Mode],, Item-1)
}

;hacer visible un item
;TV_VisibleItem( [ID], [Item] )
TV_VisibleItem(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1114,,,, Item-1)
}

;editar etiqueta del item
;TV_EditLabel( [ID], [Item] )
TV_EditLabel(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1141,,,, Item-1)
}

;eliminar un item o 'todos (defecto)'
;Sintaxis: TV_DeleteItem( [ID], [Item] )
TV_DeleteItem(hWnd, Item := 0) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1101,,,, -65536)
	return SendMessage(hWnd, 0x1101,,,, Item-1)
}

;expandir/contraer/invertir items
;Sintaxis: TV_Expand( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773568%28v=vs.85%29.aspx
TV_Expand(hWnd, Item := 0, Mode := "EXPAND") {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	static Modes := {"COLLAPSE": 0x0001, "COLLAPSERESET": 0x8000, "EXPAND": 0x0002, "EXPANDPARTIAL": 0x4000, "TOGGLE": 0x0003}
	return SendMessage(hWnd, 0x1102, "UInt", Modes[Mode],, Item-1)
}

;cambiar nombre
;Sintaxis: TV_SetItemText( [ID], [texto], [Item] )
TV_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	, VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	, NumPut(0x0001, TVITEMEX, 0, "UInt"), NumPut(Item-1, TVITEMEX, 4, "Ptr")
	, NumPut(&NewText, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
	, NumPut(StrLen(NewText), TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
	return return SendMessage(hWnd, 0x113F,,,, &TVITEMEX)
}

;obtener nombre
;Sintaxis: TV_GetItemText( [ID], [Item] )
TV_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	, VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	, NumPut(0x0001, TVITEMEX, 0, "UInt"), NumPut(Item-1, TVITEMEX, 4, "Ptr")
    , VarSetCapacity(TVTEXT, 256 * 2, 0), NumPut(&TVTEXT, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
    , NumPut(256, TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
    , SendMessage(hWnd, 0x113E,,,, &TVITEMEX)
    return StrGet(NumGet(TVITEMEX, A_PtrSize = 4 ? 16 : 20, "UPtr"))
}
























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: TAB CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;obtener cantidad de items
;Sintaxis: TC_GetItemCount( [ID] )
TC_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1304)
}

;obtener posicion del item que tiene el foco o el item seleccionado.
;Sintaxis: TC_GetItemFocus( [ID], [¿seleccionado=true?] )
TC_GetItemFocus(hWnd, Selected := true) {
	return SendMessage(hWnd, Selected?0x130B:0x132F)+1
}

;obtener texto de un item
;Sintaxis: TC_GetItemText( [ID], [Item] )
TC_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	, VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	, NumPut(0x0001, TCITEM, 0, "UInt"), VarSetCapacity(TCTEXT, 256 * 2, 0)
	, NumPut(&TCTEXT, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	, NumPut(256, TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	, SendMessage(hWnd, 0x133C,, Item-1,, &TCITEM)
	return StrGet(NumGet(TCITEM, A_PtrSize = 4 ? 12 : 16, "UPtr"))
}

;cambiar texto de un item
;Sintaxis: TC_SetItemText( [ID], [Texto], [Item] )
TC_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	, VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	, NumPut(0x0001, TCITEM, 0, "UInt"), NumPut(&NewText, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	, NumPut(StrLen(NewText), TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	return SendMessage(hWnd, 0x133D,, Item-1,, &TCITEM)
}

;dar foco a un item o seleccionarlo
;Sintaxis: TC_SetItemFocus( [ID], [Item], [¿seleccionar?] )
;Notas: si se omite el 2do parametro, auto-selecciona el item anterior o 'siguiente si no hay anterior'.
TC_SetItemFocus(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		Item := ((i:=TC_GetItemFocus(hWnd, Select))-1)>0?i-1:(i=1?i+(TC_GetItemCount(hWnd)>1?1:0):1)
	return SendMessage(hWnd, Select?0x130C:0x1330,, Item-1)
}

;deselecciona todos los items o todos menos el item seleccionado
;Sintaxis: TC_Reset( [ID], [¿evitar deseleccionar el item seleccionado?] )
TC_Reset(hWnd, Mode := 0) {
	return SendMessage(hWnd, 0x1332,, Mode)
}

;eliminar un item, opcional seleccionar el anterior (o siguiente si no hay anterior)
;Sintaxis: TC_DeleteItem( [ID], [Item], [¿seleccionar el item anterior?] )
;Nota: dejar vacio el 2do parametro (o establecerlo <0) para eliminar todos los items.
TC_DeleteItem(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1309)
	i := SendMessage(hWnd, 0x1308,, Item-1)
	if Select
		TC_SetItemFocus(hWnd, ((Item-1)>0?(Item-1):1))
	return i, ErrorLevel := !i
}

;resalta el item
;Sintaxis: TC_HighlightItem( [ID], [Item], [Estado 0|1] )
TC_HighlightItem(hWnd, Item := 0, State := 1) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	return SendMessage(hWnd, 0x1333, "Int", Item-1, "Int", State)
}

;resalta la pestaña al posicionar el mouse por encima
TC_HighlightStyle(hWnd) {
	Control, Style, 0x54010040,, ahk_id %hWnd%
}






































 







/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: COMBOBOX & DROPDOWNLIST CONTROL ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
*/
;renombrar item
;Sintaxis: CB_SetText( [hWnd], [texto], [posición], [¿seleccionar item?] )
;Nota: si no espesifica el 3er parámetro, no se modifica ningún item, solo cambia el texto en el control.
CB_SetText(hWnd, Text := "", Index := 0, Select := false) {
	if !(Index)
		return ControlSetText(0, hWnd, Text)
	CB_DeleteString(hWnd, Index)
	return CB_AddString(hWnd, Text, Index), i:=Select?CB_SelectItem(hWnd, Index):""
}

;establece la señal textual que se muestra por el control de edición para pedir al usuario para obtener información
;Sintaxis: CB_SetCueBanner( [hWnd], [texto] )
CB_SetCueBanner(hWnd, Text := "") {
	Result := SendMessage(hWnd, 0x1703,,,, &Text)
	return (Result=1), ErrorLevel := (Result!=1)
}

;ajustar la altura del campo de selección o la altura de los elementos de lista.
;Sintaxis: CB_SetItemHeight( [hWnd], [Altura], [modo] )
;Modos: por defecto modifica ambos.
	;1 = modificar la altura del campo de selección.
	;2 = modificar  la altura de los elementos de lista.
CB_SetItemHeight(hWnd, Height, Mode := 3) {
	If (Mode=1)
		return PostMessage(hWnd, 0x153, "Int", -1, "UInt", Height)
	if (Mode=2)
		return PostMessage(hWnd, 0x153, "Int", 0, "UInt", Height)
	return r:=(CB_SetItemHeight(hWnd, Height, 1)+CB_SetItemHeight(hWnd, Height, 2)), ErrorLevel := (r!=2)
}

;seleccionar texto.
;Sintaxis: CB_SetEditSel( [hWnd], [inicio], [fin] )
;Uso:
	;Quitar seleccion: CB_SetEditSel(hWnd, -1, -1)
	;Seleccionar todo (defecto): CB_SetEditSel(hWnd, 1, -1)
	;Seleccionar parte del texto: CB_SetEditSel(hWnd, 3, 5)
CB_SetEditSel(hWnd, Start := 1, End := -1) {
	return r:=SendMessage(hWnd, 0x0142,,, "UInt", LOWORD(Start-1)+HIWORD(End-1, false)), ErrorLevel := !r
}

;---------------------------------------------------------------------------------------------------------------------

;limita el número de caracteres que el usuario puede ingresar en el control.
;Sintaxis: CB_LimitText( [hWnd], [caracteres máximos permitidos 1~2147483646] )
;Nota: el mensaje no afecta a los item en el control.
CB_LimitText(hWnd, Limit := 30000) {
	return SendMessage(hWnd, 0x0141, "UShort", Limit)
}

;selecciona el item por texto
;Sintaxis: CB_SelectString( [hWnd], [texto] )
;Nota: si se encuentra el item, devuelve la posición.
CB_SelectString(hWnd, Text) {
	List := []
	Loop, % (Count:=CB_GetCount(hWnd)) {
		if ((List[A_Index]:=CB_GetText(hWnd, A_Index))==Text) {
			Index := A_Index
			break
	}} if !(Index) {
		Loop, % (Count) {
			if (List[A_Index]=Text) {
				Index := A_Index
				break
	}}} Index := SendMessage(hWnd, 0x014D, "Int", Index?Index-1:-1,, &Text)
	return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}

;selecciona el item por posición
;Sintaxis: CB_SelectString( [hWnd], [posición] )
;Nota: si se encuentra el item, devuelve la posición.
;ErrorLevel: 1 = error | 2 = la posición ingresada es mayor al número de items
CB_SelectItem(hWnd, Pos) {
	if ((Count:=CB_GetCount(hWnd))<Pos)
		return false, ErrorLevel := 2
	Loop, % (Count) {
		if (A_Index=Pos) {
			Text := CB_GetText(hWnd, A_Index), Index := SendMessage(hWnd, 0x014D, "Int", A_Index-2,, &Text)
			return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}}}

;añadir item
;Sintaxis: CB_AddString( [hWnd], [texto], [posición], [¿seleccionar?] )
;Posición: si no se espesifica y el control no tiene el estilo CBS_SORT, se añade al final de la lista.
	;si se espesifica -1, se añade al final de la lista.
;Nota: devuelve la posición del item.
;ErrorLevel: 1 = error al añadir | 2 = espacio insuficiente.
CB_AddString(hWnd, Text := "", Pos := 0, Select := false) {
	Index := SendMessage(hWnd, Pos?0x014A:0x0143, Pos?"Int":"Ptr", Pos?(Pos=-1?-1:Pos-1):0,, &Text)
	return (Index=-1)||(Index=-2)?0:Index+1, i:=Select?CB_SelectItem(hWnd, Index+1):"", ErrorLevel := (Index=-1)?1:(Index=-2)?2:0
}

;eliminar item
;Sintaxis: CB_DeleteString( [hWnd], [indice] )
;Indice: espesificar -1 para eliminar todos los items (defecto).
;Nota: devuelve la cantidad de items restantes en el control.
CB_DeleteString(hWnd, Index := -1) {
	Index := SendMessage(hWnd, (Index=-1)?0x014B:0x0144, (Index=-1)?"Ptr":"Int", (Index=-1)?0:(Index-1))
	return Index, ErrorLevel := (Index=-1)
}

;obtiene la posición del item mediante el texto espesificado; ya sea exacto, desde una posición espesífica o contenido.
;Sintaxis: CB_FindString( [hWnd], [texto], [inicio] )
;Inicio: espesificar la posición en la que empezar la busqueda, al terminar, retoma desde el inicio.
	;por defecto (-1), busca desde el primer item.
;Nota: devuelve la posición del item.
CB_FindString(hWnd, Text, Pos := -1) {
	Count := CB_GetCount(hWnd), Pos := (Pos=-1)?-1:((Pos>Count)||(Pos<1)?-1:Pos)
	if !((Index:=SendMessage(hWnd, 0x0158, "Int", (Pos=-1)?-1:(Pos-1),, &Text))>-1) || (Count<Index) {
		if !((Index:=SendMessage(hWnd, 0x014C, "Int", (Pos=-1)?-1:(Pos-1),, &Text))>-1) || (Count<Index) {
			List := []
			Loop, % (Count:=CB_GetCount(hWnd)) {
				if (InStr(List[A_Index]:=CB_GetText(hWnd, A_Index), Text, true)) {
					Index := A_Index-1
					break
			}} if !(Index>-1) {
				Loop, % (Count) {
					if (InStr(List[A_Index], Text)) {
						Index := A_Index-1
						break
	}}}}} return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}

;---------------------------------------------------------------------------------------------------------------------

;recupera la cantidad de items en el control
;Sintaxis: CB_GetCount( [hWnd] )
CB_GetCount(hWnd) {
	return SendMessage(hWnd, 0x0146)
}

;obtiene el texto seleccionado, opcional la posición inicial y final del texto seleccionado
;Sintaxis: CB_GetSelected( [hWnd], [inicio], [fin] )
;Nota: si no hay texto seleccionado, el 2do y 3er parámetro devuelven la posición del cursor.
CB_GetSelected(hWnd, ByRef Start := "", ByRef End := "") {
	Pos := SendMessage(hWnd, 0x0140), Text := CB_GetText(hWnd)
	, Start := LOWORD(Pos)+1, End := HIWORD(Pos)+1
	return (Start=End)?"":StrTrimLeft(StrLeft(Text A_Space, End-1), Start-1)
}

;obtiene el texto actual o de un item.
;Sintaxis: CB_GetText( [hWnd], [posición] )
;Posición: por defecto (-1) obtiene el texto actual.
CB_GetText(hWnd, Index := -1) {
	if (Index=-1)
		return ControlGetText(0, hWnd)
	Length := SendMessage(hWnd, 0x0149, "Int", Index-1)
	, VarSetCapacity(Text, (Length * 2) + 1, 0)
	, SendMessage(hWnd, 0x0148, "Int", Index-1, "Str", Text)
	return Text
}





















































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: PROGRESS BAR CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece el valor mínimo y máximo.
;Sintaxis: PB_SetRange( [hWnd], [min], [max] )
PB_SetRange(hWnd, Min := 0, Max := 100) {
	Min := (Min>-1)?Min:0, Max := (Max>Min)?Max:(Min+1)
	return SendMessage(hWnd, 0x0406, "Int", Min, "Int", Max)
}

;establecer estado.
;Sintaxis: PB_SetState( [hWnd], [estado] )
;Estado: Normal | Error | Paused
PB_SetState(hWnd, State := 1) {
	if (State="Normal") || (State="N") || (State=1)
		return SendMessage(hWnd, 0x0410, "Int", 1)
	if (State="Error") || (State="E") || (State=2)
		return SendMessage(hWnd, 0x0410, "Int", 2)
	if (State="Paused") || (State="P") || (State=3)
		return SendMessage(hWnd, 0x0410, "Int", 3)
	return false, ErrorLevel := true
}

;establecer/incrementar/decrementar valor.
;Sintaxis: PB_SetPos( [hWnd], [+/- valor] )
;Devuelve: la posición anterior.
;Nota: si el valor está fuera del rango del control, la posición se establece en el límite más cercano.
PB_SetPos(hWNd, Value := "+10") {
	M := InStr(Value, "+"), L := InStr(Value, "-")
	if (M) || (L) ;+/-
		Pos := PB_GetPos(hWnd), Value := (M?(Pos+StrReplace(Value, "+")):(Pos-StrReplace(Value, "-")))
	return SendMessage(hWnd, 0x0402, "Int", Value)
}

;establece el color de la barra de indicador de progreso.
;Sintaxis: PB_SetBarColor( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB.
;Nota: devuelve el color anterior.
PB_SetBarColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x0409,,,, RGBToInt(_getcolor(Color))))
}

;establee el color de fondo de la barra de progreso.
;Sintaxis: PB_SetBKColor( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB.
;Nota: devuelve el color anterior.
PB_SetBKColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x2001,,,, RGBToInt(_getcolor(Color))))
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;establece la barra de progreso para el modo de marquesina. esto hace que la barra de progreso para moverse como una marquesina.
;Sintaxis: PB_SetMarquee( [hWnd], [0|1], [retraso, en milisegundos] )
PB_SetMarquee(hWnd, State := true, Delay := 0) {
	WinSetStyle(hWnd, (State?"+":"-") 0x08)
	return SendMessage(hWnd, 0x040A, "Int", !!State, "UInt", (Delay>-1)?Delay:0)
}

;muestra el progreso en una barra de desplazamiento suave.
;Sintaxis: PB_SetSmooth( [hWnd], [0|1], [¿reverse?] )
;Reverse: el comportamiento de animación que la barra de progresa lo utiliza cuando se mueve hacia atrás
PB_SetSmooth(hWnd, State := true, Reverse := false) {
	Pos := PB_GetPos(hWnd), r:=WinSetStyle(hWnd, (State?"+":"-") (Reverse?0x10:0x01))
	return r, PB_SetPos(hWnd, Pos), ErrorLevel := !r
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;obtener el valor minimo y maximo.
;Sintaxis: PB_GetRange( [hWnd], [min (out)], [max (out)] )
;Nota: devuelve un Array con los valores [min, max].
PB_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	VarSetCapacity(PBRANGE, 8, 0), SendMessage(hWnd, 0x0407,,,, &PBRANGE)
	return [Min:=NumGet(PBRANGE, 0, "Int"), Max:=NumGet(PBRANGE, 4, "Int")]
}

;obtener estado.
;Sintaxis: PB_GetState( [hWnd] )
;Devuelve: Normal | Error | Paused
PB_GetState(hWnd) {
	State := SendMessage(hWnd, 0x0411)
	return (r:=(State=1)?"Normal":(State=2)?"Error":(State=3)?"Paused":""), ErrorLevel := !r
}

;obtener valor.
;Sintaxis: PB_GetPos( [hWnd] )
PB_GetPos(hWnd) {
	return SendMessage(hWnd, 0x0408)
}

;obtiene el color RGB de la barra de indicador de progreso.
;Sintaxis: PB_GetBarColor( [hWnd] )
PB_GetBarColor(hWnd) {
	return RGB(SendMessage(hWnd, 0x040F))
}

;obtiene el color RGB de fondo de la barra de progreso.
;Sintaxis: PB_GetBKColor( [hWnd] )
PB_GetBKColor(hWnd) {
	return RGB(SendMessage(hWnd, 0x040E))
}
























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: SLIDER CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establecer posicion
;Sintaxis: TB_SetPos( [hWnd], [valor], [¿redibujar?] )
TB_SetPos(hWnd, Value, Redraw := true) {
	return SendMessage(hWnd, 0x0405, "Int", !!Redraw, "Int", Value)
}

;establecer valor minimo y maximo.
;Sintaxis: TB_SetRange( [hWnd], [min], [max], [¿redibujar?] )
TB_SetRange(hWnd, Min := 0, Max := 100, Redraw := true) {
	Min := (Min>-1)?Min:0, Max := (Max>Min)?Max:(Min+1)
	return SendMessage(hWnd, 0x0406, "Int", !!Redraw,, LOWORD(Min)+HIWORD(Max, false))
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;obtener posicion
;Sintaxis: TB_GetPos( [hWnd] )
TB_GetPos(hWnd) {
	return SendMessage(hWnd, 0x0400)
}

;obtener valor minimo y maximo.
;Sintaxis: TB_GetRange( [hWnd], [min (out)], [max (out)] )
;Nota: devuelve un Array [min, max].
TB_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	return [Min:=SendMessage(hWnd, 0x0401), Max:=SendMessage(hWnd, 0x0402)]
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: UPDOWN CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece el control "compañero"
;Sintaxis: UD_SetBuddy( [hWnd], [hWnd compañero] )
;Nota: devuelve el hWnd del compañero anterior
UD_SetBuddy(hWnd, Buddy) {
	return SendMessage(hWnd, 0x0469,, Buddy)
}

;establece el rango minimo y maximo
;Sintaxis: UD_SetRange( [hWnd], [min -2147483648], [max 2147483647] )
;Nota: dejar vacío para no modificar
UD_SetRange(hWnd, Min := "", Max := "") {
	if (Min="") || (Max="")
		UD_GetRange(hWnd, mi, ma)
	SendMessage(hWnd, 0x046F, "Int", Min=""?mi:Min, "Int", Max=""?ma:Max)
	return !ErrorLevel
}

;------------------------------------------------------------------------------------------------------------------------------------------

;obtiene el hWnd del control "compañero"
;Sintaxis: UD_GetBuddy( [hWnd] )
UD_GetBuddy(hWnd) {
	return SendMessage(hWnd, 0x046A)
}

;recupera el rango minimo y maximo
;Sintaxis: UD_GetRange( [hWnd], [min (out)], [max (out)] )
UD_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	VarSetCapacity(Min, 16, 0), VarSetCapacity(Max, 16, 0)
	, SendMessage(hWnd, 0x0470,, &Min,, &Max)
	return [Min:=NumGet(Min, 0, "Int"), Max:=NumGet(Max, 0, "Int")]
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: GUI & DIALOGOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;MessageBox
;Sintaxis: MsgBox( [opciones], [titulo], [texto], [tiempo fuera] )
;NOTA: la variable global A_MsgBoxResult contiene el resultado.
;EJEMPLO:
	;MsgBox % "Resultado: " MsgBox() "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(0) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox("") "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(4112, "ERROR!",, 1 ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(20, "Título" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(34,, "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(16694, "Título", "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
MsgBox(Info*) {
	global A_MsgBoxResult
	if !(Info.MaxIndex())
		MsgBox, 0, *, Press OK to continue., % Info[4]
	else if (Info[1]!=""&&Info[2]=""&&Info[3]="")
		MsgBox, 0, *, % Info[1], % Info[4]
	else MsgBox, % Info[1], % Info[2]=""?"*":Info[2], % Info[3], % Info[4]
	Loop, Parse, % "Yes,No,Ok,Cancel,Abort,Ignore,Retry,Timeout,Continue,TryAgain", `,
		IfMsgBox, %A_LoopField%
			return ErrorLevel:=A_MsgBoxResult:=A_LoopField
} MsgBoxEx(l*) {
	static r := {3: "Abort", 2: "Cancel", 11: "Continue", 5: "Ignore", 7: "No", 1: "OK", 4: "Retry", 10: "TryAgain", 6: "Yes"} ;1: "Timeout"
	if !(l.MaxIndex())
		return r[DllCall("User32.dll\MessageBoxTimeoutW", "Ptr", 0, "Str", "Press OK to continue.", "Str", "*", "UInt", 0, "Short", 0, "UInt", l[4]=""?0xFFFFFFFF:l[4])]
	if (l[1]!="") && (l[2]="") && (l[3]="")
		return r[DllCall("User32.dll\MessageBoxTimeoutW", "Ptr", 0, "Str", l[3], "Str", "*", "UInt", 0, "Short", 0, "UInt", l[4]=""?0xFFFFFFFF:l[4])]
	return r[DllCall("User32.dll\MessageBoxTimeoutW", "Ptr", 0, "Str", l[3], "Str", l[2], "UInt", l[1], "Short", 0, "UInt", l[4]=""?0xFFFFFFFF:l[4])]
}

;Sintaxis: ToolTip( [texto], [xpos], [ypos], [tiempo fuera, en segundos] )
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
ToolTip(Text := "", xpos := "", ypos := "", TimeOut := 0) {
	static ToolTip := Func("ToolTip").Bind()
	SetTimer(ToolTip, "Off")
	if (Text="") {
		ToolTip,,,, 20
	} else {
		ToolTip, %Text%, %xpos%, %ypos%, 20
		if (TimeOut)
			SetTimer(ToolTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
}}

;cambiar fuente y color de los ToolTips.
;Sintaxis 1: ToolTipFont( [opciones], [fuente] )
;Sintaxis 2: ToolTipColor( [color de fondo], [color del texto] )
ToolTipFont(Options := "", FontName := "", hWnd := "") {
    static hFont := 0
	if (hWnd)
		SendMessage, 0x30, hfont, 0,, ahk_id %hwnd%
	else  hfont := Options="Default"?0:ToolTipChange("Font", Options, FontName), ToolTipHook()
} ToolTipColor(Background := "", Text := "", hWnd := "") {
    static bc := "", tc := ""
    if !(hWnd)
		bc := ((Background="")||(Background="Default"))?"":ToolTipChange("Color", Background)
		, tc := ((Text="")||(Text="Default"))?"":ToolTipChange("Color", Text), ToolTipHook()
    else {
        VarSetCapacity(empty, 2, 0)
        , DllCall("UxTheme.dll\SetWindowTheme", "Ptr", hWnd, "Ptr", 0, "Ptr", ((bc!="")||(tc!=""))?&empty:0)
        if (bc!="")
            SendMessage, 1043, %bc%,,, ahk_id %hWnd%
        if (tc!="")
            SendMessage, 1044, %tc%,,, ahk_id %hWnd%
}} ToolTipHook() {
    static hook := 0
    if !(hook)
        hook := DllCall("User32.dll\SetWindowsHookExW", "Int", 4
            , "Ptr", RegisterCallback("ToolTipWndProc", "Fast", 3), "Ptr", 0
            , "UInt", DllCall("Kernel32.dll\GetCurrentThreadId"), "Ptr")
} ToolTipWndProc(nCode, _wp, _lp) {
    Critical, 999 ;lParam  := NumGet(_lp+0*A_PtrSize) | wParam  := NumGet(_lp+1*A_PtrSize)
    uMsg    := NumGet(_lp+2*A_PtrSize), hWnd    := NumGet(_lp+3*A_PtrSize)
    if ((nCode>=0) && ((uMsg=1081) || (uMsg=1036)) && WinExist("ahk_class tooltips_class32 ahk_id " hWnd))
        ToolTipColor(,, hwnd), ToolTipFont(,, hwnd)
    return DllCall("User32.dll\CallNextHookEx", "Ptr", 0, "Int", nCode, "Ptr", _wp, "Ptr", _lp, "Ptr")
} ToolTipChange(Cmd, Arg1, Arg2 := "") {
    static htext := 0, hgui := 0, hWnd := 0
    if !htext {
		Gui, New:+HWNDhWnd +E0x20 +0x40000000
        Gui, %hWnd%: Add, Text, +hwndhtext
    } Gui %hWnd%: %Cmd%, %Arg1%, %Arg2%
    if (Cmd = "Font") {
        GuiControl, Font, %htext%
        SendMessage, 0x31, 0, 0,, ahk_id %htext%
        return ErrorLevel
    } if (Cmd = "Color") {
        hdc := DllCall("User32.dll\GetDC", "ptr", htext, "ptr")
        SendMessage, 0x138, hdc, htext,, ahk_id %hWnd%
        clr := DllCall("Gdi32.dll\GetBkColor", "ptr", hdc, "uint")
        , DllCall("User32.dll\ReleaseDC", "ptr", htext, "ptr", hdc)
        return clr
}} ;http://ahkscript.org/boards/viewtopic.php?p=55014#p55014

;muestra un mensaje cerca del icono del área de notificacion.
;Sintaxis: TrayTip( [titulo], [texto], [tiempo fuera, en segundos], [opciones] )
;OPCIONES:
	;0 = sin icono | 1 = Info (defecto) | 2 = Advertencia | 3 = Error | M/16 = sin sonido (0M, 1M, 2M, 3M, 3+16, etc...)
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
TrayTip(Title := "", Text := "", TimeOut := 0, Options := 1) {
	static x
	static TrayTip := Func("TrayTip").Bind()
	if !(x)
		RegWrite("REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "EnableBalloonTips", 2)
		, RegWrite("REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "Start_NotifyNewApps", x:=1)
	SetTimer(TrayTip, "Off")
	if (Text="") && (Title="") {
		TrayTip
	} else {
		TrayTip, %Title%, %Text%, 30, % RegExReplace(Options, "[^0-9]")+(InStr(Options, "M")?16:0)
		if (TimeOut)
			SetTimer(TrayTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
}}

;color para los controles
;conversor de colores: http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
;Sintaxis: GuiControlColor( [control], [color del texto], [color de fondo] )
GuiControlColor( ControlId, TextColor := "Black", BackgroundColor := "White", Force := 0 ) {
	if (Force)
		CtlColors.Detach(ControlId)
	CtlColors.Change(ControlId, BackgroundColor, TextColor)
} 

GuiControlGetHwnd(ControlId) {
	GuiControlGet, hWnd, HWND, %ControlId%
	return hWnd ? hWnd : ControlId
}

GuiControlSetFont(hWnd, Type, Font) {
   Gui, Font, %Type%, %Font%
   GuiControl, Font, %hWnd%
}

;dialogo Abrir Con...
;Sintaxis: OpenWithDialog( [owner window hwnd], [archivo] )
OpenWithDialog(hWnd, Filename) {
	VarSetCapacity(OPENASINFO,  (StrLen(Filename) * 2) + 4, 0)
	, NumPut(&Filename, OPENASINFO, 0, "Ptr"), NumPut(5, OPENASINFO, 2 * A_PtrSize)
	, r := DllCall("Shell32.dll\SHOpenWithDialog", "Ptr", hWnd, "Ptr", &OPENASINFO)
	if (ErrorLevel)
		return DllCall("shell32\OpenAs_RunDLLW", "Ptr", hWnd, "UInt", 0, "WStr", Filename)
	return r>0, ErrorLevel := r<0
}


































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: LISTA DE IMÁGENES (ImageList), IMÁGENES & ICONOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;LISTA DE IMÁGENES
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;elimina una lista de imágenes 
;Sintaxis: IL_DestroyEx( [ID] )
IL_DestroyEx(ImageList) {
	return (r:=DllCall("Comctl32.dll\ImageList_Destroy", "Ptr", ImageList)), ErrorLevel := !r
}

;elimina una imagen de una lista de imágenes
;Sintaxis: IL_Remove( [ID], [Posición] )
;NOTA: si el segundo parametro es 0, elimina todas las imágenes
IL_Remove(ImageList, Pos := 0) {
	return (r:=DllCall("ComCtl32.dll\ImageList_Remove", "Ptr", ImageList, "Int", (Pos - 1))), ErrorLevel := !r
}

;crea una lista de imágenes 
;Sintaxis: IL_CreateEx( [cantidad inicial], [aumento al pasar el limite], [¿iconos grandes?], [ancho], [alto] )
IL_CreateEx(InitialCount := 2, GrowCount := 5, LargeIcons := false, cx := 0, cy := 0) {
	static SM_CXICON, SM_CXSMICON, SM_CYICON, SM_CYSMICON
	!(SM_CXICON)?(SM_CXICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 11)): ;el ancho predeterminada de un icono, en píxeles.
	!(SM_CXSMICON)?(SM_CXSMICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 49)): ;el ancho recomendado de un icono pequeño, en píxeles.
	!(SM_CYICON)?(SM_CYICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 12)): ;la altura predeterminada de un icono, en píxeles.
	!(SM_CYSMICON)?(SM_CYSMICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 50)): ;la altura recomendada de un icono pequeño, en píxeles.
	, i := DllCall("Comctl32.dll\ImageList_Create", "UInt", ((cx>0)?cx:(LargeIcons?SM_CXICON:SM_CXSMICON)) ;el ancho en píxeles de las imagenes.
		, "UInt", ((cy>0)?cy:(LargeIcons?SM_CYICON:SM_CYSMICON)) ;la altura en píxeles de las imagenes.
		, "UInt", 0x00000001|0x00000020 ;opciones
		, "Int", InitialCount ;el número de imágenes que la lista de imágenes contiene inicialmente.
		, "Int", GrowCount) ;el número de iconos por el que la lista crecerá cada ves que se supere el limite.
	return i, ErrorLevel := !i
}

;crea un duplicado de una lista de imágenes existente
;Sintaxis: IL_Duplicate( [ID] )
IL_Duplicate(ImageList) {
	return (r:=DllCall("Comctl32.dll\ImageList_Duplicate", "Ptr", ImageList)), ErrorLevel := !r
}

;recupera el número de imágenes en una lista de imágenes
;Sintaxis: IL_GetCount( [ID] )
IL_GetCount(ImageList) {
	return (r:=DllCall("ComCtl32.dll\ImageList_GetImageCount", "Ptr", ImageList, "Int")), ErrorLevel := !r
}

;recupera las dimensiones de las imágenes en una lista de imágenes
;NOTA: todas las imágenes tienen las mismas dimensiones
;Sintaxis: IL_GetSize( [ID], [Ancho, en pixeles], [Alto, en pixeles] )
IL_GetSize(ImageList, ByRef Width := "", ByRef Height := "") {
	i := DllCall("ComCtl32.dll\ImageList_GetIconSize", "Ptr", ImageList, "IntP", Width, "IntP", Height)
	, s := {}, s.h := s.Height := Height, s.w := s.Width := Width
	return s, ErrorLevel := !i
}

;obtener HANDLE de una imagen en la lista de imagenes
;Sintaxis: IL_GetIcon( [ID], [Indice], [estilo de dibujo] )
;Estilos de dibujo: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761533(v=vs.85).aspx
IL_GetIcon(ImageList, Index := 1, Flags := 0x0) {
	return r:=DllCall("Comctl32.dll\ImageList_GetIcon", "Ptr", ImageList, "Int", Index-1, "UInt", Flags), ErrorLevel := !r
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;IMÁGENES
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener ancho y alto de una imagen
;Sintaxis: ImageGetDimension( [imagen], [ancho (out)], [alto (out)] )
;Return: OK=[ancho, alto] | ERROR=0
ImageGetDimension(Image, ByRef Width := "", ByRef Height := "") {
	GdiplusStartup(hModule), pBitmap := GdipCreateBitmapFromFile(Image), pGraphics := GdipGraphicsFromImage(pBitmap)
	, Ok := GdipGetImageDimensions(pBitmap, Width, Height), GdipDeleteGraphics(pGraphics), GdipDisposeImage(pBitmap)
	return Ok?[Width, Height]:false, GdiplusShutdown(, hModule), ErrorLevel := !Ok
}

;convertir imágenes
;Sintaxis: ImageConvert( [imagen], [directorio\nombre.ext], [ancho], [alto], [¿preservar la relacion de aspecto?], [profundidad de bits 24/32 (solo .bmp)] )
;Extensiones soportadas: png, bmp, jpg, tiff, gif
;Return: 0|1
;Nota: el archivo salida es reescrito (si existe)
ImageConvert(Image, Output := "", Width := "", Height := "", PreserveAspectRatio := true, BitDepth := 32) {
	GdiplusStartup(hModule), SplitPath(Output,,, Ext), pBitmapFile := GdipCreateBitmapFromFile(Image)
	, CurrentWidth := GdipGetImageWidth(pBitmapFile), CurrentHeight := GdipGetImageHeight(pBitmapFile)
	, NewWidth := Width=""?CurrentWidth:Width, NewHeight := Height=""?CurrentHeight:Height
	if (PreserveAspectRatio) && ((r1:=CurrentWidth/NewWidth)>(r2:=CurrentHeight/NewHeight))
		NewHeight := CurrentHeight/r1
	else if (PreserveAspectRatio)
		NewWidth := CurrentWidth/r2
	pBitmap := GdipCreateBitmap(NewWidth, NewHeight, (Ext="bmp"&&BitDepth=24)?0x00021808:0x26200A)
	, pGraphics := GdipGraphicsFromImage(pBitmap), GdipSetSmoothingMode(pGraphics), GdipSetInterpolationMode(pGraphics)
	, GdipDrawImage(pGraphics, pBitmapFile, false, false, NewWidth, NewHeight), GdipDisposeImage(pBitmapFile)
	, Ok := GdipSaveBitmapToFile(pBitmap, Output), GdipDisposeImage(pBitmap), GdipDeleteGraphics(pGraphics)
	return Ok, GdiplusShutdown(, hModule), ErrorLevel := !Ok
} ;http://ahkscript.org/boards/viewtopic.php?f=6&p=49878&sid=8974c43be898318cea6b8dc509f2e6df#p49878

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;ICONOS
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;extraer icono
;Sintaxis 1: ExtractIcon( [archivo], [índice | 0 para obtener el número de iconos] )
;Sintaxis 2: ExtractIconEx( [archivo], [indice], [ancho], [alto] )
ExtractIcon(Icon, Index := 1) {
	if (Index=-1)
		return r:=DllCall("User32.dll\DestroyIcon", "UPtr", Icon), ErrorLevel := !r
	if !(hIcon:=DllCall("Shell32.dll\ExtractIconW", "Ptr", A_ScriptHwnd, "Str", Icon, "UInt", Index-1))
		hIcon := ExtractIconEx(Icon, Index)
	return hIcon, ErrorLevel := !hIcon
} ExtractIconEx(Icon, Index := 1, Width := 16, Height := 16) {
	r := DllCall("User32.dll\PrivateExtractIconsW", "Str", Icon, "Int", Index-1, "Int", Width, "Int", Height, "UIntP", hIcon, "UInt", 0, "UInt", 1, "UInt", 0)
	return hIcon, ErrorLevel := !r || (r=0xFFFFFFFF)
} ExtractIcon2(Icon, Index := 1, LargeIcons := false) {
	ImageList := IL_Create(1, 1, !!LargeIcons), IL_Add(ImageList, Icon, Index)
	return IL_GetIcon(ImageList, Index), IL_Destroy(ImageList)
}

;eliminar icono
DestroyIcon(hIcon*) {
	Ok := 0, Error := ErrorLevel
	Loop, % hIcon.MaxIndex()
		Ok += !!DllCall("User32.dll\DestroyIcon", "UPtr", hIcon[A_Index], "Int")
	return Ok=hIcon.MaxIndex(), ErrorLevel := Error
}

;extraer icono pequeño/grande
;Sintaxis: DefExtractIcon( [archivo], [indice], [icono pequeño (out)], [icono grande (out)] )
DefExtractIcon(IconFile, Index := 1, ByRef iconSmall := "", ByRef iconLarge := "") {
	r:=DllCall("Shell32.dll\SHDefExtractIconW", "Ptr", &IconFile, "Int", Index-1, "UInt", 0, "PtrP", iconSmall, "PtrP", iconLarge, "UInt", 0)
	return !r, ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762149(v=vs.85).aspx

;duplicar icono
DuplicateIcon(hIcon) {
	return r:=DllCall("Shell32.dll\DuplicateIcon", "Ptr", A_ScriptHwnd, "Ptr", hIcon), ErrorLevel := !r
}

;dibuja un icono o cursor en el contexto de dispositivo especificado
DrawIcon(hDC, Left := 0, Top := 0, hIcon := 0, Width := 32, Height := 32, istepIfAniCur := 0, hbrFlickerFreeDraw := 0, Flags := 3) {
	return DllCall("User32.dll\DrawIconEx", "Ptr", hDC, "Int", Left, "Int", Top, "Ptr", hIcon, "Int", Width
	, "Int", Height, "UInt", istepIfAniCur, "Ptr", hbrFlickerFreeDraw, "UInt", Flags, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648065(v=vs.85).aspx










































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: CONTROL ::::::::::::::::::::::::::::::::::
NOTAS:
	• espesificar -1 en el 2do parametro para referirse al control que tiene el foco en la ventana espesificada.
	• espesificar -2 en el 2do parametro para referirse al control bajo el cursor.
	• espesificar -3 en el 2do parametro para referirse al último control espesificado.
	• el 1er parametro (hWnd) solo es necesario si se epesifica ClassN del control (Ej. Static1) en el 2do.
	• para actuar directamente sobre el ID de un control, espesificar el ID en el 2do parámetro y establecer el 1ero en 0
	• Parámetros:
		;--> hWnd = ID de la ventana que contiene el control.
		;--> Control = hWnd o nombre (ClassN, donde N es un número) del control.
#############################################################################################################################################
*/
;destruir control en una ventana creada por el script
;Sintaxis: ControlDestroy( [hWnd], [control] )
;Nota: para destruir todos los controles en una ventana, usar WinDestroy( [hWnd], true)
ControlDestroy(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinDestroy(Control)
}

;obtener posicion
;Sintaxis: ControlGetPos( [hWnd], [control], [x], [y], [ancho], [alto] )
ControlGetPos(hWnd, Control, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	_gethwnd(hWnd, Control)
	ControlGetPos, x, y, Width, Height,, ahk_id %Control%
	i := {}, i.w := i.Width := Width, i.h := i.Height := Height, i.x := x, i.y := y
	return i
}

;enviar pulsaciones de teclas a un control
;Sintaxis: ControlSend( [hWnd], [Control], [Teclas], [Repeticiones], [retraso (ms)] )
ControlSend(hWnd, Control, Keys, Count := 1, Delay := -2) {
	_gethwnd(hWnd, Control)
	if !(ok := 0) AND (Count <= 1) {
		ControlSend,, %Keys%, ahk_id %Control%
		return !ErrorLevel, Sleep(Delay)
	} Loop, %Count%
		ok += ControlSend(hWnd, Control, Keys,, A_Index=Count?-2:Delay)
	return ok=Count?Control:false, ErrorLevel := ok=Count?false:true
} ControlSendRaw(hWnd, Control, Text, Count := 1, Delay := -2) {
	return ControlSend(hWnd, Control, "{raw}" Text, Count, Delay)
}

;establece foco en un control
;Sintaxis: ControlFocus( [hWnd], [Control] )
ControlFocus(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinActivate(Control,, true)
}

;establecer texto
;Sintaxis: ControlSetText( [hWnd], [Control], [Texto] )
ControlSetText(hWnd, Control, NewText := "") {
	_gethwnd(hWnd, Control)
	return SendMessage(Control, 0x000C,,,, &NewText)?Control:false
}

;obtener texto
;Sintaxis: ControlGetText( [hWnd], [Control] )
ControlGetText(hWnd, Control) {
	_gethwnd(hWnd, Control), Size := SendMessage(Control, 0x000E,,,,, "UIntP")
	, VarSetCapacity(Text, (Size+1) * 2)
	, SendMessage(Control, 0x000D, "UInt", Size + 1, "Str", Text)
	return Text
} 

;recupera el control que tiene el foco, si lo hay.
;Sintaxis: ControlGetFocus( [hWnd] )
ControlGetFocus(hWnd) {
	_gethwnd(hWnd)
	ControlGetFocus, OutputVar, ahk_id %hWnd%
	return OutputVar
}

;comprueba si un control existe en una ventana espesifica.
;Sintaxis: ControlExist( [hWnd], [control] )
;Nota: devuelve el id del control.
ControlExist(hWnd, Control) {
	_gethwnd(hWnd)
	ControlGet, ControlId, hWnd,, %Control%, ahk_id %hWnd%
	return ControlId?ControlId:Control
}

;enviar un boton del raton o evento de la rueda.
;Sintaixs: ControlClick( [hWnd], [control], [left|right|middle|wheelleft|wheelright], [clics], [opciones] )
ControlClick(hWnd, Control, WhichButton := "LEFT", ClickCount := 1, Options := 0) {
	_gethwnd(hWnd, Control)
	ControlClick,, ahk_id %Control%,, %WhichButton%, %ClickCount%, %Options%
	return ErrorLevel?false:Control
}

;mover control
;Sintaxis: ControlMove( [hWnd], [control], [x], [y], [ancho], [alto] )
ControlMove(hWnd, Control, x := "", y := "", Width := "", Height := "") {
	_gethwnd(hWnd, Control)
	ControlMove,, %x%, %y%, %Width%, %Height%, ahk_id %Control%
	return ErrorLevel?false:Control
}

;hace una variedad de cambios en un control.
;Sintaxis: Control( [hWnd], [control], [comando], [valor] )
Control(hWnd, Control, Cmd, Value) {
	_gethwnd(hWnd, Control)
	if (Cmd="TabSelect")
		SendMessage(Control, 0x1330, "Int", Value), ErrorLevel := !SendMessage(Control, 0x130C, "Int", Value,,, "Int")
	else Control, %Cmd%, %Value%,, ahk_id %Control%
	return ErrorLevel?false:Control
}

;deshabilitar control
;Sintaxis: ControlDisable( [hWnd], [Control] )
ControlDisable(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinDisable(Control)
}

;habilitar control
;Sintaxis: ControlEnable( [hWnd], [Control] )
ControlEnable(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinEnable(Control)
} 

;determina si el control está habilitado
;Sintaxis: ControlEnabled( [hWnd], [Control] )
ControlEnabled(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinEnabled(Control)
}

;ocultar control
;Sintaxis: ControlHide( [hWnd], [Control] )
ControlHide(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinHide(Control)
}

;mostrar control
;Sintaxis: ControlShow( [hWnd], [Control] )
ControlShow(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinShow(Control)
}

;determina si el control es visible
;Sintaxis: ControlVisible( [hWnd], [Control] )
ControlVisible(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinVisible(Control)
}

;redibujar control
;Sintaxis: ControlRedraw( [hWnd], [Control] )
ControlRedraw(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinRedraw(Control)
}

;cambiar la fuente de un control
;Sintaxis: ControlSetFont( [hWnd], [control], [hFont], [¿redibujar?] )
;hFont: usar FontCreate()
;EJEMPLO:
	;Gui, Add, Edit, x15 y45 w465 h395 HWNDhWnd, Fuente ~ Edit Control, AutoHotKey %A_AhkVersion%
	;ControlSetFont(0, hWnd, FontCreate("Times New Roman", 17, true, true, true, 5))
	;Gui, Show, w500 h500
	;return
	;GuiEscape:
	;GuiClose:
	;ExitApp
ControlSetFont(hWnd, Control, hFont := "", Redraw := false) {
	_gethwnd(hWnd, Control)
	return SendMessage(Control, 0x30,, hFont, "Int", !!Redraw, "UInt")
}

;obtiene la fuente del control
;Sintaxis: ControlGetFont( [hWnd], [control] )
;Return: hFont
;Nota: usar FontQuery para obtener información de la fuente
ControlGetFont(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return SendMessage(Control, 0x31,,,,, "Ptr")
}

;cambiar color del texto y fondo de un control
;Sintaxis: ControlSetColor( [hWnd], [Control], [color del texto, nombre o RGB], [color de fondo, nombre o RGB] )
;NOTA: necesario CtlColors_Class
ControlSetColor(hWnd, Control, TC := "Black", BG := "White") {
	_gethwnd(hWnd, Control)
	return CtlColors.Change(Control, Hex(_getcolor(BG), 6,, ""), Hex(_getcolor(TC), 6,, ""))
}

;permitir/bloquear el redibujado de un control
;Sintaxis: ControlSetRedraw( [hWnd], [control], [0|1] )
ControlSetRedraw(hWnd, Control, Redraw := true) {
	_gethWnd(hWnd, Control)
	return WinSetRedraw(Control, Redraw)
}

;cambiar color de fondo y texto
;Sintaxis: ControlColor( [hWnd control], [color de fondo], [color del texto] )
;Color: RGB o Nombre
;Controles soportados (clases): Static, ListBox, Edit
ControlColor(hWnd, BackgroundColor := "White", TextColor := "") {
	static Controls := {}, Init := false
	If (Controls.HasKey(BackgroundColor)) {
		if !(Controls[BackgroundColor].T="")
			DllCall("Gdi32.dll\SetTextColor", "Ptr", hWnd, "UInt", Controls[BackgroundColor].T)
		DllCall("Gdi32.dll\SetBkColor", "Ptr", hWnd, "UInt", Controls[BackgroundColor].B)
		, DllCall("Gdi32.dll\SetDCBrushColor", "Ptr", hWNd, "UInt", Controls[BackgroundColor].B)
		return DllCall("Gdi32.dll\GetStockObject", "UInt", 18, "UPtr") 
	} if (DllCall("User32.dll\IsWindow", "Ptr", hWnd)) {
		Loop, Parse, % "0x0133|0x0134|0x0138", |
			if !(OnMessage(A_LoopField)=A_ThisFunc)
				OnMessage(A_LoopField, A_ThisFunc)
		Controls.RemoveAt(hWNd, ""), BackgroundColor := _getcolor(BackgroundColor), TextColor := _getcolor(TextColor)
		If !(BackgroundColor="") && !((B:=((BackgroundColor&0xFF0000)>>16)|(BackgroundColor&0x00FF00)|((BackgroundColor&0x0000FF)<<16))="")
			Controls[hWnd] := {B: B, T: TextColor=""?"":((TextColor&0xFF0000)>>16)|(TextColor&0x00FF00)|((TextColor&0x0000FF)<<16)}
		return r:=DllCall("User32.dll\RedrawWindow", "Ptr", hWnd, "Ptr", 0, "Ptr", 0, "UInt", 0x0405, "UInt"), ErrorLevel := !(r)
	} return false, ErrorLevel := true
}




















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: MOUSE/CURSOR Y TECLADO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;desplazamiento acelerado, más rápido gire la rueda, más líneas se desplazará por tic
;Sintaxis: MouseAutoWheelSpeed( [TimeOut (ms)], [Boost], [Limit], [ToolTip] )
;DESCRIPCION - PARÁMETROS:
	;TimeOut: tiempo fuera en el que se resetea el desplazamiento, en milisegundos
	;Boost: si se desplaza una distancia larga en una sola sesión, aplicar factor de impulso adicional (0=desactivado)
	;Limit: velcidad máxima (espesificar 0 para desactivar)
	;ToolTip: espesificar 1 (o el tiempo fuera, en milisegundos) para mostrar la velocidad de dezplazamiento como ToolTip
;NOTA: devuelve la velocidad actual (la misma que se muestra con ToolTip activado)
;EJEMPLO: WheelUp::MouseAutoWheelSpeed(,,, 1)
MouseAutoWheelSpeed(TimeOut := 500, Boost := 30, Limit := 60, ToolTip := 0) {
	static d := 0, i := 0
	t := A_TimeSincePriorHotkey, ToolTip := !(ToolTip>-1)?0:((ToolTip=1)?TimeOut:ToolTip)
	, TimeOut := (TimeOut>0)?TimeOut:500, Boost := (Boost>-1)?Boost:30
	if (A_PriorHotkey=A_ThisHotkey) && (t<TimeOut) && (Limit>0) {
		d := (d+1), v := ((t<80)&&(t>1))?((250.0/t)-1):1
		if (Boost>1&&d>Boost) {
			z := (v>i)?(i:=v):(v:=i)
			v *= (d/Boost)
		} v := (v>1)?((v>Limit)?Limit:Floor(v)):1
		if (ToolTip)
			ToolTip("×" v,,, -ToolTip)
		return MouseClick( A_ThisHotkey,,, v )
	} else {
		d := (i:=0)
		if (ToolTip)
			ToolTip("×" 1,,, -ToolTip)
		return MouseClick(A_ThisHotkey)
}} ;http://www.autohotkey.com/board/topic/48426-accelerated-scrolling-script/

;clics o mantiene pulsado un botón del ratón, o girar la rueda del ratón
;Sintaxis: MouseClick( [boton/rueda], [xpos], [ypos], [repeticiones], [velocidad de movimiento (x,y)] )
MouseClick(WhichButton := "Left", x := "", y := "", ClickCount := 1, Speed := 0, DU := "", R := "") {
	Loop, %ClickCount%
		MouseClick, %WhichButton%, %x%, %y%,, %Speed%, %DU%, %R%
	return ClickCount
}

;Envia pulsaciones de teclado clics del ratón a la ventana activa.
;Sintaxis: Send( [Texto], [¿Repetir?], [Retraso en cada repeticion (ms)] )
Send(Keys, Count := 1, Delay := -2) {
	if !(ok:=0)&&!(Count>1) {
		SendInput, %Keys%
		return !ErrorLevel, Sleep(Delay)
	} Loop, %Count%
		ok += Send(Keys,, A_Index=Count?-2:Delay)
	return ok, ErrorLevel := ok=Count?0:1
} SendInput(Keys, Count := 1, Delay := -2) {
	return Send(Keys, Count, Delay)
} SendRaw(Keys, Count := 1, Delay := -2) {
	return Send("{raw}" Keys, Count, Delay)
} SendPlay(Keys, Count := 1, Delay := -2) {
	if !(ok:=0)&&!(Count>1) {
		SendPlay, %Keys%
		return !ErrorLevel, Sleep(Delay)
	} Loop, %Count%
		ok += SendPlay(Keys,, A_Index=Count?-2:Delay)
	return ok, ErrorLevel := ok=Count?0:1
}

;envía una o más combinaciones de teclas a la ventana activa
;Ejemplo: SendKeys("Hola{+}"), SendKeys("`r"), SendKeys("Hola{+}"), SendKeys("`r"), SendKeys("Hola{+}")
SendKeys(Keys) {
	static WshShell
	if !(IsObject(WshShell))
		WshShell := ComObjCreate("WScript.Shell")
	return WshShell.SendKeys(Keys)
} ;https://msdn.microsoft.com/en-us/library/8c6yea83%28v=vs.84%29.aspx

;espera por una tecla a ser precionada o liberada
;Sintaxis: KeyWait( [tecla], [opciones], [tiempo fuera, en segundos] )
;OPCIONES:
	;D = espera a que la tecla sea precionada
	;[Vacío] (defecto) = espera a que la tecla sea liberada por el usuario
KeyWait(KeyName, Options := "", TimeOut := 0) {
	KeyWait, %KeyName%, % Options (TimeOut?" T" TimeOut:"")
	return !ErrorLevel
}

;Activa o desactiva la función de rastros del mouse
;Sintáxis: MouseTrails( [Número o dejar vacio para recuperar el estado actual.] )
;Nota: especifique un número mayor a 1 para activar. para desactivar especifique 0 o 1
;Ejemplos: MouseTrails( 10 ) | MouseTrails( 0 ) | MouseTrails(  )
MouseTrails(N := "", Save := false) {
	if (N != "")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005D, "UInt", N, "Str", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005E, "UInt", 0, "UIntP", N, "UInt", 0)
	return N
}

;cambia o recupera la velocidad actual del mouse
;Sintáxis: MouseSpeed( [establecer velocidad / dejar vacio], [¿guardar cambios?] )
MouseSpeed(Value := "", Save := false) {
	if (Value!="")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x71, "UInt", 0, "UInt", (Value>20)?20:(Value<1)?1:Value, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x70, "UInt", 0, "UIntP", Value, "UInt", 0)
	return Value
}

;recupera/cambia el número de líneas para desplazarse cuando se mueve la rueda ratón verticalmente
;Sintaxis: MouseScrollLines( [valor], [¿guardar cambios?] )
MouseScrollLines(Lines := -1, Save := false) {
	if (Lines >= 0)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0069, "UInt", Lines, "UInt", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0068, "UInt", 0, "UIntP", Lines, "UInt", 0)
	return Lines
}

;establece/recupera el tiempo (ms) de doble clic para el ratón
;Sintaxis: MouseDoubleClick( [milisegundos (1~5000)] )
MouseDoubleClick(ms := -1) {
	if (ms >= 0)
		return DllCall("User32.dll\SetDoubleClickTime", "UInt", ms)
	return DllCall("User32.dll\GetDoubleClickTime")
}

;Invierte o restaura los botones izquierdo y derecho del ratón
;Sintaxis: MouseSwap( 0|1 )
MouseSwap(fSwap := false) {
	return DllCall("User32.dll\SwapMouseButton", "Int", !!fSwap)
}

;recupera/establece el número de caracteres para desplazarse cuando se mueve la rueda horizontal ratón
;Sintaxis: MouseWheelScrollChars( [valor, defecto = 3], [¿guardar?] )
MouseWheelScrollChars(Value := "", Save := false) {
	if (Value!="")
		return DllCall("User32.dll\SystemParametersInfo", "UInt", 0x006D, "UInt", Value, "UIntP", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfo", "UInt", 0x006C, "UInt", 0, "UIntP", Value, "UInt", 0)
	return  Value
}

;Mueve el cursor a las coordenadas de pantalla especificadas
;Sintaxis: MouseSetPos( [x], [y], [velocidad] )
MouseSetPos(x := "", y := "", Speed := "", R := 0) {
	if (Speed!="")
		return MouseMove(x, y, Speed, R)
	if (x="") || (y="")
		CursorGetPos(x_, y_)
	return DllCall("User32.dll\SetCursorPos", "Int", x=""?x_:x, "Int", y=""?y_:y)
} CursorSetPos(x := "", y := "", Speed := 0, R := 0) {
	return MouseSetPos(x, y, Speed, R)
} MouseMove(x, y, Speed := -1, R := "") {
	MouseMove, %x%, %y%, % Speed>-1?Speed:A_DefaultMouseSpeed, % R?"R":""
	return !ErrorLevel
}

;recupera la posicion del cursor, ventana y control bajo el cursor.
;Sintaxis: MouseGetPos( [x (out)], [y (out)], [ventana (out)], [control (out)], [modo] )
;Modos:
	;2 = devuelve el hWnd en ves de ClassN en el 4to parámetro
;Return: [x, y, ventana (solo si se espesificó una variable), control (solo si se espesificó una variable)]
MouseGetPos(ByRef x := "", ByRef y := "", ByRef  Window := "", ByRef Control := "", Mode := 0) {
	if IsByRef(Control) || (Control)
		MouseGetPos, x, y, Window, Control, %Mode%
	else if IsByRef(Window) || (Window)
		MouseGetPos, x, y, Window,, %Mode%
	else MouseGetPos, x, y,,, %Mode%
	return [x, y, Window, Control]
} 

;recupera la posicion xy del cursor.
;Sintaxis: CursorGetPos( [x (out)], [y (out)], [ventana (out)], [hWNd ScreenToClient] )
;Return: [x, y]
CursorGetPos(ByRef x := "", ByRef y := "", ByRef Window := "", ScreenToClient := 0) {
	VarSetCapacity(POINT, 8, 0)
	, Ok := DllCall("User32.dll\GetCursorPos", "Ptr", &POINT, "Int")
	if (ScreenToClient)
		Ok := Ok?DllCall("User32.dll\ScreenToClient", "Ptr", ScreenToClient, "Ptr", &POINT, "UInt"):false
	if (IsByRef(Window))
		Window := DllCall("User32.dll\WindowFromPoint", "Int64", NumGet(POINT, 0, "Int64"), "Ptr")
	return Ok?POINT(POINT, x, y):false, ErrorLevel := !Ok
}

;obtener el texto en las coordenadas espesificadas
;Sintaxis: MouseGetText( [x], [y] )
;Ejemplo:
	;for k, v in MouseGetText()
	;	MsgBox % k ": " v
	;ExitApp
MouseGetText(x := "", y := "", Encoding := "UTF-16") {
	static uia
	if (x="") || (y="")
		CursorGetPos(_x, _y), x := x=""?_x:x, y := y=""?_y:y
	if !(uia) ;https://msdn.microsoft.com/en-us/library/windows/desktop/ff384838%28v=vs.85%29.aspx
		uia := ComObjCreate("{ff48dba4-60ef-4201-aa87-54103eef594e}", "{30cbe57d-d9d0-452a-ab13-7ac5ac4825ee}")
	Item := {}, DllCall(_vt(uia,7),"Ptr",uia,"int64",x|y<<32,"Ptr*",element)
	if !(element)
		return "", ErrorLevel := true
	DllCall(_vt(element,23),"Ptr",element,"Ptr*",name),DllCall(_vt(element,10),"Ptr",element,"UInt",30045,"Ptr",_variant(var))
	,DllCall(_vt(element,10),"Ptr",element,"uint",30092,"Ptr",_variant(lname)), DllCall(_vt(element,10),"Ptr",element,"uint",30093,"Ptr",_variant(lval))
	,a:=StrGet(name,"utf-16"),b:=StrGet(NumGet(val,8,"Ptr"),Encoding),c:=StrGet(NumGet(lname,8,"Ptr"),Encoding)
	,d:=StrGet(NumGet(lval,8,"Ptr"),Encoding),a?Item.Push(a):0,b&&_vas(Item,b)?Item.Push(b):0,c&&_vas(Item,c)?Item.Push(c):0
	,d&&_vas(Item,d)?Item.Push(d):0,DllCall(_vt(element,21),"Ptr",element,"Uint*",type)
	if (type=50004)
		e:=MouseGetText_ElementWhole(uia,element),e&&_vas(item,e)?item.Push(e):false
	return Item, ObjRelease(element), ErrorLevel := false
} MouseGetText_ElementWhole(uia, element) {
	static init := 1, trueCondition, walker
	if (init)
		init:=DllCall(_vt(uia,21),"ptr",uia,"ptr*",trueCondition),init+=DllCall(_vt(uia,14),"ptr",uia,"ptr*",walker)
	DllCall(_vt(uia,5),"ptr",uia,"ptr*",root), DllCall(_vt(uia,3),"ptr",uia,"ptr",element,"ptr",root,"int*",same), ObjRelease(root)
	if (same)
		return
	hr:=DllCall(_vt(walker,3),"ptr",walker,"ptr",element,"ptr*",parent)
	if !(e:="") && !(parent)
		return
	DllCall(_vt(parent,6),"ptr",parent,"uint",2,"ptr",trueCondition,"ptr*",array), DllCall(_vt(array,3),"ptr",array,"int*",length)
	Loop % (length)
		DllCall(_vt(array,4),"ptr",array,"int",A_Index-1,"ptr*",newElement), DllCall(_vt(newElement,23),"ptr",newElement,"ptr*",name)
		, e.=StrGet(name,"utf-16"), ObjRelease(newElement)
	return e, ObjRelease(array), ObjRelease(parent)
} ;http://www.autohotkey.com/board/topic/94619-ahk-l-screen-reader-a-tool-to-get-text-anywhere/

;muestra/oculta el cursor
;Sintaxis: CursorShow( [Estado (0|1)], [Modo (0|1)], [Reestablecer (segundos)], [¿esperar?] )
;REESTABLECER: tiempo fuera en el que el cursor se muestra/oculta (dependiedo el estado espesificado)
;EJEMPLO: CursorShow(0,, 5, true), ExitApp()
CursorShow(State, Mode := 0, TimeOut := 0, WaitTimeOut := false) {
	;--------------------------------------------------------------------------------------------------------------
	static hCursor, hCursorImage, Cursor, LastState, LastMode
	static CursorShow := Func("CursorShow").Bind(-1)
	if (State=-1)
		return i := CursorShow( !LastState, LastMode ), ErrorLevel := !i
	;--------------------------------------------------------------------------------------------------------------
	if (TimeOut > 0) { ;alternar: State=0|1, Mode=0|1, TimeOut>0
		if !CursorShow( LastState:=State, LastMode:=Mode )
			return 0, ErrorLevel := 1
		if WaitTimeOut
			Sleep(TimeOut*1000)
		else return SetTimer(CursorShow, -(TimeOut*1000))
		return i := CursorShow( !State, Mode ), ErrorLevel := !i
	} ;--------------------------------------------------------------------------------------------------------------
	if (Mode) ;solo afecta a las ventanas creadas por el script: State=0|1, Mode=1, TimeOut=0
		Loop {
			NewDisplayCounter := DllCall("User32.dll\ShowCursor", "Int", State)
			if (State&&(NewDisplayCounter>=0))||(!State&&(NewDisplayCounter<=-1))
				return 1, ErrorLevel := 0
			if (NewDisplayCounter=OldDisplayCounter)||(State&&(NewDisplayCounter<OldDisplayCounter))
			||(!State&&(NewDisplayCounter>OldDisplayCounter))
				return 0, ErrorLevel := 1
			OldDisplayCounter := NewDisplayCounter
		}
	;--------------------------------------------------------------------------------------------------------------
	if (State) ;restaura los cursores: State=1, Mode=0, TimeOut=0
		return CursorReload()
	VarSetCapacity( AndMask, 32 * 4, 0xFF ), VarSetCapacity( XorMask, 32 * 4, 0 ), i := 0
	Loop, Parse, % "32650,32512,32515,32649,32651,32513,32641,32648,32640,32646,32643,32645,32642,32644,32516,32514", `,
	{ if !(Cursor) {
			hCursor := hCursorImage := []
			, hCursor[A_Index] := DllCall("User32.dll\CreateCursor", "Ptr", 0, "Int", 0, "Int", 0
				, "Int", DllCall("User32.dll\GetSystemMetrics", "Int", 13)
				, "Int", DllCall("User32.dll\GetSystemMetrics", "Int", 14)
				, "Ptr", &AndMask, "Ptr", &XorMask)
			, hCursorImage[A_Index] := DllCall("User32.dll\CopyImage", "Ptr", hCursor[A_Index], "UInt", 2, "Int", 0, "Int", 0, "UInt", 0)
		} i += DllCall("User32.dll\SetSystemCursor", "Ptr", hCursorImage[A_Index], "UInt", A_LoopField)
	} return Cursor := i, ErrorLevel := !i
} ;--------------------------------------------------------------------------------------------------------------

;vuelve a cargar los cursores del sistema
CursorReload() {
	return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0)
}

;cambiar cursor
;Sintaxis: SetSystemCursor( [cursor type] )
;Cursor Type: ARROW|IBEAM|WAIT|CROSS|UPARROW|SIZENWSE|SIZENESW|SIZEWE|SIZENS|SIZEALL|NO|HAND|APPSTARTING|HELP
;Nota: para restaurar dejar vacío
SetSystemCursor(Cursor := "") {
	static SystemCursors := "32512IDC_ARROW|32513IDC_IBEAM|32514IDC_WAIT|32515IDC_CROSS|32516IDC_UPARROW|32642IDC_SIZENWSE|32643IDC_SIZENESW"
		. "|32644IDC_SIZEWE|32645IDC_SIZENS|32646IDC_SIZEALL|32648IDC_NO|32649IDC_HAND|32650IDC_APPSTARTING|32651IDC_HELP"
	If !(Cursor)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0)
	If (StrLen(SystemCursors) = 221)
		Loop, Parse, % SystemCursors, |
			SystemCursors := StrReplace(SystemCursors, A_LoopField, DllCall("User32.dll\LoadCursor", "UInt", 0, "Int", SubStr(A_LoopField, 1, 5)) A_LoopField)
	Cursor := SubStr(SystemCursors, InStr(SystemCursors "|", "IDC_" Cursor "|") - 5 - (p:=(StrLen(SystemCursors) - 221)) / 14, 5)
	Loop, Parse, % SystemCursors, |
		DllCall("User32.dll\SetSystemCursor", "Ptr", DllCall("User32.dll\CopyIcon", "UInt", Cursor), "UInt",  SubStr(A_LoopField, 6, p))
}



























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA Y CONFIGURACIÓN ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;CONFIGURACIÓN
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;recupera el valor de configuración del sistema métrico o sistema especificado.
;Sintaxis: GetSystemMetrics( [valor] )
;Parámetros:
	;Valores: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385(v=vs.85).aspx
;Nota: todas las dimencionas son recuperadas en pixeles
GetSystemMetrics(Index) {
	return DllCall("User32.dll\GetSystemMetrics", "Int", Index, "Int")
} SysGet(Subcommand, Param3 := "") {
	SysGet, OutputVar, %Subcommand%, %Param3%
	return OutputVar
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;SISTEMA
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;modo de inicio del sistema
;Sintaxis: SystemBoot()
;Return: 0(normal) | 1(a prueba de fallos) | 2(a prueba de fallos con acceso a la red)
SystemBoot() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", 67)
}

;notifica al sistema que las asociaciones de tipo de archivo han cambiado.
SystemAssocChanged() {
	return r:=DllCall("Shell32.dll\SHChangeNotify", "UInt", 0x08000000, "UInt", 0, "Ptr", 0, "Ptr", 0), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762118%28v=vs.85%29.aspx

;Apagar Equipo
;Sinraxis: Shutdown( [Código], [¿Forzar?] )
;CÓDIGOS
	;1 = Apagar | 2 = Reiniciar | 3 = Cerrar sesion | 4 = apaga el ardenador y alimentación
	;5 = Suspender | 6 = Hibernar
	;7 = Apagar monitor | 8 = Encender monitor | 9 = Poner el monitor en bajo consumo
	;10 = bloquear el equipo (WIN+L)
Shutdown(Code, Force := false) {
	if (Code=5) || (Code=6) { ;Suspender / Hibernar
		if (Code=5) ;Suspender
			CMD("powercfg -h Off"), h := false ;desactivar Hibernación
		else CMD("powercfg -h On"), h := true ;activar Hibernación
		Run, % A_SysDir() "\rundll32.exe powrprof.dll,SetSuspendState " h "," !!Force ",0",, Hide, PID ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa373201(v=vs.85).aspx
		return ErrorLevel?false:(PID?PID:true)
	} else if (Code=7) || (Code=8) || (Code=9) {
		Code := Code=7?2:Code=8?-1:1, GetDesktop(,, hDesktop)
		return SendMessage(hDesktop, 0x112, "UInt", 0xF170, "Int", Code, "UInt")
	} else if (Code=1) || (Code=2) || (Code=3) || (Code=4) {
		Code := Code=1?0x00000001:Code=2?0x00000002:Code=3?0:0x00000008
		return DllCall("User32.dll\ExitWindowsEx", "UInt", Force?Code|0x00000004:Code, "UInt", 0)
	} else if (Code=10) {
		return DllCall("User32.dll\LockWorkStation")
	} return false, ErrorLevel := true
} ShutdownEx(Code, Seconds := 0) { ;Code = /s: apagar, /r: reiniciar, /f: forzar, /a: cancelar.
	Seconds := (Seconds>0)?"/t" A_Space Seconds:
	Run, %ComSpec% /c Shutdown %Code% %Seconds%,, Hide
	return !ErrorLevel
} ;programar apagado. Sintaxis: ShutdownEx( [/s|/r /f], [segundos] )

;cambiar fecha y hora
;Sintaxis: SystemSetTime( [tiempo], [Local / System] )
;Parámetros:
	;Tiempo = [año, mes, día, hora, min, seg, ms]
;Ejemplo: SystemSetTime( [2020,12,09,,,01] )
SystemSetTime(Time, Mode := "Local") {
	VarSetCapacity(SYSTEMTIME, 8 * 2, 0)
	, NumPut(Time[1]=""?A_Year:Time[1], SYSTEMTIME, 0, "UShort")
	, NumPut(Time[2]=""?A_Mon:Time[2], SYSTEMTIME, 2, "UShort")
	, NumPut(Time[7]=""?A_WDay:Time[7], SYSTEMTIME, 4, "UShort")
	, NumPut(Time[3]=""?A_DD:Time[3], SYSTEMTIME, 6, "UShort")
	, NumPut(Time[4]=""?A_Hour:Time[4], SYSTEMTIME, 8, "UShort")
	, NumPut(Time[4]=""?A_Min:Time[5], SYSTEMTIME, 10, "UShort")
	, NumPut(Time[5]=""?A_Sec:Time[5], SYSTEMTIME, 12, "UShort")
	, NumPut(Time[6]=""?A_MSec:Time[6], SYSTEMTIME, 14, "UShort")
	return i:=DllCall("kernel32.dll\Set" Mode "Time", "Ptr", &SYSTEMTIME)
		, ErrorLevel := !i
}

;obtener fecha y hora
;Sintaxis: SystemGetTime( [Local / System] )
;Nota: devuelve un array con el formato año/mes/día/hora/min/seg/ms
SystemGetTime(Mode := "Local") {
	nSize := VarSetCapacity(SYSTEMTIME, 8 * 2, 0), NumPut(nSize, SYSTEMTIME, "UShort")
	i := DllCall("kernel32.dll\Get" Mode "Time", "Ptr", &SYSTEMTIME), Time := []
	Loop, Parse, % "0,2,6,8,10,12,14", `,
		Time[A_Index] := NumGet(SYSTEMTIME, A_LoopField, "UShort")
	return Time, ErrorLevel := !i
}

;porcentaje de uso del CPU
SystemCPULoad() {
	static PIT, PKT, PUT
	if !PIT
		DllCall("Kernel32.dll\GetSystemTimes", "Int64P", PIT, "Int64P", PKT, "Int64P", PUT)
	DllCall("Kernel32.dll\GetSystemTimes", "Int64P", CIT, "Int64P", CKT, "Int64P", CUT)
	Return (((SystemTime:=(PKT-CKT)+(PUT-CUT))-(PIT-CIT))*100)//SystemTime,PIT:=CIT,PKT:=CKT,PUT:=CUT
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3413
	
;sistema operativo: información de la versión
SysGetVersion() { ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff561910%28v=vs.85%29.aspx
	static VersionInfo
	if !(VersionInfo)
		VarSetCapacity(RTL_OSVIEX, 284, 0), NumPut(284, RTL_OSVIEX, 0, "UInt")
		, DllCall("ntdll.dll\RtlGetVersion", "Ptr", &RTL_OSVIEX), i := {}
		, i.MajorVersion := NumGet(RTL_OSVIEX, 4, "UInt")
		, i.MinorVersion := NumGet(RTL_OSVIEX, 8, "UInt")
		, i.BuildNumber := NumGet(RTL_OSVIEX, 12, "UInt")
		, i.PlatformId := NumGet(RTL_OSVIEX, 16, "UInt")
		, i.CSDVersion := StrGet(&RTL_OSVIEX + 20, 128, "UTF-16")
		, i.ServicePackMajor := NumGet(RTL_OSVIEX, 276, "UShort")
		, i.ServicePackMinor := NumGet(RTL_OSVIEX, 278, "UShort")
		, i.SuiteMask := NumGet(RTL_OSVIEX, 280, "UShort")
		, i.ProductType := NumGet(RTL_OSVIEX, 282, "UChar")
	return (VersionInfo?VersionInfo:(VersionInfo:=i))
}

SystemGetFontInfo(ByRef Name := "", ByRef Size := "", ByRef Weight := "", ByRef IsItalic := "") {
	nSize := VarSetCapacity(NCM, 500, 0), NumPut(nSize, &NCM, 0, "UInt")
	, i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0029, "UInt", nSize, "Ptr", &NCM, "UInt", 0)
	, Name := StrGet(&NCM+408+28, 32), Height := NumGet(&NCM+408, 0, "Int")
	, Size := DllCall("MulDiv", "Int", -Height, "Int", 72, "Int", A_ScreenDPI)
	, Weight := NumGet(&NCM + 408 + 16, 0, "Int"), IsItalic := NumGet(&NCM + 408 + 20, 0, "UChar")
	return i, ErrorLevel := !i
}

SystemSetFontInfo(Name := "", Size := "", Weight := "", IsItalic := "") {
	nSize := VarSetCapacity(NCM, 500, 0), NumPut(nSize, &NCM, 0, "UInt")
	, DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0029, "UInt", nSize, "Ptr", &NCM, "UInt", 0)
	, Name := Name?StrPut(Name, &NCM+408+28, 32):Name
	, Size := Size?NumPut(-DllCall("MulDiv", "Int", Size, "Int", A_ScreenDPI, "Int", 72), &NCM+408+0, "Int"):Size
	, Weight := Weight?NumPut(Weight, &NCM+408+16, "Int"):Weight
	, IsItalic := IsItalic=1||IsItalic=0?NumPut(IsItalic, &NCM+408+20, "UChar"):IsItalic
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x002A, "UInt", nSize, "Ptr", &NCM, "UInt", 0x01|0x02)
		, ErrorLevel := !i
}

;vuelve a cargar los iconos del sistema
SystemIconsReload() {
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0058, "UInt", 0, "Ptr", 0, "UInt", 0), ErrorLevel := !i
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: VARIABLES ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Recupera la ruta a la raíz del directorio del usuario actual
A_UserProfile() {
	static UserProfile
	if !(UserProfile) {
		if !(IsDir(UserProfile:=EnvGet("USERPROFILE"))) {
			SplitPath, A_AppData,, UserProfile
			SplitPath, UserProfile,, UserProfile
	}	} return UserProfile
}

;Recupera la ruta a la raíz del directorio que contiene los datos del programa compartidos por todos los usuarios.
A_AllUsersProfile() {
	static AllUsersProfile
	if !(AllUsersProfile)
		DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(AllUsersProfile, uSize * 2, 0)
		, DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Str", AllUsersProfile, "UInt*", uSize)
	return AllUsersProfile
}

;Recupera la ruta de acceso al directorio raíz donde se almacenan los perfiles de usuario.
A_Profiles() {
	static Profiles
	if !(Profiles)
		DllCall("Userenv.dll\GetProfilesDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(Profiles, uSize * 2, 0)
		, DllCall("Userenv.dll\GetProfilesDirectoryW", "Str", Profiles, "UInt*", uSize)
	return Profiles
}

;Recupera la ruta de acceso a la raíz del perfil de usuario predeterminado.
A_DefaultUserProfile() {
	static DefaultUserProfile
	if !(DefaultUserProfile)
		DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(DefaultUserProfile, uSize * 2)
		, DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Str", DefaultUserProfile, "UInt*", uSize)
	return DefaultUserProfile
}

;recupera el nombre del usuario actual
A_UserName() {
	static UserName
	if !(UserName)
		DllCall("Advapi32.dll\GetUserNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(UserName, (uSize * 2) + 1, 0)
		, DllCall("Advapi32.dll\GetUserNameW", "Str", UserName, "UInt*", uSize + 1)
	return UserName
} 

;obtiene el dominio y nombre de usuario
A_UserNameEx() {
	static UserNameEx
	if !(UserNameEx)
		DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UIntP", Size)
		, VarSetCapacity(UserNameEx, (Size * 2) + 1, 0)
		, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", UserNameEx, "UIntP", Size + 1)
	return UserNameEx
}

;recupera el dominio del usuario actual
A_UserDomain(ByRef UserName := "") {
	static UserDomain
	if !(UserDomain)
		DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(UserDomain, (uSize * 2) + 1, 0)
		, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", UserDomain, "UInt*", uSize + 1)
	return StrSplit(UserDomain, "\")[1], UserName := IsByRef(UserName)?StrSplit(UserDomain, "\")[2]:""
}

;Recupera/Establece el nombre NetBIOS del equipo local.
;Este nombre se estableció al inicio del sistema, cuando el sistema lo lee desde el registro.
A_ComputerName(lpComputerName*) {
	static ComputerName
	if (lpComputerName.MaxIndex())
		return DllCall("Kernel32.dll\SetComputerNameW", "Str", lpComputerName[1])
	if !(ComputerName)
		DllCall("kernel32.dll\GetComputerNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(ComputerName, uSize * 2, 0)
		, DllCall("kernel32.dll\GetComputerNameW", "Str", ComputerName, "UInt*", uSize)
	return ComputerName
}

;recupera la ruta del directorio de sistema utilizado por WOW64.
;NOTA: Este directorio no está presente en Windows de 32 bits.
A_SysDir64() {
	static SysDir64
	if !(SysDir64)
		uSize := DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(SysDir64, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Str", SysDir64, "UInt", uSize)
	return SysDir64
}

;recupera la ruta del directorio de sistema.
;El directorio del sistema contiene los archivos del sistema, como las bibliotecas y los controladores de vínculos dinámicos.
A_SysDir() {
	static SysDir
	if !(SysDir)
		uSize := DllCall("kernel32.dll\GetSystemDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(SysDir, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemDirectoryW", "Str", SysDir, "UInt", uSize)
	return SysDir
}

;recupera la ruta del directorio compartido de Windows en un sistema multi-usuario.
A_SysWinDir() {
	static SysWinDir
	if !(SysWinDir)
		uSize := DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(SysWinDir, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Str", SysWinDir, "UInt", uSize)
	return SysWinDir
}

;recupera la ruta de acceso del directorio de Windows.
A_WinDir() {
	static WinDir
	if !(WinDir)
		uSize := DllCall("kernel32.dll\GetWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(WinDir, uSize * 2, 0)
		, DllCall("kernel32.dll\GetWindowsDirectoryW", "Str", WinDir, "UInt", uSize)
	return WinDir
}

;Archivos Temporales
A_Temp() {
	static Temp
	if !(Temp)
		uSize := DllCall("kernel32.dll\GetTempPathW", "UInt", 0, "Ptr", 0)
		, VarSetCapacity(Temp, (uSize * 2) + 1, 0)
		, DllCall("kernel32.dll\GetTempPathW", "UInt", uSize + 1, "Str", Temp)
	return Temp
}

;recupera/establece el directorio de trabajo
A_WorkingDir(WorkingDir*) {
	if (WorkingDir.MaxIndex())
		return DllCall("kernel32.dll\SetCurrentDirectoryW", "Str", WorkingDir[1])
	VarSetCapacity(WorkingDir, (260 * 2) + 1) / 2
	, DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt*", 261, "Str", WorkingDir)
	return WorkingDir
}

;recupera la ruta a la consola de windows (cmd.exe)
A_ComSpec() {
	static _ComSpec
	return _ComSpec?_ComSpec:(_ComSpec:=EnvGet("ComSpec"))
}

;recupera el idioma por defecto del sistema
A_Language() {
	static Language
	return Language?Language:(Language:=Format("{:04X}", DllCall("Kernel32.dll\GetSystemDefaultUILanguage", "UShort")))
}

A_AppDataLocal() {
	static AppDataLocal
	return AppDataLocal?AppDataLocal:(AppDataLocal:=EnvGet("LOCALAPPDATA"))
} ;http://ahkscript.org/boards/viewtopic.php?f=13&p=52910#p52910

;ancho del monitor actual
A_ScreenWidth() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", false)
}

;tamaño de la zona de trabajo en el monitor de pantalla principal.
;el área de trabajo es la parte de la pantalla que no está oculta por la barra de tareas o las barras de herramientas de escritorio de aplicaciones.
;Sintaxis: A_MonitorWorkArea( [xpos], [ypos], [ancho], [alto] )
A_MonitorWorkArea(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 8 * 2, 0), i := {}
	, r := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0030, "UInt", 0, "Ptr", &RECT, "UInt", 0)
	, i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	, i.w := i.Width := Width := NumGet(RECT,  8, "Int") - x
	, i.h := i.Height := Height := NumGet(RECT, 12, "Int") - y
	return i, ErrorLevel := !r
}

;alto del monitor actual
A_ScreenHeight() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", true)
}

;ruta completa al script
A_ScriptFullPath() {
	return A_ScriptFullPath
}

;directorio del script
A_ScriptDir() {
	return A_ScriptDir
}

;nombre del script
A_ScriptName() {
	return A_ScriptName
}

;devuelve 1 si el script se está ejecutando como administrador
A_IsAdmin() {
	return A_IsAdmin
}

A_IPAddress1() {
	return A_IPAddress1
} A_IPAddress2() {
	return A_IPAddress2
} A_IPAddress3() {
	return A_IPAddress3
} A_IPAddress4() {
	return A_IPAddress4
}

A_Cursor() {
	return A_Cursor
}

A_OSVersion() {
	return A_OSVersion
} A_OSType() {
	return A_OSType
}

A_TickCount(ByRef ElapsedTime := "") {
	static Time
	return _Time := A_TickCount, ElapsedTime := _Time-Time, Time := _Time
}

A_LastError(SetLastError*) {
	return SetLastError.MaxIndex()?SetLastError(SetLastError[1]):A_LastError
}

A_DetectHiddenWindows() {
	return A_DetectHiddenWindows="On"
}

A_Year(Year := "") {
	return Year=""?A_Year:SystemSetTime([Year])
} A_Mon(Mon := "") {
	return Mon=""?A_Mon:SystemSetTime([, Mon])
} A_DD(Day := "") {
	return Day=""?A_DD:SystemSetTime([,, Day])
} A_Hour(Hour := "") {
	return Hour=""?A_Hour:SystemSetTime([,,, Hour])
} A_Min(Min := "") {
	return Min=""?A_Min:SystemSetTime([,,,, Min])
} A_Sec(Sec := "") {
	return Sec=""?A_Sec:SystemSetTime([,,,,, Sec])
} A_MSec(MSec := "") {
	return MSec=""?A_MSec:SystemSetTime([,,,,,, MSec])
} A_WDay(WDay := "") {
	return WDay=""?A_WDay:SystemSetTime([,,,,,,, WDay])
}

A_Time(Delimiter := "") {
	CurrentTime := SplitTime()
	return CurrentTime[1] Delimiter CurrentTime[2] Delimiter CurrentTime[3] Delimiter
		. CurrentTime[4] Delimiter CurrentTime[5] Delimiter CurrentTime[6]
}

;------------------------------------------------------------------------------------------------------------------------------------------------

;recupera el directorio de Archivos De Programa
A_ProgramFiles() {
	static _ProgramFiles
	if !(_ProgramFiles)
		_ProgramFiles := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{905e63b6-c1bf-494e-b29c-65b732d3d21a}":0x0026)
	return _ProgramFiles
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio del usuario actual 
A_Programs() {
	static Programs
	if !(Programs)
		Programs := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}":0x0002)
	return Programs
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio para todos los usuarios
A_ProgramsCommon() {
	static ProgramsCommon
	if !(ProgramsCommon)
		ProgramsCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}":0X0017)
	return ProgramsCommon
}

;directorio de sistema de archivos que contiene los datos de aplicación para el usuario actual
A_AppData() {
	static AppData
	if !(AppData)
		AppData := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}":0x001a)
	return AppData
}

;directorio de sistema de archivos que contiene los datos de aplicación para todos los usuarios
A_AppDataCommon() {
	static AppDataCommon
	if !(AppDataCommon)
		AppDataCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}":0x0023)
	return AppDataCommon
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio del usuario actual
A_Desktop() {
	static Desktop
	if !(Desktop)
		Desktop := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}":0x0010)
	return Desktop
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio para todos los usuarios
A_DesktopCommon() {
	static DesktopCommon
	if !(DesktopCommon)
		DesktopCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}":0x0019)
	return DesktopCommon
}

;ruta completa y el nombre de la carpeta del menú Inicio del usuario actua
A_StartMenu() {
	static StartMenu
	if !(StartMenu)
		StartMenu := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}":0x000b)
	return StartMenu
}

;ruta completa y el nombre de la carpeta del menú Inicio para todos los usuarios
A_StartMenuCommon() {
	static StartMenuCommon
	if !(StartMenuCommon)
		StartMenuCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{A4115719-D62E-491D-AA7C-E74B8BE3B067}":0x0016)
	return StartMenuCommon
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio del usuario actual
A_Startup() {
	static Startup
	if !(Startup)
		Startup := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{B97D20BB-F46A-4C97-BA10-5E3608430854}":0x0007)
	return Startup
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio para todos los usuarios
A_StartupCommon() {
	static StartupCommon
	if !(StartupCommon)
		StartupCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}":0x0018)
	return StartupCommon
}

A_MyDocuments() {
	static MyDocuments
	if !(MyDocuments)
		MyDocuments := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{FDD39AD0-238F-46AF-ADB4-6C85480369C7}":0x0005)
	return MyDocuments
}

A_DocumentsCommon() {
	static DocumentsCommon
	if !(DocumentsCommon)
		DocumentsCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{ED4824AF-DCE4-45A8-81E2-FC7965083634}":0x002e)
	return DocumentsCommon
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de música
A_MyMusic() {
	static MyMusic
	if !(MyMusic)
		MyMusic := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{4BD8D571-6D19-48D3-BE97-422220080E43}":0x000d)
	return MyMusic
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de imagen
A_MyPictures() {
	static MyPictures
	if !(MyPictures)
		MyPictures := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{33E28130-4E1E-4676-835A-98395C3BC3BB}":0x0027)
	return MyPictures
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de vídeo
A_MyVideo() {
	static MyVideo
	if !(MyVideo)
		MyVideo := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{18989B1D-99B5-455B-841C-AB7C74E4DDFC}":0x000e)
	return MyVideo
}

;directorio de sistema de archivos que contiene accesos directos a los documentos usados recientemente del usuario
A_Recent() {
	static Recent
	if !(Recent)
		Recent := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{AE50C081-EBD2-438A-8655-8A092E34987A}":0x0008)
	return Recent
}

;directorio de sistema de archivos que contiene Enviar a elementos de menú
A_SendTo() {
	static SendTo
	if !(SendTo)
		SendTo := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{8983036C-27C0-404B-8F08-102D10DCFD74}":0x0009)
	return SendTo
}

;------------------------------------------------------------------------------------------------------------------------------------------------

;espacio
A_Space(Count := 1) {
	Loop, %Count%
		_ .= Chr(32)
	return _
}

;tabulación
A_Tab(Count := 1) {
	Loop, %Count%
		_ .= Chr(9)
	return _
}

;comilla
A_Quote(Count := 1) {
	Loop, %Count%
		_ .= Chr(34)
	return _
}

;obtiene un array con los parámetros usados para ejecutar el script
;EJEMPLO: MsgBox( A_Args()[1] "`n" A_Args()[2] "`n" A_Args()[3] "`n" A_Args()[4] "`n" A_Args()[5] "`n`nTotal: " A_Args()[0] )
A_Args() { ;http://ahkscript.org/boards/viewtopic.php?t=4357 || By SKAN
	static Args
	if (Args)
		return Args
	CommandLineString := DllCall("Kernel32.dll\GetCommandLineW", "Str"), Args := [], Skip := A_IsCompiled ? 1 : 2
	, pArgs := DllCall("Shell32.dll\CommandLineToArgvW", "WStr", CommandLineString, "PtrP", nArgs) 
	Loop, %nArgs% {
		if (A_Index > Skip)
			hArgs := NumGet( (A_Index - 1) * A_PtrSize + pArgs )
			, Args[A_Index - Skip] := StrGet( hArgs, "UTF-16" )
	} return Args, Args[0] := nArgs-Skip, DllCall("Kernel32.dll\LocalFree", "Ptr", pArgs)
}

;------------------------------------------------------------------------------------------------------------------------------------------------

/* -------------------------------------------------------------------------------------------------------------------------------------------------------------
 ::::::::::::::::::::::::::::::::::::::::::::: VERSION HELPER FUNCTIONS ::::::::::::::::::::::::::::::::::
• Ejemplo:
	MsgBox %  "IsWindowsXPOrGreater: " IsWindowsXPOrGreater()
		. "`nIsWindowsXPSP1OrGreater: " IsWindowsXPSP1OrGreater()
		. "`nIsWindowsXPSP2OrGreater: " IsWindowsXPSP2OrGreater()
		. "`nIsWindowsXPSP3OrGreater: " IsWindowsXPSP3OrGreater()
		. "`nIsWindowsVistaOrGreater: " IsWindowsVistaOrGreater()
		. "`nIsWindowsVistaSP1OrGreater: " IsWindowsVistaSP1OrGreater()
		. "`nIsWindowsVistaSP2OrGreater: " IsWindowsVistaSP2OrGreater()
		. "`nIsWindows7OrGreater: " IsWindows7OrGreater()
		. "`nIsWindows7SP1OrGreater: " IsWindows7SP1OrGreater()
		. "`nIsWindows8OrGreater: " IsWindows8OrGreater()
		. "`nIsWindows8Point1OrGreater: " IsWindows8Point1OrGreater()
		. "`nIsWindows10OrGreater: " IsWindows10OrGreater()
		. "`nIsWindowsServer: " IsWindowsServer()
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
IsWindowsVersionOrGreater(MajorVersion, MinorVersion, ServicePackMajor) {
	VersionInfo := SysGetVersion()
	return (VersionInfo.MajorVersion > MajorVersion)?true
	: (VersionInfo.MajorVersion < MajorVersion)?false
	: (VersionInfo.MinorVersion > MinorVersion)?true
	: (VersionInfo.MinorVersion < MinorVersion)?false
	: (VersionInfo.ServicePackMajor >= ServicePackMajor)?true:false
}

IsWindowsXPOrGreater() { ; >= WIN_XP
	return isWindowsVersionOrGreater(5, 1, 0)
} IsWindowsXPSP1OrGreater() { ; >= WIN_XP SP1
	return isWindowsVersionOrGreater(5, 1, 1)
} IsWindowsXPSP2OrGreater() { ; >= WIN_XP SP2
	return isWindowsVersionOrGreater(5, 1, 2)
} IsWindowsXPSP3OrGreater() { ; >= WIN_XP SP3
	return isWindowsVersionOrGreater(5, 1, 3)
}

IsWindowsVistaOrGreater() { ; >= WIN_V
	return isWindowsVersionOrGreater(6, 0, 0)
} IsWindowsVistaSP1OrGreater() { ; >= WIN_V SP1
	return isWindowsVersionOrGreater(6, 0, 1)
} IsWindowsVistaSP2OrGreater() { ; >= WIN_V SP2
	return isWindowsVersionOrGreater(6, 0, 2)
}

IsWindows7OrGreater() { ; >= WIN_7
	return isWindowsVersionOrGreater(6, 1, 0)
} IsWindows7SP1OrGreater() { ; >= WIN_7 SP1
	return isWindowsVersionOrGreater(6, 1, 1)
}

IsWindows8OrGreater() { ; >= WIN_8
	return isWindowsVersionOrGreater(6, 2, 0)
} IsWindows8Point1OrGreater() { ; >= WIN_8.1
	return isWindowsVersionOrGreater(6, 3, 0)
}

IsWindows10OrGreater() { ; >= WIN_10
	return isWindowsVersionOrGreater(10, 0, 0)
}

IsWindowsServer() { ; = WIN_SERVER
	static isWindowsServer
	if (isWindowsServer!="")
		return isWindowsServer
	VersionInfo := SysGetVersion()
	return isWindowsServer:=(((VersionInfo.CSDVersion="")&&(VersionInfo.ProductType!=0x0000001))||((DllCall("User32.dll\GetSystemMetrics", "Int", 89))&&!(ErrorLevel)))
}

;devuelve una cadena que identifica al sistema operativo actual.
;Sintaxis 1: WindowsVersion( [Service Pack (salida)] )
;Sintaxis 2: WindowsVersionEx( [¿mostrar Service Pack y Arquitectura?] )
;Sintaxis 3: WinVersion()
;Service Pack: número del último Service Pack instalado en el sistema (0, 1, 2, 3 ...).
;Return: WIN_SERVER2003R2, WIN_HOMESERVER, WIN_SERVER2008, WIN_SERVER2008R2, WIN_SERVER2012, WIN_SERVER2012R2, WIN_SERVER2016
	;WIN_XP, WIN_V, WIN_7, WIN_8, WIN_8.1, WIN_10
;Nota: si hay una nueva version de windows aún no incluida en la funcion, devuelve lo mismo que WinVersion().
;Ejemplo: 
	;MsgBox % "WindowsVersion: " WindowsVersion(SP) " Service Pack " SP
	;	. "`nWindowsVersionEx: " WindowsVersionEx(true)
	;	. "`nWinVersion: " WinVersion()
WindowsVersion(ByRef ServicePackMajor := "") {
	static WindowsVersion, ServicePackMajor2
	if (WindowsVersion!="")
		return WindowsVersion, ServicePackMajor := ServicePackMajor2
	VersionInfo := SysGetVersion()
	return (WindowsVersion:=(((VersionInfo.MajorVersion=5)&&(VersionInfo.MinorVersion=2)&&(VersionInfo.SuiteMask&0x00008000))?"WIN_HOMESERVER"
	: ((DllCall("User32.dll\GetSystemMetrics", "Int", 89))&&!(ErrorLevel))?"WIN_SERVER2003R2" ;SM_SERVERR2
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=0)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2008"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=1)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2008R2"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=2)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2012"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=3)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2012R2"
	: ((VersionInfo.MajorVersion=10)&&(VersionInfo.MinorVersion=0)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2016"
	: (VersionInfo.MajorVersion=5)?"WIN_XP"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=0))?"WIN_V"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=1))?"WIN_7"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=2))?"WIN_8"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=3))?"WIN_8.1"
	: ((VersionInfo.MajorVersion=10)&&(VersionInfo.MinorVersion=0))?"WIN_10":WinVersion())), ServicePackMajor := (ServicePackMajor2:=VersionInfo.ServicePackMajor)
} WindowsVersionEx(Ex := false) {
	static WindowsVersionEx, WindowsVersion
	if (Ex=2)
		return ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_OperatingSystem")
	if (WindowsVersionEx)||(WindowsVersion)
		return Ex?WindowsVersion A_Space WindowsVersionEx:WindowsVersion
    for OS in ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_OperatingSystem") {
		WindowsVersion := Trim(OS.Caption), WindowsVersionEx := Trim((OS.CSDVersion?OS.CSDVersion A_Space:"") (A_Is64bitOS?"x64":"x86"))
		return Ex?WindowsVersion A_Space WindowsVersionEx:WindowsVersion
}} WinVersion() { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724833(v=vs.85).aspx
	VersionInfo := SysGetVersion()
	return VersionInfo.MajorVersion "." VersionInfo.MinorVersion "." VersionInfo.BuildNumber
}








































































;#############################################################################################################################################
;  ::::::::::::::::::::::::::::::::::::::::::::: ESTRUCTURAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;crear / obtener estructura RECT
;Sintaxis: RECT( [RECT (in_out)], [x (in_out)], [y (in_out)], [ancho (in_out)], [alto (in_out)] )
;RECT:
	;• si se espesifica una estructura RECT válida, devuelve [x, y, ancho, alto]
	;• caso contrario, crea la estructura con las coordinadas y dimenciones espesificadas
;Notas:
	;• cuando se crea la estructura, al ancho se le suma «x», y al alto se le suma «y».
	;• cuando se obtiene la estructura, al ancho se le resta «x», y al alto se le resta «y».
;Ejemplo:
	;RECT(RECT, 0, 5, 10, 40) ;crear RECT. x=0 | y=5 | w=10 | h=40
	;MsgBox % "x" RECT(RECT, x, y, w, h)[1] "`ny: " y "`nw: " w "`nh: " h ;obtener RECT. x=0 | y=5 | w=10 | h=40
	;MsgBox % NumGet(RECT, 12, "Int") ;obtener alto. h=40+5 (h+y) (si se obtiene de esta manera, no se le resta el «y»)
;Return: si se espesifico una estructura válida, devuelve [x, y, w, h], de lo contrario, ""
RECT(ByRef RECT, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "") {
	if (VarSetCapacity(RECT)) ;obtener RECT. 
		return [x:=NumGet(RECT, 0, "Int"), y:=NumGet(RECT, 4, "Int")
			, w:=NumGet(RECT, 8, "Int")-x, h:=NumGet(RECT, 12, "Int")-y]
	VarSetCapacity(RECT, 16, 0) ;crear RECT
	, NumPut(x, RECT, 0, "Int"), NumPut(y, RECT, 4, "Int")
	, NumPut(w+x, RECT, 8, "Int"), NumPut(h+y, RECT, 12, "Int")
} ;https://msdn.microsoft.com/en-us/library/dd162897(v=vs.85).aspx

POINT(ByRef POINT, ByRef x := "", ByRef y := "") {
	if (VarSetCapacity(POINT)) ;obtener POINT
		return [x:=NumGet(POINT, 0, "Int"), y:=NumGet(POINT, 4, "Int")]
	VarSetCapacity(POINT, 8, 0) ;crear POINT
	, NumPut(x, POINT, 0, "Int"), NumPut(y, POINT, 4, "Int")
} ;https://msdn.microsoft.com/en-us/library/dd162805(v=vs.85).aspx





























































































/*#############################################################################################################################################
  ::::::::::::::::::::::::::::::::::::::::::::: VENTANAS ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
NOTAS:
	• las funciones solo aceptan el ID de la ventana, excepto algunas como IsWindow(), IsWinActive(), WinWait(), etc.
	• para el titulo o ahk_xxx usar WinExist( .. ) o IsWindow(, [clase], [proceso/pid], [titulo]).
	• para referirse a la ventana activa, espesificar -1.
	• para referirse a la ventana bajo el cursor, espesificar -2.
	• para referirse a la última ventana espesificada, espesificar -3.
*/
;comprueba si la ventana no responde
WinHugh(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsHungAppWindow", "Ptr", hWnd, "Int")
}

;comprueba si la ventana está habilitada
;Sintaxis: WinEnabled( [ID] )
WinEnabled(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsWindowEnabled", "Ptr", hWnd, "Int")
}

;comprueba si la ventana existe / obtiene la ventana activa.
;Sintaxis: IsWindow( [ID], [clase], [proceso/pid], [título] )
;NOTA: dejar vacio para obtener el ID de la ventana activa
;EJEMPLO: MsgBox % IsWindow(,, "notepad.exe" )
IsWindow(hWnd*) { 
	if !hWnd.MaxIndex()
		return __gsvalue.LastWindowId := DllCall("User32.dll\GetForegroundWindow", "Ptr")
	if !hWnd[1]&&(hWnd[2]||hWnd[3]||hWnd[4]) {
		Loop, Parse, % WinEnum(), `n
		{ if hWnd[2]&&(WinGetClass(A_LoopField)!=hWnd[2])
				continue
			if (hWnd[4]!="")&&(WinGetTitle(A_LoopField)!=hWnd[4])
				continue
			if hWnd[3]&&(_getpid(A_LoopField,hWnd[3])!=hWnd[3])
				continue
			return __gsvalue.LastWindowId := A_LoopField
	}} if !hWnd[1]||!DllCall("User32.dll\IsWindow", "Ptr", hWnd[1], "Int")
	||(hWnd[2]&&(WinGetClass(hWnd[1])!=hWnd[2]))
	||(hWnd[4]&&(WinGetTitle(hWnd[1])!=hWnd[4]))
	||(hWnd[3]&&(_getpid(hWnd[1],hWnd[3])!=hWnd[3]))
		return false
	return __gsvalue.LastWindowId := hWnd[1]
}

;comprueba si la ventana es visible
WinVisible(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsWindowVisible", "Ptr", hWnd, "Int")
}

;comprueba si la ventana está minimizada
WinMin(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsIconic", "Ptr", hWnd, "Int")
}

;comprueba si la ventana está maximizada
WinMax(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsZoomed", "Ptr", hWnd, "Int")
}

;devuelve 1 si la ventana: existe, no esta maximizada/minimizada, es visible
WinNormal(hWnd) {
	_gethwnd(hWnd)
	if !IsWindow(hWnd)||WinMin(hWnd)||WinMax(hWnd)||!WinVisible(hWnd)
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;comprueba si es una ventana hija
;Sintaxis: WinChild( [ID ventana padre], [ID ventana hija] )
WinChild(hWnd, ChWnd*) {
	if !ChWnd.MaxIndex()
		return WinGetStyle(hWnd)&0x40000000?hWnd:WinGet(hWnd, "TopChild")
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsChild", "Ptr", hWnd, "Ptr", ChWnd[1], "Int")
}

;comprueba si la ventana está activa
;Sintaxis: IsWinActive( [ID], [clase], [proceso/pid], [titulo] )
IsWinActive(hWnd := "", Class := "", ProcessName := "", Title := "") {
	ActiveWindowId := IsWindow()
	if (!Class&&!ProcessName&&!ActiveWindowId&&!Title)
	||(!hWnd&&!Class&&!ProcessName&&!Title)
	||(hWnd&&(ActiveWindowId!=hWnd))
	||(Class&&(WinGetClass(hWnd?hWnd:ActiveWindowId)!=Class))
	||(Title&&(WinGetTitle(hWnd?hWnd:ActiveWindowId)!=Title))
	||(ProcessName&&(_getpid(hWnd,ProcessName,ActiveWindowId) != ProcessName))
		return false, ErrorLevel := true
	return true, ErrorLevel := false
}

;comprueba si la ventana tiene el estilo extendido AlwaysOnTop
;Sintaxis: WinAlwaysOnTop( [ID], [-1(alternar)|0|1] )
WinAlwaysOnTop(hWnd, AlwaysOnTop := "") {
	_gethwnd(hWnd)
	if (AlwaysOnTop!="")
		return WinSet(hWnd, "AlwaysOnTop", AlwaysOnTop=-1?!WinAlwaysOnTop(hWnd):AlwaysOnTop)
	return (WinGetExStyle(hWnd)&0x00000008)?true:false
}

;comprueba si la ventana tiene el estilo WS_SIZEBOX (+Resize)
;Sintaxis: WinResized( [ID], [-1(alternar)|0|1], [¿redibujar?] )
WinResized(hWnd, Resize := "", Redraw := false) {
	_gethwnd(hWnd)
	if (Resize!="") {
		r:=WinSetStyle(hWnd, (Resize=-1?(WinResized(hWnd)?"-":"+"):(Resize?"":"-")) 0x00040000)
		if (Redraw)
			WinRedraw(hWnd)
		return r
	} return (WinGetStyle(hWnd)&0x00040000)?true:false	
}

;comprueba si la ventana tiene el estilo extendido WS_EX_ACCEPTFILES
;Sintaxis: WinDragDrop( [ID], [-1(alternar)|0|1] )
WinDragDrop(hWnd, ACCEPTFILES := "") {
	_gethwnd(hWnd)
	if (ACCEPTFILES!="")
		return WinSetExStyle(hWnd, (ACCEPTFILES=-1?(WinDragDrop(hWnd)?"-":""):(ACCEPTFILES?"":"-")) 0x00000010)
	return (WinGetExStyle(hWnd)&0x00000010)?true:false
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;obtiene una lista con todas las ventanas de nivel superior en la pantalla o controles en la ventana
;W8+: sólo ventanas de nivel superior de las aplicaciones de escritorio
;Sintaxis: WinEnum( [hWnd], [¿incluir ventanas ocultas?], [delimitador], [cantidad (salida)] )
;hWnd: espesificar el hWnd de una ventana para obtener una lista con todos los controles
WinEnum(hWnd := 0, dhw := true, Delimiter := "`n", ByRef Count := "") {
	static EnumAddress := RegisterCallback("EnumWindowsProc", "Fast", 2) ;lpEnumFunc
	_gethwnd(hWnd), Param := {List: "", dhw: dhw, Delimiter: Delimiter, Count: 0}, Error := ErrorLevel
	, DllCall("User32.dll\EnumChildWindows", "Ptr", hWnd, "Ptr", EnumAddress, "Ptr", &Param)
	return Param.List, Count := Param.Count, ErrorLevel := Error
} EnumWindowsProc(hWnd, lParam) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633494(v=vs.85).aspx
	Param := Object(lParam)
	if (Param.dhw) || (WinVisible(hWnd))
		Param.List .= (Param.Count?Param.Delimiter:"") hWnd, Param.Count++
    return true
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633493(v=vs.85).aspx

;minimiza todas las ventanas
;Sintaxis: WinMinimizeAll( [¿forzar?] )
;NOTA: si se usa forzar, usar WinMinimizeAllUndo(1) para restaurarlas
	;para dar foco al escritorio usar ShowDesktop()
WinMinimizeAll(Force := false) {
	static Array, ActiveWindow
	if (Force="?"||Force="*")
		return Force="?"?Array:ActiveWindow
	ActiveWindow := IsWindow()
	if Force {
		Array := [], ok := Count := 0
		Loop, Parse, % WinEnum(, false), `n
		{	if !WinMin(A_LoopField) {
				Count++
				if WinMinimize(A_LoopField)
					ok++, Array[ok] := A_LoopField
		}} return ok, ErrorLevel := !(ok=Count)
	} if !(hWindow := FindWindow("Shell_TrayWnd"))
		return ComObjCreate("shell.application").MinimizeAll()
	return PostMessage(hWindow, 0x0111, "UInt", 419)
}

;restaura todas las ventanas
;Sintaxis: WinMinimizeAllUndo( [¿forzar?] )
;NOTA: si se usa forzar, restaura solo las ventanas minimizadas por WinMinimizeAll(1)
WinMinimizeAllUndo(Force := false) {
	if Force {
		ok := Count := 0
		for Index, hWnd in WinMinimizeAll("?") {
			if WinMin(hWnd)&&WinVisible(hWnd)
				ok += WinRestore(hWnd)?true:false, Count++
		} return ok, WinActivate(WinMinimizeAll("*")), ErrorLevel := !(ok=Count)
	} if !(hWindow := FindWindow("Shell_TrayWnd"))
		return ComObjCreate("shell.application").UndoMinimizeALL()
	return PostMessage(hWindow, 0x0111, "UInt", 416)
}

;recupera un identificador de la ventana de nivel superior cuyo nombre de clase y nombre de la ventana  conincida con lo espesificado
;Sintaxis: FindWindow( [clase], [título] )
;Notas: 
	;• para buscar ventanas secundarias usar FindWindowEx()
	;• no distingue entre mayúsculas y minúsculas
FindWindow(ClassName := "", WindowName*) {
	WinName := WindowName[1], Error := ErrorLevel
	return DllCall("User32.dll\FindWindowW", "Ptr", ClassName=""?0:&ClassName
		, "Ptr", WindowName.MaxIndex()?&WinName:0, "Ptr"), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx

;recupera un identificador a una ventana hija cuyo nombre de clase y nombre de la ventana coincida con lo espesificado
;Sintaxis: FindWindowEx( [ventana superior], [ventana hija de la cual empesar el orden], [clase], [título] )
;Nota: no distingue entre mayúsculas y minúsculas
FindWindowEx(Parent := 0, ChildAfter := 0, ClassName := "", WindowName*) {
	WinName := WindowName[1], Error := ErrorLevel
	return DllCall("User32.dll\FindWindowExW", "Ptr", Parent, "Ptr", ChildAfter, "Ptr", ClassName=""?0:&ClassName
	, "Ptr", WindowName.MaxIndex()?&WinName:0, "Ptr"), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633500(v=vs.85).aspx

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;centrar ventana, opcional posicionarla arriba/abajo/izquierda/derecha.
;Sintaxis: WinCenter( [ID], [Posición] )
;Posición: se pueden combinar.
	;Center = centrar ventana.
	;Top | Bottom = posicionar arriba. posicionar abajo.
	;Left | Right = posicionar a la izquierda. posicionar a la derecha.
;Notas:
	;• si la ventana está maximizada, se modifica el ancho o el alto dependiendo la posicion.
		;--> si se posiciona arriba o abajo, se modifica el alto (A_ScreenHeight/2-10%).
		;--> si se posiciona a la izquierda o a la derecha, se modifica el ancho (A_ScreenWidth/2-10%).
	;• la ventana se ajusta a la pantalla visible, sin importar la posicion de la barra de tareas (la ventana no es tapada por la barra de tareas)
;Ejemplo: abra Notepad para el ejemplo.
 	;MsgBox % "Centrar ventana: " ((!!WinActivate(WinExist("ahk_class Notepad"), 3)+WinMove(-3,,, 543, 403)+!!WinCenter(-3))-2)
	;MsgBox % "Posicionar arriba a la izquierda: " WinCenter(-3, "Top Left")
	;MsgBox % "Posicionar arriba a la derecha: " WinCenter(-3, "Top Right")
	;MsgBox % "Posicionar abajo a la izquierda: " WinCenter(-3, "Bottom Left")
	;MsgBox % "Posicionar abajo a la derecha: " WinCenter(-3, "Bottom Right")
	;MsgBox % "Posicionar arriba y centrarla: " WinCenter(-3, "Top Center")
	;MsgBox % "Posicionar abajo y centrarla: " WinCenter(-3, "Bottom Center")
	;MsgBox % "Posicionar a la izquierda y centrarla: " WinCenter(-3, "Left Center")
	;MsgBox % "Posicionar a la derecha y centrarla: " WinCenter(-3, "Right Center")
WinCenter(hWnd, Pos := "") {
	_gethwnd(hWnd), WinGetPos(hWnd, x, y, w, h), A_MonitorWorkArea(mx, my, mw, mh)
	, T := InStr(Pos, "Top"), B := InStr(Pos, "Bottom"), L := InStr(Pos, "Left"), R := InStr(Pos, "Right"), C := InStr(Pos, "Center")
	if (WinMax(hWnd)) 
		w := (L||R)?Percent(mw/2, 10):mw, h := (T||B)?Percent(mh/2, 10):mh
	if (T) || (B) || (L) || (R)
		return WinMove(hWnd, (L?0:R?(mw-w):C?((mw/2)-(w/2)):x) +mx, (T?0:B?(mh-h):C?((mh/2)-(h/2)):y) +my, w, h)
	return WinMove(hWnd, ((mw/2) - (w/2)) +mx, ((mh/2) - (h/2)) +my, w, h)
}

;parpadea la ventana especificada. no cambia el estado activo de la ventana.
;Sintaxis: WinFlash( [ID], [opciones], [veces que parpadea la ventana], [velocidad de parpadeo en milisegundos] )
;Opciones (se pueden sumar para combinar):
	;0 = parar (defecto).
	;1 = afecta al titulo de la ventana
	;2 = afecta al boton de la barra de tareas
	;12 = hasta que la ventana esté activa
WinFlash(hWnd, dwFlags := 0, uCount := 0, dwTimeout := 0) {
	_gethwnd(hWnd)
	, cbSize := VarSetCapacity(FLASHWINFO, A_PtrSize = 4 ? 20 : 32, 0) 
	, NumPut(cbSize, FLASHWINFO, 0, "UInt")
	, NumPut(hWnd, FLASHWINFO, 4, "Ptr")
	, NumPut(dwFlags+(uCount=0?4:0), FLASHWINFO, 8, "UInt")
	, NumPut(uCount>0?uCount:0, FLASHWINFO, A_PtrSize = 4 ? 12 : 16, "UInt")
	, NumPut(dwTimeout>0?dwTimeout:0, FLASHWINFO, A_PtrSize = 4 ? 16 : 24, "UInt")
	return DllCall("User32.dll\FlashWindowEx", "Ptr", &FLASHWINFO)
}

;redibujar la ventana
;Sintaxis: WinRedraw( [ID], [x], [y], [ancho], [alto], [¿forzar redibujado?] )
;x / y / Ancho / Alto: espesificar las coordenadas de parte de la ventana a redibujar o dejar en 0 para toda la ventana
WinRedraw(hWnd, x := "", y := "", w := "", h := "", Force := true) {
	_gethwnd(hWnd)
	if !(x="") && !(y="") && !(w="") && !(h="")
		RECT(RECT, x, y, w, h), l := true
	Ok := !!DllCall("User32.dll\InvalidateRect", "Ptr", hWnd, "Ptr", l?&RECT:0, "Int", true, "UInt")
	if (Force)
		Ok += !!DllCall("User32.dll\UpdateWindow", "Ptr", hWnd, "UInt")
	return Force?(Ok=2):Ok, ErrorLevel := Force?(Ok!=2):!Ok
}

;Permite producir efectos especiales al mostrar u ocultar ventanas
;Sintaxis: WinAnimate( [ID], [duracion de la animación , en milisegundos], [tipo de animación], [transparencia], [region] )
;TIPOS DE ANIMACIÓN (se pueden combinar):
	;S = Mostrar | H = Ocultar | C = Centrar | R = redibujar al terminar la animacion | T = quitar transparencia antes de producir el efecto (recomendado, si la tiene)
	;1 = Desvanecer | 2 = Diapositiva (combinar con 3/4 y/o 5/6)
	;3 = Izquierda A Derecha | 4 = Derecha A Izquierda
	;5 = Arriba Abajo | 6 = Abajo Arriba
;Nota: cuando se usa la opcion 'S' (mostrar), a veces los controles no se muestran correctamente, por ello, es necesario
	;redibujar la ventana, usar WinRedraw(), o agregar la opcion R.
WinAnimate(hWnd, Time := 200, Mode := "RS1", Transparent := "", Region := "") { 
	static List := {S: 0x00020000, 1: 0x00080000, C: 0x00000010, H: 0x00010000, 3: 0x00000001, 4: 0x00000002, 2: 0x00040000, 5: 0x00000004, 6: 0x00000008}
	_gethwnd(hWnd)
	if InStr(Mode, "T")
		WinSet(hWnd, "Transparent", "Off")
	i := DllCall("User32.dll\AnimateWindow", "Ptr", hWnd, "UInt", Time, "UInt", _cstr(List, Mode, "~", "+"))
	if InStr(Mode, "R")
		WinRedraw(hWnd)
	if (Transparent!="")
		WinSet(hWnd, "Transparent", Transparent)
	if (Region!="")
		WinSet(hWnd, "Region", Region)
	return i, ErrorLevel := !i
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632669%28v=vs.85%29.aspx

;mover ventana
;Sintaxis: WinMove( [ID], [x], [y], [ancho], [alto], [¿redibujar?] )
WinMove(hWnd, x := "", y := "", Width := "", Height := "", Redraw := true) {
	_gethwnd(hWnd)
	if (x="") || (y="") || (Width="") || (Height="")
		WinGetPos(hWnd, x_, y_, w_, h_)
	x := (x="")?x_:x, y := (y="")?y_:y, Width := (Width="")?w_:Width, Height := (Height="")?h_:Height
	return r:=DllCall("User32.dll\MoveWindow", "Ptr", hWnd, "Int", x, "Int", y, "Int", Width, "Int", Height, "Int", !!Redraw), ErrorLevel:=!r
}

;cerrar ventana
;Sintaxis: WinClose( [ID], [Segundos a esperar], [¿Forzar?] )
;NOTA: espesificar 0 segundos para esperar indefinidamente
WinClose(hWnd, Seconds := -1, Force := false) {
	_gethwnd(hWnd)
	if (Force)
		r := WinKill(hWnd)
	else r := PostMessage(hWnd, 0x0002)
	if (Seconds>-1)
		WinWaitClose(hWnd, Seconds)
	return !!r, ErrorLevel := !r
}

;forzar cierre de la ventana
;Sintais: WinKill( [hWnd], [¿forzar cierre del proceso?] )
WinKill(hWnd, Force := true) {
	_gethwnd(hWnd)
	if (Force)
		return ProcessClose(WinGetPID(hWnd))
	WinGetPID(hWnd, ThreadId), hThread := OpenThread(ThreadId, 0x0001)
	, r := DllCall("Kernel32.dll\TerminateThread", "Ptr", hThread, "UInt", 0, "UInt")
	if !(r)
		r := DllCall("User32.dll\EndTask", "Ptr", hWnd, "Int", false, "Int", true)
	return !!r, CloseHandle(hThread), ErrorLevel := !r
}

;destruir ventanas creadas por el script
;Sintaxis: WinDestroy( [hWnd], [¿solo eliminar los controles?], [¿detectar controles ocultos?] )
;Return: si elimina los controles, devuelve la cantidad de controles eliminados
WinDestroy(hWnd, DeleteCtrls := false, DetectHiddenWindows := true) {
	_gethwnd(hWnd), Ok := 0, Count := 0
	if (DeleteCtrls) { ;eliminar todos los controles de la ventana -->
		Loop, Parse, % WinEnum(hWnd, DetectHiddenWindows), `n
		{	Ok += !!DllCall("User32.dll\DestroyWindow", "Ptr", A_LoopField, "UInt")
			Count++
		} return Ok, ErrorLevel := Ok!=Count ;<--
	} return r:=DllCall("User32.dll\DestroyWindow", "Ptr", hWnd, "UInt"), ErrorLevel := !r
}

;cierra todas las ventanas que coincidan con los datos espesificados
;Sintaxis: WinCloseEx( [ID], [Clase], [Proceso/PID], [¿forzar?], [¿afectar a las ventanas ocultas?], [titulo] )
WinCloseEx(hWnd := "", Class := "", ProcessName := "", Force := false, DetectHiddenWindows := true, Title*) {
	Win := Total := 0
	Loop, Parse, % WinEnum(, DetectHiddenWindows), `n
	{ if hWnd&&(hWnd!=A_LoopField)
			continue
		if Class&&!(WinGetClass(A_LoopField)==Class)
			continue
		if ProcessName&&(_getpid(A_LoopField,ProcessName)!=ProcessName)
			continue
		if Title.MaxIndex()&&(WinGetTitle(A_LoopField)!=Title[1])
			continue
		Win += WinClose(A_LoopField,, Force), Total++
	} return Win=Total, ErrorLevel := !(Win=Total)
}

;minimiza la ventana
;Sintaxis: WinMinimize( [ID], [¿Forzar?] )
WinMinimize(hWnd, Force := false) {
	_gethwnd(hWnd)
	if (Force) {
		r := PostMessage(hWnd,  0x112, "UInt", 0xF020)
		if !(IsWindowsVistaOrGreater())
			return r, ErrorLevel := !r
		return r:=DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 11), ErrorLevel := !r
	} return r:=DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 6), ErrorLevel := !r
}

;maximiza la ventana
;Sintaxis: WinMaximize( [ID], [¿Forzar?] )
WinMaximize(hWnd, Force := false) {
	_gethwnd(hWnd)
	if (Force) ;SW_MAXIMIZE = 3
		PostMessage(hWnd, 0x112, "UInt", 0xF030) 
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 3), ErrorLevel := !i 
}

;restaura la ventana a su tamaño y posicion original
;Sintaxis: WinRestore( [ID], [¿Forzar?] )
WinRestore(hWnd, Force := 0) {
	_gethwnd(hWnd)
	if Force ;SW_RESTORE = 9
		PostMessage(hWnd, 0x112, "UInt", 0xF120)
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 9), ErrorLevel := !i 
}

;oculta la ventana
;NOTA: para ocultar la ventana solo en la barra de tareas usar TaskBarRemove()
WinHide(hWnd) {
	_gethwnd(hWnd) ;SW_HIDE = 0
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", false), ErrorLevel := !i 
}

;habilita la ventana
;Sintaxis: WinEnable( [ID], [¿Activar?], [¿Esperar? (seg)] )
WinEnable(hWnd, Activate := false, WaitActive := -1) {
	_gethwnd(hWnd)
	return i := DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", true)
		, a := Activate?WinActivate(hWnd):"", ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
}

;deshabilita la ventana
WinDisable(hWnd) {
	_gethwnd(hWnd)
	return i:=!DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", false), ErrorLevel := !i
}

;muestra la ventana
;Sintaxis: WinShow( [ID], [¿Activar?], [¿Esperar? (segundos)] )
WinShow(hWnd, Activate := false, WaitActive := -1) {
	_gethwnd(hWnd)
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 5)
		, a := Activate?WinActivate(hWnd):"", ErrorLevel := !i 
		, WinWaitActive(hWnd, WaitActive) ;SW_SHOW = 5
}

;activa la ventana
;NOTA: si la ventana está minimizada, las restaura a su tamaño y posicion original
;Sintaxis: WinActivate( [ID], [¿Esperar? (segundos)], [¿Forzar?] )
WinActivate(hWnd, WaitActive := -1, Force := false) {
	_gethwnd(hWnd)
	if WinMin( hWnd )
		WinRestore(hWnd)
	if (Force) {
		CurrentThreadId := ProcessExist(-2), WinGetPID(hWnd, WinThreadId)
		, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", true)
		return i := DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
			, DllCall("User32.dll\BringWindowToTop", "Ptr", hWnd)
			, DllCall("User32.dll\SetFocus", "Ptr", hWnd)
			, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", false)
			, ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
	} return i := DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
		, ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;obtener coordenadas y dimenciones de la ventana
;Sintaxis: WinGetPos( [hWNd], [x (out)], [y (out)], [ancho (out)], [alto (out)], [modo] )
;Modos:
	;0 (defecto) = incluir bordes
	;1 = excluir bordes
	;+2 = convertir en coordenadas de pantalla
;Return: [x, y, ancho, alto]
;ErrorLevel: 0|1
WinGetPos(hWnd, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "", Mode := 0) {
	_gethwnd(hWnd), VarSetCapacity(RECT, 16, 0)
	;if (Mode=0) || (Mode=2) ;incluir bordes. 0 | 0+2
		Ok := DllCall("User32.dll\GetWindowRect", "Ptr", hWnd, "Ptr", &RECT, "Int"), RECT(RECT, x, y, w, h)
	if (Mode=1) || (Mode=3) ;excluir bordes. 1 | 1+2
		Ok := DllCall("User32.dll\GetClientRect", "Ptr", hWnd, "Ptr", &RECT, "Int"), RECT(RECT,,, w, h)
	if (Mode=2) || (Mode=3) ;convertir en coordenadas de pantalla. 0+2 || 1+2
		Ok := Ok?DllCall("User32.dll\ClientToScreen", "Ptr", hWnd, "Ptr", &RECT, "Int"):false
	return [x, y, w, h], ErrorLevel := !Ok
}

;convierte en coordenadas de pantalla o relativo a la ventana, suma/quita bordes.
;Sintaxis: WinClient( [ID], [x], [y], [ancho], [alto], [ScreenToClient|ClientToScreen|+/-Borders] )
;Return: [x, y, ancho, alto]
WinClient(hWnd, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "", Mode := "ClientToScreen") {
	if (Mode="+Borders") || (Mode="-Borders") {
        WinGetPos(hWnd, _x, _y, _w, _h)
        , w := Mode="+Borders"?(w=_w?w:w<_w?w+(_w-w):w):(w=_w?w:w>_w?w-(w-_w):w)
        , h := Mode="+Borders"?(h=_h?h:h<_h?h+(_h-h):h>_h?(_h+(h-_h)):h):(h=_h?h:h>_h?h-(h-_h):h)
		return [x := x=""?_x:x, y := y=""?_y:y, w, h]
	} _gethwnd(hWnd), RECT(RECT, x, y, w, h), Error := !DllCall("User32.dll\" Mode, "Ptr", hWnd, "Ptr", &RECT, "Int")
	return RECT(RECT, x, y, w, h), ErrorLevel := Error
}

;obtiene el ancho y alto de los bordes de la ventana
;Sintaxis: WinGetBorder( [ID], [ancho], [alto], [modo] )
;Modos: 0 = normal | 1 = convierte en coordenadas de pantalla
;Return: [ancho, alto]
WinGetBorder(hWnd, ByRef w := "", ByRef h := "", Mode := 0) {
	WinGetPos(hWnd,,, w, h, Mode?2:0), WinGetPos(hWnd,,, w2, h2, Mode?3:1)
	return [w:=w-w2, h:=h-h2]
}

;obtiene el estilo de la ventana
;Ejemplo: MsgBox % Hex(WinGetStyle(-1), 8, 1)
WinGetStyle(hWnd) { ;0x40000 = resize
	static Func := A_PtrSize = 4 ? "GetWindowLongW" : "GetWindowLongPtrW"
	_gethwnd(hWnd), Style := DllCall("User32.dll\" Func, "Ptr", hWnd, "Int", -16, "UInt")
	return Style, ErrorLevel := !Style
}

;obtiene el estilo extendido de la ventana
;Ejemplo: MsgBox % Hex(WinGetExStyle(-1), 8, 1)
WinGetExStyle(hWnd) {
	static Func := A_PtrSize = 4 ? "GetWindowLongW" : "GetWindowLongPtrW"
	_gethwnd(hWnd), ExStyle := DllCall("User32.dll\" Func, "Ptr", hWnd, "Int", -20, "UInt")
	return ExStyle, ErrorLevel := !ExStyle
}

;obtiene el titulo de la ventana especificada.
;Sintaxis: WinGetTitle( [hWnd] )
WinGetTitle(hWnd) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633520%28v=vs.85%29.aspx
	_gethwnd(hWnd)
	, Size := DllCall("User32.dll\GetWindowTextLengthW", "Ptr", hWnd, "Int") + 1
	, VarSetCapacity(OutputVar, Size * 2, 0)
	, Error := !DllCall("User32.dll\GetWindowTextW", "Ptr", hWnd, "Str", OutputVar, "Int", Size * 2, "Int")
	return OutputVar, ErrorLevel := Error
}

;obtiene el nombre de la clase a la que pertenece la ventana especificada.
WinGetClass(hWnd) {
	_gethwnd(hWnd), Size := 256 + 1
	, VarSetCapacity(OutputVar, Size * 2, 0)
	, Error := !DllCall("User32.dll\GetClassNameW", "Ptr", hWnd, "Str", OutputVar, "Int", Size * 2, "Int")
	return OutputVar, ErrorLevel := Error
}

;recupera el PID, opcional ThreadId/ProcessName/ProcessPath
;Sintaxis: WinGetPID( [ID], [ThreadId (salida)], [Proceso (salida)], [Proceso Ruta (salida)] )
;EJEMPLO: MsgBox % "Pid: " WinGetPid(IsWindow(),,,i) "`nCompanyName: " FileGetInfo(i,"CompanyName") "`nRuta: " i
WinGetPID(hWnd, ByRef ThreadId := "", ByRef ProcessName := "", ByRef ProcessPath := "") {
	_gethwnd(hWnd), ThreadId := DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "UIntP", ProcessId, "UInt")
	if (IsByRef(ProcessName))
		ProcessName := ProcessName(ProcessId)
	if (IsByRef(ProcessPath))
		ProcessPath := ProcessPath(ProcessId)
	return ProcessId, ErrorLevel := !ThreadId
}

;obtener el texto de la ventana
;Sintaxis: WinGetText( [ID] )
WinGetText(hWnd) {
	_gethwnd(hWnd)
	WinGetText, OutputVar, ahk_id %hWnd%
	return OutputVar
}

;obtener informacion de la ventana
;Sintaxis: WinGet( [ID], [CMD] )
;CMD: TopChild|Top|Parent
WinGet(hWnd, Cmd) {
	_gethwnd(hWnd)
	if (Cmd="TopChild") {
		top_hwnd := hWnd
		Loop {
			if !(top_hwnd:=DllCall("User32.dll\GetTopWindow", "Ptr", top_hwnd, "Ptr"))
				return last_hwnd?last_hwnd:hWnd
			last_hwnd := top_hwnd
	}} else if (Cmd="Top")
		return DllCall("User32.dll\GetTopWindow", "Ptr", hWnd, "Ptr")
	else if (Cmd="Parent")
		return DllCall("User32.dll\GetParent", "Ptr", hWnd, "Ptr")
	dhw := A_DetectHiddenWindows
	DetectHiddenWindows, On
	WinGet, OutputVar, %Cmd%, ahk_id %hWnd%
	DetectHiddenWindows, %dhw%
	return OutputVar
}

;obtiene el icono de la ventana
;Sintaxis: WinGetIcon( [ID], [tipo] )
;Tipos: 0 = icono pequeño | 1 = icono grande
	;2 = Recupera el icono pequeño que proporciona la aplicación.
		;si la aplicación no proporciona uno, el sistema utiliza el icono generado por el sistema para esa ventana.
WinGetIcon(hWnd, Type := 0) {
	_gethwnd(hWnd)
	return SendMessage(hWnd, 0x007F, "UInt", Type,,, "Ptr")
}

;obtener hWnd del menu de la ventana espesificada
;Sintaxis: WinGetMenu( [hWnd] )
WinGetMenu(hWnd) {
	return DllCall("User32.dll\GetMenu", "Ptr", hWnd, "Ptr")
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;establecer el titulo de la ventana espesificada
;Sintaxis: WinSetTitle( [ID], [Titulo], [Modo] )
;Modos: 1 = ocultar el titulo | 2 = ocultar el icono
	;Nota: espesificar el númeo pero negativo para restaurar
WinSetTitle(hWnd, NewTitle := "") {
	_gethwnd(hWnd)
	return Ok:=DllCall("User32.dll\SetWindowTextW", "Ptr", hWnd, "Str", NewTitle, "Int"), ErrorLevel := !Ok
}

;cambia el icono de la ventana
;Sintaxis: WinSetIcon( [ID], [Icono/DLL/Ejecutable], [Índice] )
WinSetIcon(hWnd, Icon, Index := 1) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632643%28v=vs.85%29.aspx
	if !(hIcon := ExtractIcon(Icon, Index))
		return false, ErrorLevel := 2
	_gethwnd(hWnd)
	, SendMessage(hWnd, 0x0080,,,, hIcon), SendMessage(hWnd, 0x0080, "UInt", 1,, hIcon)
	if ErrorLevel
		return false, DestroyIcon(hIcon), ErrorLevel := true
	return true, ErrorLevel := false ;WM_SETICON := 0x0080, ICON_SMALL := 0, ICON_BIG := 1
}

;permitir/bloquear el redibujado de la ventana
;Sintaxis: WinSetRedraw( [hWnd], [0|1] )
WinSetRedraw(hWnd, Redraw := true) {
	_gethWnd(hWnd), r := SendMessage(hWnd, 0x000B, "Int", !!Redraw,,, "UInt")
	return (r=0), ErrorLevel := (r!=0)
}

;establecer estilo
;Sintaxis: WinSetStyle( [ID], [+-^Estilo], [SWP_FRAMECHANGED] )
;Estilo: +(añadir) -(quitar) ^(alternar) || por defecto reemplaza el estilo
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600%28v=vs.85%29.aspx
;Nota: algunos cambios necesitan SWP_FRAMECHANGED para que surtan efecto.
WinSetStyle(hWnd, Style, FRAMECHANGED := false) {
	static Func := "User32.dll\" ((A_PtrSize=4)?"SetWindowLongW":"SetWindowLongPtrW")
	_gethwnd(hWnd), Style := _mnum(WinGetStyle(hWnd), Style)
	if (ErrorLevel) || !(DllCall(Func, "Ptr", hWnd, "Int", -16, "Int", Style))
		return false, ErrorLevel := true
	if (FRAMECHANGED) ;http://ahkscript.org/boards/viewtopic.php?f=5&t=9591
		DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x27)
	return true, ErrorLevel := false
}

;establecer estilo extendido
;Sintaxis: WinSetExStyle( [ID], [+-^Estilo], [SWP_FRAMECHANGED] )
;Estilo: +(añadir, defecto) -(quitar) ^(alternar)
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543%28v=vs.85%29.aspx
;Nota: algunos cambios necesitan SWP_FRAMECHANGED para que surtan efecto.
WinSetExStyle(hWnd, ExStyle, FRAMECHANGED := false) {
	static Func := "User32.dll\" ((A_PtrSize=4)?"SetWindowLongW":"SetWindowLongPtrW")
	_gethwnd(hWnd), ExStyle := _mnum(WinGetExStyle(hWnd), ExStyle)
	if (ErrorLevel) || !(DllCall(Func, "Ptr", hWnd, "Int", -20, "Int", ExStyle))
		return false, ErrorLevel := true
	if (FRAMECHANGED) ;http://ahkscript.org/boards/viewtopic.php?f=5&t=9591
		DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x27)
	return true, ErrorLevel := false
}

;hace una variedad de cambios en la ventana.
;Sintaxis: WinSet( [ID], [Atributo], [Valor] )
;Atributos: Bottom|Top|+/-AlwaysOnTop|Parent
WinSet(hWnd, Attribute, Value := "") {
	_gethwnd(hWnd)
	if (Attribute="Bottom")
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="Top")
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="TOPMOST"||Attribute="+AlwaysOnTop"||(Attribute="AlwaysOnTop"&&Value!=0&&Value!="Off"))
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", -1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="NOTOPMOST"||Attribute="-AlwaysOnTop"||(Attribute="AlwaysOnTop"&&(Value=0||Value="Off")))
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", -2, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="Parent")
		return DllCall("User32.dll\SetParent", "Ptr", hWnd, "Ptr", Value)
	dhw := A_DetectHiddenWindows
	DetectHiddenWindows, On
	WinSet, %Attribute%, %Value%, ahk_id %hWnd%
	DetectHiddenWindows, %dhw%
	return !ErrorLevel
}

;hace una variedad de cambios en el menú de la ventana
;Sintaxis: WinSetMenu( [hWnd], [opciones], [¿restaurar?] )
;Opciones (separar con | para combinar): https://msdn.microsoft.com/en-us/library/windows/desktop/ms646360(v=vs.85).aspx
	;0xF020 = deshabilitar boton minimizar | SC_MINIMIZE
	;0xF030 = deshabilitar boton maximizar | SC_MAXIMIZE
	;0xF060 = deshabilitar boton cerrar | SC_CLOSE
	;0xF010 = deshabilitar mover ventana | SC_MOVE
	;0xF120 = deshabilitar restaurar ventana | SC_RESTORE
	;0xF000 = deshabilitar redimencionar ventana | SC_SIZE
WinSetMenu(hWnd, Options := 0, Restore := false) {
	_gethwnd(hWnd)
	if !(r:=l:=0) && !(hMenu:=DllCall("User32.dll\GetSystemMenu", "Ptr", hWnd, "Int", !!Restore, "Ptr"))
		return !!Restore, ErrorLevel := !Restore ;GetSystemMenu devuelve "" si se usa Restore=1
	Loop, Parse, % Options, |, % A_Space A_Tab
		r += !!DllCall("User32.dll\RemoveMenu", "Ptr", hMenu, "UInt", A_LoopField, "UInt", 0, "Int"), l++
	return r=l, DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd, "Int"), ErrorLevel := r!=l
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;espera a que la ventana no exista
;Sintaxis: WinWaitClose( [ID], [segundos], [clase], [proceso/pid], [titulo] )
WinWaitClose(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title*) {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWindow(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que la ventana se active
;Sintaxis: WinWaitActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title*) {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if IsWinActive(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que la ventana pierda el foco
;Sintaxis: WinWaitNotActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitNotActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWinActive(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que la ventana exista
;Sintaxis: WinWait( [ID], [Segundos], [clase], [proceso/pid], [Título] )
;Nota: devuelve el ID 
WinWait(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName)
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (i:=IsWindow(hWnd, Class, ProcessName, Title))
			return i, ErrorLevel := false
		if (Seconds>0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}






































































/*#############################################################################################################################################
 ::::::::::::::::::::::::::::::::::::::::::::: MENU ::::::::::::::::::::::::::::::::::
PARÁMETROS:
	• hWnd = ID de la ventana
	• hMenu = ID del menu (para obtener el ID del menu por nombre, usar GetMenuByName)
	• Menu = nombre del menu
EJEMPLO:
	Menu, MyMenu, Add, Item 1: Hola, close
	Menu, MyMenu, Add, % "ID: " GetMenuByName("MyMenu"), close
	MenuCheckRadioItem(GetMenuByName("MyMenu"), 2)
	Menu, MyMenu, Show
	return
	close:
	ExitApp
#############################################################################################################################################
*/
;ejecuta un comando del menu de la ventana
;Sintaxis: MenuSelectItem( [hWnd], [ID del Menú], [Nombre del Menú] )
;NOTA: espesificar ' > ' para submenús
;Ejemplo: MenuSelectItem( IsWindow(),, "Archivo > Abrir..." )
;VER: MenuGetItemList()
MenuSelectItem(hWnd, MenuItemId := "", MenuItemName := "") {
	if (MenuItemName != "") {
		Loop, Parse, % List:=MenuGetItemList(hWnd), `n, `r
		{ RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
			if (MenuItemName = MenuItem2) {
				MenuItemId := MenuItem1
				break
		}} if (MenuItemId="")
			Loop, Parse, % List, `n, `r
			{ RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
				if InStr(MenuItem2, MenuItemName) {
					MenuItemId := MenuItem1
					break
	}}} return DllCall("User32.dll\SendNotifyMessageW", "Ptr", hWnd, "UInt", 0x111, "Ptr", MenuItemId, "Ptr", 0)
}

;Invoca un elemento de menú de la barra de menú de la ventana especificada
;Sintaxis: MenuSelect( [hWnd], [Menu Principal], [Submenus*] )
;EJEMPLO: MenuSelect( IsWindow(), "Archivo", "Abrir..." )
;VER: MenuSelectItem()
MenuSelect(hWnd, Menu, Submenu*) {
	if !Submenu.MaxIndex()
		return MenuSelectItem(hWnd,, Menu)
	Loop, % Submenu.MaxIndex()
		_Submenu .= " > " Submenu[A_Index]
	return MenuSelectItem(hWnd,, Menu _Submenu)
}

;redibujar el menú de la ventana.
;Sintaxis: MenuRedraw( [hWnd] )
MenuRedraw(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd)
}

;marcar el menu espesificado. al mismo tiempo desmarca todos los demás en el grupo espesificado
;Sintaxis: MenuCheckRadioItem( [hMenu], [item], [inicio], [fin] )
MenuCheckRadioItem(hMenu, ItemPos, First := 1, Last := 0) {
	if !(Last>0)
		Last := MenuGetItemCount(hMenu)
	return DllCall("User32.dll\CheckMenuRadioItem", "Ptr", hMenu, "UInt", First - 1, "UInt", Last - 1, "UInt", ItemPos - 1, "UInt", 0x0400)
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;comprueba si es un menú válido
;Sintaxis: IsMenu( [hMenu] )
IsMenu(hMenu) {
	return DllCall("User32.dll\IsMenu", "Ptr", hMenu)
}

MenuIsChecked(hMenu, ItemPos) {
	return (DllCall("User32.dll\GetMenuState", "Ptr", hMenu, "UInt", ItemPos - 1, "UInt", 0x0400, "UInt") & 0x08)
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;obtener una lista con todos los elementos de los menús de la ventana
;Sintaxis: MenuGetItemList( [hWnd] )
;NOTA: sólo funciona con aplicaciones que utilizan menús estándar de Windows
;EJEMPLO: ver uso de LoopParse con RegExMatch() en: MenuSelectItem()
MenuGetItemList(hWnd, hMenu := 0, Prefix := "") { ;http://ahkscript.org/boards/viewtopic.php?p=48401#p48401
	_gethwnd(hWnd)
	, hMenu := hMenu ? hMenu : DllCall("User32.dll\GetMenu", "Ptr", hWnd)
	, Count := DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
	Loop, %Count% {
		sSize := DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Ptr", 0, "Int", 0, "UInt", 0x00000400)
		, sSize := VarSetCapacity( lpString, (sSize + 1) * 2 ) / 2
		if !DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Str", lpString, "Int", sSize, "UInt", 0x00000400)
			continue
		lpString := StrReplace(lpString, "&")
		, ItemId := DllCall("User32.dll\GetMenuItemID", "Ptr", hMenu, "Int", A_Index-1)
		if (itemID = -1) AND (hSubMenu := DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", A_Index-1)) {
			List .= MenuGetItemList( "", hSubMenu, Prefix lpString " > " ) "`n"
			continue
		} List .= ItemId "`t" Prefix RegExReplace( lpString, "`t.*" ) "`n"
	} return RTrim( List, "`n" )
}

;obtener el ID del menu por nombre
;Sintaxis: GetMenuByName( [menu] )
GetMenuByName(Menu) {
	static hMenu
	If !(hMenu) {
		Menu, %A_ThisFunc%Menu, Add
		Menu, %A_ThisFunc%Menu, DeleteAll
		Gui, %A_ThisFunc%GUI:+HWNDhWnd
		Gui, %A_ThisFunc%GUI:Menu, %A_ThisFunc%Menu
		hMenu := WinGetMenu(hWnd)
		Gui, %A_ThisFunc%GUI:Menu
		Gui, %A_ThisFunc%GUI:Destroy
	} Menu, %A_ThisFunc%Menu, Add, :%Menu%
	hSubMenu := MenuGetSubMenu(hMenu)
	Menu, %A_ThisFunc%Menu, Delete, :%Menu%
	return hSubMenu
}

;obtener el ID del submenu del menu espesificado
;Sintaxis: MenuGetSubMenu( [hMenu], [item] )
MenuGetSubMenu(hMenu, ItemPos := 1) {
	return DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", ItemPos - 1)
}

;determina la cantidad de items en el menu
;Sintaxis: MenuGetItemCount( [hMenu] )
MenuGetItemCount(hMenu) {
	return DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
}











































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: TAREAS PROGRAMADAS ::::::::::::::::::::::::::::::::::
;Nota: requiere WIN_V+
;#############################################################################################################################################
;recupera todas las tareas programadas
;Sintaxis: SchTasksEnum( [¿buscar tareas en subcarpetas?] )
;Return: for [Index], [v.Name, v.Path] in SchTasksEnum()
;Ejemplo:
	;for k, v in SchTasksEnum(true)
	;	List .= v.path "`n"
	;MsgBox % List
SchTasksEnum(All := false) {
	if !(schservice:=SchTasksInit())
		return false
	RootFolder := schservice.GetFolder("\"), List := []
	, TaskCollection := RootFolder.GetTasks(0)
	for RegisteredTask in TaskCollection
			Task := {}, Task.Path := RegisteredTask.Path, Task.Name := RegisteredTask.Name, List.Push(Task)
	if (All)
		Loop, Parse, % SchTasksFoldersEnum(), `n
		{ 	TaskFolder := schservice.GetFolder(A_LoopField)
			, TaskCollection := TaskFolder.GetTasks(0)
			for RegisteredTask in TaskCollection
					Task := {}, Task.Path := RegisteredTask.Path, Task.Name := RegisteredTask.Name, List.Push(Task)
		} return List
} SchTasksInit(ByRef TaskPath := "", ByRef TaskName := "") {
	static schservice
	if !(IsObject(schservice)) {
		try schservice := ComObjCreate("Schedule.Service")
		catch, OutputVar
			return false, ErrorLevel := OutputVar
		schservice.Connect()
	} if (IsByRef(TaskName)) {
		SplitPath, TaskPath, TaskName, TaskPath
		TaskPath := "\" LTrim(TaskPath, "\")
	} return schservice
}

;enumera todas las subcarpetas en el directorio espesificado
;Sintaxis: SchTasksFoldersEnum( [ruta], [¿enumerar todas las carpetas y subcarpetas del directorio espesificado?] )
;Nota: si no espesifica un ruta (defecto), recupera todas las carpetas y subcarpetas en el directorio raiz.
;Ejemplos:
	;MsgBox % SchTasksFoldersEnum("\") ;recupera todas las carpetas en el directorio raiz.
	;MsgBox % SchTasksFoldersEnum() ;recupera todas las carpetas y subcarpetas en el directorio raiz.
SchTasksFoldersEnum(TaskPath := "", All := false, Prefix := "") {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\" LTrim(TaskPath, "\"))
	, FolderCollection := TaskFolder.GetFolders(0)
	catch, OutputVar
		return "", ErrorLevel := OutputVar
	for RegisteredFolder in FolderCollection {
		if (TaskPath="") || (All) {
			TaskFolder2 := schservice.GetFolder(RegisteredFolder.Path)
			if (TaskFolder2.GetFolders(0).Count>0) {
				List .= SchTasksFoldersEnum(RegisteredFolder.Path, true, RegisteredFolder.Path "`n") "`n"
			} else List .= Prefix RegisteredFolder.Path "`n"
		} else List .= (A_Index=1?"":"`n") RegisteredFolder.Name
	} Sort, List, U D`n
	return List
}

;habilitar tarea
;Sintaxis: SchTasksEnable( [ruta\nombre] )
SchTasksEnable(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Enabled := true
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;deshabilitar tarea
;Sintaxis: SchTasksDisable( [ruta\nombre] )
SchTasksDisable(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Enabled := false
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;crear carpeta\subcarpeta(s...)
;Sintaxis: SchTasksCreateFolder( [carpeta\sub1\sub2\etc...] )
SchTasksCreateFolder(TaskPath) {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\"), TaskFolder.CreateFolder(TaskPath)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;detener tarea
;Sintaxis: SchTasksStop( [ruta\nombre] )
SchTasksStop(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Stop(0)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;ejecutar tarea
;Sintaxis: SchTasksRun( [ruta\nombre], [parámetros] )
SchTasksRun(TaskPath, Params := "") {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Run(Params, RunningTask)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;obtener información de la tarea.
;Sintaxis: SchTasksGetInfo( [ruta\nombre], [estado], [info] )
;Estado: Unknown | Disabled | Queued | Ready | Running
;Info: devuelve la informacion en formato .XML. usar SchTasksSplitInfo() para leer los valores.
;Ejemplo:
	;SchTasksGetInfo("CCleanerSkipUAC", State, RegistrationInfo)
	;MsgBox % State
	;MsgBox % RegistrationInfo
	;Info := SchTasksSplitInfo(RegistrationInfo)
	;MsgBox % "Autor: " Info.Author "`nDominio\Usuario: " Info.UserId "`nLogonType: " Info.LogonType "`nPrioridad: " Info.Priority
	;	. "`nHabilitado: " Info.Enabled "`nOculto: " Info.Hidden "`nComando: " Info.Command "`nArgumentos: " Info.Arguments
SchTasksGetInfo(TaskPath, ByRef State := "", ByRef RegistrationInfo := "") {
	static States := {0: "Unknown", 1: "Disabled", 2: "Queued", 3: "Ready", 4: "Running"}
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	if (IsByRef(State))
		State := States[RegisteredTask.State]
	if (IsByRef(RegistrationInfo))
		RegistrationInfo := RegisteredTask.XML
	return true, ErrorLevel := false
} SchTasksSplitInfo(RegistrationInfo) {
	RegInfo := {}
	Loop, Parse, % "Author,UserId,LogonType,Priority,Enabled,Hidden,Command,Arguments", `,
		RegExMatch(RegistrationInfo, "<" A_LoopField ">(.+)</" A_LoopField ">", TypeID)
		, RegInfo[A_LoopField] := (A_LoopField="Enabled"||A_LoopField="Hidden")?(TypeID1="true"):TypeID1
	return RegInfo
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;establecer prioridad
;Sintaxis: SchTasksSetPriority( [ruta\nombre], [prioridad 0~10 (defecto=7)] )
SchTasksSetPriority(TaskPath, Priority := 7) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, TaskDefinition := RegisteredTask.Definition
	, TaskSettings := TaskDefinition.Settings
	, TaskSettings.Priority := ((Priority>-1)&&(Priority<11))?Priority:7
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;eliminar tarea
;Sintaxis: SchTasksDelete( [ruta\nombre] )
SchTasksDelete(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, TaskFolder.DeleteTask(TaskName, 0)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;eliminar carpeta junto con todas sus subcarpetas
;Sintaxis: SchTasksDeleteFolder( [ruta], [¿eliminar si la carpeta tiene subcarpetas?] )
SchTasksDeleteFolder(TaskPath, Recurse := true) {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\")
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	if (Recurse) && (TaskFolder.GetFolders(0).Count>0) {
		Loop, Parse, % SchTasksFoldersEnum("\" LTrim(TaskPath, "\"), true), `n
		{ SplitPath, A_LoopField, TaskName2, TaskPath2
			try TaskFolder2 := schservice.GetFolder("\" LTrim(TaskPath2, "\"))
			, TaskFolder2.DeleteFolder(TaskName2, 0)
	}} try TaskFolder.DeleteFolder(TaskPath, 0)
	return true, ErrorLevel := false
}












































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SONIDO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PRINCIPALES (WIN_V+)
;Parámetros:
	;Vol: espesificar un número entre 0.0 y 100.0 inclusive.
	;Channel: índice del canal para ajustar.
	;Tipo: espesificar uno de los siguientes tipos de dispositivos a los que ajustar el volumen, un indice, o el tipo y el indice separados por dos puntos «:».
		;Default = usar el dispositivo actual
		;ALL = todos
		;Capture
		;Render / PlayBack
	;Ejemplos de tipo:
		;Capture:2 (buscar en todos los dispositivos Capture y devuelve solo el de indice 2)
		;PlayBack:1 (buscar en todos los dispositivos PlayBack y devuelve solo el de indice 1)
		;PlayBack (devuelve todos los dispositivos PlayBack)
		;4 (busca en todos los dispositivos y devuelve solo el de indice 4)
;Link MSDN: https://msdn.microsoft.com/en-us/library/ms679028(VS.85).aspx
;Source (Vista Audio Control Reference 2.3 by Lexikos): http://www.autohotkey.net/~Lexikos/docs/VA.html
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;establecer volumen
;Sintaxis: Sound_SetMasterVolume( [Vol], [channel], [tipo] )
Sound_SetMasterVolume(Vol, Channel := 0, Type := "Default") {
	for k, v in Sound_GetDevice(Type) {
		hInterface := Sound_GetEndpointVolume(v)
		if (Channel)
			DllCall(NumGet(NumGet(hInterface+0)+11*A_PtrSize), "Ptr", hInterface, "UInt", Channel-1, "Float", Vol/100, "Ptr", 0)
		else DllCall(NumGet(NumGet(hInterface+0)+7*A_PtrSize), "Ptr", hInterface, "Float", Vol/100, "Ptr", 0)
		ObjRelease(hInterface)
}}

;obtener volumen
;Sintaxis: Sound_GetMasterVolume( [channel], [tipo] )
;Return: devuelve los valores separados por coma
Sound_GetMasterVolume(Channel := 0, Type := "Default") {
	for k, v in Sound_GetDevice(Type) {
		hInterface := Sound_GetEndpointVolume(v)
		if (Channel)
			DllCall(NumGet(NumGet(hInterface+0)+13*A_PtrSize), "Ptr", hInterface, "UInt", Channel-1, "Float*", Vol)
		else DllCall(NumGet(NumGet(hInterface+0)+9*A_PtrSize), "Ptr", hInterface, "Float*", Vol)
		OutputVar .= Round(Vol*100, 1) ",", ObjRelease(hInterface)
	} return RTrim(OutputVar, ",")
}

;silenciar/restaurar volumen
;Sintaxis: Sound_SetMasterMute( [0|1], [tipo] )
Sound_SetMasterMute(Mute := true, Type := "Default") {
	for k, v in Sound_GetDevice(Type)
		hInterface := Sound_GetEndpointVolume(v)
		, DllCall(NumGet(NumGet(hInterface+0)+14*A_PtrSize), "Ptr", hInterface, "Int", !!Mute, "Ptr", 0)
		, ObjRelease(hInterface)
}

;obtiene el estado actual del volumen
;Sintaxis: Sound_GetMasterMute( [tipo] )
;Return: devuelve 1 si está silenciado (separados por coma si se encontraron mas dispositivos)
Sound_GetMasterMute(Type := "Default") {
	for k, v in Sound_GetDevice(Type)
		hInterface := Sound_GetEndpointVolume(v)
		, DllCall(NumGet(NumGet(hInterface+0)+15*A_PtrSize), "Ptr", hInterface, "IntP", Mute)
		, ObjRelease(hInterface), OutputVar .= !!Mute ","
	return RTrim(OutputVar, ",")
}

;obtiene el número de canales que tiene el dispositivo de audio espesificado
;Sintaxis: Sound_GetMasterChannelCount( [tipo] )
Sound_GetMasterChannelCount(Type := "Default") {
	for k, v in Sound_GetDevice(Type)
		hInterface := Sound_GetEndpointVolume(v)
		, DllCall(NumGet(NumGet(hInterface+0)+5*A_PtrSize), "Ptr", hInterface, "UIntP", ChannelCount)
		, ObjRelease(hInterface), OutputVar := ChannelCount ","
	return RTrim(OutputVar, ",")
}

;obtener una lista  de todos los dispositivos de audio (HANDLE, NOMBRE, INDEX)
;Sintaxis: Sound_EnumDevices( [tipo], [cantidad (out)] )
;Nota: usar ObjRelease() cuando no ya no se necesite. ver ejemplo.
;Ejemplo:
	;for Index, Device in Sound_EnumDevices(, Count)
	;	MsgBox % "Device HANDLE: " Device[1] "`nDevice Name: " Device[2] "`nDevice Number: " Device[3] "`n---------`n" A_Index " de " Count
	;for Index, Device in Sound_EnumDevices(, Count)
	;	MsgBox % ObjRelease(Device[1])
Sound_EnumDevices(Type := "ALL", ByRef Count := "") {
	static Types := {ALL: 2, Capture: 1, Render: 0, PlayBack: 0}
	if (Types[Type]="") ;si no se espesifico ALL, Capture, Render o PlayBack
		Index := StrSplit(Type, ":", A_Space A_Tab)[2] ;obtiene el indice. Ej: PlayBack:4
		, Type := ((p:=InStr(Type, "PlayBack"))||(r:=InStr(Type, "Render")))?"PlayBack":(c:=InStr(Type, "Capture"))?"Capture":Type
	obj := ComObjCreate("{BCDE0395-E52F-467C-8E3D-C4579291692E}", "{A95664D2-9614-4F35-A746-DE8DB63617E6}")
	, DllCall(NumGet(NumGet(obj+0)+3*A_PtrSize), "Ptr", obj, "Int", Types[Type]=""?2:Types[Type], "UInt", 1, "PtrP", Devices), ObjRelease(obj)
	, DllCall(NumGet(NumGet(Devices+0)+3*A_PtrSize), "Ptr", Devices, "UIntP", Count), List := []
	Loop, %Count% {
		if (Types[Type]="") && !(A_Index=Type) ;index
			continue
		else if (p||r||c) && !(A_Index=Index) ;type:index (p, r o c solo será verdadero si se espesificó Capture, Render o PlayBack y su indice)
			continue ;else => type => ALL, Capture, Render o PlayBack
		if (DllCall(NumGet(NumGet(Devices+0)+4*A_PtrSize), "Ptr", Devices, "UInt", A_Index-1, "PtrP", Device)=0)
			List.Push([Device, Sound_GetDeviceName(Device), A_Index])
	} return List
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PARA USO INTERNO (WIN_V+)
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sound_GetDevice(Type := "Default") {
	if (Type="Default") {
		obj := ComObjCreate("{BCDE0395-E52F-467C-8E3D-C4579291692E}", "{A95664D2-9614-4F35-A746-DE8DB63617E6}")
		, DllCall(NumGet(NumGet(obj+0)+5*A_PtrSize), "Ptr", obj, "WStr", "", "PtrP", hDevice:=0)
		, DllCall(NumGet(NumGet(obj+0)+4*A_PtrSize), "Ptr", obj, "Int", 0, "Int", 0, "PtrP", hDevice)
		return [hDevice], ObjRelease(obj)
	} OutputVar := []
	for k, v in Sound_EnumDevices(Type)
		OutputVar.Push(v[1])
	return OutputVar
}

Sound_GetEndpointVolume(hDevice, Release := true) {
	VarSetCapacity(CLSID, 16, 0)
	, DllCall("Ole32.dll\CLSIDFromString", "WStr", "{5CDF2C82-841E-4546-9722-0CF74078229A}", "Ptr", &CLSID)
	, DllCall(NumGet(NumGet(hDevice+0)+3*A_PtrSize), "Ptr", hDevice, "Ptr", &CLSID, "UInt", 7, "UInt", 0, "PtrP", Interface)
	return Interface, Release := Release?ObjRelease(hDevice):0
}

;obtener nombre del dispositivo
Sound_GetDeviceName(Device) {
	static Name
	if !(VarSetCapacity(Name)) && (VarSetCapacity(Name, 20)) && (VarSetCapacity(Name, 16, 0))
		DllCall("Ole32.dll\CLSIDFromString", "WStr", "{A45C254E-DF1C-4EFD-8020-67D146A850E0}", "Ptr", &Name)
		, NumPut(14, &Name, 16)
	VarSetCapacity(Prop, 16), DllCall(NumGet(NumGet(Device+0)+4*A_PtrSize), "Ptr", Device, "UInt", 0, "PtrP", Store)
	, DllCall(NumGet(NumGet(Store+0)+5*A_PtrSize), "Ptr", Store, "Ptr", &Name, "Ptr", &Prop)
	, ObjRelease(Store), OutputVar := NumGet(prop, 8)
	return StrGet(ptr:=OutputVar, "UTF-16"), DllCall("ole32.dll\CoTaskMemFree", "Ptr", ptr) 
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES (WIN_XP+)
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Silenciar
;Sintáxis: SoundMute( [Opcion] )
;OPCIONES:
	;0 = restaurar | 1 = silenciar | 2 = alternar
	;-1 (defecto) = devuelve 1 si esta silenciado
SoundMute(Mode := -1) {
	if (Mode = -1)
		return SoundGet(, "MUTE")="On"?true:false
	return SoundSet(Mode=2?"+1":Mode,, "MUTE")
}

;obtener volumen 
SoundGet(ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundGet, OutputVar, %ComponentType%, %ControlType%, %DeviceNumber%
	return OutputVar
}

;establecer volumen
SoundSet(Percent, ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundSet, %Percent%, %ComponentType%, %ControlType%, %DeviceNumber%
	return !ErrorLevel
}

;emite un tono desde el altavoz del PC.
;Sintaxis: SoundBeep( [frequencia 37~32767], [duración] )
SoundBeep(Frequency := 523, Duration := 150) {
	return DllCall("Kernel32.dll\Beep", "UInt", Frequency, "UInt", Duration)
}

;reproduce un sonido, video u otro tipo de archivo compatible
;Sintaxis: SoundPlay( [archivo], [¿esperar?] )
SoundPlay(Filename, Wait := false) {
	if (Wait) {
		SoundPlay, %Filename%, 1
		SoundPlay, ________.wav
	} else SoundPlay, %Filename%
	return !ErrorLevel
}













































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SERVICIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;enumerar todos los servicios y obtener información
;Ejemplo:
	;for k, v in ServiceEnum()
	;	MsgBox % "#" k "`nServicio: " v.Name "`nNombre: " v.Caption "`nProcess ID: " v.ProcessId "`nParámetros: " v.PathName
ServiceEnum() {
	List := []
	for Srv in ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_Service")
		Info := {}, Info.AcceptPause := Srv.AcceptPause, Info.AcceptStop := Srv.AcceptStop, Info.Caption := Srv.Caption, Info.CreationClassName := Srv.CreationClassName
		, Info.Description := Srv.Description, Info.DesktopInteract := Srv.DesktopInteract, Info.DisplayName := Srv.DisplayName, Info.SystemName := Srv.SystemName
		, Info.CheckPoint := Srv.CheckPoint, Info.DelayedAutoStart := Srv.DelayedAutoStart, Info.ProcessId := Srv.ProcessId, Info.WaitHint := Srv.WaitHint, Info.TagId := Srv.TagId
		, Info.ErrorControl := Srv.ErrorControl, Info.ExitCode := Srv.ExitCode, Info.InstallDate := Srv.InstallDate, Info.Name := Srv.Name, Info.PathName := Srv.PathName
		, Info.ServiceSpecificExitCode := Srv.ServiceSpecificExitCode, Info.ServiceType := Srv.ServiceType, Info.SystemCreationClassName := Srv.SystemCreationClassName
		, Info.Started := Srv.Started, Info.StartMode := Srv.StartMode, Info.StartName := Srv.StartName, Info.State := Srv.State, Info.Status := Srv.Status, List.Push(Info)
	return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa394073(v=vs.85).aspx

;cambiar modo de inicio del servicio.
;Sintaxis: ServiceSet( [servicio], [boot | system | auto | manual | disabled] )
ServiceSet(IpName, StartMode := "") {
	static StartupModes := {"boot": 0x00000000, "system": 0x00000001, "auto": 0x00000002, "manual": 0x00000003, "disabled": 0x00000004, "disable": 0x00000004}
	hService := ServiceOpen( IpName,, 0x0002 ) ;SERVICE_NO_CHANGE := 0xffffffff | SERVICE_CHANGE_CONFIG := 0x0002
	if StartupModes[StartMode]
		return i := DllCall("Advapi32.dll\ChangeServiceConfigW", "Ptr", hService, "UInt", 0xffffffff, "UInt", StartupModes[StartMode]
		, "UInt", 0xffffffff, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	return 0, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := 1
}

;recupera la informacion del servicio
;Sintaxis: ServiceGetDescription( [servicio], [Fast|Slow] )
ServiceGetDescription(IpName, Mode := "Fast") {
	if (Mode="F"||Mode="Fast") { ;Fast: lee desde el registro (recomendado)
		return RegRead("HKLM\SYSTEM\CurrentControlSet\Services\" IpName, "Description")
	} else if (Mode="S"||Mode="Slow") { ;Slow: abre el servicio para leer la descripcion (mas lento)
		hService := ServiceOpen(IpName,, 0x0001)
		, DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", 0, "UInt", 0, "UIntP", pcbBytesNeeded)
		, cbBufSize := VarSetCapacity(SERVICE_DESCRIPTION, pcbBytesNeeded * 2, 0) / 2
		, i := DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", &SERVICE_DESCRIPTION, "UInt", cbBufSize, "UIntP", 0)
		return StrGet(NumGet(SERVICE_DESCRIPTION, 0, "Ptr"), cbBufSize, "UTF-16")
			, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	} return 0, ErrorLevel := 1
}

;establece la informacion del servicio
;Sintaxis: ServiceSetDescription( [servicio], [descripcion], [Fast|Slow] )
ServiceSetDescription(IpName, Description := "", Mode := "Slow") {
	Description := Trim(StrReplace(Description, A_Tab, A_Space))
	if (Mode="F"||Mode="Fast") { ;Fast: establece desde el registro (puede dar problemas con permisos)
		return RegWrite(, "HKLM\SYSTEM\CurrentControlSet\Services\" IpName, "Description", Description)
	} else if (Mode="S"||Mode="Slow") { ;Slow: abre el servicio para establecer la descripcion (recomendado)
		hService := ServiceOpen(IpName,, 0x0002)
		, VarSetCapacity(SERVICE_DESCRIPTION, StrLen(Description) * 2, 0)
		, NumPut(&Description, SERVICE_DESCRIPTION, 0, "Ptr")
		return i := DllCall("Advapi32.dll\ChangeServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", &SERVICE_DESCRIPTION)
			, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	} return 0, ErrorLevel := 1
}

;pausar
ServicePause(IpName) {
	hService := ServiceOpen( IpName,, 0x0040 )
	, VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000002, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;reanudar servicio
ServiceContinue(IpName) {
	hService := ServiceOpen( IpName,, 0x0040 )
	, VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000003, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;eliminar
ServiceDelete(IpName) {
	hService := ServiceOpen(IpName,, 0x00010000)
	return r := DllCall("Advapi32.dll\DeleteService", "Ptr", hService)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !r
}

;iniciar
ServiceStart(IpName) {
	if (ServiceInfo(IpName).StartMode = "disable")
		ServiceSet( IpName, "manual" )
	hService := ServiceOpen( IpName,, 0x0010 )
	return i := DllCall("Advapi32.dll\StartServiceW", "Ptr", hService, "UInt", 0, "Ptr", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !i
}

;detener
ServiceStop(IpName) {
	hService := ServiceOpen( IpName,, 0x0020 )
	, VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000001, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;obtiene el estado
;Sintaxis: ServiceStatus( [servicio] )
;EJEMPLO: MsgBox % ServiceStatus("spooler").State
ServiceStatus(IpName) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms685996%28v=vs.85%29.aspx
	static s1 := "STOPPED", s2 := "START_PENDING", s3 := "STOP_PENDING", s4 := "RUNNING", s5 := "CONTINUE_PENDING", s6 := "PAUSE_PENDING", s7 := "PAUSED"
	static t1 := "KERNEL_DRIVER", t2 := "FILE_SYSTEM_DRIVER", t16 := "OWN_PROCESS", t32 := "SHARE_PROCESS", t100 := "INTERACTIVE_PROCESS"
	hService := ServiceOpen( IpName,, 0x0004 ), i := {}
	, cbBufSize := VarSetCapacity(SERVICE_STATUS_PROCESS, A_PtrSize=4?36:44, 0), VarSetCapacity(pcbBytesNeeded, 4)
	, r := DllCall("Advapi32.dll\QueryServiceStatusEx", "Ptr", hService, "UInt", 0, "Ptr", &SERVICE_STATUS_PROCESS, "UInt", cbBufSize, "UIntP", &pcbBytesNeeded)
	, i.Type := (x:=NumGet(&SERVICE_STATUS_PROCESS, 0, "UInt"))?t%x%:t%x%
	, i.State := (x:=NumGet(&SERVICE_STATUS_PROCESS, 4, "UInt"))?s%x%:s%x%
	, i.ControlsAccepted := NumGet(&SERVICE_STATUS_PROCESS, 8, "UInt")
	, i.ExitCode := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 12 : 16, "UInt")
	, i.SpecificExitCode := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 16 : 24, "UInt")
	, i.CheckPoint := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 20 : 28, "UInt")
	, i.WaitHint := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 24 : 32, "UInt")
	, i.ProcessId := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 28 : 36, "UInt")
	, i.Flags := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 32 : 40, "UInt") ;1=system process (always be running)
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !r
}

;obtener informacion
;Sintaxis: ServiceInfo( [servicio] )
;EJEMPLO:
	;for k, v in ServiceInfo( "spooler" )
	;	MsgBox % k ": " v
ServiceInfo(IpName) {
	static StartType := {0: "BOOT", 1: "SYSTEM", 2: "AUTO", 3: "MANUAL", 4: "DISABLE"}
	hService := ServiceOpen( IpName,, 0x0001 )
	, DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", 0, "UInt", 0, "UIntP", pcbBytesNeeded)
	, cbBufSize := VarSetCapacity(QUERY_SERVICE_CONFIG, pcbBytesNeeded>0?pcbBytesNeeded:8000, 0) 
	, DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", &QUERY_SERVICE_CONFIG, "UInt", cbBufSize, "UIntP", 0)
	, i := {}, i.Type := NumGet(&QUERY_SERVICE_CONFIG, 0, "UInt") 
		, i.StartType := NumGet(&QUERY_SERVICE_CONFIG, 4, "UInt"), i.StartMode := StartType[i.StartType]
		, i.ErrorControl := NumGet(&QUERY_SERVICE_CONFIG, 8, "UInt")
		, i.PathName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 12 : 16, "UInt") )
		, i.OrderGroup := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 16 : 24, "UInt") ) 
		, i.TagId := NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 20 : 28, "UInt")
		, i.Dependencies := NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 24 : 32, "Ptr")
		, i.StartName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 28 : 36, "UInt") ) 
		, i.DisplayName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 32 : 40, "UInt") ) 
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := i.StartType=""?1:0
}

;comprueba si existe el servicio
;Sintaxis: ServiceExist( [servicio], [Fast|Slow] )
ServiceExist(lpDisplayName, Mode := "Fast") {
	if (Mode="F"||Mode="Fast") ;Fast: comprueba si existe desde el registro. (recomendado)
		return RegExistKey("HKLM\SYSTEM\CurrentControlSet\Services\" lpDisplayName)
	if (Mode="S"||Mode="Slow") ;Slow: abre y cierra el servicio para comprobar si existe. (mas lento)
		return i:=DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", ServiceOpen(lpDisplayName)), ErrorLevel:=!i
	return 0, ErrorLevel := 1
}

;abre un servicio para modificar/leer datos/configuracion
;Sintaxis: ServiceOpen( [servicio], [acceso para SCManager], [acceso para el servicio], [SCManager (salida)] )
ServiceOpen(lpDisplayName, SCManagerAccess := 0xF003F, ServiceAccess := 0xF01FF, ByRef hSCManager := "") {
	hSCManager := DllCall("AdvApi32.dll\OpenSCManagerW", "Ptr", 0, "Ptr", 0, "UInt", SCManagerAccess) 
	, DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Str", lpDisplayName, "Ptr", 0, "UIntP", lpcchBuffer)
	, VarSetCapacity(lpServiceName, lpcchBuffer * 2)
	, lpServiceName := DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Str", lpDisplayName, "Str", lpServiceName, "UIntP", lpcchBuffer) ? lpServiceName : lpDisplayName
	return i := DllCall("Advapi32.dll\OpenServiceW", "Ptr", hSCManager, "Str", lpServiceName, "UInt", ServiceAccess)
		, x:=IsByRef(hSCManager)?"":DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hSCManager)
		, ErrorLevel := !i
}

























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: UNIDADES ::::::::::::::::::::::::::::::::::
;Parámetros:
	;unidad = ruta o letra de la unidad. solo se toma en cuenta el primer carácter, no espacios.
;#############################################################################################################################################
;dar formato a una unidad
;Sintaxis: DriveFormat( [unidad], [FileSystem], [QuickFormat 0|1], [ClusterSize], [Label] )
;FileSystem: formato del sistema de archivos.
	;NTFS (defecto)
	;FAT32
	;FAT
;QuickFormat: formato rápido mediante la eliminación de archivos desde el disco sin escanear el disco en busca de sectores defectuosos
;ClusterSize: tamaño del clúster
;Label: etiqueta. 11 carácteres max para FAT y FAT32. 32 carácteres max para NTFS.
DriveFormat(Drive, FileSystem := "NTFS", QuickFormat := true, ClusterSize := 4096, Label := "") { ;WIN_V+
	Drive := SubStr(Trim(Drive), 1, 1) ":", Label := Trim(StrReplace(StrReplace(StrReplace(Label, A_Tab, A_Space), "`r"), "`n"))
	if (FileSystem="FAT") || (FileSystem="FAT32")
		Label := SubStr(Label, 1, 11) ;FAT/32 11max
	else if !(FileSystem="NTFS")
		return false, ErrorLevel := true
	else Label := SubStr(Label, 1, 32) ;NTFS 32max
	for this in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Volume Where DriveLetter = '" Drive "'")
		return !(Error:=this.Format(FileSystem, !!QuickFormat, ClusterSize, Label, !!EnableCompression)), ErrorLevel := Error
	return false, ErrorLevel := -1
} ;https://msdn.microsoft.com/en-us/library/aa390432(v=vs.85).aspx

;cambiar nombre de la unidad
;Sintaxis: DriveSetLabel( [unidad], [nombre] )
DriveSetLabel(Drive, VolumeLabel := "") {
	return r:=DllCall("Kernel32.dll\SetVolumeLabelW", "Str", SubStr(Trim(Drive), 1, 1) ":", "Str", VolumeLabel), ErrorLevel := !r
}

 ;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 ;obtener tipo de unidad: Unknown, Removable, Fixed, Network, CDROM, RAMDisk
;Sintaxis: DriveGetType( [Unidad] )
;Tipos: Unknown | Removable | Fixed | Network | CDROM | RAMDisk
;Ejemplo: MsgBox % DriveGetType(A_WinDir)
DriveGetType(Drive) {
	static Types := {0: "Unknown", 1: "", 2: "Removable", 3: "Fixed", 4: "Network", 5: "CDROM", 6: "RAMDisk"}
	Type := DllCall("Kernel32.dll\GetDriveTypeW", "Str", SubStr(Trim(Drive), 1, 1) ":")
	return Types[Type], ErrorLevel := (Types[Type]="Unknown"||!Types[Type])
}

;obtener informacion de la unidad
;Sintaxis: DriveGetInfo( [unidad], [nombre], [sistema de archivos], [serial], [MaximumComponentLength], [FileSystemFlags] )
;Ejemplo:
	;DriveGetInfo(A_WinDir, VolumeName, FileSystem, SerialNumber, MCLength, FileSystemFlags)
	;MsgBox % "VolumeName: " VolumeName "`nFileSystem: " FileSystem "`nSerialNumber: " SerialNumber "`nMCLength: " MCLength "`nFileSystemFlags: " FileSystemFlags
DriveGetInfo(Drive, ByRef VolumeName := "", ByRef FileSystem := "", ByRef SerialNumber := "", ByRef MCLength := "", ByRef FileSystemFlags := "") {
	VarSetCapacity(VolumeName, (260 + 1) * 2), VarSetCapacity(FileSystem, (260 + 1) * 2), Drive := SubStr(Drive, 1, 1)
	r := DllCall("Kernel32.dll\GetVolumeInformationW", "Str", Drive ":", "Str", VolumeName, "UInt", 261, "UIntP"
	, SerialNumber, "UIntP", MCLength, "UIntP", FileSystemFlags, "Str", FileSystem, "UInt", 261)
	if (r) && (VolumeName="")
		RegRead, VolumeName, % "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" Drive "\DefaultLabel"
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364993%28v=vs.85%29.aspx

;obtener informacion de la unidad
;Sintaxis: DriveGetInfoEx( [unidad], [nombre], [sistema de archivos], [tipo], [serial], [espacio], [nombre compartido en red] )
;Sistema de archivos: FAT | FAT32 | NTFS | CDFS.
;Tipos: Unknown | Removable | Fixed | Network | CDROM | RAMDisk.
;Espacio (array): [total, disponible, en uso]. en bytes.
;Ejemplo:
	;DriveGetInfoEx(A_WinDir, VolumeName, FileSystem, Type, SerialNumber, Size, ShareName)
	;MsgBox % "VolumeName: " VolumeName "`nFileSystem: " FileSystem "`nType: " Type "`nSerialNumber: " SerialNumber
	;	. "`nTotal: " Round(Size[1]/(1024**3), 2) " GB | Disponible: " Round(Size[2]/(1024**3), 2) " GB | En Uso: " Round(Size[3]/(1024**3), 2) " GB`nShareName: " ShareName
DriveGetInfoEx(Drive, ByRef VolumeName := "", ByRef FileSystem := "", ByRef Type := "", ByRef SerialNumber := "", ByRef Size := "", ByRef ShareName := "") {
	static Types := {0: "Unknown", 1: "Removable", 2: "Fixed", 3: "Network", 4: "CDROM", 5: "RAMDisk"}
	try fso := ComObjCreate("Scripting.FileSystemObject"), d := fso.GetDrive(fso.GetDriveName(Drive))
	catch
		return false, ErrorLevel := true
	if (IsByRef(VolumeName))
		VolumeName := d.VolumeName
	if (IsByRef(FileSystem))
		FileSystem := d.FileSystem
	if (IsByRef(Type))
		Type := Types[d.DriveType]
	if (IsByRef(SerialNumber))
		SerialNumber := d.SerialNumber
	if (IsByRef(Size))
		Size := [t:=d.TotalSize, f:=(d.FreeSpace?d.FreeSpace:d.AvailableSpace), t-f]
	if (IsByRef(ShareName))
		ShareName := d.ShareName
	return true, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/ts2t8ybh(v=vs.84).aspx

 ;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

;recupera la cantidad de espacio libre en Bytes
;Sintaxis: DriveSpaceFree( [unidad], [KB|MB|GB] )
DriveSpaceFree(Drive, Units := 0) {
	static Size := {KB: 1024, MB: 1024**2, GB: 1024**3}
	VarSetCapacity(FreeSpace, 8, 0), Drive := SubStr(Trim(Drive), 1, 1) ":"
	, Ok := DllCall("Kernel32.dll\GetDiskFreeSpaceExW", "Str", Drive, "UInt64", &FreeSpace, "Ptr", 0, "Ptr", 0, "UInt")
	return Size[Units]?NumGet(FreeSpace, 0, "UInt64")/Size[Units]:NumGet(FreeSpace, 0, "UInt64"), ErrorLevel := !Ok
}

;listar unidades
;Sintaxis: DriveEnum( [CDROM|REMOVABLE|FIXED|NETWORK|RAMDISK|UNKNOWN separados por coma] )
DriveEnum(Type := "") {
	DriveGet, OutputVar, List
	if (Type)
		Loop, Parse, % OutputVar
			if (InVar(DriveGetType(A_LoopField), Type))
				List .= A_LoopField
	return Type?List:OutputVar
}

;expulsar/retraer unidad de CD/DVD. expulsar USB.
;Sintaxis: DriveEject( [unidad], [0|1] )
;NOTA: el script no avanza hasta que la unidad se cierre/expulse.
DriveEject(Drive, Close := false) {
	Drive := SubStr(Drive, 1, 1)
	if ((IpType:=DriveGetType(Drive))="CDROM") || !(IpType) {
		if !(IpType)
			return false, ErrorLevel := true
		Drive, Eject, %Drive%:, % !!Close
		return !ErrorLevel
	} hDrive := DllCall("Kernel32.dll\CreateFileW", "Str", "\\.\" Drive ":", "UInt", 0, "UInt", 0, "UInt", 0, "UInt", 3, "UInt", 0, "Ptr", 0)
	, Size := VarSetcapacity(STORAGE_DEVICE_NUMBER, 8 + A_PtrSize, 0), nVT := true
	, IpR := DllCall("Kernel32.dll\DeviceIoControl", "Ptr", hDrive, "UInt", 0x2D1080, "Ptr", 0, "UInt", 0, "Ptr", &STORAGE_DEVICE_NUMBER, "UInt", Size, "UIntP", 0, "Ptr", 0)
	, CloseHandle(hDrive), IpType := NumGet(STORAGE_DEVICE_NUMBER, "UInt")
	, sPHDRV := (IpType=0x00000007)?"\\\\.\\PHYSICALDRIVE" NumGet(STORAGE_DEVICE_NUMBER, 4, "UInt"):""
	, queryEnum := ComObjGet("winmgmts:").ExecQuery("Select * from Win32_DiskDrive WHERE DeviceID='" sPHDRV "' AND InterfaceType='USB'")._NewEnum()
	If !(queryEnum[Drive])
		return false, ErrorLevel := true
	if !(GetModuleHandle("SetupAPI.dll"))
		hModule := LoadLibrary("SetupAPI.dll")
	DllCall("SetupAPI.dll\CM_Locate_DevNode", "PtrP", nDID, "Str", Drive.PNPDeviceID, "UInt", 0), DllCall("SetupAPI.dll\CM_Get_Parent", "PtrP", nDID, "UInt", nDID, "UInt", 0)
	while % (nDID && nVT && (A_Index<4)) 
		DllCall("SetupAPI.dll\CM_Request_Device_Eject", "UInt", nDID, "PtrP", nVT,  "Ptr", 0, "UInt", 0, "UInt", 0)
	if (hModule)
		FreeLibrary(hModule) 
	return !nVT, ErrorLevel := nVT
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=4491























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: MONITOR ::::::::::::::::::::::::::::::::::
;Parámetros:
	;hWnd: hWnd a una ventana existente. -1 para la ventana activa (defecto).
	;hMonitor: identificador del monitor, 0 para el monitor primario
	;Monitor_Name: nombreN del monitor o 0 para el monitor primario (defecto). se puede obtener con GetMonitorInfo(hMonitor).Name
	;Monitor: espesificar hMonitor, Monitor_Name o 0 para usar el monitor primario (defecto)
;Link: https://msdn.microsoft.com/en-us/library/dd145072(v=vs.85).aspx
;Constantes: https://www.omniref.com/ruby/gems/win-user32-ruby/0.1.1/symbols/WinAPISys::MONITOR_DEFAULTTOPRIMARY
;Class Monitor: https://autohotkey.com/boards/viewtopic.php?t=7854
;#############################################################################################################################################
;obtener información de un monitor
;Sintaxis: GetMonitorInfo( [hMonitor] )
;Return: 
	;0 = ERROR
	;{Name, Primary?, Left, Top, Right, Bottom, wLeft, wTop, wRight, wBottom} = OK
;ErrorLevel: 0|1
;Notas:
	;el ancho es: Right-Left
	;el alto es: Bottom-Top
GetMonitorInfo(hMonitor) {
	Size := VarSetCapacity(MONITORINFOEX, (4+16+16+4 +12) * 2, 0)
	, NumPut(Size, MONITORINFOEX, 0, "UInt")
	, Ok := DllCall("User32.dll\GetMonitorInfoW", "Ptr", hMonitor, "Ptr", &MONITORINFOEX, "UInt")
	, Info := {}, Info.Name := StrGet(&MONITORINFOEX+40) ;Sintaxis: \\.\[nombre][número]
	, Info.Primary := NumGet(MONITORINFOEX, 36, "UInt") ;primario?
	Loop, Parse, % "Left,Top,Right,Bottom,wLeft,wTop,wRight,wBottom", `, ;pos
		Info[A_LoopField] := NumGet(MONITORINFOEX, 4 * A_Index, "Int")
	return Ok?Info:false, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/dd144901(v=vs.85).aspx

;obtener resolucion  y frecuencia
;Sintaxis: GetMonitorSettings( [monitor], [ancho (out)], [alto (out)], [frecuencia (out)] )
;Parámetros:
	;Ancho / Alto: resolución
	;Frecuencia: frecuencia, en hercios (ciclos por segundo), del dispositivo.
;Return: 0|1
;ErrorLevel: 0|1
;Nota: si solo necesita la resolucion, usar GetMonitorResolution() o GetMonitorInfo()
GetMonitorSettings(hMonitor := 0, ByRef Width := "", ByRef Height := "", ByRef Freqency := "", ByRef DEV_MODE := "") {
	Monitor_Name := GetMonitorName(hMonitor)
	, Ok := EnumDisplaySettings(Monitor_Name,, DEV_MODE)
	, Width := NumGet(DEV_MODE, 108 + 64, "UInt")
	, Height := NumGet(DEV_MODE, 112 + 64, "UInt")
	, Freqency := NumGet(DEV_MODE, 120 + 64, "UInt")
	return !!Ok, ErrorLevel := !Ok
}

;establecer resolución y frecuencia
;Sintaxis: SetMonitorSettings( [monitor], [ancho], [alto], [frecuencia, en hercios] )
;Nota: dejar los parámetros vacíos para no modificar
;Return: 0|1
SetMonitorSettings(hMonitor := 0, Width := "", Height := "", Freqency := "") {
	Monitor_Name := GetMonitorName(hMonitor)
	, GetMonitorSettings(Monitor_Name, w, h, f, DEV_MODE)
	, NumPut(0x5c0000, DEV_MODE, 6 + 32, "UInt")
	, NumPut(Width=""?w:Width, DEV_MODE, 108 + 64, "UInt")
	, NumPut(Height=""?h:Height, DEV_MODE, 112 + 64, "UInt")
	, NumPut(Freqency=""?(f?f:0):Freqency, DEV_MODE, 120 + 64, "UInt")
	return DllCall("User32.dll\ChangeDisplaySettingsEx", "Ptr", &Monitor_Name, "Ptr", &DEV_MODE, "Ptr", 0, "UInt", 0x00000001, "Ptr", 0, "Int")=0
}

;obtener ancho y alto actual (resolución) del monitor
;Sintaxis: GetMonitorResolution( [hMonitor], [ancho (out)], [alto (out)], [anchoW (out)], [altoW (out)] )
;Parámetros:
	;Alto: alto total del la pantalla
	;Ancho: ancho total del la pantalla
	;AnchoW: el área se reduce a excluir a la zona ocupada por la barra de tareas y otras barras de herramientas de escritorio registrados
	;AltoW: el área se reduce a excluir a la zona ocupada por la barra de tareas y otras barras de herramientas de escritorio registrados
;Return: [ancho, alto, anchoW, altoW]
;Ejemplo:
	;hMonitor := GetPrimaryDisplayMonitor()
	;MsgBox % GetMonitorResolution(hMonitor,, h, w2, h2)[1] "x" h "`n" w2 "x" h2
GetMonitorResolution(hMonitor, ByRef Width := "", ByRef Height := "", ByRef wWidth := "", ByRef wHeight := "") {
	Info := GetMonitorInfo(hMonitor)
	return [Width:=Info.Right-Info.Left, Height:=Info.Bottom-Info.Top, wWidth:=Info.wRight-Info.wLeft, wHeight:=Info.wBottom-Info.wTop]
}

;recupera un identificador para el monitor de visualización que tiene la mayor superficie de intersección con el rectángulo de delimitación de una ventana especificada
;Sintaxis: MonitorFromWindow( [hWnd] )
;Return: hMonitor
MonitorFromWindow(hWnd := -1) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\MonitorFromWindow", "Ptr", hWnd, "UInt", 0x00000002, "Ptr")
}

;recupera un identificador para el monitor de visualización que tiene la mayor superficie de intersección con un rectángulo especificado
;Sintaxis: MonitorFromRect( [&RECT] )
;Sintaxis 2: MonitorFromPoint [&POINT] )
;Parámetros:
	;RECT: espesificar una estructura rect.
	;POINT: espesificar una estructura point.
;Return: hMonitor
MonitorFromRect(RECT) {
	return DllCall("User32.dll\MonitorFromRect", "Ptr", RECT, "UInt", 0x00000002, "Ptr")
} MonitorFromPoint(POINT) {
	return DllCall("User32.dll\MonitorFromPoint", "Ptr", POINT, "UInt", 0x00000002, "Ptr")
}

;obtener el monitor primario
;Ejemplo: MsgBox % GetMonitorInfo(GetPrimaryDisplayMonitor()).Name ;obtener nombreN del monitor principal
GetPrimaryDisplayMonitor() {
	return DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", 0x00000001, "Ptr")
}

;enumera monitores de visualización (incluyendo pseudo-monitores invisibles asociados con los controladores de mirroring)
;que intersecan una región formada por la intersección de un área de recorte especificada y la región visible de un contexto de dispositivo.
;Sintaxis: EnumDisplayMonitors( [hDC, RECT] )
;Return: 
	;0 = ERROR
	;[] = OK
;ErrorLevel: 0|1
;Ejemplo:
	;for k, v in EnumDisplayMonitors()
	;	MsgBox % "#" k "`n`nhMonitor: " v.hMonitor "`nNombre: " GetMonitorInfo(v.hMonitor).Name
EnumDisplayMonitors(hDC := 0, RECT := 0) {
	Address := RegisterCallback("MonitorEnumProc", "Fast", 4), Data := {List: []}
	, Ok := DllCall("User32.dll\EnumDisplayMonitors", "Ptr", hDC, "Ptr", RECT, "Ptr", Address, "Ptr", &Data)
	return Ok?Data.List:false, ErrorLevel := !Ok, GlobalFree(Address)
} MonitorEnumProc(hMonitor, hDC, RECT, Data) {
	Data := Object(Data), Data.List.Push({hMonitor: hMonitor, hDC: hDC, RECT: RECT})
	return true
}

;cuenta sólo los monitores de visualización
;Return: int
GetDisplayMonitors() {
	return GetSystemMetrics(80)
}

;obtener DPI del monitor
;Sintaxis: GetMonitorDPI( [monitor] )
;Return: 0 = ERROR
GetMonitorDPI(hMonitor := 0) {
	hDC := GetMonitorDC(hMonitor)
	return GetDeviceCaps(hDC, 88), DeleteDC(hDC) ;LOGPIXELSX=88 | LOGPIXELSY=90
}

;establecer gama
;Sintaxis: SetDeviceGammaRamp( [monitor], [gama] )
;Parámetros:
	;Gama: un valor entre 1 y 255 inclusive. 125 es el predeterminado
;Return: 0|1
SetDeviceGammaRamp(hMonitor := 0, Gamma := 125) { ;WIN_V+
	Gamma := (Gamma > 255) ? 255 : (Gamma < 0) ? 0 : Gamma
	, hDC := GetMonitorDC(hMonitor), Size := VarSetCapacity(Ramp, 1536, 0)
	Loop, % Size / 6
            NumPut((N := (Gamma + 128) * (A_Index - 1)) > 65535 ? 65535 : N, Ramp, 2 * (A_Index - 1), "UShort")
        MoveMemory(&Ramp + 512, &Ramp, 512), MoveMemory(&Ramp + 1024, &Ramp, 512)
	return DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC, "Ptr", &Ramp, "Int"), DeleteDC(hDC)
}

;obtener gama
;Sintaxis: GetDeviceGammaRamp( [monitor] )
;Return: Int
;ErrorLevel: 0|1
GetDeviceGammaRamp(hMonitor := 0) { ;WIN_V+
	hDC := GetMonitorDC(hMonitor), VarSetCapacity(Ramp, 1536, 0)
	, Ok := DllCall("Gdi32.dll\GetDeviceGammaRamp", "Ptr", hDC, "Ptr", &Ramp, "Int")
	return NumGet(Ramp, 2, "UShort") - 128, ErrorLevel := !Ok, DeleteDC(hDC)
}

;obtener hPhysicalMonitor desde hMonitor
GetPhysicalMonitorsFromHMONITOR(hMonitor, ByRef PHYSICAL_MONITOR := "") {
	if !DllCall("Dxva2.dll\GetNumberOfPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UIntP", NumberOfPhysicalMonitors, "Int")
		return false
	VarSetCapacity(PHYSICAL_MONITOR, (A_PtrSize + 256) * NumberOfPhysicalMonitors, 0)
	if !DllCall("Dxva2.dll\GetPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UInt", NumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR, "Int")
		return false
	return NumGet(PHYSICAL_MONITOR) ;0?
}

/* COMENTADO DEBIDO A QUE GetPhysicalMonitorsFromHMONITOR() NO DEVUELVE hPhysicalMonitor CORRECTAMENTE EN CIERTOS MONITORES
	,LINK REFERENCIA: http://stackoverflow.com/questions/846518/getphysicalmonitorsfromhmonitor-returned-handle-is-always-null
;recupera las capacidades de configuración de un monitor. Llame a esta función para saber qué funciones de configuración del monitor de alto nivel son compatibles con el monitor.
;Sintaxis: GetMonitorCapabilities( [hMonitor], [MonitorCapabilities (out)], [SupportedColorTemperatures (out)] )
;Parámetros:
	;MonitorCapabilities: para comprobar si soporta una capacidad use (MonitorCapabilities & N), donde N es uno de los siguientes valores.+
		;MC_CAPS_NONE = 0x00000000,
		;MC_CAPS_MONITOR_TECHNOLOGY_TYPE = 0x00000001
		;MC_CAPS_BRIGHTNESS = 0x00000002
		;MC_CAPS_CONTRAST = 0x00000004
		;MC_CAPS_COLOR_TEMPERATURE = 0x00000008
		;MC_CAPS_RED_GREEN_BLUE_GAIN = 0x00000010
		;MC_CAPS_RED_GREEN_BLUE_DRIVE = 0x00000020
		;MC_CAPS_DEGAUSS = 0x00000040
		;MC_CAPS_DISPLAY_AREA_POSITION = 0x00000080
		;MC_CAPS_DISPLAY_AREA_SIZE = 0x00000100
		;MC_CAPS_RESTORE_FACTORY_DEFAULTS = 0x00000400
		;MC_CAPS_RESTORE_FACTORY_COLOR_DEFAULTS = 0x00000800
		;MC_RESTORE_FACTORY_DEFAULTS_ENABLES_MONITOR_SETTINGS = 0x00001000
	;SupportedColorTemperatures: para comprobar si soporta una temperatura de color use (SupportedColorTemperatures & N), donde N es uno de los siguientes valores.
		;MC_SUPPORTED_COLOR_TEMPERATURE_NONE = 0x00000000
		;MC_SUPPORTED_COLOR_TEMPERATURE_4000K = 0x00000001
		;MC_SUPPORTED_COLOR_TEMPERATURE_5000K = 0x00000002
		;MC_SUPPORTED_COLOR_TEMPERATURE_6500K = 0x00000004
		;MC_SUPPORTED_COLOR_TEMPERATURE_7500K = 0x00000008
		;MC_SUPPORTED_COLOR_TEMPERATURE_8200K = 0x00000010
		;MC_SUPPORTED_COLOR_TEMPERATURE_9300K = 0x00000020
		;MC_SUPPORTED_COLOR_TEMPERATURE_10000K = 0x00000040
		;MC_SUPPORTED_COLOR_TEMPERATURE_11500K = 0x00000080
;Return: 0|1
GetMonitorCapabilities(hMonitor, ByRef MonitorCapabilities := "", ByRef SupportedColorTemperatures := "") { ;WIN_V+
	hPhysicalMonitor := GetPhysicalMonitorsFromHMONITOR(hMonitor)
	if !DllCall("Dxva2.dll\GetMonitorCapabilities", "Ptr", hPhysicalMonitor, "UIntP", MonitorCapabilities, "UIntP", SupportedColorTemperatures, "Int")
		return false
	return true
} ;https://msdn.microsoft.com/en-us/library/dd692940(v=vs.85).aspx
*/

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PARA USO INTERNO
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener hDC desde hMonitor, Monitor_Name o 0=MONITOR PRIMARIO
GetMonitorDC(hMonitor := 0) {
	Monitor_Name := (hMonitor+0)=""?hMonitor:(hMonitor?GetMonitorInfo(hMonitor).Name:"DISPLAY")
	return CreateDC(Monitor_Name)
}

;obtener nombre desde hMonitor, Monitor_Name, 0=MONITOR PRIMARIO
GetMonitorName(hMonitor) {
	Monitor_Name := (hMonitor+0)=""?hMonitor:GetMonitorInfo(hMonitor?hMonitor:GetPrimaryDisplayMonitor()).Name
	return Monitor_Name
}

;obtiene la estructura DEV_MODE con información de un monitor 
;https://autohotkey.com/board/topic/85382-change-screen-resolution-using-unicode-and-ansi-version/
;https://autohotkey.com/board/topic/96293-changing-multiple-monitor-display-resolutions/
EnumDisplaySettings(Monitor_Name := 0, ModeNum := -1, ByRef DEV_MODE := "") {
	Size := VarSetCapacity(DEV_MODE, 220, 0)
	, NumPut(Size, DEV_MODE, 4 + 32, "UInt")
	return DllCall("User32.dll\EnumDisplaySettingsW", "Ptr", &Monitor_Name, "UInt", ModeNum, "Ptr", &DEV_MODE, "Int") 
} ;https://msdn.microsoft.com/en-us/library/dd162611(v=vs.85).aspx









































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CLASES (para uso interno de otras funciones) ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;IVirtualDesktopManager interface
;Exposes methods that enable an application to interact with groups of windows that form virtual workspaces.
;https://msdn.microsoft.com/en-us/library/windows/desktop/mt186440(v=vs.85).aspx
class IVirtualDesktopManager {
	static obj ;IVirtualDesktopManager Object
	
	;create IVirtualDesktopManager Object
	ComObjCreate() {
		if !(this.obj)
			CLSID := "{aa509086-5ca9-4c25-8f95-589d3c07b48a}" ;VirtualDesktopManager clsid
			, IID := "{a5cd92ff-29be-454c-8d04-d82879fb3f1b}" ;IID_IVirtualDesktopManager
			, this.obj := ComObjCreate(CLSID, IID)
	}
	
	;free IVirtualDesktopManager
	ObjRelease() {
		ObjRelease(this.obj), this.obj := ""
	}

	;IVirtualDesktopManager::IsWindowOnCurrentVirtualDesktop method
	;Indicates whether the provided window is on the currently active virtual desktop.
	;https://msdn.microsoft.com/en-us/library/windows/desktop/mt186442(v=vs.85).aspx
	IsWindowOnCurrentVirtualDesktop(hWnd) {
		this.ComObjCreate()
		Error := DllCall(NumGet(NumGet(this.obj+0), 3*A_PtrSize), "Ptr", this.obj, "Ptr", hWnd, "IntP", onCurrentDesktop, "UInt")
		return Error=0?onCurrentDesktop:false, ErrorLevel := Error
	}
}

;recordar valores espesificados en las funciones
class __gsvalue {
	static LastWindowId ;ultimo ID espesificado para una ventana
	static LastControlId ;ultimo ID espesificado para un control
	static LastProcessId ;ultimo ID espesificado para un proceso
}

;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: INCLUDE :::::::::::::::::::::::::::::::::: *i
;Notas:
	;• poner las clases y funciones en la carpeta Lib.
		;--> %A_MyDocuments%\AutoHotkey\Lib
		;--> %A_ScriptDir%\Lib
		;--> %AHK_INSTALL_PATH%\Lib
	;• las funciones y clases con *i son opcionales (omite si no existe).
return
;#############################################################################################################################################
;--------------------------------------
;CLASES
;--------------------------------------
;estilo para los botones (redondeado, color de fondo/texto/borde ...)
#Include <Class_ImageButton> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=1103
;color para los controles
#Include <Class_CtlColors> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=4026
;color para ListView controles
#Include *i <Class_LV_Colors> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=1081
;otra opcion para las funciones con archivos INI
#Include *i <Class_INIFile> ;https://github.com/flipeador/AutoHotKey/blob/master/Class_INIFile
;clase para archivos
#Include *i <Class_OpenFile> ;https://github.com/flipeador/AutoHotKey/blob/master/Class_OpenFile
;editar filas individuales en ListView
#Include *i <Class_LV_InCellEdit> ;http://ahkscript.org/boards/viewtopic.php?p=15056#p15056

;--------------------------------------
;FUNCIONES
;--------------------------------------
;otra opcion al InputBox
#Include *i <InputBoxEx> ;http://ahkscript.org/boards/viewtopic.php?f=42&t=5827
;otra opcion al TrayTip
#Include *i <TrayTipEx> ;http://ahkscript.org/boards/viewtopic.php?f=42&t=5827
;otra opcion al ToolTip
#Include *i <ToolTipEx> ;https://github.com/flipeador/AutoHotKey/blob/master/ToolTipEx
;color de fondo para Picture controles
#Include *i <LinearGradient> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3593
;dialogo para seleccionar un icono
#Include *i <ChooseIcon> ;https://autohotkey.com/boards/viewtopic.php?f=42&t=10802

;--------------------------------------
;CONSTANTES
;--------------------------------------
;Link: http://ahkscript.org/boards/viewtopic.php?f=6&t=4557

;--------------------------------------
;OTROS
;--------------------------------------
#NoEnv ;evita comprobar las variables vacías para ver si son variables de entorno (recomendado para todos los nuevos scripts).
#MaxMem 4095 ;establece la capacidad máxima de cada variable, en megabytes.
