/*
FUNCIONES  AUTOHOTKEY UNICODE 32 & 64 BITS.
-------------------------------------------------------------------------
SO: WXP, WV, W7 & W8 ~ 32 & 64 Bits.
Funciones: archivos, carpetas, cadena, criptografía, procesos, internet,
					gui & dialogos, registro, control, mouse & teclado, sistema,
					ventanas, servicios, unidades, sonido, monitor, números &
					operaciones matemáticas, Menús, otros.
Link: http://ahkscript.org/boards/viewtopic.php?f=42&t=5535
AutoHotKey: 1.1.21.01+
Actualizado: AHK-U1.1.22.02 || Viernes, 26 de junio de 2015
*/ ;flipeador@gmail.com

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: ARCHIVOS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;eliminar archivo(s)
;devuelve el número de archivos eliminados
;Sintaxis: FileDelete( [archivo], [¿operar en subcarpetas?] )
FileDelete(FilePattern, Recurse := 0) {
	if !InStr(FilePattern, "*") AND !InStr(FilePattern, "?") AND !Recurse {
		FilePattern := GetFullPathName( FilePattern )
		if !(i := DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" FilePattern))
			FileSetAttrib( "-R", A_LoopFileLongPath, 0 )
			, i := DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" FilePattern)
		return i, ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileDelete( A_LoopFileLongPath ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}

;eliminar archivo(s) al reiniciar
FileRDelete(FilePattern, Recurse := 0) {
	if !InStr(FilePattern, "*") AND !InStr(FilePattern, "?") AND !Recurse {
		FilePattern := GetFullPathName( FilePattern )
		return i := DllCall("Kernel32.dll\MoveFileExW", "Str", "\\?\" FilePattern, "Ptr", 0, "UInt", 0x4)
			, ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileRDelete( A_LoopFileLongPath ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}
	
;eliminar archivo(s) de forma segura
;Sintáxis: FileSDelete( [archivo], [pasadas], [¿incluir subcarpetas?] )
FileSDelete(FilePattern, Pases := 1, Recurse := 0) {
	if !InStr(FilePattern, "*") AND !InStr(FilePattern, "?") AND !Recurse {
		FilePattern := GetFullPathName( FilePattern )
		if !IsFile( FilePattern )
			return 0, ErrorLevel := 1
		i := FileOpen2( FilePattern )
		Loop, %Pases% {
			nSize := i.Length < (10 ** 8) ? i.Length : (10 ** 8)
			VarSetCapacity(IpBuffer, nSize, A_Index)
			Loop, % Floor(i.Length / (10 ** 8))
				i.RawWrite(IpBuffer, nSize)
			nSize := Mod(i.Length, (10 ** 8))
			VarSetCapacity(IpBuffer, nSize, A_index)
			i.RawWrite(IpBuffer, nSize)
		}
		i.Close()
		FileSetTime( 2000, FilePattern, "MCA" )
		return i := FileDelete( FilePattern ), ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileSDelete( A_LoopFileLongPath, Pases ), i++
	return ok, ErrorLevel := ok = i ? 0 : 1
}

;renombrar archivo(s)
;Sintaxis: Rename( [Archivo], [Nuevo Nombre] )
;devuelve la cantidad de archivos renombrados
FileRename(FilePattern, NewName, Recurse := 0) {
	ValidateName( NewName )
	if (NewName = "")
		return 0
	if !InStr(FilePattern, "*") AND !InStr(FilePattern, "?") AND !Recurse {
		FilePattern := GetFullPathName( FilePattern )
		SplitPath( FilePattern,, Directory )
		return i := FileMove( FilePattern, Directory "\" NewName ), ErrorLevel := !i
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileRename( A_LoopFileLongPath, NewName ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}

FileGetVersion( Filename ) {
	FileGetVersion, IpVersion, %Filename%
	return IpVersion
}

;comparar 2 versiones (By. boiler; modificado): http://ahkscript.org/boards/viewtopic.php?f=6&t=5959
;RESULTADO:
	;0: Ver1 = Ver2
	;1: Ver1 > Ver2
	;2: Ver1 < Ver2
FileVersionCompare(version1, version2) {
	version1 := RegExReplace(version1, "[^0-9.]"), version2 := RegExReplace(version2, "[^0-9.]")
	version1 := Trim( version1, "." ), version2 := Trim( version2, "." )
	verA := StrSplit( version1, "." ), verB := StrSplit( version2, "." )
	Count := verA[0] > verB[0] ? verA[0] : verB[0]
	Loop, %Count% {
		if (verA[0] < A_Index)
			verA[A_Index] := 0
		if (verB[0] < A_Index)
			verB[A_Index] := 0
		if (verA[A_Index] > verB[A_Index])
			return 1
		if (verB[A_Index] > verA[A_Index])
			return 2
	}
	return 0
}

;obtener tamaño del archivo
;Sintáxis: FileGetSize( [archivo], [KB|MB|GB] )
FileGetSize(lpFileName, Units := 0) {
	lpFileName := GetFullPathName( lpFileName )
	sKB := 1024, sMB := 1024 ** 2, sGB := 1024 ** 3, s0 := 0
	hFile := DllCall("Kernel32.dll\CreateFileW", "Str", "\\?\" lpFileName, "UInt", 128, "UInt", 1, "UInt", 0, "UInt", 3, "UInt", 0, "Ptr", 0)
	VarSetCapacity(lpFileSize, 1048576, 0)
	DllCall("Kernel32.dll\GetFileSizeEx", "UInt", hFile, "UInt", &lpFileSize)
	fs := NumGet(lpFileSize, 0, "Int64*")
	return s%Units% ? fs / s%Units% : fs
		, DllCall("Kernel32.dll\CloseHandle", "UInt", hFile)
}

;Sintaxis: FileCreate( [archivo], [Acceso deseado], [0|1(R)|2(W)|4(D)] )
FileCreate(lpFileName, dwDesiredAccess := 28, dwShareMode := 7, lpSecurityAttributes := 0, dwCreationDisposition := 3, dwFlagsAndAttributes := 0, hTemplateFile := 0) {
	if (dwDesiredAccess = "r")
		dwDesiredAccess := 0x80000000
	else	if (dwDesiredAccess = "w")
		dwDesiredAccess := 0x40000000
	else	if (dwDesiredAccess = "rw")
		dwDesiredAccess := 0x80000000|0x40000000
	return DllCall("Kernel32.dll\CreateFileW", "Str", "\\?\" lpFileName, "UInt", dwDesiredAccess, "UInt", dwShareMode
		, "UInt", lpSecurityAttributes, "UInt", dwCreationDisposition, "UInt", dwFlagsAndAttributes, "Ptr", hTemplateFile)
}

;mover archivo
;Sintaxis: FileMove( [archivo], [archivo destino], [sobreescribir] )
FileMove(Source, Dest, Flag := 0) {
	if !IsFile( Source )
		return 0, ErrorLevel := 2
	FileMove, %Source%, %Dest%, %Flag%
	return !ErrorLevel
}

;Sintaxis: FileSetTime( [fecha], [archivo], [M|C|A], [0(F)|1(FD)|2(D)], [0|1(R)] )
FileSetTime(Time := "", FilePattern := "", WhichTimeMCA := "M", OperateOnFolders := 0, Recurse := 0) {
	Loop, Parse, % WhichTimeMCA
		FileSetTime, %Time%, %FilePattern%, %A_LoopField%, %OperateOnFolders%, %Recurse%
	return !ErrorLevel
}

;obtener fecha de creacion, modificacion y/o último acceso
;Sintaxis: FileGetTime( [archivo/carpeta], [M/C/A] )
;EJEMPLO:
	;Time := FileGetTime(comspec, "M", obj)
	;MsgBox % Time "`n" obj.Year "`n" obj.Mon "`n" obj.Day "`n" obj.Hour "`n" obj.Min "`n" obj.Sec
	;MsgBox % FileGetTime(comspec).M
FileGetTime(Filename, WhichTime := 0, ByRef ObjTime := "") {
	Filename := RTrim( Filename, "\" ), i := {}
	if WhichTime {
		FileGetTime, Time, %Filename%, %WhichTime%
		if IsByRef( ObjTime )
			FTime := FormatTime( Time )
			, i.Year := SubStr( FTime, 1, 4 ), i.Mon := SubStr( FTime, 5, 2 )
			, i.Day := SubStr( FTime, 7, 2 ), i.Hour := SubStr( FTime, 9, 2 )
			, i.Min := SubStr( FTime, 11, 2 ), i.Sec := SubStr( FTime, 13, 2 )
		return Time, i.Time := Time, ObjTime := i
	}
	i.M := i.ModificationTime := FileGetTime( Filename, "M" )
	i.C := i.CreationTime := FileGetTime( Filename, "C" )
	i.A := i.LastAccessTime := FileGetTime( Filename, "A" )
	return i
}

;recyclar archivo(s) o carpeta(s)
;FileRecycle( [archivo/carpeta], [¿operar en subcarpetas?] )
FileRecycle(FilePattern, Recurse := 0) {
	if !InStr(FilePattern, "*") AND !InStr(FilePattern, "?") AND !Recurse {
		FilePattern := GetFullPathName( FilePattern )
		FileSetAttrib( "-RS", FilePattern )
		FileRecycle, %FilePattern%
		return !ErrorLevel
	}
	ok := i := 0
	Loop, Files, %FilePattern%, % Recurse ? "FR" : "F"
		ok += FileRecycle( A_LoopFileLongPath ), i++
	return ok, ErrorLevel := ok = i ? 1 : 0
}

;comprueba si es archivo
;Sintaxis: IsFile( [archivo]  )
IsFile(Filename) {
	Attrib := FileGetAttrib( Filename, "D" )
	return i := ErrorLevel = 2 ? 0 : !Attrib
		, ErrorLevel := !i
}

;obtener atributos de un archivo o carpeta
;Sintaxis: FileGetAttrib( [Archivo/Carpeta] )
FileGetAttrib(lpFileName, IfEqual := 0) {
	lpFileName := GetFullPathName(lpFileName)
	if InStr(lpFileName, ":") AND (StrLen(lpFileName) = 2)
		lpFileName .= "\"
	List := {0x1 : "R", 0x20 : "A", 0x4 : "S", 0x2 : "H", 0x80 : "N", 0x10000 : "V"
		, 0x10 : "D", 0x1000 : "O", 0x800 : "C", 0x100 : "T", 0x4000 : "E"}
	hAttrib := DllCall("Kernel32.dll\GetFileAttributesW", "Str", "\\?\" lpFileName)
	if !(hAttrib > 0)
		return 0, ErrorLevel := 2
	for Value, Attrib in List
		FileAttrib .= hAttrib & Value ? Attrib : ""
	return IfEqual ? InStr(FileAttrib, IfEqual) : FileAttrib, ErrorLevel := !FileAttrib
}

;cambiar atributo(s)
;Sintaxis: FileSetAttrib( [atributos], [archivo], [modo], [¿incluir subdirectorios?] )
;devuelve el número de archivos/carpetas modificadas
FileSetAttrib(Attributes, FilePattern, Mode := -1, Recurse := 0) {
	Mode :=  Mode = 0 ? "F" : Mode = 1 ? "FD" : Mode = 2 ? "D" : Mode = -1 ? (IsFolder(FilePattern) ? "D" : "F") : Mode
	Mode .= Recurse ? "R" : "", ok := 0
	Loop, Files, %FilePattern%, %Mode%
	{
		FileSetAttrib, %Attributes%, %A_LoopFileLongPath%
		ok := ErrorLevel ? ok : ok + 1
	}
	return ok
}

SplitPath(InputVar, ByRef OutFileName := "", ByRef OutDir := "", ByRef OutExtension := "", ByRef OutNameNoExt := "", ByRef OutDrive := "") {
	SplitPath, InputVar, OutFileName, OutDir, OutExtension, OutNameNoExt, OutDrive
	i := {}, i.FileName := i.FN := OutFileName ;nombre.ext
		, i.Dir := OutDir ;directorio
		, i.Ext := i.Extension := OutExtension ;extension
		, i.Name := OutNameNoExt ;nombre
		, i.Drive := OutDrive ;unidad
	return i
}

;copiar archivo(s); devuelve el número de archivos copiados
;Sintaxis: FileCopy( [archivo(s)], [destino], [sobreescribir], [¿incluir archivos en subcarpetas?] )
FileCopy(Source, Dest, Overwrite := 0, Recurse := 0) {
	Flags := Overwrite ? "" : 0x00000001, ok := 0, IsFolder := DirExist( Dest )
	Loop, Files, %Source%, % Recurse ? "FR" : "F"
	{
		Dest2 := IsFolder ? Dest "\" SplitPath(A_LoopFileLongPath).FileName : Dest
		error := DllCall("CopyFileExW", "Str", "\\?\" A_LoopFileLongPath, "Str", "\\?\" Dest2, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags|0x00001000)
		if !error
			error := DllCall("CopyFileExW", "Str", "\\?\" A_LoopFileLongPath, "Str", "\\?\" Dest2, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags)
		ok := error ? ok + 1 : ok
	}
	return ok
}

FileGetShortcut(ShortcutFile, ByRef OutTarget := "", ByRef OutDir := "", ByRef OutArgs := "", ByRef OutDescription := "", ByRef OutIcon := "", ByRef OutIconNum := "", ByRef OutRunState := "") {
	FileGetShortcut, %ShortcutFile%, OutTarget, OutDir, OutArgs, OutDescription, OutIcon, OutIconNum, OutRunState
	return ErrorLevel ? ShortcutFile : OutTarget ? OutTarget : ShortcutFile
}

FileCreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := "", ShortcutKey := "", IconNumber := "", RunState := "") {
	FileCreateShortcut, %Target%, %ShortcutFile%, %WorkingDir%, %Args%, %Description%, %IconFile%, %ShortcutKey%, %IconNumber%, %RunState%
	return !ErrorLevel
}

;dialogo para seleccionar archivos
;Sintaxis: FileSelect( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
FileSelect(RootDirFilename := "", Filter := "", Options := 3, Prompt := "") {
	FileSelectFile, OutputVar, %Options%, %RootDirFilename%, %Prompt%, %Filter%
	return OutputVar
} ;------------------------------------------------------------------------------------------

;dialogo para guardar archivo
;Sintaxis: FileSave( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
FileSave(RootDirFilename := "", Filter := "", Options := 24, Prompt := "") {
	FileSelectFile, OutputVar, S%Options%, %RootDirFilename%, %Prompt%, %Filter%
	return OutputVar
} ;------------------------------------------------------------------------------------------

;leer archivo
;Sintáxis: FileRead( [Archivo], [Caracteres maximos] )
FileRead(Filename, CharCount := 0) {
	return CharCount > 0 ? FileOpen(Filename, "r").Read(CharCount)
		: FileOpen(Filename, "r").Read()
}

;leer texto de un número de linea de un archivo
;Sintaxis: FileReadLine( [Archivo], [Linea] )
FileReadLine(Filename, LineNum, Encoding := "") {
	i := FileOpen(Filename, "r", Encoding)
	Loop, % (LineNum - 1)
		i.ReadLine()
	return i.ReadLine(), i.Close()
}

;escribir en un archivo (añadir)
;Sintáxis: FileAppend( [Texto], [Archivo] )
FileAppend(Text, Filename, Encoding := "") {
	FileAppend, %Text%, %Filename%, %Encoding%
	if ErrorLevel {
		FileSetAttrib( "-R", Filename, 0 )
		FileAppend, %Text%, %Filename%, %Encoding%
	}
	return !ErrorLevel
}

;escribir en un número de linea de un archivo (añadir)
;Sintáxis: FileAppendLine( [Texto], [Archivo], [Número de linea] )
FileAppendLine(Text, Filename, LineNum, Encoding := "") {
	ThisContent := [], FileAppend( "`n", Filename, Encoding )
	Loop, Read, %Filename%
		ThisContent.Push(A_LoopReadLine)
	if (ThisContent.MaxIndex() < LineNum) {
		i := FileOpen(Filename, "a", Encoding)
		Loop, % ( LineNum - ThisContent.MaxIndex() )
			ThisContent.Push(""), i.Write("`n")
		i.Close()
	}
	for k, v in ThisContent
			ThisFileNewText .= k = LineNum ? v Text "`n" : v "`n"
	return FileWrite( RTrim(ThisFileNewText, "`n"), Filename, Encoding)
}

;escribir en un archivo (mismo efecto que eliminar el archivo y volver a crearlo).
;Sintáxis: FileWrite( [Texto], [Archivo] )
FileWrite(Text, Filename, Encoding := "") {
	i := FileOpen2( Filename, "w", Encoding )
	return i.Write( Text ), i.Close()
}
	
;escribir en un número de linea de un archivo (reemplazar linea entera)
;Sintáxis: FileWriteLine( [Texto], [Archivo], [Número de linea] )
FileWriteLine(Text, Filename, LineNum, Encoding := "") {
	ThisContent := [], FileAppend( "`n", Filename, Encoding )
	Loop, Read, %Filename%
		ThisContent.Push(A_LoopReadLine)
	if (ThisContent.MaxIndex() < LineNum) {
		i := FileOpen(Filename, "a", Encoding)
		Loop, % ( LineNum - ThisContent.MaxIndex() )
			ThisContent.Push(""), i.Write("`n")
		i.Close()
	}
	for k, v in ThisContent
			ThisFileNewText .= k = LineNum ? Text "`n" : v "`n"
	return FileWrite( RTrim(ThisFileNewText, "`n"), Filename, Encoding)
}

FileOpen2(file, mode := "rw", encoding := "") {
	i := FileOpen(file, mode, encoding)
	if !IsObject( i ) AND InStr2(mode, "w,a")
		FileSetAttrib( "-R", file, 0 )
		, i := FileOpen(file, mode, encoding)
	return i, ErrorLevel := !IsObject( i )
}

;ejecutar archivo, abrir carpeta/URL || AHK v1.1-
;Sintáxis: Run( [Archivo], [directorio de trabajo], [opciones], [PID] )
Run(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	Run, % InStr( Target, Chr(34) ) ? Target : FileExist( Target ) ? Chr(34) Target Chr(34) : Target, %WorkingDir%, UseErrorLevel %Options%, OutputVarPID
	return ErrorLevel ? 0 : OutputVarPID ? OutputVarPID : 1
}

RunWait(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	RunWait, % InStr( Target, Chr(34) ) ? Target : FileExist( Target ) ? Chr(34) Target Chr(34) : Target, %WorkingDir%, UseErrorLevel %Options%, OutputVarPID
	return ErrorLevel ? 0 : OutputVarPID ? OutputVarPID : 1
}

;Sintaxis: Start( [archivo], [parámetros*] ) 
Start(Target, Param*) {
	Loop, % Param.MaxIndex()
		_ .= (A_Index = 1 ? "" : " ") Chr(34) Param[A_Index] Chr(34)
	Run, "%Target%" %_%,, UseErrorLevel, PID
	return ErrorLevel ? 0 : (PID ? PID : 1)
}

FileFNPath(Filename, String := "(%A_Index%)", Add := 1) {
	tmppath := 0, SplitPath( Filename, FullName, Dir, Ext, Name )
	if !Add AND (String = "(%A_Index%)") AND (StrRight(Name) = ")") AND InStr(Name, "(") {
		index := StrTrimLeft( Name, InStr(Name, "(",, -1) )
		index := StrLeft( index, InStr(index, ")") - 1 )
		if IsNumber( index )
			Name := StrTrimRight( Name, 1 + StrLen( index ) + 1 )
	}
	Loop {
		if IsFile( tmppath ? tmppath : Filename ) {
			tmppath := Dir "\" Name ( InStr(String, "%A_Index%") ? StrReplace(String, "%A_Index%", A_Index) : "(" A_Index ")" ) "." Ext
		} else {
			return tmppath ? tmppath : Filename
		}
	}
}

;obtiene informacion sobre un archivo
;EJEMPLOS:
	;MsgBox % FileGetInfo( comspec ).CompanyName
	;MsgBox % FileGetInfo( comspec, "FileDescription" )
FileGetInfo( lptstrFilename, FileInfo := "") {
	List := "Comments InternalName ProductName CompanyName LegalCopyright ProductVersion"
		. " FileDescription LegalTrademarks PrivateBuild FileVersion OriginalFilename SpecialBuild", i := {}
	dwLen := DllCall("Version.dll\GetFileVersionInfoSizeW", "Str", lptstrFilename, "Ptr", 0)
	dwLen := VarSetCapacity( lpData, dwLen + A_PtrSize)
	DllCall("Version.dll\GetFileVersionInfoW", "Str", lptstrFilename, "UInt", 0, "UInt", dwLen, "Ptr", &lpData) 
	DllCall("Version.dll\VerQueryValueW", "Ptr", &lpData, "Str", "\VarFileInfo\Translation", "PtrP", lplpBuffer, "PtrP", puLen )
	sLangCP := Format( "{:04X}{:04X}", NumGet(lplpBuffer+0, "UShort"), NumGet(lplpBuffer+2, "UShort") )
    ;VarSetCapacity(sLangCP, 18)
    ;DllCall("msvcrt\swprintf", "Str", sLangCP, "Str", "%04X%04X", "UShort", NumGet(lplpBuffer+0, "UShort"), "UShort", NumGet(lplpBuffer+2, "UShort"))
	if FileInfo {
		DllCall("Version.dll\VerQueryValueW", "Ptr", &lpData, "Str", "\StringFileInfo\" sLangCP "\" FileInfo, "PtrP", lplpBuffer, "PtrP", puLen )
		return StrGet(lplpBuffer, puLen)
	}
	Loop, Parse, % List, %A_Space%
		DllCall("Version.dll\VerQueryValueW", "Ptr", &lpData, "Str", "\StringFileInfo\" sLangCp "\" A_LoopField, "PtrP", lplpBuffer, "PtrP", puLen )
		, i[A_LoopField] := StrGet(lplpBuffer, puLen)
	return i
}

;obtiene informacion de un archivo (mas lento)
FileGetInfo2(Filename, ValidatePath := 0) {
	Filename := ValidatePath ? FileGetValidPath(Filename) : Filename
	if !IsFile( Filename )
		return "", ErrorLevel := 1
	Filename := StrReplace(Filename, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Datafile WHERE Name = '" Filename "'")
		i.AccessMask := a.AccessMask
		, i.Archive := a.Archive
		, i.Caption := a.Caption
		, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod
		, i.CreationClassName := a.CreationClassName
		, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName
		, i.CSName := a.CSName
		, i.Description := a.Description
		, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName
		, i.Encrypted := a.Encrypted
		, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension
		, i.FileName := a.FileName
		, i.FileSize := a.FileSize
		, i.FileType := a.FileType
		, i.FSCreationClassName := a.FSCreationClassName
		, i.FSName := a.FSName
		, i.Hidden := a.Hidden
		, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount
		, i.LastAccessed := a.LastAccessed
		, i.LastModified := a.LastModified
		, i.ManuFacturer := a.Manufacturer
		, i.Name := a.Name
		, i.Path := a.Path
		, i.Readable := a.Readable
		, i.Status := a.Status
		, i.System := a.System
		, i.Version := a.Version
		, i.Writeable := a.Writeable
	return i, ErrorLevel := !i.Name
}

;obtiene una ruta valida
FileGetValidPath(Filename) {
	Filename := ValidatePath( Filename )
	if IsFile( Filename )
		return Filename, ErrorLevel := 0
	if IsFile( i := StrLeft( Filename, InStr( Filename, " " ) - 1 ) )
		return i, ErrorLevel := 0
	return Filename, ErrorLevel := 1
}

;abre un directorio y selecciona el/los archivo(s)
;Sintaxis : FileExplore( [Directorio/Archivo], [Archivos*] )
FileExplore(sPath, Files*) {
	sPath := Trim( sPath )
	if IsFile( sPath )
		SplitPath( sPath, filename, filedir )
		, Files := "", Files := []
		, Files[1] := filename
		, sPath := filedir "\"
	else
		sPath .= SubStr(sPath, 0, 1) = "\" ? "" : "\"
	DllCall("Shell32.dll\SHParseDisplayName", "Str", sPath, "Ptr", 0, "Ptr*", FolderPidl, "UInt", 0, "UInt*", 0)
	VarSetCapacity(PidlArray, Files.MaxIndex() * A_PtrSize, 0)
	for v in Files
		DllCall("Shell32.dll\SHParseDisplayName", "Str", sPath Files[v], "Ptr", 0, "Ptr*", ItemPidl, "UInt", 0, "UInt*", 0)
		, NumPut(ItemPidl, PidlArray, (v - 1) * A_PtrSize) 
	i := DllCall("shell32\SHOpenFolderAndSelectItems", "Ptr", FolderPidl, "UInt", Files.MaxIndex(), "Ptr", &PidlArray, "UInt", 0)
	for i in Files 
		DllCall("Ole32.dll\CoTaskMemFree", "Ptr", NumGet(PidlArray, (i - 1) * A_PtrSize))
	DllCall("Ole32.dll\CoTaskMemFree", "Ptr", FolderPidl)
	if !i AND filename
		return FileExplore2( sPath Files[1]  )
	return i, ErrorLevel := !i
}
FileExplore2(Filename) {
	pszName := RTrim( Trim( pszName ), "\" )
	if !IsFile( Filename )
		return 0, ErrorLevel := 1
	Run, %A_WinDir%\Explorer.exe /n`,/select`,"%Filename%",, UseErrorLevel
	return !ErrorLevel
}






























;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: CARPETAS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;eliminar carpeta
;Sintaxis: DirDelete( [carpeta], [¿eliminar archivos y subcarpetas?] )
DirDelete(lpPathName, Recurse := 0) {
	lpPathName := RTrim( Trim( lpPathName ), "\" )
	if !Recurse
		return DllCall("Kernel32.dll\RemoveDirectoryW", "Str", "\\?\" lpPathName)
	FileRemoveDir, %lpPathName%, %Recurse%
	return !ErrorLevel
}

;eliminar carpeta(s) al reiniciar
DirRDelete(FilePattern, Recurse := 0) {
	ok := 0
	Loop, Files, %FilePattern%, % Recurse ? "DR" : "D"
		error := !DllCall("Kernel32.dll\MoveFileExW", "Str", "\\?\" A_LoopFileLongPath, "Ptr", 0, "UInt", 0x4)
		, ok := error ? ok : ok + 1
	return ok, ErrorLevel := error
}

;eliminar carpeta de forma segura
;Sintáxis: DirSDelete( [carpeta], [pasadas] )
DirSDelete(Filename, Pases := 1) {
	Filename := RTrim(Filename, "\")
	ok := FileSDelete( Filename "\*.*", Pases, 1 )
	ok := FileSetTime( 2000, Filename, "MAC", 2 ) + ok
	return DirDelete(Filename, 1) + ok
}

;renombrar carpeta(s)
;Sintaxis: Rename( [Carpeta], [Nuevo Nombre], [¿Incluir carpetas en subdirectorios?] )
DirRename(Source, NewName, Recurse := 0) {
	ValidateName( NewName ), ok := 0
	if (NewName = "")
		return 0
	Loop, Files, %Source%, % Recurse ? "DR" : "D"
		SplitPath( A_LoopFileLongPath,, Dir )
		, ok += DirMove( A_LoopFileLongPath, Dir "\" NewName, "R")
	return ok, ErrorLevel := !ok
}

;Mover carpeta
DirMove(Source, Dest, Flag := "") {
	Source := RTrim(Source, "\"), Dest := RTrim(Dest, "\")
	FileMoveDir, %Source%, %Dest%, %Flag%
	return !ErrorLevel
}

;copiar carpeta
DirCopy(Source, Dest, Flag := 0) {
	Source := RTrim(Source, "\"), Dest := RTrim(Dest, "\")
	FileCopyDir, %Source%, %Dest%, %Flag%
	return !ErrorLevel
}

;crear carpeta
;devuelve el número de carpetas creadas (+subcarpetas)
DirCreate(lpPathName) {
	ok := 0, ValidatePath( lpPathName )
	if IsDir( lpPathName )
		return 1, ErrorLevel := 0
	Loop, Parse, % lpPathName, \, %A_Space%
	{
		path .= A_LoopField "\"
		if (A_Index > 1)
			ok += DllCall("Kernel32.dll\CreateDirectoryW", "Str", "\\?\" RTrim(path, "\"), "Ptr", 0)
	}
	return ok, ErrorLevel := !ok
}

;dialogo: seleccionar carpeta
;Sintaxis: DirSelect( [Directorio], [Opciones], [Título] )
DirSelect(StartingFolder := "", Options := 1,  Prompt := "") {
	FileSelectFolder, OutputVar, %StartingFolder%, %Options%, %Prompt%
	return RTrim( OutputVar, "\" )
}

;comprueba si es carpeta
;Sintaxis: IsFolder( [carpeta] )
IsFolder(Dir) {
	return isDir( Dir )
}
isDir(Dir) {
	return i := FileGetAttrib( Dir, "D" )
		, ErrorLevel := !i
}

;comprueba si el directorio existe
;transforma la ruta en su forma larga (FilePattern)
DirExist(ByRef FilePattern, Recurse := 0) {
	FilePattern := RTrim( FilePattern, "\" )
	Loop, Files, %FilePattern%, % Recurse ? "DR" : "D"
		return FilePattern := A_LoopFileLongPath
	return 0
}

;abrir carpeta con explorer.exe
;Sintaxis: DirOpen( [carpeta], [abrir en una nueva ventana] ) 
DirOpen(Folder, NewWindow := 0) {
	if !DirExist( Folder )
		return 0
	NewWindow := NewWindow ? "/n," : ""
	Run, %A_WinDir%\explorer.exe %NewWindow%"%Folder%",, UseErrorLevel
	return !ErrorLevel
}

;obtiene informacion sobre un directorio
;EJEMPLO: MsgBox % DirGetInfo( A_WinDir ).CSName
DirGetInfo(Dirname, ValidatePath := 0) {
	ComObjError( false )
	if !DirExist( Dirname )
		return "", ErrorLevel := 1
	Dirname := StrReplace(Dirname, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Directory WHERE Name = '" Dirname "'")
		i.AccessMask := a.AccessMask
		, i.Archive := a.Archive
		, i.Caption := a.Caption
		, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod
		, i.CreationClassName := a.CreationClassName
		, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName
		, i.CSName := a.CSName
		, i.Description := a.Description
		, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName
		, i.Encrypted := a.Encrypted
		, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension
		, i.FileName := a.FileName
		, i.FileSize := a.FileSize
		, i.FileType := a.FileType
		, i.FSCreationClassName := a.FSCreationClassName
		, i.FSName := a.FSName
		, i.Hidden := a.Hidden
		, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount
		, i.LastAccessed := a.LastAccessed
		, i.LastModified := a.LastModified
		, i.Name := a.Name
		, i.Path := a.Path
		, i.Readable := a.Readable
		, i.Status := a.Status
		, i.System := a.System
		, i.Version := a.Version
		, i.Writeable := a.Writeable
	return i, ErrorLevel := !i.Name
}









































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: NÚMEROS & OPERACIONES MATEMÁTICAS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtiene el mayor numero
;EJEMPLO: MsgBox % Max( 7, 9, 0, -11, 6, 3, 5, 8 ) "`n" Max( "5,2,8,-44,7" )
Max(n*) {
	n := n.MaxIndex() = 1 ? StrSplit( n[1], ",", A_Space ) : n, _ := n[1]
	Loop, % n.MaxIndex()
		_ := _ < n[A_Index+1] ? n[A_Index+1] : _
	return _
}

;obtiene el menor numero
;EJEMPLO: MsgBox % Min( 7, 9, 0, 222, -0.2 ) "`n" Min( "5,2,8,-44,7" )
Min(n*) {
	n := n.MaxIndex() = 1 ? StrSplit( n[1], ",", A_Space ) : n, _ := n[1]
	Loop, % n.MaxIndex()
		_ := _ > n[A_Index+1] ? (n[A_Index+1] = "" ? _ : n[A_Index+1]) : _
	return _
}

;convertir a hexadecimal
Hex(num, max := 0, may := 0) {
	return max = 0 ? Format("0x{:" (may ? "X" : "x") "}", num)
		: Format("0x{:" 0 LTrim(max,0) (may ? "X" : "x") "}", num)
}

;convertir a Unsigned Integer
Int(num, Signed := 0) {
	return Format("{:" (Signed ? "d" : "u") "}", num)
}






























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: STRING ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
/* AutoHotKey v2

StrReplace(HayStack, SearchText, ReplaceText := "", ByRef OutputVarCount := "", Limit := -1) {
	StrReplace, String, %HayStack%, %SearchText%, %ReplaceText%, OutputVarCount, %Limit%
	return String
}

*/

StrNormalize(String) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd319093%28v=vs.85%29.aspx
    len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", 0, "Int", 0)
    Loop {
        VarSetCapacity(buf, len * 2)
        len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", &buf, "Int", len)
        if (len >= 0)
            break
        if (A_LastError != 122) ;ERROR_INSUFFICIENT_BUFFER
            return
        len *= -1
    }
    return RegExReplace(StrGet(&buf, len, "UTF-16"), "\pM")
}

StrSplitP(String, Delimiter := "'", OmitChars := "", ReplaceLiteralVar := 0) {
	Array := [], Index := 0
	Loop, Parse, % String, %Delimiter%, %OmitChars%
		if IsEven(A_Index)
			Index++
			, Array[Index] := ReplaceLiteralVar ? ReplaceLiteralVar(A_LoopField) : A_LoopField
	return Array, ErrorLevel := Array.MaxIndex()
}
	
;Separa una cadena en una matriz de subcadenas utilizando los delimitadores especificados.
;Sintaxis: StrSplit( [cadena/array], [delimitador], [omitir], [defecto si es vacio] )
;NOTA: Array[ 0 ] y ErrorLevel se establecen en la cantidad total de índices
;EJEMPLO:
	;String := "Este Es Un Ejemplo", Array := [ "Este", "Es", "Un", "Ejemplo" ]
	;s := StrSplit( String, A_Space ), a := StrSplit( Array, A_Space )
	;MsgBox % s[1] " = " a[1] "`n" s[2] " = " a[2] "`n" s[3] " = " a[3] "`n" s[4] " = " a[4]
StrSplit(String, Delimiter, OmitChars := "", Default := "") {
	Array := [], String := IsObject( String ) ? StrMergeArray( String, Delimiter ) : String
	Loop, Parse, % String, %Delimiter%, %OmitChars%
		Array[ A_Index ] := A_LoopField = "" ? Default : A_LoopField
	Array[ 0 ] := Array.MaxIndex()
	return Array, ErrorLevel := Array[ 0 ]
}

StrMergeArray(Array, Delimiter) {
	if IsObject( Array )
		for k, v in Array
			Array .= k = 1 ? v : Delimiter v
	return Array
}

;Determina la longitud de la cadena especificada
StrLen2(IpString) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647492%28v=vs.85%29.aspx
	return DllCall("Kernel32.dll\lstrlenW", "Str", lpString)
}

;quitar caracteres de izquierda a derecha
;Sintaxis : StrTrimLeft( [Var], [Limite], [resto que se quitó] )
StrTrimLeft(String, Length := 1, ByRef OutStr2 := "") {
	OutString := SubStr(String, (Length + 1))
	return OutString, OutStr2 := IsByRef( OutStr2 ) ? StrLeft( String, Length ) : ""
}

;quitar caracteres de derecha a izquierda
;Sintaxis : StrTrimRight( [Var], [Limite], [resto que se quitó] )
StrTrimRight(String, Length := 1, ByRef OutStr2 := "") {
	OutString := SubStr(String, 1, (StrLen(String) - Length))
	return OutString, OutStr2 := IsByRef( OutStr2 ) ? StrRight( String, Length ) : ""
}

;obtener caracteres de izquierda a derecha
;Sintaxis : StrLeft( [Var], [Limite], [resto que se quitó] )
StrLeft(String, Length := 1, ByRef OutStr2 := "") {
	OutString := SubStr(String, 1, Length)
	return OutString, OutStr2 := IsByRef( OutStr2 ) ? StrTrimLeft( String, Length ) : ""
}
	
;obtener caracteres de derecha a izquierda
;Sintaxis : StrRight( [Var], [Limite], [resto que se quitó] )
StrRight(String, Length := 1, ByRef OutStr2 := "") {
	OutString := SubStr(String, -(Length - 1))
	return OutString, OutStr2 := IsByRef( OutStr2 ) ? StrTrimRight( String, Length ) : ""
}

;If [var] in [ .. ]
InVar(Haystack, Needle, Delimiter := ",", OmitChars := "") {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (A_LoopField = Haystack)
			return 1
	return 0
}

;if [value] between [low] [high]
;Sintaxis: Between( [número], [valor menor], [valor mayor] ) 
Between(value, low := 0, high := 100) {
    return value >= low && value <= high
}

InStr2(Haystack, Needle, Delimiter := ",", OmitChars := "") {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if InStr( Haystack, A_LoopField ) 
			return 1
	return 0
}

;si el número es par devuelve 1, caso contrario 0 (impar)
IsEven(num) {
	return ((num & 1) != 0) ? 0 : 1
}

;obtener un nombre válido para un archivo
ValidateName(ByRef IpName) {
	return IpName := RegExReplace(IpName, "[\Q*/\:?" Chr(34) "<>|`n\E]")
}

;obtener una ruta válida para un directorio
;EJEMPLOS: 
	;MsgBox % ValidatePath( "\<`n||\ " A_WinDir "\/\ \ *Sys/t<e>m?32\c::md.:exe|`n\\" )
	;MsgBox % SetWorkingDir(A_WinDir) ValidatePath( "\system32\\cmd.:exe\ " )
ValidatePath(ByRef IpPath) {
	IpPath := RegExReplace(IpPath, "[\Q*/?" Chr(34) "<>|`n\E]")
	IpPath := Trim( IpPath ), IpPath := Trim( IpPath, "\" ), IpPath := Trim( IpPath )
	IpDrive := StrLeft( IpPath, 2 ) 
	if FileExist( IpDrive ) AND InStr( IpDrive, ":" )
		IpPath := IpDrive StrReplace( StrTrimLeft( IpPath, 2 ), ":" )
	else
		IpPath := A_WorkingDir "\" StrReplace( IpPath, ":" )
	IpPath := StrReplace(IpPath, "\\", "\")
	IpPath := StrReplace(IpPath, " \ ", "\")
	IpPath := Trim( IpPath ), IpPath := Trim( IpPath, "\" ), IpPath := Trim( IpPath )
	return IpPath := StrReplace(IpPath, "\\", "\")
}

;obtiene el mayór número (no negativos)
;Ver: Max()
StrMax(num, Delimiter := ",") {
	num := RegExReplace(num, "[^0-9\Q" Delimiter "\E]")
	RegExMatch(Sort(num, "D" Delimiter " N R"), "[\d.-]*", z)
	return z
}

;obtiene el menór número (no negativos)
;Ver: Min()
StrMin(num, Delimiter := ",") {
	num := RegExReplace(num, "[^0-9\Q" Delimiter "\E]")
	RegExMatch(Sort(num, "D" Delimiter " N"), "[\d.-]*", z)
	return z
}

Sort(VarName, Options := "") {
	Sort, VarName, %Options%
	return VarName
}

;convertir texto en minúscula 
StrLower(String, T := 0) {
	return Format(T ? "{:T}" : "{:L}", String)
	String2 := DllCall("User32.dll\CharLowerW", "Str", String)
	return StrGet( String2, StrLen(String) )
}

;comprueba si es minúscula
IsLower(String) {
	if String is LOWER
		return 1
	return 0
}

;convertir texto en mayuscula
StrUpper(String, T := 0) {
	return Format(T ? "{:T}" : "{:U}", String)
	String2 := DllCall("User32.dll\CharUpperW", "Str", String)
	return StrGet( String2, StrLen(String) )
}

;comprueba si es mayúscula
IsUpper(String) {
	if String is UPPER
		return 1
	return 0
}

;determina si es Número (negativo o positivo)
;NOTA: +1, -1, .1, 0.2, *1, 0x0d04, etc. son considerados numeros validos 
IsNumber( num ) {
	n := num + 1
	return n = "" ? 0 : n ? n : 1
}

;Convierte la ruta especificada a su forma larga .
StrLPath(lpszShortPath) {
	lpszShortPath := RegExReplace(RegExReplace(RegExReplace(lpszShortPath, "^\s+"), "\s+$"), "\\+$")
	cchBuffer := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" lpszShortPath, "Ptr", 0, "UInt", 0)
	VarSetCapacity( lpszLongPath, cchBuffer * 2, 0 )
	i := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" lpszShortPath, "Str", lpszLongPath, "UInt", cchBuffer)
	return i ? RegExReplace(lpszLongPath, "^\\\\\?\\+") : lpszShortPath, ErrorLevel := !i
}

;Recupera la ruta corta del directorio espesificado
StrSPath(lpszShortPath) {
	lpszShortPath := RegExReplace(RegExReplace(RegExReplace(lpszShortPath, "^\s+"), "\s+$"), "\\+$")
	cchBuffer := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" lpszShortPath, "Ptr", 0, "UInt", 0)
	VarSetCapacity( lpszLongPath, cchBuffer * 2, 0 )
	i := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" lpszShortPath, "Str", lpszLongPath, "UInt", cchBuffer)
	return i ? RegExReplace(lpszLongPath, "^\\\\\?\\+") : lpszShortPath, ErrorLevel := !i
}

StrDownload(URL) {
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	i.Open("GET", URL), i.Send()
	return i.ResponseText
}

;Convierte una cadena que representa un número decimal o hexadecimal a un entero
StrToInt(String, Flags := 0) {
	DllCall("shlwapi.dll\StrToIntEx", "Ptr", &String, "Int", Flags, "Int*", Ret)
	return Ret
}

;Convierte una cadena que representa un valor decimal o hexadecimal a un entero de 64 bits
StrToInt64(String, Flags := 0) {
	DllCall("shlwapi.dll\StrToInt64Ex", "Ptr", &String, "Int", Flags, "Int64*", Ret)
	return Ret
}

;reemplaza variables literales.
;Sintaxis: ReplaceLiteralVar( [Var], [archivo] )
ReplaceLiteralVar(String, IsFile := 0) {
	;variables del sistema y usuario -----------------------------------
	i := {"HKCU" : "Environment", "HKLM" : "SYSTEM\ControlSet001\Control\Session Manager\Environment"}
	for k, v in i
		Loop, Reg, %k%\%v%, V
			String := StrReplace(String, "%" A_LoopRegName "%", EnvGet(A_LoopRegName))
	i := ""
	;otras variables y cmd -----------------------------------R
	i := {"Temp" : A_Temp(), "ProgramFiles" : A_ProgramFiles(), "CD" : A_WorkingDir(), "CommonProgramFiles" : A_ProgramsCommon(), "AppData" : A_AppData(), "OS" : A_OSVersion()
		, "COMPUTERNAME" : A_ComputerName(), "DATE" : (d:=A_DD) "/" (m2:=A_Mon) "/" (y:=A_Year), "HOMEDRIVE" : SubStr(A_WinDir(), 1, 2), "LOCALAPPDATA" : A_AppDataCommon(), "desktop" : A_Desktop()
		, "WINDIR" : A_WinDir(), "USERNAME" : A_UserName(), "TIME" : (h:=A_Hour) ":" (m:=A_Min) ":" (s:=A_Sec), "SYSTEMROOT" : A_WinDir(), "PROCESSOR_ARCHITECTURE" : A_Is64bitOS ? "64" : "32"
		, "LOCALAPPDATA" : A_AppDataCommon(), "CMDEXTVERSION" : A_OSType(), "StartMenu" : A_StartMenu(), "MyDocuments" : A_MyDocuments(), "Documents" : A_MyDocuments(), "DateTime" : y "_" m2 "_" d "_" h "_" m "_" s
		, "Cursor" : A_Cursor(), "SendTo" : A_SendTo(), "Recent" : A_Recent(), "MyVideo" : A_MyVideo(), "MyPictures" : A_MyPictures(), "MyMusic" : A_MyMusic(), "DocumentsCommon" : A_DocumentsCommon()
		, "Programs" : A_Programs(), "ComSpec" : A_ComSpec(), "SysWinDir" : A_SysWinDir(), "SysDir" : A_SysDir(), "SysDir64" : A_SysDir64(), "DefaultUserProfile" : A_DefaultUserProfile()
		, "Profiles" : A_Profiles, "AllUsersProfile" : A_AllUsersProfile(), "UserProfile" : A_UserProfile() }
	for k, v in i
		String := StrReplace(String, "%" k "%", v)
	i := ""
	;variables autohotkey -----------------------------------
	i := {"A_Temp" : A_Temp(), "A_DDD" : A_DDD, "A_DDDD" : A_DDDD, "A_MMM" : A_MMM, "A_MMMM" : A_MMMM, "A_DD" : d, "A_MM" : A_MM, "A_YYYY" : A_YYYY, "A_DD" : A_DD, "A_AhkVersion" : A_AhkVersion, "A_ScriptName" : A_ScriptName()
		, "A_ScriptFullPath" : A_ScriptFullPath(), "A_WorkingDir" : A_WorkingDir, "A_ScriptDir" : A_ScriptDir(), "A_Space" : A_Space(), "A_Tab" : A_Tab(), "A_Year" : y, "A_Mon" : m2, "A_WDay" : A_WDay, "A_YDay" : A_YDay, "A_Hour" : h
		, "A_YWeek" : A_YWeek, "A_Min" : m, "A_Sec" : s, "A_Now" : A_Now, "A_MSec" : A_MSec, "ComSpec" : A_ComSpec(), "A_OSVersion" : A_OSVersion(), "A_WinDir" : A_WinDir()
		, "A_ProgramFiles" : A_ProgramFiles(), "A_AppData" : A_AppData(), "A_Language" : A_Language(), "A_Desktop" : A_Desktop(), "A_StartMenu" : A_StartMenu(), "A_UserName" : A_UserName(), "A_AppDataCommon" : A_AppDataCommon()
		, "A_ComputerName" : A_ComputerName(), "A_StartMenuCommon" : A_StartMenuCommon(), "A_Programs" : A_Programs(), "A_ProgramsCommon" : A_ProgramsCommon(), "A_Cursor" : A_Cursor(), "A_Startup" : A_Startup(), "A_IsAdmin" : A_IsAdmin()
		, "A_DesktopCommon" : A_DesktopCommon(), "Clipboard" : Clipboard, "A_LastError" : A_LastError(), "A_StartupCommon" : A_StartupCommon(), "A_ScreenHeight" : A_ScreenHeight(), "A_ScreenWidth" : A_ScreenWidth(), "A_IPAddress4" : A_IPAddress4()
		, "A_IPAddress1" : A_IPAddress1(), "A_IPAddress2" : A_IPAddress2(), "A_IPAddress3" : A_IPAddress3(), "ClipboardAll" : ClipboardAll, "A_MyDocuments" : A_MyDocuments}
	for k, v in i
		String := StrReplace(String, "%" k "%", v)
	i := ""
	;variables para el archivo especificado -----------------------------------
	if IsFile
		String := StrReplace(String, "%A_FileVersion%", FileGetVersion(IsFile))
	;--------------------------------------------------------------------------------------------------------------------------------------------
	return String
}


















































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: CRIPTOGRAFÍA ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
Base32Encode(Decoded, UseHex := 0, Len := 0) { 
	CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	If (Len = 0)
		Len := StrPut(Decoded, "UTF-8") - 1
		, VarSetCapacity(UTF8, Len, 0)
		, StrPut(Decoded, &UTF8, "UTF-8")
		, BinAddr := &UTF8
	else
		BinAddr := &Decoded
	VarSetCapacity(Endcoded, Len * 2, 0)
	I := 0
	while (I < Len) {
		J := N := 0
		S := 40
		Loop, 5
			N += NumGet(BinAddr + I++, "UChar") << (8 * (5 - ++J))
		Until (I >= Len)
		Loop, % Ceil((8 * J) / 5)
			Encoded .= SubStr(Chars, ((N >> (S -= 5)) & 0x1F) + 1, 1)
	}
	Loop, % ((40 - (J * 8)) // 5)
		Encoded .= "="
	return Encoded
}

Base64Encode(pbBinary) {
	cbBinary := StrLen( pbBinary ) * 2
	dwFlags := CRYPT_STRING_BASE64 := 0x00000001
	DllCall( "Crypt32.dll\CryptBinaryToStringW", "UChar", &pbBinary, "UInt", cbBinary, "UInt", dwFlags, "Ptr", 0, "UInt*", pcchString, "CDECL Int")
	pcchString := VarSetCapacity( pszString, pcchString * 2 )
	i := DllCall( "Crypt32.dll\CryptBinaryToStringW", "UChar", &pbBinary, "UInt", cbBinary, "UInt", dwFlags, "Str", pszString, "UInt*", pcchString, "CDECL Int")
	return pszString, ErrorLevel := !i
}

;----------------------------------------

Base32Decode(Encoded, UseHex := 0, ByRef Decoded := "") {
	CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	Len := StrLen(Encoded)
	VarSetCapacity(Decoded, Len * 2, 0)
	I := J := K := 0
	Loop, Parse, % Encoded
	{
		If !(N := InStr(Chars, A_LoopField))
			break
		K += --N << (5 * (8 - ++J))
		If (J = 8) {
			S := 40
			Loop, 5
				NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
			J := K := 0
		}
	}
	If (J < 8) {
		S := 40
		Loop, % Ceil((5 * J) / 8)
			NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
	}
	return IsByRef(Decoded) ? I : StrGet(&Decoded, I, "UTF-8")
}

Base64Decode(pszString) {
	cchString := StrLen( pszString )
	dwFlags := CRYPT_STRING_BASE64 := 0x00000001
	DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &pszString, "UInt", cchString, "UInt", dwFlags, "UChar", 0, "UInt*", pcbBinary, "UInt*", 0, "UInt*", 0, "CDECL Int")
	pcbBinary := VarSetCapacity( pbBinary, pcbBinary * 2)
	i := DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &pszString, "UInt", cchString, "UInt", dwFlags, "Str", pbBinary, "UInt*", pcbBinary, "UInt*", 0, "UInt*", 0, "CDECL Int")
	return pbBinary, ErrorLevel := !i
}































/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  ::::::::::::::::::::::::::::::::::::::::::::: PROCESOS ::::::::::::::::::::::::::::::::::
---------------------------------------------------------------------------------------------------------------------------------------------------------------
NOTA: las funciones aceptan el PID y Nombre del proceso (este último lo hace mas lento)
*/
;devuelve una lista de todos los procesos + informacion
;ErrorLevel es 1 si ha ocurrido un error
;EJEMPLO:
	;for k, v in ProcessEnum()
		;MsgBox % k "- " v.Name A_Tab v.ProcessId A_Tab v.UserDomain "\" v.UserName
ProcessEnum() {
	ppProcessInfo := pCount := 0, List := {}
	hModule := LoadLibrary( "Wtsapi32.dll" )
	hWts := DllCall("Wtsapi32.dll\WTSEnumerateProcessesW", "Ptr", 0, "UInt", 0, "UInt", 1, "Ptr*", ppProcessInfo, "UInt*", pCount)
	WTS_PROCESS_INFO_EX := ppProcessInfo
	Loop, %pCount% {
		Info := "", Info := {}, Info.Count := pCount ;número de procesos
		Info.SessionId := NumGet(WTS_PROCESS_INFO_EX + 0, "UInt") ;sid sesión para la sesión asociada con el proceso
		Info.ProcessId := NumGet(WTS_PROCESS_INFO_EX + 4, "UInt") ;PID
		Info.Name := StrGet(NumGet(WTS_PROCESS_INFO_EX + 8)) ;nombre
		Info.UserSid := NumGet(WTS_PROCESS_INFO_EX + 16) ;sid del usuario
			VarSetCapacity(UserName, 512, 0), VarSetCapacity(UserDomain, 512, 0), VarSetCapacity(peUse, 512, 0)
			DllCall("Advapi32.dll\LookupAccountSid", "Ptr", 0, "Ptr", Info.UserSid, "Str", UserName, "UIntP", 256, "Str", UserDomain, "UIntP", 256, "UIntP", peUse)
		Info.UserName := UserName ;nombre del usuario
		Info.UserDomain := UserDomain ;dominio
		Info.peUse := peUse ;valor SID_NAME_USE que indica el tipo de la cuenta.
		List.InsertAt(A_Index, Info), WTS_PROCESS_INFO_EX += (A_PtrSize = 4 ? 16 : 24)
	}
	return List
		, DllCall("Wtsapi32.dll\WTSFreeMemory", "Ptr", ppProcessInfo)
		, FreeLibrary( hModule )
		, ErrorLevel := !hWts
}

;Recupera información sobre el uso de memoria del proceso especificado en bytes
ProcessMemoryInfo(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0010|0x0400, "UInt", 0, "UInt", ProcessId)
	nSize := VarSetCapacity(memCounters, A_PtrSize = 8 ? 72 : 40), NumPut(nSize, memCounters)
	if !DllCall("Psapi.dll\GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", nSize) {
		memCounters := "", nSize := VarSetCapacity(memCounters, A_PtrSize = 8 ? 80 : 44), NumPut(nSize, memCounters)
		if !DllCall("Kernel32.dll\K32GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", nSize)
			return 0
	}
	i := {} ; i.Length := NumGet(memCounters, 0, "UInt")
		, i.PageFaultCount := NumGet(memCounters, 4, "UInt") ;número de fallos de página.
		, i.PeakWorkingSetSize := NumGet(memCounters, 8, "Ptr") ;tamaño máximo de trabajo
		, i.WorkingSetSize := NumGet(memCounters, A_PtrSize = 8 ? 16 : 12, "Ptr") ;El tamaño del conjunto de trabajo actual, en bytes. (uso de memoria)
		, i.QuotaPeakPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 24 : 16, "Ptr")
		, i.QuotaPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 32 : 20, "Ptr")
		, i.QuotaPeakNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 40 : 24, "Ptr")
		, i.QuotaNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 48 : 28, "Ptr")
		, i.PagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 56 : 32, "Ptr")
		, i.PeakPagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 64 : 36, "Ptr")
		, i.PrivateUsage := NumGet(memCounters, A_PtrSize = 8 ? 72 : 40, "Ptr")
	return i, DllCall("kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;uso de CPU del proceso
ProcessCPULoad(ProcessName) {
		Static oldKrnlTime, oldUserTime, newKrnlTime, newUserTime
		ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
		oldKrnlTime := newKrnlTime, oldUserTime := newUserTime
		hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		DllCall("Kernel32.dll\GetProcessTimes", "Uint", hProcess, "int64P", CreationTime, "int64P", ExitTime, "int64P", newKrnlTime, "int64P", newUserTime) 
		return ( ( (newKrnlTime - oldKrnlTime) + (newUserTime-oldUserTime) ) / 10000000) * 100, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;comprueba si el proceso existe
;Sintaxis: ProcessExist( [ProcessName] )
;NOTAS:
	;Devuelve el PID o 0 en caso de error
	;ErrorLevel se establece en el PID o 0 en caso de error
ProcessExist(ProcessName) {
	ProcessName := Trim( ProcessName )
	if (ProcessName = "")
		return 0, ErrorLevel := 1
	;---------------------------------------------------------------------------------------------------------------------
	if (ProcessName = -1) ;si ProcessName es -1, devuelve el PID del proceso actual
		return DllCall("Kernel32.dll\GetCurrentProcessId")
	;---------------------------------------------------------------------------------------------------------------------
	if (ProcessName = -2)
		return DllCall("Kernel32.dll\GetCurrentThreadId")
	;---------------------------------------------------------------------------------------------------------------------
	dwSize := VarSetCapacity(lppe, A_PtrSize = 4 ? 556 : 568, 0), NumPut(dwSize, lppe, 0, "UInt")
	hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
	DllCall("Kernel32.dll\Process32FirstW", "Ptr", hSnapshot, "Ptr", &lppe)
	Loop {
		ProcessId := NumGet(lppe, 8, "UInt")
		ProcessExe := StrGet(&lppe + (A_PtrSize = 4 ? 36 : 44), 260 * 2, "UTF-16")
		if (ProcessId = ProcessName) OR (ProcessExe = ProcessName)
			return ProcessId, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot), ErrorLevel := ProcessId
		if !DllCall("Kernel32.dll\Process32NextW", "Ptr", hSnapshot, "UInt", &lppe)
			return 0, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot), ErrorLevel := 0
	}
}

;esperar a que el proceso exista
;Sintaxis: ProcessWait( [Proceso], [Segundos a esperar] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no existe; caso contrario devuelve el PID
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWait(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return 0
	GetTickCount( StartTime )
	Loop {
		if ( ProcessId := ProcessExist( ProcessName ) )
			return ProcessId, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds > 0) AND (ElapsedTime >= Seconds)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que el proceso finalize
;Sintaxis: ProcessWaitClose( [Proceso], [Segundos] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no se ha cerrado; caso contrario devuelve 1
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWaitClose(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return 0
	GetTickCount( StartTime )
	Loop {
		if !ProcessExist( ProcessName )
			return 1, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds > 0) AND (ElapsedTime >= Seconds)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}
WaitForSingleObject(ProcessName, Seconds := 0) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032%28v=vs.85%29.aspx
	if (Seconds = -1)
		return 0
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x00100000, "UInt", 0, "UInt", ProcessId)
	i := DllCall("Kernel32.dll\WaitForSingleObject", "Ptr", hProcess, "UInt", Seconds > 0 ? Seconds : 0xFFFFFFFF)
	return i = 0 OR i = -1 ? (ProcessId ? ProcessId : 1) : 0
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ErrorLevel := i = 0 OR i = -1 ? 0 : 1
}

;obtener/establecer prioridad 
;Sintaxis: ProcessPriority( [Nombre o PID], [Prioridad] )
;Nota: dejar vacio el segundo parametro para recuperar la prioridad
ProcessPriority(ProcessName, dwPriorityClass := 0, Spa := 0) {
	r32 := "Normal", r64 := "Low", r128 := "High" , r256 := "RealTime", r16384 := "BelowNormal", r32768 := "AboveNormal"
	rn32 := "Normal", rn64 := "Baja", rn128 := "Alta" , rn256 := "Tiempo real", rn16384 := "Debajo de lo normal", rn32768 := "Arriba de lo normal"
	rNormal := rN := 32, rLow := rL := 64, rHigh := rH := 128 , rRealTime := rR := 256, rBelowNormal := rB := 16384, rAboveNormal := rA := 32768
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	if !dwPriorityClass {
		hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		hCPriority := DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess)
		return Spa ? (rn%hCPriority% ? rn%hCPriority% : hCPriority) : (r%hCPriority% ? r%hCPriority% : hCPriority)
			, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
			, ErrorLevel := Spa ? (rn%hCPriority% ? 1 : 0) : (r%hCPriority% ? 1 : 0)
	}
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0200, "UInt", 0, "UInt", ProcessId)
	return i := DllCall("kernel32.dll\SetPriorityClass", "Ptr", hProcess, "UInt", r%dwPriorityClass% ? r%dwPriorityClass% : dwPriorityClass)
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ErrorLevel := r%dwPriorityClass% ? !i : 0
}
	
;cerrar proceso(s)
;Sintaxis: ProcessClose( [PID/Nombre*], [¿Esperar? (segundos)], [¿Terminar SubProcesos?], [código de salida] )
;NOTAS: 
	;espesificar * para terminar todos los procesos que coincidan con el nombre espesificado
	;espesificar 0 segundos para esperar indefinidamente
;Terminar SubProcesos: 
	;1 = terminar el proceso junto con todos los procesos que inició
	;2 = teminar todos los procesos que el proceso espesificado inició
ProcessClose(ProcessName, WaitClose := -1, SubProcess := 0, uExitCode := 0) {
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	if InStr(ProcessName, "*") { ;terminar procesos que coincidan con el mismo nombre
		ProcessName := StrReplace(ProcessName, "*")
		dwSize := VarSetCapacity(lppe, A_PtrSize = 4 ? 556 : 568, 0), NumPut(dwSize, lppe, 0, "UInt")
		hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		if DllCall("Kernel32.dll\Process32FirstW", "Ptr", hSnapshot, "Ptr", &lppe)
			Loop {
				ProcessId := NumGet(lppe, 8, "UInt")
				ProcessExe := StrGet(&lppe + (A_PtrSize = 4 ? 36 : 44), 260 * 2, "UTF-16")
				if (ProcessExe = ProcessName)
					hList .= ProcessClose( ProcessId, WaitClose, SubProcess, uExitCode ) "`n"
				if !DllCall("Kernel32.dll\Process32NextW", "Ptr", hSnapshot, "UInt", &lppe)
					return RTrim(hList, "`n"), DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot)
			}
	}
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	if InStr(ProcessName, ".") OR (ProcessName = -1)
		ProcessId := ProcessExist( ProcessName )
	else
		ProcessId := ProcessName
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	if SubProcess { ;termina el proceso junto con todos sus subprocesos
		dwSize := VarSetCapacity(lppe, A_PtrSize = 4 ? 556 : 568, 0), NumPut(dwSize, lppe, 0, "UInt")
		hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		DllCall("Kernel32.dll\Process32FirstW", "Ptr", hSnapshot, "Ptr", &lppe)
		Loop {
			Process_ID := NumGet(lppe, 8, "UInt"), Parent := NumGet(lppe, A_PtrSize = 4 ? 24 : 32, "UInt")
			if (Process_ID != ProcessId) AND (Parent = ProcessId)
				hList .= ProcessClose( Process_ID, WaitClose,, uExitCode ) "`n"
			if !DllCall("Kernel32.dll\Process32NextW", "Ptr", hSnapshot, "UInt", &lppe)
				return SubProcess = 1 ? hList ProcessClose(ProcessId, WaitClose,, uExitCode) : RTrim(hList, "`n")
					, DllCall("Kernel32.dll\CloseHandle", "Ptr", hSnapshot)
		}
	}
	;----------------------------------------------------------------------------------------------------------------------------------------------------------------
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0001, "UInt", 0, "UInt", ProcessId)
	hResult := DllCall("Kernel32.dll\TerminateProcess", "Ptr", hProcess, "UInt", uExitCode)
	return hResult ? ProcessId : 0
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ProcessWaitClose(ProcessId, WaitClose), ErrorLevel := !hResult
} ;----------------------------------------------------------------------------------------------------------------------------------------------------------------

;recupera la ruta completa al archivo ejecutable del proceso
;Sintaxis: ProcessPath( [ID], [nombre del ejecutable (out)] )
ProcessPath(ProcessName, ByRef ProcessEName := "") {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400|0x0010, "UInt", 0, "UInt", ProcessId)
	FileNameSize := VarSetCapacity(ModuleFileName, 260 * 2, 0) / 2
	DllCall("Psapi.dll\GetModuleFileNameExW", "Ptr", hProcess, "UInt", 0, "Str", ModuleFileName, "UInt", FileNameSize)
	return ModuleFileName, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
		, ProcessEName := IsByRef( ProcessEName ) ? ProcessEName( ProcessId ) : ""
}

;recupera el nombre del archivo ejecutable del proceso
ProcessEName(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400|0x0010, "UInt", 0, "UInt", ProcessId)
	nSize := VarSetCapacity(lpBaseName, 260 * 2, 0) / 2
	if !DllCall("Kernel32.dll\GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", lpBaseName, "UInt", nSize)
		DllCall("Psapi.dll\GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", lpBaseName, "UInt", nSize)
	return lpBaseName, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}
ProcessName(ProcessName) {
	return ProcessEName( ProcessName )
}

;Habilitar/Deshabilitar privilegios para el proceso
;Sintaxis: ProcessSetPrivilege( [Proceso], [Tipo de privilegio], [0|1 (deshabilitar/habilitar)] )
ProcessSetPrivilege(ProcessName, Privilege, OnOff) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
	TOKEN_ADJUST_PRIVILEGES := 0x0020, TOKEN_QUERY := 0x00000008
	DllCall("Advapi32.dll\OpenProcessToken", "Ptr", hProcess, "UInt", TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, "UIntP", hToken)
	DllCall("Advapi32.dll\LookupPrivilegeValueW", "Ptr", 0, "Str", Privilege, "Int64P", lpLuid)
	VarSetCapacity(ti, 16, 0), NumPut(1, ti, 0, "UInt"), NumPut(lpLuid, ti, 4, "Int64"), NumPut(2, ti, 12, "UInt")
	return DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", hToken, "Int", !OnOff, "Ptr", &ti, "UInt", 0, "Ptr", 0, "Ptr", 0)
		, DllCall("kernel32.dll\CloseHandle", "Ptr", hToken), DllCall("kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;suspender
ProcessSuspend(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0800, "UInt", 0, "UInt", ProcessId)
	DllCall("ntdll.dll\NtSuspendProcess", "Ptr", hProcess)
	return hProcess, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}
	
;reanudar
ProcessResume(ProcessName) {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0800, "UInt", 0, "UInt", ProcessId)
	DllCall("ntdll.dll\NtResumeProcess", "Ptr", hProcess)
	return hProcess, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}
	
;obtiene el SID, opcional también el nombre de usuario y dominio del proceso
;Sintaxis: ProcessGetSID( [proceso], [nombre de usuario (salida)], [dominio (salida)] )
;NOTA: devuelve el SID
ProcessGetSID(ProcessName, ByRef UserName := "", ByRef UserDomain := "") {
	ProcessId := InStr(ProcessName, ".") ? ProcessExist(ProcessName) : ProcessName
	hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x00020000, "UInt", 0, "UInt", ProcessId)
	i := DllCall("Advapi32.dll\GetSecurityInfo", "Ptr", hProcess, "UInt", 6, "UInt", 1, "PtrP", PSID, "PtrP", 0, "PtrP", 0, "PtrP", 0)
	if IsByRef( UserName ) OR IsByRef( UserDomain )
		VarSetCapacity(UserName, 512, 0), VarSetCapacity(UserDomain, 512, 0)
		, DllCall("Advapi32.dll\LookupAccountSid", "Ptr", 0, "Ptr", PSID, "Str", UserName, "UIntP", 256, "Str", UserDomain, "UIntP", 256, "UIntP", 0)
	return PSID, ErrorLevel := i
}
























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: INTERNET ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------

;descargar archivo
;Sintaxis: Download( [URL], [Archivo] )
Download(URL, Filename) {
	URLDownloadToFile, %URL%, %Filename%
	return !ErrorLevel
}

;comprueba la conexion a internet
NetGetState(lpdwFlags := 0x40) {
	i := DllCall("Wininet.dll\InternetGetConnectedState", "UInt*", 0x40, "UInt", 0)
	return i, ErrorLevel := !i
}

;obtener tamaño del archivo
NetGetFileSize(URL) {
	ComObjError(false)
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	i.Open("HEAD", URL), i.Send()
	return i.GetResponseHeader("Content-Length")
}

;obtener texto
NetGetString() {
		ComObjError(false)
		i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		i.Open("GET", URL), i.Send()
		return i.ResponseText
}































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: OTROS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;bloquear mouse y teclado & suspende el script
;Sintaxis: BlockInput( [0|1] )
BlockInput( OnOff ) {
	if !OnOff {
		Suspend, Off
		RegDelete( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger" )
		SetTimer( "BlockInput_Function_Label", "Delete" )
		return DllCall("User32.dll\BlockInput", "Int", 0)
	}
	Suspend, On
	return DllCall("User32.dll\BlockInput", "Int", 1)
		, SetTimer( "BlockInput_Function_Label", 500 )
		, RegWrite(, "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger", "Disable")
	BlockInput_Function_Label:
	DllCall("User32.dll\BlockInput", "Int", 1)
	return
}

;establecer porcentaje de progreso en la barra de tareas
;Sintaxis: SetTaskbarProgress( [ESTADO], [Ventana ID] )
;ESTADOS:
	;0~100 = porcentaje
	;Normal, Paused, Indeterminate, Error = estado
SetTaskbarProgress(State, hWnd := "") {
	static ppv
	if !ppv
		DllCall("ole32.dll\OleInitialize", "PtrP", 0)
		, VarSetCapacity(CLSID, 16), VarSetCapacity(riid, 16)
		, DllCall("ole32.dll\CLSIDFromString", "Str", "{56FDF344-FD6D-11d0-958A-006097C9A090}", "Ptr", &CLSID)
		, DllCall("ole32.dll\CLSIDFromString", "Str", "{ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf}", "Ptr", &riid)
		, DllCall("ole32.dll\CoCreateInstance", "Ptr", &CLSID, "Ptr", 0, "UInt", 21, "Ptr", &riid, "PtrP", ppv)
	hWnd := hWnd ? hWnd : IsWindow()
	s0 := 0, sI := sIndeterminate := 1, sN := sNormal := 2, sE := sError := 4, sP := sPaused := 8
	if InVar( State, "0,N,P,E,I,Normal,Paused,Error,Indeterminate" )
		return DllCall(NumGet(NumGet(ppv+0)+10*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "UInt", s%State%)
	return DllCall(NumGet(NumGet(ppv+0)+9*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "Int64", State * 10, "Int64", 1000)
}

;Devuelve una matriz asociativa de objetos COM activos,donde cada tecla es el apodo, artículo o sufijo del objeto.
;Si se especifica un prefijo, sólo los objetos cuyos apodos del elemento que coincida con el prefijo dado son devueltos, y el prefijo se omite de las teclas devueltas.
GetActiveObjects(Prefix:="", CaseSensitive:=false) { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=6494 || By Lexikos
    objects := {}
    DllCall("ole32.dll\CoGetMalloc", "UInt", 1, "Ptr*", malloc)
    DllCall("ole32.dll\CreateBindCtx", "UInt", 0, "Ptr*", bindCtx)
    DllCall(NumGet(NumGet(bindCtx+0)+8*A_PtrSize), "Ptr", bindCtx, "Ptr*", rot)
    DllCall(NumGet(NumGet(rot+0)+9*A_PtrSize), "Ptr", rot, "Ptr*", enum)
    while DllCall(NumGet(NumGet(enum+0)+3*A_PtrSize), "Ptr", enum, "UInt", 1, "Ptr*", mon, "Ptr", 0) = 0
    {
        DllCall(NumGet(NumGet(mon+0)+20*A_PtrSize), "Ptr", mon, "Ptr", bindCtx, "Ptr", 0, "Ptr*", pname) 
        name := StrGet(pname, "UTF-16")
        DllCall(NumGet(NumGet(malloc+0)+5*A_PtrSize), "Ptr", malloc, "Ptr", pname)
        if InStr(name, Prefix, CaseSensitive) = 1 {
            DllCall(NumGet(NumGet(rot+0)+6*A_PtrSize), "Ptr", rot, "Ptr", mon, "Ptr*", punk)
            if (pdsp := ComObjQuery(punk, "{00020400-0000-0000-C000-000000000046}"))
                obj := ComObject(9, pdsp, 1), ObjRelease(punk)
            else
                obj := ComObject(13, punk, 1)
            objects[SubStr(name, StrLen(Prefix) + 1)] := obj
        }
        ObjRelease(mon)
    }
    ObjRelease(enum), ObjRelease(rot), ObjRelease(bindCtx), ObjRelease(malloc)
    return objects
}

;Define el contenido de la variable de entorno especificada para el proceso actual .
EnvAdd(lpName, lpValue) {
	return DllCall("Kernel32.dll\SetEnvironmentVariableW", "Str", lpName, "Str", lpValue)
}	

;Recupera el contenido de la variable especificada desde el bloque de entorno del proceso invocador .
;ErrorLevel es:
	;0 = Sin errores | 1 = Error | 2 = La variable de entorno especificada no se encontró
EnvGet(EnvVarName, ByRef UserEnv := "", ByRef SystemEnv := "") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683188%28v=vs.85%29.aspx
	UserEnv := IsByRef( UserEnv ) ? RegRead( "HKCU\Environment", EnvVarName ) : ""
	SystemEnv := IsByRef( SystemEnv ) ? RegRead( "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", EnvVarName ) : ""
	if !( nSize := DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Ptr", 0, "UInt", 0) )
		return "", ErrorLevel := 2
	VarSetCapacity(lpBuffer, nSize * 2) ;max 32767
	if !DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Str", lpBuffer, "UInt", nSize)
		return "", ErrorLevel := 1
	return lpBuffer, ErrorLevel := 0
}

;Notifica el sistema operativo y todas las aplicaciones que se ejecutan que las variable(s) del sistema han cambiado .
EnvUpdate() {
    HWND_BROADCAST := 0xFFFF, WM_SETTINGCHANGE := 0x001A
	return DllCall("User32.dll\SendMessageTimeoutW", "Ptr", HWND_BROADCAST, "UInt", WM_SETTINGCHANGE, "Ptr", 0
		, "Str", "Environment", "UInt", 0x0002, "UInt", 5000, "UPtrP", 0)
}

;añadir al registro: para el usuario actual
UserEnvAdd(lpName, lpValue) {
	return RegWrite(, "HKCU\Environment", lpName, lpValue )
}

;añadir al registro: para todos los usuarios
SystemEnvAdd(lpName, lpValue) {
	return RegWrite(, "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", lpName, lpValue )
}

;cambiar fondo de pantalla
;La imagen debe ser: .BMP
SetDesktopBackground(Img_BMP) {
    if !IsFile( Img_BMP )
        return 0
    SPI_SETDESKWALLPAPER := 0x0014, SPIF_UPDATEINIFILE := 0x0001, SPIF_SENDWININICHANGE := 0x0002
    return DllCall("User32.dll\SystemParametersInfoW", "UInt", SPI_SETDESKWALLPAPER, "UInt", 0, "Str", Img_BMP, "UInt", SPIF_UPDATEINIFILE|SPIF_SENDWININICHANGE)
}

;recupera la ruta y el nombre completo del archivo/carpeta especificado
GetFullPathName(lpFileName) {
	lpFileName := Trim( lpFileName )
	if InStr( lpFileName, ":" ) AND (StrLen( lpFileName ) = 2)
		lpFileName .= "\"
	nBufferLength := DllCall("Kernel32.dll\GetFullPathNameW", "Str", lpFileName, "UInt", 0, "Ptr", 0, "PtrP", 0)
	VarSetCapacity( lpBuffer, nBufferLength * 2 ) 
	i := DllCall("Kernel32.dll\GetFullPathNameW", "Str", lpFileName, "UInt", nBufferLength, "Str", lpBuffer, "PtrP", 0)
	return RTrim( lpBuffer, "\" ), ErrorLevel := !i
}

;ACCIÓN AL CERRAR/ABRIR TAPA DEL PORTATIL
;Sintáxis: StartPSN( [FUNCIÓN] )
;registrar
StartPSN(Function := "WM_POWERBROADCAST") {
  VarSetCapacity(guid, 16)
  Numput(0xBA3E0F4D, guid, 0, "UInt"), Numput(0x4094B817, guid, 4, "UInt")
  Numput(0x63D5D1A2, guid, 8, "UInt"), Numput(0xF3A0E679, guid, 12, "UInt")
  if ( R := DllCall("User32.dll\RegisterPowerSettingNotification", "Ptr", A_ScriptHwnd, "Ptr", &guid, "UInt", 0) ) {
      OnMessage(0x218, Function)
      return R
  }
  return 0
}
;Sintáxis: StopPSN( [valor que devuelve StartPSN] )
;anular
StopPSN(H) {
  return DllCall("User32.dll\UnregisterPowerSettingNotification", "Ptr", H), OnMessage(0x218, "")
}
;acción a tomar al cerrar o abrir (función)
WM_POWERBROADCAST(wparam, lparam) {
  if (wparam = 0x8013) { ;PBT_POWERSETTINGCHANGE 32787 (0x8013) --> Identificador de sucesos.
      S := Numget(lparam + 20, 0, "uchar") ? 1 : 0 ;POWERBROADCAST_SETTING  --> https://msdn.microsoft.com/en-us/library/windows/desktop/hh448380%28v=vs.85%29.aspx
      MsgBox, 4160, PowerSettingNotification, Estado: %S%
  }
  return 1
}

ComVar() { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3964
	static base := {__Get: "ComVarGet", __Set: "ComVarSet", __Delete: "ComVarDel"}
	static ComObjParam := A_AhkVersion < "2" ? "ComObjParameter" : "ComObject"
	; Create an array of 1 VARIANT.  This method allows built-in code to take
	; care of all conversions between VARIANT and AutoHotkey internal types.
	arr := ComObjArray(0xC, 1)
	; Lock the array and retrieve a pointer to the VARIANT.
	DllCall("oleaut32\SafeArrayAccessData", "ptr", ComObjValue(arr), "ptr*", arr_data)
	; Store the array and an object which can be used to pass the VARIANT ByRef.
	return {ref: %ComObjParam%(0x400C, arr_data), _: arr, base: base}
}

ComVarGet(cv, p*) { ;Called when script accesses an unknown field.
	if p.MaxIndex() = "" ; No name/parameters, i.e. cv[]
		return cv._[0]
}

ComVarSet(cv, v, p*) { ;Called when script sets an unknown field.
	if p.MaxIndex() = "" ; No name/parameters, i.e. cv[]:=v
		return cv._[0] := v
}

ComVarDel(cv) { ;Called when the object is being freed.
	; This must be done to allow the internal array to be freed.
	DllCall("oleaut32\SafeArrayUnaccessData", "ptr", ComObjValue(cv._))
}

;establece datos en un Array
;NOTA: funcion reservada para las demás funciones en las que se necesite guardar datos
;			para agilizar el resultado la próxima ves que se la llame.
;Sintaxis: Set( [Var], [Valor] )
Set(Var, Value := "") {
	static Array := []
	if InVar( Var, "?,*,!" )
		return Var = "?" ? Array[Value] 
			: Var = "*" ? Array := Value
			: Var = "!" ? Array : ""
	if (Value = "")
		return Array.Delete(Var)
	return Value, Array[Var] := Value
}

;obtiene los datos establecidos por Set()
;Sintaxis: Get( [Var], [Valor (salida)] )
Get(Var, ByRef Value := "") {
	return Value := Set( "?", Var )
}

;obtener sugerencias de una palabra vía google
GoogleSuggest(query) { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=7182
	if !query
		return
    i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, i.Open("GET", "http://suggestqueries.google.com/complete/search?output=firefox&q=" query, 1)
		, i.Send(), i.WaitForResponse()
    s := StrReplace(i.ResponseText, Chr(34) ",[" Chr(34), "`r`n")
		, s := StrReplace(s, Chr(34) "," Chr(34), "`r`n"), s := StrReplace(s, Chr(34))
		, s := StrReplace(s, "["), s := StrReplace(s, "]"), s := StrReplace(s, query,,, 1)
	return StrReplace(s, "`r`n",,, 1)
}

;SendMessage
;Sintaxis: SendMessage( [hWnd], [mensaje], [wparam], [iparam], [wparam ptr|str|uint], [iparam ptr|str|uint], [tiempo fuera] )
SendMessage(hWnd, Msg, wParam := 0, IParam := 0, wType := 0, IType := 0, TimeOut := 5000) {
	w := wType ? wType : IsNumber( wParam ) ? "Ptr" : "Str"
	i := IType ? IType : IsNumber( IParam ) ? "Ptr" : "Str"
	return DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", Msg, w, wParam, i, IParam, "UInt", 0x0002, "UInt", TimeOut, "UPtrP", lpdwResult)
		, ErrorLevel := lpdwResult
}

;PostMessage
;Sintaxis: PostMessage( [hWnd], [mensaje], [wparam], [iparam], [wparam ptr|str|uint], [iparam ptr|str|uint] )
PostMessage(hWnd, Msg, wParam := 0, IParam := 0, wType := 0, IType := 0) {
	w := wType ? wType : IsNumber( wParam ) ? "Ptr" : "Str"
	i := IType ? IType : IsNumber( IParam ) ? "Ptr" : "Str"
	return hR := DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", Msg, w, wParam, i, IParam)
		, ErrorLevel := !hR
}

;Libera la biblioteca (DLL ) módulo cargado de vínculos dinámicos
FreeLibrary(hModule) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683152%28v=vs.85%29.aspx
	return DllCall("Kernel32.dll\FreeLibrary", "Ptr", hModule) 
}

;Carga los módulos especificados en el espacio de direcciones del proceso de llamada 
;el valor devuelto es un identificador para el módulo cargado
LoadLibrary(lpFileName, hFile := 0, dwFlags := 0) {
	return DllCall("Kernel32.dll\LoadLibraryExW", "Str", lpFileName, "UInt", hFile, "UInt", dwFlags) 
}

;Sintaxis: SetTimer( [etiqueta|funcion|0|1], [On(1)|Off(0)|Delete(D)] )
SetTimer(Label := "", PeriodOnOffDelete := 1) {
	if (Label = 0) OR (Label = 1) OR (Label = -1)
		PeriodOnOffDelete := Label = -1 ? "D" : Label, Label := A_ThisLabel
	PeriodOnOffDelete := PeriodOnOffDelete = 1 ? "On" 
		: PeriodOnOffDelete = 0 ? "Off"
		: PeriodOnOffDelete = "D" ? "Delete" : PeriodOnOffDelete
	SetTimer, %Label%, %PeriodOnOffDelete%
}

gosub(Label) {
	if !IsLabel(Label)
		return 0
	gosub, %Label%
	return Label
}

;esperar (ms)
Sleep(Delay := 0) {
	if (Delay >= -1)
		Sleep, %Delay%
}
Wait(Delay := 0) {
	static Frequency
	if !Frequency
		DllCall("Kernel32.dll\QueryPerformanceFrequency", "Int64*", Frequency)
	DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Start)
	Finish := Start + (Frequency * (Delay / 1000))
	Loop
		DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Current)
	until (Current >= Finish)
}

;reiniciar script
Reload() {
	Reload
}

;termina el script
;Sintaxis: ExitApp( [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
ExitApp(Force := 0, ExitCode := 0) {
	if (Force)
		ProcessClose( -1,,, ExitCode )
	ExitApp, %ExitCode%
}

;tiempo fuera en el que el script finaliza
;Sintaxis: ExitAppTimer( [segundos], [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
;EJEMPLO:
	;ExitAppTimer(5)
	;Loop {
		;ToolTip % ExitAppTimer()
		;Sleep 100
	;}
ExitAppTimer(Seconds := "", Force := 0, ExitCode := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=46906#p46906
    static ending
    if (Seconds = -1)
        ExitApp( Force, ExitCode )
    if !(Seconds > 0)
        return (ending - A_TickCount()) / 1000.0
    static fn := Func("ExitAppTimer").Bind( -1, Force, ExitCode )
    SetTimer( fn, Seconds * -1000 )
    ending := A_TickCount() + Seconds * 1000
}

;potapapeles
;Sintaxis: Clipboard( [texto], [¿copiar seleccionado al portapapeles? (segundos a esperar)] )
Clipboard(String := "", Selected := "") {
	if Selected {
		Temp := ClipboardAll
		Clipboard(), Send( "^c" ), ClipWait( Selected > 0 ? Selected : 1 )
		return Clipboard, Clipboard := Temp
	}
	if (String = "") {
		DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd)
		return DllCall("User32.dll\EmptyClipboard")
			, DllCall("User32.dll\CloseClipboard")
	}
	return Clipboard := String
}

;recupera el tiempo que ha pasado (ms) desde que el script se inició
GetTickCount(ByRef TickCount := "") {
	return TickCount := DllCall("Kernel32.dll\GetTickCount")
}

;espera a que el portapapeles contenga datos
;Sintaxis: ClipWait( [segundos], [¿cualquier tipo de datos?] )
ClipWait( Seconds := -1, AnyFormats := 1 ) {
	GetTickCount( StartTime )
	Loop {
		if AnyFormats AND DllCall("User32.dll\CountClipboardFormats")
			return 1, ErrorLevel := 0
		else if (!AnyFormats AND (DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 1) OR DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 15)))
				return 1, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds >= 0) AND (ElapsedTime >= Seconds)
			return 0, ErrorLevel := 1
		Sleep( 50 )
	}
}

;establecer directorio de trabajo
SetWorkingDir(DirName) {
	return DllCall("kernel32.dll\SetCurrentDirectoryW", "Str", DirName)
}

;obtener directorio de trabajo
GetWorkingDir() {
	uSize := VarSetCapacity(lpBuffer, (260 + 1) * 2) / 2
	DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt*", uSize, "Str", lpBuffer)
	return lpBuffer
}

;A_LastError
GetLastError(ByRef FormatMessage := "") {
	return LastError := DllCall("Kernel32.dll\GetLastError")
		, FormatMessage := IsByRef( FormatMessage ) ? FormatMessage( LastError ) : ""
}

;establece A_LastError
SetLastError(num) {
	return DllCall("User32.dll\SetLastErrorEx", "UInt", num, "UInt", 0)
}

;descripcion del error
FormatMessage(dwMessageId := "") {
	dwMessageId := dwMessageId != "" ? dwMessageId : GetLastError()
	nSize := VarSetCapacity(lpBuffer, 2024) - 1524
	if DllCall("Kernel32.dll\FormatMessageW", "UInt", 0x1000, "Ptr", 0, "UInt", dwMessageId, "UInt", 0x800, "Str", lpBuffer, "UInt", nSize, "UInt", 0)
		return lpBuffer
}

;ejecuta el script como administrador 
;establece la prioridad en Alta
;modifica los privilegios para el correcto funcionamiento del script
RunAsAdmin() {
	SetBatchLines, -1
	SetWorkingDir, %A_ScriptDir%
	SetTitleMatchMode, 2
	SetTitleMatchMode, Fast
	CoordMode, Mouse, Screen 
	ListLines, Off
	SetStoreCapslockMode, Off
	SetDefaultMouseSpeed, 0
	SendMode, Input 
	SetControlDelay, 10
	SetKeyDelay, 10, 10, 10
	SetMouseDelay, -1
	SetWinDelay, 50
	AutoTrim, On
	StringCaseSense, Off
	if !A_IsAdmin {
		Run, *RunAs "%A_ScriptFullPath%",, UseErrorLevel
		if !ErrorLevel
			ExitApp(1)
	}
	ProcessSetPrivilege( ProcessExist(-1), "SeDebugPrivilege", 1 )
	ProcessPriority( ProcessExist(-1), "High")
	;DllCall("Kernel32.dll\SetErrorMode", "UInt", 0x0001) ;AHK1.1.21.00+ (defecto)
}

FormatTime(Time, Format := "yyyyMMddHmmss") {
	FormatTime, hTime, %Time%, %Format%
	return hTime
}

;comprueba si existe un archivo o carpeta y obtiene la ruta completa.
Exist(ByRef Filename) {
	return i := FileExist( Filename )
		, Filename := RTrim(GetFullPathName( Filename ), "\")
		, ErrorLevel := !i
}

IniRead(Filename, Section := "", Key := "") {
	if (Key != "") AND (Section != "")
		IniRead, OutputVar, %Filename%, %Section%, %Key%, %A_Space% ;OutputVar
	else if (Key = "") AND (Section != "")
		IniRead, OutputVar, %Filename%, %Section% ;OutputVarSection
	else if (Key = "") AND (Section = "")
		IniRead, OutputVar, %Filename% ;OutputVarSectionNames
	return OutputVar
}

IniWrite(Value, Filename, Section, Key := "") {
	if (Key != "")
		IniWrite, %Value%, %Filename%, %Section%, %Key%
	else
		IniWrite, %Value%, %Filename%, %Section%
	return !ErrorLevel
}

IniDelete(Filename, Section, Key := "") {
	if (Key != "")
		IniDelete, %Filename%, %Section%, %Key%
	else
		IniDelete, %Filename%, %Section%
	return !ErrorLevel
}

Edit(Filename := -1, OpenWith := 0) {
	if (Filename = -1) {
		Edit
		return 1
	}
	if OpenWith
		Run, "%OpenWith%" "%Filename%",, UseErrorLevel, PID
	if ErrorLevel OR !OpenWith
		Run, Edit "%Filename%",, UseErrorLevel, PID
	return PID
}

;Thread, NoTimers [, false]
;Thread, Priority, n
;Thread, Interrupt [, Duration, LineCount]
Thread(Setting := "NoTimers", P2 := "", P3 := "") {
	Thread, %Setting%, %P2%, %P3%
}

;ejecutar script
;Sintaxis: ExecScript( [script], [parámetros], [ejecutableAHK], [nombre] )
ExecScript(Script, Params := "", AhkPath := "", Name := "") {
	Name := Name = "" ? "AutoHotKey" A_AhkVersion : Name, Pipe := []
	AhkPath := IsFile( AhkPath ) ? AhkPath : A_AhkPath
	Call := Chr(34) AhkPath Chr(34) " /CP65001 " Chr(34) "\\.\pipe\" Name Chr(34)
	Pipe[1] := DllCall("CreateNamedPipe", "Str", "\\.\pipe\" Name, "UInt", 2, "UInt", 0, "UInt", 255, "UInt", 0, "UInt", 0, "UPtr", 0, "UPtr", 0, "UPtr")
	Pipe[2] := DllCall("CreateNamedPipe", "Str", "\\.\pipe\" Name, "UInt", 2, "UInt", 0, "UInt", 255, "UInt", 0, "UInt", 0, "UPtr", 0, "UPtr", 0, "UPtr")
	Shell := ComObjCreate("WScript.Shell"), Exec := Shell.Exec(Call " " Params)
	DllCall("ConnectNamedPipe", "UPtr", Pipe[1], "UPtr", 0), DllCall("CloseHandle", "UPtr", Pipe[1])
	DllCall("ConnectNamedPipe", "UPtr", Pipe[2], "UPtr", 0), FileOpen(Pipe[2], "h", "UTF-8").Write( Script )
	return Exec, DllCall("CloseHandle", "UPtr", Pipe[2])
}




















;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: REGISTRO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;leer en el registro
;Sintáxis: RegRead( [Clave\SubClave], [Valor] )
RegRead(Key, ValueName*) {
	if (ValueName.MaxIndex() > 0)
		RegRead, OutputVar, %Key%, % ValueName[1]
	else
		RegRead, OutputVar, %Key%
	return OutputVar
}
	
;elimina en el registro
;Sintáxis: RegDelete( [Clave\SubClave], [Valor] )
;en caso de éxito devuelve la clave
RegDelete(Key, ValueName*) {
	if !Key
		return 0
	if (ValueName.MaxIndex() > 0) {
		if (ValueName[1] = "")
			return 0
		RegDelete, %Key%, % ValueName[1]
	} else
		RegDelete, %Key%
	return ErrorLevel ? 0 : Key
}
	
;escribe en el registro
;Sintáxis: RegWrite( [Tipo], [Clave\SubClave], [Valor], [Datos] )
;NOTA: 'Tipo' puede ser reemplazado por 'Clave\SubClave', se establece en REG_SZ
;EJEMPLOS:
	;RegWrite( "HKCC\2" )
	;RegWrite(, "HKCC\2", "RSZ", "VAL_RSZ" )
	;RegWrite( "TIPO INVÁLIDO", "HKCC\2", "RSZ2", "VAL_RSZ2" )
	;RegWrite( "REG_DWORD", "HKCC\2", "RDW", 1024 ** 3 )
RegWrite(ValueType := 0, Key := "", ValueName := "", Value := "") {
	if !InVar( ValueType, "REG_BINARY,REG_DWORD,REG_EXPAND_SZ,REG_MULTI_SZ,REG_SZ" )
		Key := Key ? Key : ValueType, ValueType := "REG_SZ"
	if !Key
		return 0
	if (ValueName = "")
		RegWrite, %ValueType%, %Key%,, %Value%
	else
		RegWrite, %ValueType%, %Key%, %ValueName%, %Value%
	return !ErrorLevel
}

;importar clave
;sintaxis: RegImport( [Archivo], [Esperar?] )
RegImport(Filename, Wait := 0) {
	if (Wait)
		RunWait, %A_WinDir%\regedit.exe -v -s "%Filename%"
	else
		Run, %A_WinDir%\regedit.exe -v -s "%Filename%"
	return ErrorLevel ? 0 : Filename
}
	
;exportar clave
;sintaxis: RegExport( [Archivo], [Clave], [Esperar?] )
RegExport(Filename, Key, Wait := 0) {
	Key := RegSKName(Key, 1)
	if (Wait)
		RunWait, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%"
	else
		Run, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%"
	return ErrorLevel ? 0 : Filename
}

;renombrar un valor/clave
;Sintaxis: RegRename( [clave], [valor], [nuevo nombre], [¿forzar?] )
;NOTA 1: para renombrar una clave, dejar vacio 'valor' (el segundo parámetro). Puede ser MUY LENTO dependiendo de las subclaves y valores
;NOTA 2: el cuarto parámetro (forzar) aumenta la precision. renombra la clave aún si no hay subclaves, valores ni valor por defecto, pero lo hace mas lento dependiendo la cantidad de claves hermanas y/o valores
;A_LastError SE ESTABLECE EN:
	;1 = error al renombrar el valor o la clave.
	;0 = sin errores
	;-1 = el valor o clave a renombrar no existe
	;-2 = ya existe un valor o clave con el mismo nombre
RegRename(Key, ValueName := "", NewName := "", Force := 0) {
	;-----------------------------------------------------------------------------------------------------------
	NewName := StrReplace(StrReplace(NewName, "["), "]") ;quitar '[' y ']' en el nuevo nombre
	if (NewName = "") ;sin nombre
		return 0, SetLastError( 1 )
	;-----------------------------------------------------------------------------------------------------------
	if (ValueName != "") { ; ::::::::::::::::: RENOMBRAR VALOR :::::::::::::::::
		if !( ValueType := RegExist(Key, ValueName, Force) ) ;si no existe el valor
			return 0, SetLastError( -1 )
		if RegExist(Key, NewName, Force) ;si ya existe un valor con el nuevo nombre
			return 0, SetLastError( -2 )
		ValueData := RegRead(Key, ValueName) ;leer datos
			, RegDelete(Key, ValueName) ;eliminar
			, RegWrite(ValueType, Key, NewName, ValueData) ;crear
		return !ErrorLevel, SetLastError( ErrorLevel )
	} 
	;-----------------------------------------------------------------------------------------------------------
	return RegCopy(Key, SplitPath(Key).Dir "\" NewName, Force), RegDelete( Key )
} ;-----------------------------------------------------------------------------------------------------------

RegMove(Key, KeyDest, Force := 0) {
	if !RegCopy(Key, KeyDest, Force)
		return 0
	return RegDelete( Key )
}

;copia una clave a otra nueva
;Sintaxis: Copy( [clave a copiar], [destino], [¿Forzar?] )
;A_LastError SE ESTABLECE EN:
	;1 = error al copiar
	;0 = sin errores
	;-1 = la clave a copiar no existe
	;-2 = la clave destino ya existe
RegCopy(Key, KeyDest, Force := 0) {
	Key := RegSKName(Key, 1, KeyLen)
	if !InStr(Key, "\") OR !InStr(KeyDest, "\") ;clave inválida
		return 0, SetLastError( 1 )
	if !RegExist(Key,, Force) ;la clave a renombrar no existe -1
			return 0, SetLastError( -1 )
	if RegExist(KeyDest,, Force) ;la clave destino ya existe
			return 0, SetLastError( -2 )
	DefaultValue := RegRead(Key) ;leer valor por defecto
	if !ErrorLevel
		RegWrite(, KeyDest,, DefaultValue) ;establecer valor por defecto
	Loop, Reg, %Key%, KVR ;busca claves(K) y valores(V) includas todas las subclaves(R)
	{
		if (A_LoopRegType = "KEY") { ;si es una clave
			SKey_ := KeyDest "\" RegExReplace(SubStr(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, (KeyLen + 2)), "\\+$")
				, RegWrite( SKey_ )
			if ErrorLevel
				return 0, SetLastError( 1 )
		} else if SKey_ { ;si es un valor
			DefaultValue := RegRead(A_LoopRegKey "\" A_LoopRegSubKey) ;leer valor por defecto
				, RegWrite(, SKey_,, DefaultValue) ;establecer valor por defecto
			if ErrorLevel
				return 0, SetLastError( 1 )
			ValueName := RegRead(A_LoopRegKey "\" A_LoopRegSubKey, A_LoopRegName) ;leer datos
				, RegWrite(A_LoopRegType, SKey_, A_LoopRegName, ValueName) ;establecer datos
			if ErrorLevel
				return 0, SetLastError( 1 )
		}
	}
	Loop, Reg, %Key%, V ;copiar valores
	{
		ValueData := RegRead(A_LoopRegKey "\" A_LoopRegSubkey, A_LoopRegName) ;leer datos
			, RegWrite(A_LoopRegType, KeyDest, A_LoopRegName, ValueData) ;establecer datos
		if ErrorLevel
			return 0, SetLastError( 1 )
	}
	return 1, SetLastError( 0 )
}

;comprueba si existe una clave o un valor
;NOTA 1: VALOR: devuelve el tipo de valor | CLAVE: devuelve la fecha de modificacion (solo si se usa 'forzar')
;NOTA 2: omite si no hay claves, valores y el valor por defecto es 'valor no establecido' (devuelve 0 como si no existiera)
;NOTA 3: para evitar lo anterior, debe establecer 'forzar' en 1, pero puede ser lento dependiendo la cantidad de claves hermanas
;Sintaxis: RegExist( [clave], [valor], [¿forzar?] )
RegExist(Key, ValueName := "", Force := 0) {
	;-----------------------------------------------------------------------------------------------------------
	if (ValueName != "") { ; :::::::::: COMPROBAR SI EXISTE UN VALOR ::::::::::::::::
		if Force { ;forzar
			Loop, Reg, %Key%, V
				if (A_LoopRegName = ValueName)
					return A_LoopRegType ? A_LoopRegType : 1
			return 0
		} ;normal
		RegRead(Key, ValueName)
		return !ErrorLevel
	} ;-----------------------------------------------------------------------------------------------------------
	if Force { ; ::::::::::::: COMPROBAR SI EXISTE UNA CLAVE ::::::::::::::
		SplitPath( Key, KeyName, Key_ ) ;forzar
		Loop, Reg, %Key_%, K
			if (A_LoopRegName = KeyName)
				return A_LoopRegTimeModified ? A_LoopRegTimeModified : 1
		return RegExist(Key)
	} ;normal
	Loop, Reg, %key%, KV
		return 1
	RegRead(key)
	return !ErrorLevel
} ;-----------------------------------------------------------------------------------------------------------

;transforma una clave en su forma larga/corta
;Sintaxis: RegSKName( [clave], [¿forma larga?] )
RegSKName(Key, Full := 0, ByRef Len := "") {
	Key := RegExReplace(Key, "^\s+"), Key := RegExReplace(Key, "\s+$")
	if ( KeyPos := InStr(Key, "\") )
		SubKey := "\" SubStr(Key, (KeyPos + 1))
			, Key := SubStr(Key, 1, KeyPos)
	Key := RegExReplace(Key, "[^a-zA-Z_]")
	if Full
		HKCR := "HKEY_CLASSES_ROOT", HKCC := "HKEY_CURRENT_CONFIG",  HKCU := "HKEY_CURRENT_USER", HKLM := "HKEY_LOCAL_MACHINE", HKU := "HKEY_USERS"
	else
		HKEY_CLASSES_ROOT := "HKCR", HKEY_CURRENT_CONFIG := "HKCC",  HKEY_CURRENT_USER := "HKCU", HKEY_LOCAL_MACHINE := "HKLM", HKEY_USERS := "HKU"
	return FullKey := ( ( %Key% ? %Key% : Key ) SubKey ), Len := IsByRef(Len) ? StrLen(FullKey) : ""
}

SetRegView(RegView_32or64 := "Default") {
	SetRegView, %RegView_32or64%
}

RegFNKey(Key, Force := 0, String := "(%A_Index%)") {
	tmpkey := 0, Key := Trim( Key )
	Loop {
		if RegExist( tmpkey ? tmpkey : Key,, Force ) {
			tmpkey := Key ( InStr(String, "%A_Index%") ? StrReplace(String, "%A_Index%", A_Index) : "(" A_Index ")" )
		} else {
			return tmpkey ? tmpkey : Key
		}
	}
}

;Copia la clave de registro especificada, junto con sus valores y subclaves, a la clave de destino especificada.
;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379768%28v=vs.85%29.aspx
RegCopyTree(Key, Dest) {
	;valores de las claves
	HKEY_CLASSES_ROOT := HKCR := 0x80000000
	HKEY_CURRENT_USER := HKCU := 0x8000000
	HKEY_LOCAL_MACHINE := HKLM := 0x80000002
	HKEY_USERS := HKU := 0x80000003
	HKEY_CURRENT_CONFIG := HKCC := 0x80000005
	
	;inicio: clave\subclave
	Key := Trim( Key ), Pos := InStr( Key, "\" )
	SubKey := Pos ? StrTrimLeft( Key, Pos ) : "" ;subclave
	Key := Pos ? StrLeft( Key, Pos - 1 ) : Key ;clave
	
	Dest := Trim( Dest ), Pos2 := InStr( Dest, "\" )
	SubKey2 := Pos2 ? StrTrimLeft( Dest, Pos2 ) : "" ;subclave
	Key2 := Pos2 ? StrLeft( Dest, Pos2 - 1 ) : Dest ;clave
	
	;abrir la clave
	if !DllCall("Advapi32.dll\RegOpenKeyExW", "Ptr", %Key%, "Ptr", &SubKey, "UInt", 0, "UInt", 0x20019, "Ptr", hKey)
		return 0, ErrorLevel := 2 ;ErrorLevel es 2 si ha ocurrido un error al abrir la clave a copiar
	
	;crear clave destino, si ya existe la abre
	if !DllCall("Advapi32.dll\RegCreateKeyExW", "Ptr", %Key2%, "Ptr", &SubKey2, "UInt", 0, "Ptr", 0, "UInt", 0, "UInt", 0x0004, "Ptr", 0, "Ptr", hKey2, "Ptr", 0)
		return 0, ErrorLevel := 3 ;ErrorLevel es 3 si ha ocurrido un error al abrir/crear la clave destino

	;copiar clave
	if !DllCall("Advapi32.dll\RegCopyTreeW", "Ptr", hKey, "Ptr", 0, hKey2)
		return 0, ErrorLevel := 1 ;ErrorLevel es 1 si ha ocurrido un error al copir la clave
	
	;cerrar clave
	if (SubKey != "")
		DllCall("Advapi32.dll\RegCloseKey", "Ptr", hKey)
		, DllCall("Advapi32.dll\RegCloseKey", "Ptr", hKey2)
	
	return 1, ErrorLevel := 0
}



































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: GUI & DIALOGOS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: InputBox( [Título], [Texto], [Defecto], [Tiempo Fuera (seg)], [Opciones para el Edit]] )
;ErrorLevel es:
	;0 = el usuario precionó Aceptar
	;1 = el usuario precionó Cancelar o Cerrar
	;2 = la ventana ya existe
	;3 = se ha alcanzado el tiempo máximo para la ventana
InputBox(Title, Text, Default := "", Timeout := 0, EditOptions := "") {
	;inicio
	global _InputBoxResult, _InputBoxErrorLevel, _InputBoxId, _InputBoxInfoText
	_InputBoxResult := _InputBoxErrorLevel := _InputBoxId := ""
	
	;comprueba si ya existe la ventana
	if IsWindow( _InputBoxHWND )
		return "", ErrorLevel := 2
	
	;interfaz
	Gui, _InputBoxGuiName:-Caption +ToolWindow +OwnDialogs +LastFound +HWND_InputBoxHWND +AlwaysOnTop +MinSize420x217 +MaxSize%A_ScreenWidth%x%A_ScreenHeight%
		_InputBoxId := _InputBoxHWND
	Gui, %_InputBoxHWND%:Color, White
	Gui, %_InputBoxHWND%:Margin, 0, 0
	Gui, %_InputBoxHWND%:Font, s12 w600 Q5, Times New Roman
	Gui, %_InputBoxHWND%:Add, Button, x0 y0 w%A_ScreenWidth% h30 HWND_InputBoxTitle Disabled +Left, % " " Title
		GuiButtonStyle( _InputBoxTitle, 7 )
	Gui, %_InputBoxHWND%:Add, Text, x0 y0 w350 h30 g_InputBoxTMove BackgroundTrans
	Gui, %_InputBoxHWND%:Font, s12 w400, Courier New
	Gui, %_InputBoxHWND%:Add, Button, x388 y2 w30 h25 HWND_InputBoxClose g_InputBoxClose, X
		GuiButtonStyle( _InputBoxClose, 3 )
	Gui, %_InputBoxHWND%:Add, Button, x357 y2 w30 h25 HWND_InputBoxMax g_InputBoxMax, % Chr(9794)
		GuiButtonStyle( _InputBoxMax, 4 )
	Gui, %_InputBoxHWND%:Font, s10 w400, Arial
	Gui, %_InputBoxHWND%:Add, Edit, x5 y155 w410 h25 HWND_InputBoxResult v_InputBoxResult %EditOptions%, %Default%
		AttachEditControlText( _InputBoxResult, " " Default ) 
	Gui, %_InputBoxHWND%:Add, Text, x5 y35 w410 h115 v_InputBoxInfoText g_InputBoxInfoText, %Text%
	Gui, %_InputBoxHWND%:Font, s11 w500, Times New Roman
	Gui, %_InputBoxHWND%:Add, Button, x212 y185 w95 h27 HWND_InputBoxAccept g_InputBoxAccept Default, Aceptar
		GuiButtonStyle( _InputBoxAccept, 8 )
	Gui, %_InputBoxHWND%:Add, Button, x320 y185 w95 h27 HWND_InputBoxCancel g_InputBoxClose, Cancelar
		GuiButtonStyle( _InputBoxCancel, 8 )
	Gui, %_InputBoxHWND%:Show, w420 h217
	
	;esperar a que la ventana cierre
	if !WinWaitClose( _InputBoxHWND, Timeout ) {
		Gui, %_InputBoxHWND%:Destroy
		return "", ErrorLevel := 3
	}
	
	;devuelve el resultado
	return _InputBoxResult, ErrorLevel := _InputBoxErrorLevel
		, _InputBoxErrorLevel := _InputBoxId := _InputBoxInfoText := ""
	;-------------------------------------------------------------------------------------------------------------------------------------
	
	;ajustar tamaño de la ventana
	_InputBoxGuiNameGuiSize:
	Gui, %_InputBoxId%:Default
	GuiControl, Move, Button2, % "x" (A_GuiWidth - 32)
	GuiControl, Move, Button3, % "x" (A_GuiWidth - 63)
	GuiControl, MoveDraw, Button4, % "x" (A_GuiWidth - 210) " y" (A_GuiHeight - 32)
	GuiControl, MoveDraw, Button5, % "x" (A_GuiWidth - 100) " y" (A_GuiHeight - 32)
	GuiControl, Move, Static1, % "w" (A_GuiWidth - 70)
	GuiControl, MoveDraw, Static2, % "w" (A_GuiWidth - 10) " h" (A_GuiHeight - 102)
	GuiControl, MoveDraw, Edit1, % "y" (A_GuiHeight - 60) " w" (A_GuiWidth - 10)
	return

	;texto
	_InputBoxInfoText:
	Gui, %_InputBoxId%:Default
	GuiControl, Focus, _InputBoxInfoText
	return
	
	;boton Titulo (mover ventana)
	_InputBoxTMove:
	Gui, %_InputBoxId%:Default
	GuiControl, Focus, _InputBoxInfoText
	DllCall("User32.dll\PostMessageW", "Ptr", _InputBoxId, "UInt", 0xA1, "Ptr", 2, "Ptr", 0)
	return
	
	;boton Cerrar y Cancelar
	_InputBoxClose:
	Gui, %_InputBoxId%:Default
	GuiControlGet, _InputBoxResult
	_InputBoxErrorLevel := 1
	Gui, %_InputBoxId%:Destroy
	return
	
	;boton Cambiar Tamaño Si/No (habilita a la ventana para cambiar el tamaño)
	_InputBoxMax:
	if !_InputBoxErrorLevel
		Gui, %_InputBoxId%: +Resize
	else
		Gui, %_InputBoxId%: -Resize
	_InputBoxErrorLevel := !_InputBoxErrorLevel
	return
	
	;boton Aceptar
	_InputBoxAccept:
	Gui, %_InputBoxId%:Default
	GuiControlGet, _InputBoxResult
	_InputBoxErrorLevel := 0
	Gui, %_InputBoxId%:Destroy
	return
}

;Sintaxis: ToolTip( [texto], [tiempo fuera (seg)] )
ToolTip(Text := "", TimeOut := 0) {
	if (Text = "") {
		ToolTip,,,, 20
		return
	}
	ToolTip, %Text%,,, 20
	if (TimeOut > 0)
		SetTimer( Func("ToolTip").Bind(), -(TimeOut*1000) )
}

;TrayTip( [titulo], [texto], [tiempo fuera (seg)], [opciones] )
;OPCIONES:
	;0 = sin icono | 1 = Info (defecto) | 2 = Advertencia | 3 = Error
	;M = sin sonido (0M, 1M, 2M, 3M)
TrayTip(Title := "", Text := "", TimeOut := 0, Options := 1) {
	RegWrite( "REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "EnableBalloonTips", 2 )
	RegWrite( "REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "Start_NotifyNewApps", 1 )
	if (Text = "") AND (Title = "") {
		TrayTip
		return 1
	}
	TrayTip, %Title%, %Text%, 30, % InStr(Options, "M") ? RegExReplace(Options, "[^0-9]") + 16 : RegExReplace(Options, "[^0-9]")
	if (TimeOut > 0)
		SetTimer( Func("TrayTip").Bind(), -(TimeOut*1000) )
}

;mensaje
;Sintaxis: MsgBox( [titulo], [texto], [tipo], [icono], [modalidad] )
;NOTAS: 
	;A_LastError se establece en 0 si se eligió OK, YES, CONTINUE o IGNORE. Caso contrario, se establece en 1
	;ErrorLevel se establece en 1 si ha ocurrido algún error. Caso contrario, se establece en 0
	;devuelve 0 si ha ocurrido algún error, caso contrario devuelve la opcion elegida
;TIPOS:
	;OkCancel / OC = boton cancelar
	;YesNo / YN = botones si y no
	;RetryCancel / RC = botones reintentar y cancelar
	;YesNoCancel / YNC = botones si, no y cancelar
	;CancelTryContinue / CTC = botones cancelar, volver a intentar y continuar
	;AbortRetryIgnore / ARI = botones abortar/anular, reintentar e ignorar/omitir
	;+[1 / 2 / 3 / 4] = boton por defecto, espesificar un Número
;ICONOS:
	;Warning / W = atención
	;Info / I = informacion 
	;Question / Q = pregunta
	;Error / E = error
;MODALIDADES:
	;TopMost / TM / A / AOT = siempre al frente
	;System / S = Sistema. Siempre al frente
	;Task / T
;EJEMPLOS:
	;MsgBox % "Resultado: " MsgBox( "Ejemplo, MsgBox", "Tipo: Abortar/Anular, Reintentar, Ignorar/Omitir`nIcono: Atención`nBotono por defecto: 2 (reintentar)", "ARI 2", "W", "S" )
	;MsgBox( "Texto" )
MsgBox(lpCaption := "", ByRef lpText := "", uType := "", Icon := "", Mode := "") {
	;resultado
	r1 := "Ok", r2 := "Cancel", r3 := "Abort", r4 := "Retry", r5 := "Ignore"
	, r6 := "Yes", r7 := "No", r10 := "TryAgain", r11 := "Continue"
	
	;A_LastError: resultado
	e1 := e6 := e11 := e5 := 1
	
	;inicio
	if !IsByRef( lpText ) AND (lpText = "") AND (lpCaption != "")
		lpText := lpCaption, lpCaption := A_ScriptName
	uType := RegExReplace(uType, "\s"), Icon := RegExReplace(Icon, "\s"), Mode := RegExReplace(Mode, "\s")
	, Default := RegExReplace(uType, "[^0-9]"), uType := RegExReplace(uType, "[0-9]"), uType := uType ? uType : "_"
	, Default := Default ? Default : 1, Icon := Icon ? Icon : "_", Mode := Mode ? Mode : "_"
	
	;boton por defecto
	b1 := 0x00000000, b2 := 0x00000100, b3 := 0x00000200, b4 := 0x00000300
	
	;tipos
	tCancelTryContinue := tCancelContinueTry := tContinueCancelTry := tContinueTryCancel := tTryCancelContinue := tTryContinueCancel := 0x00000006
	, tCTC := tCCT := tTCC := 0x00000006, tARI := tAIR := tRAI := tRIA := tIAR := tIRA := 0x00000002, tYNC := tYCN := tNCY := tNYC := tCYN := tCNY := 0x00000003
	, tAbortRetryIgnore := tAbortIgnoreRetry := tRetryAbortIgnore := tRetryIgnoreAbort := tIgnoreAbortRetry := tIgnoreRetryAbort := 0x00000002
	, tYesNoCancel := tYesCancelNo := tNoCancelYes := tNoYesCancel := tCancelYesNo := tCancelNoYes := 0x00000003
	, tOkCancel := tCancelOk := tOC := tCO := 0x00000001, tRetryCancel := tCancelRetry := tCR := tRC := 0x00000005, tYesNo := tNoYes := tNY := tYN := 0x00000004
 
	;icono
	iExclamation := iEx := iWarning := iW := 0x00000030, iInfo := iI := 0x00000040
	, iQuestion := iQ := 0x00000020, iStop := iS := iError := iE := 0x00000010

	;modalidad 
	mSystem := mS := 0x00001000, mTask := mT := 0x00002000, mTopMost := mTM := mA := mAOT := 0x00040000
	
	;opciones
	uIcon := i%Icon% ? i%Icon% : 0x00000000 ;icono
	, uType := t%uType% ? t%uType% : 0x00000000 ;botones
	, uDefault := b%Default% ? b%Default% : 0x00000000 ;boton por defecto
	, uModal := m%Mode% ? m%Mode% : 0x00000000 ;modalidad

	hMsg := DllCall("User32.dll\MessageBoxW", "Ptr", A_ScriptHwnd, "Str", lpText, "Str", lpCaption, "UInt", uType|uIcon|uDefault|uModal) 
	return r%hMsg% ? r%hMsg% : 0 ;resultado
		, ErrorLevel := r%hMsg% ? 0 : 1 ;establece ErrorLevel 0|1
		, SetLastError( e%hMsg% ? 0 : 1 ) ;establece A_LastError 0|1
}

;estilo para los botones.
GuiButtonStyle(hWnd, Type := 1, Round := 0) { ;https://github.com/AHK-just-me/Class_ImageButton
   ;------------------------------------------------------------------------------------------------------------------------------
   if (Type = 1) { ;estilo blanco y celeste #1
		Normal := [0, 0x80F0F0F0,, 0xD3000000, Round,, 0x800099CC, 1]
		Foco := [0, 0x8033B5E5,, 0x00FFFFFF, Round,, 0x800099CC, 1]
		Precionado := [0, 0x801A9CCB,, 0x00FFFFFF, Round,, 0x800099CC, 1]
		Deshabilitado := [0, 0x80F0F0F0,, 0x00DFDFDF, Round,, 0x80A7A7A7, 1]
		Fallido := [0, 0x80F0F0F0,, 0xD3000000, Round,, 0x800099CC, 1]
		Tab := [0, 0x80F0F0F0,, 0xD3000000, Round,, 0x800099CC, 1]
   ;------------------------------------------------------------------------------------------------------------------------------
   } else if (Type = 2) { ;estilo grises, negros y blancos #1
		Normal := [7, 0x00383838, 0x00757575, 0x00CCCCCC, Round]
		Foco := [7, 0x00383838, 0x00858585, 0x00FFFFFF, Round]
		Precionado := [7, 0x00383838, 0x00AAAAAA, 0x00FFFFFF, Round]
		Deshabilitado := [7, 0x00AAAAAA, 0x00AAAAAA, 0x00FFFFFF, Round]
   } else if (Type = 3) { ;boton cerrar #1
		Normal := [0, 0x1CA7EF,, 0xCCCCCC]
		Foco := [0, 0xFF7171,, 0xffffff]
		Precionado := [0, 0xFF0000,, 0xffffff]
   } else if (Type = 4) { ;boton minimizar #1
		Normal := [0, 0x1CA7EF,, 0xCCCCCC]
		Foco := [0, 0xC0C0C0,, 0xffffff]
		Precionado := [0, 0x808080,, 0xffffff]
   } else if (Type = 5) { ;boton verde #1
		Normal := [3, 0x46cc9b, 0x228731, "White", 4]
		Foco := [3, 0x5bf0b9, 0x35bd47, "White", 4]
		Precionado := [3, 0x228731, 0x46cc9b, "White", 4]
		Deshabilitado := [0, 0xF0F0EE,, 0xCACBC2, 4,, 0xCACBC2, 1]
   } else if (Type = 6) { ;boton rojo #1
        Normal := [3, 0xFF4A4A, 0xCC0000, "White", 4]
        Foco := [3, 0xFF6A6A, 0xFF2424, "White", 4]
        Precionado := [3, 0xEA0000, 0x9B0000, "White", 4]
        Deshabilitado := [0, 0xF0F0EE,, 0xCACBC2, 4,, 0xCACBC2, 1]
   } else if (Type = 7) { ;fondo celeste, texto blanco
        Normal := Deshabilitado := [0, 0x1CA7EF,, 0xffffff]
   } else if (Type = 8) { ;botones celeste y blanco
		Normal := [0, 0x1CA7EF,, 0xffffff]
		Foco := [0, 0x6AB5FF,, 0xffffff]
		Precionado := [0, 0x808080,, 0xffffff]
	}
	
   ;------------------------------------------------------------------------------------------------------------------------------
   return ImageButton.Create(hWnd, Normal, Foco, Precionado, Deshabilitado, Fallido, Tab)
}

;establece texto por defecto a un control de edicion (edit)
;Sintaxis: AttachEditControlText( [control hwnd], [texto] )
AttachEditControlText(hWnd, Text) {
	return DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", 0x1501, "Ptr", 1
		, "Str", Text, "UInt", 0x0002, "UInt", 3000, "UPtrP", 0)
}

;establece un cursor cuando el mouse se posiciona sobre un control
;Sintaxis: AttachCursorControl( [Control HWND], [Tipo de cursor (ver funcion)] )
AttachCursorControl(Control, CursorType) { ;http://ahkscript.org/boards/viewtopic.php?p=48060#p48060
	;tipos de cursores
	Hand := 32649 ;mano
	Flecha := 32512 ;flecha normal
	AppStarting := 32650 ;flecha normal + reloj de arena (cargando)
	CrossHair := 32515 ;punto de mira (cruz)
	Help := 32651 ;flecha y signo de interrogación
	Edit := 32513 ;barra vertical de edición
	no := Slashed := 32648 ;bloqueado (círculo)
	SizeAll := 32642 ;ajustar tamaño (norte, sur, este, oeste)
	SizeNESW := 32643 ;ajustar tamaño (noreste, sudoeste)
	SizeNS := 32645 ;ajustar tamaño (norte, sur)
	SizeNWSE := 32642 ;ajustar tamaño (noroeste, sudeste)
	SizeEWE	:= 32644 ;ajustar tamaño (este, oeste)
	UpArrow := 32516 ;flecha hacia arriba
	Wait := 32514 ;reloj de arena (cargando)
	;tipo de cursor a establecer
	CursorType := %CursorType% ? %CursorType% : %Flecha%
	;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648391%28v=vs.85%29.aspx
	return hCursor := DllCall("User32.dll\LoadCursorW", "Ptr", 0, "Int", CursorType)
		, hFunc := Func("AttachCursorControl_Internal").Bind( Control, hCursor )
		, OnMessage( 0x0200, hFunc )
}
AttachCursorControl_Internal(Control, hCursor) {
	MouseGetPos,,,, MouseControlHWND, 2
	if (Control = MouseControlHWND)
		DllCall("User32.dll\SetCursor", "Ptr", hCursor)
}

GuiControlGetHwnd(ControlId) {
	GuiControlGet, hWnd, HWND, %ControlId%
	return hWnd
}

;Sintaxis: GuiControlMove( [control], [X|Y|W|H], [¿redibujar?] )
GuiControlMove(ControlId, XYWH, Redraw := 0) {
	GuiControl, % Redraw ? "MoveDraw" : "Move", %ControlId%, %XYWH%
	return !ErrorLevel
}

GuiControlRedraw(ControlId*) {
	Loop, % ControlId.MaxIndex()
		GuiControl, MoveDraw, % ControlId[ A_Index ]
	return !ErrorLevel
}

GuiControlShow(ControlId*) {
	Loop, % ControlId.MaxIndex()
		GuiControl, Show, % ControlId[ A_Index ]
	return !ErrorLevel
}

GuiControlHide(ControlId*) {
	Loop, % ControlId.MaxIndex()
		GuiControl, Hide, % ControlId[ A_Index ]
	return !ErrorLevel
}

;cambiar fuente de un control
;GuiFont( [control], [opciones], [fuente] )
;OPCIONES: c[color] | s[tamaño] | w[negrita 1~1000 nor=400 neg=700] | q[calidad 1~5]
GuiControlSetFont(hWnd, Type, Font) {
   Gui, Font, %Type%, %Font%
   GuiControl, Font, %hWnd%
}

;habilitar/deshabilitar el arrastre de archivos a la ventana
;Sintaxis: GuiDragAndDrop( [GUI_HWND], [0|1] )
GuiDragAndDrop(hWnd, Mod := 1) {
   Gui, % hWnd ":" (Mod ? "+" : "-") "E0x10"
}

;obtener el texto de un control
GuiControlGetText(hWnd) {
   ControlGetText, Text,, ahk_id %hWnd%
   return Text
}

GuiControlGetPos(hWnd) {
	GuiControlGet, pos, pos, %hWnd%
	i := {}, i.w := posW, i.h := posH, i.x := posX, i.y := posY
	return i
}

;obtener el tipo de control
GuiControlType(hWnd) {
   return WinGetClass( hWnd )
}

GuiControlIsVisible(hWnd) {
   GuiControlGet, OutputVar, Visible, %hWnd%
   return OutputVar
}

GuiControlIsEnabled(hWnd) {
   GuiControlGet, OutputVar, Enabled, %hWnd%
   return OutputVar
}

GuiMove(hWnd := 0) {
	PostMessage, 0xA1, 2, 0,, % "ahk_id " (hWnd ? hWnd : IsWindow( -1 ))
}

SB_GetText(hWnd, PartN := 1) {
	StatusBarGetText, Text, %PartN%, ahk_id %hWnd%
	return Text
}

;ListView: establece el estilo
;Sintaxis: LV_SetExStyle( [hWnd], [Estilo], [Remover = 0] )
;ESTILOS:
	;0x010000 = dibujo vía doble búfer, lo que reduce el parpadeo
	;0x00000004 = activa las casillas de verificación para los elementos (checkbox)
	;0x00000001 = muestra líneas de cuadrícula alrededor de los elementos y subelementos (grid)
LV_SetExStyle(hWnd, wParam, lParam := "*") {
	hWnd := GuiControlGetHwnd( hWnd )
	lParam := lParam = "*" ? wParam : lParam
	return DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", 0x1036, "UInt", wParam
		, "UInt", lParam, "UInt", 0x0002, "UInt", 3000, "UPtrP", 0)
}

LV_Set( Row := 0, Flags := "+Select", Type := -1 ) {
	if (Type != -1) {
		RowNumber := 0
		while ( RowNumber := LV_GetNext(RowNumber, Type = "F" ? "F" : Type = "C" ? "C" : "") )
			if (Row > 0) AND (Row != RowNumber)
			continue
		else
			LV_Modify(A_Index, Flags), List .= A_Index ","
	} else {
		Loop, % LV_GetCount( Type )
			if (Row > 0) AND (Row != A_Index)
				continue
			else
				LV_Modify(A_Index, Flags), List .= A_Index ","
	}
	return RTrim( List, "," )
}

















































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: LISTA DE IMÁGENES (ImageList) ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;elimina una lista de imágenes 
;Sintaxis: IL_Destroy( [ID] )
IL_Destroy(ImageList) {
	i := DllCall("Comctl32.dll\ImageList_Destroy", "Ptr", ImageList)
	return i, ErrorLevel := !i
}

;elimina una imagen de una lista de imágenes
;Sintaxis: IL_Remove( [ID], [Posición] )
;NOTA: si el segundo parametro es 0, elimina todas las imágenes
IL_Remove(ImageList, Pos := 0) {
	i := DllCall("ComCtl32.dll\ImageList_Remove", "Ptr", ImageList, "Int", Pos - 1)
	return i, ErrorLevel := !i
}

;crea una lista de imágenes 
;Sintaxis: IL_Create( [cantidad inicial], [aumento al pasar el limite], [¿iconos grandes?] )
IL_Create( InitialCount := 2, GrowCount := 5, LargeIcons := 0 ) {
	;ancho
	SM_CXICON := 11 ;el ancho predeterminada de un icono, en píxeles
	SM_CXSMICON := 49 ;el ancho recomendado de un icono pequeño, en píxeles
		nIndex := LargeIcons ? SM_CXICON : SM_CXSMICON
		cx := DllCall("User32.dll\GetSystemMetrics", "Int", nIndex)

	;alto
	SM_CYICON := 12 ;la altura predeterminada de un icono, en píxeles
	SM_CYSMICON := 50 ;la altura recomendada de un icono pequeño, en píxeles
		nIndex := LargeIcons ? SM_CYICON : SM_CYSMICON
		cy := DllCall("User32.dll\GetSystemMetrics", "Int", nIndex)

	;crear la lista de imagenes
	i := DllCall("Comctl32.dll\ImageList_Create", "UInt", cx ;el ancho en píxeles de cada imagen
		, "UInt", cy ;la altura en píxeles de cada imagen .
		, "UInt", 0x00000001|0x00000020 ;opciones
		, "Int", InitialCount ;el número de imágenes que la lista de imágenes contiene inicialmente
		, "Int", GrowCount) ;el número de iconos por el que la lista crecerá cada ves que se supere el limite
	return i, ErrorLevel := !i
}

;crea un duplicado de una lista de imágenes existente
;Sintaxis: IL_Duplicate( [ID] )
IL_Duplicate(ImageList) {
	i := DllCall("Comctl32.dll\ImageList_Duplicate", "Ptr", ImageList)
	return i, ErrorLevel := !i
}

;recupera el número de imágenes en una lista de imágenes
;Sintaxis: IL_GetCount( [ID] )
IL_GetCount(ImageList) {
	i := DllCall("ComCtl32.dll\ImageList_GetImageCount", "Ptr", ImageList)
	return i, ErrorLevel := !i
}

;recupera las dimensiones de las imágenes en una lista de imágenes
;NOTA: todas las imágenes tienen las mismas dimensiones
;Sintaxis: IL_GetSize( [ID], [Ancho (pixeles)], [Alto (pixeles)] )
IL_GetSize(ImageList, ByRef Width := "", ByRef Height := "") {
	i := DllCall("ComCtl32.dll\ImageList_GetIconSize", "Ptr", ImageList, "IntP", Width, "IntP", Height)
	s := {}, s.h := s.Height := Height
	s.w := s.Width := Width
	return s, ErrorLevel := !i
}































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: CONTROL ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
ControlHide(hWnd, ControlId*) {
	Loop, % ControlId.MaxIndex()
		Control, Hide,, ControlId[ A_Index ], ahk_id %hWnd%
	return !ErrorLevel
}

ControlShow(hWnd, ControlId*) {
	Loop, % ControlId.MaxIndex()
		Control, Show,, ControlId[ A_Index ], ahk_id %hWnd%
	return !ErrorLevel
}

ControlSend( hWnd, Control, Keys, Count := 1, Delay := 0 ) {
	ok := 0
	Loop, %Count% {
		ControlSend, %Control%, %Keys%, ahk_id %hWnd%
		ok := ErrorLevel ? ok : ok + 1
		Sleep( Delay > 0 ? Delay : 0 )
	}
	return ok, ErrorLevel := ok = Count ? 0 : 1
}

ControlSendRaw( hWnd, Control, Keys, Count := 1, Delay := 0) {
	return ControlSend( hWnd, Control, "{raw}" Keys, Count, Delay )
}

;Sintaxis: ControlFocus( [Control], [ID] )
ControlFocus( Control, hWnd ) {
	Control := ControlGetHwnd( Control, hWnd )
	CurrentThreadId := ProcessExist( -2 )
	WinGetPID( hWnd, WinThreadId )
	DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 1)
	return i := DllCall("User32.dll\SetFocus", "Ptr", Control)
		, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 0)
		, ErrorLevel := !i
}

ControlGetHwnd(Control, hWnd) {
	ControlGet, ControlHwnd, hWnd,, %Control%, ahk_id %hWnd%
	return ControlHwnd
}

;establecer texto
;Sintaxis: ControlSetText( [Control], [Texto], [ID] )
ControlSetText(Control, NewText, hWnd) {
	Control := ControlGetHwnd( Control, hWnd )
	return i := DllCall("User32.dll\SendMessageTimeoutW", "Ptr", Control, "UInt", 0x000C, "Ptr", 0, "Str", NewText, "UInt", 0x0002, "UInt", 3500, "UPtrP", 0)
		, ErrorLevel := !i
}

;obtener texto
;Sintaxis: ControlGetText( [Control, [ID] )
ControlGetText(Control, hWnd) {
	Control := ControlGetHwnd( Control, hWnd )
	DllCall("User32.dll\SendMessageTimeoutW", "Ptr", Control, "UInt", 0x000E, "Ptr", 0, "Ptr", 0, "UInt", 0x0002, "UInt", 3500, "UPtrP", nSize)
	nSize := VarSetCapacity( IpText, (nSize + 1) * 2, 0 ) / 2
	i := DllCall("User32.dll\SendMessageTimeoutW", "Ptr", Control, "UInt", 0x000D, "UInt", nSize, "Str", IpText, "UInt", 0x0002, "UInt", 3500, "UPtrP", 0)
	return IpText, ErrorLevel := !i
}


































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: MOUSE Y TECLADO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Envia pulsaciones de teclado clics del ratón a la ventana activa.
;se aplica a: Send, SendInput, SendRaw
;Sintaxis: Send( [Texto], [¿Repetir?], [Retraso en cada repeticion (ms)] )
Send(Keys, Count := 1, Delay := -2) {
	if !(ok := 0) AND (Count <= 1) {
		SendInput, %Keys%
		return !ErrorLevel, Sleep( Delay )
	}
	Loop, %Count%
		ok += Send( Keys,, A_Index = Count ? -2 : Delay )
	return ok, ErrorLevel := ok = Count ? 0 : 1
}
SendInput(Keys, Count := 1, Delay := 0) {
	return Send( Keys, Count, Delay )
}

SendRaw(Keys, Count := 1, Delay := 0) {
	return Send( "{raw}" Keys, Count, Delay )
}

;espera por una tecla a ser precionada o liberada
;Sintaxis: KeyWait( [tecla], [opciones], [tiempo fuera en segundos] )
;OPCIONES:
	;D = espera a que la tecla sea precionada
	;[Vacío] (defecto) = espera a que la tecla sea liberada por el usuario
KeyWait(KeyName, Options := "", TimeOut := 0) {
	KeyWait, %KeyName%, % Options (TimeOut ? " T" TimeOut : "")
	return !ErrorLevel
}

;Activa o desactiva la función de rastros del mouse
;Sintáxis: MouseTrails( [Número o dejar vacio para recuperar el estado actual.] )
;Nota: especifique un número mayor a 1 para activar. para desactivar especifique 0 o 1
;Ejemplos: Mouse.Trails( 10 ) | Mouse.Trails( 0 ) | Mouse.Trails(  )
MouseTrails(N := "") {
	if (N != "")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005D, "UInt", N, "Str", 0, "UInt", 0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005E, "UInt", 0, "UIntP", N, "UInt", 0)
	return N
}

;cambiar el cursor. Sintáxis: MouseSetCursor( [Tipo / Opcion], [Tipo / Cursor] )
MouseSetCursor(T := "R", C := "") { ;http://ahkscript.org/boards/viewtopic.php?f=5&t=6860
	if (T = "R") AND (C = "") { ;restaurar los cursores del sistema. Cursor("R")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x57, "UInt", 0, "UInt", 0, "UInt", 0) ;DllCall("User32.dll\DestroyCursor", "Ptr", hCursor)
	} else if (T) AND (FileExist(C)) { ;cargar cursor desde archivo. Cursor(32512, "Mi Cursor.ani/.cur")
		return DllCall("User32.dll\SetSystemCursor", "UInt", DllCall("User32.dll\LoadCursorFromFile", "Str", C), "Int", T) ;DllCall("GetCursorInfo", "Uint", &ci) || hCursor := NumGet(ci,8)
	} else if (T) AND (C) { ;cargar cursor del sistema. Cursor(32512, 32645)
		return DllCall("User32.dll\SetSystemCursor", "UInt", DllCall("User32.dll\LoadCursor", "UInt", 0, "Int", T), "Int", C) ;DllCall("User32.dll\SetCursor", "Ptr", hCursor, "Ptr")
	}
	return 0
}

;cambia o recupera la velocidad actual del mouse
;Sintáxis: MouseSpeed( [establecer velocidad / dejar vacio] )
MouseSpeed(Vel := "") {
	if (Vel := RegExReplace(Vel, "[^0-9]"))
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x71, "UInt", 0, "UInt", Vel > 20 ? 20 : Vel < 1 ? 1 : Vel, "UInt", 0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x70, "UInt", 0, "UIntP", Vel, "UInt", 0)
	return Vel
}

;recupera/cambia el número de líneas para desplazarse cuando se mueve la rueda ratón verticalmente
MouseScrollLines(Lines := -1) {
	if (Lines >= 0)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x69, "UInt", Lines, "UInt", 0, "UInt", 0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x68, "UInt", 0, "UIntP", Lines, "UInt", 0)
	return Lines
}

;establece/recupera el tiempo (ms) de doble clic para el ratón
;Sintaxis: MouseDoubleClick( [milisegundos (1~5000)] )
MouseDoubleClick(ms := -1) {
	if (ms >= 0)
		return DllCall("User32.dll\SetDoubleClickTime", "UInt", ms)
	return DllCall("User32.dll\GetDoubleClickTime")
}

;Invierte o restaura los botones izquierdo y derecho del ratón
;Sintaxis: MouseSwap( 0|1 )
MouseSwap(fSwap) {
	return DllCall("User32.dll\SwapMouseButton", "Int", fSwap)
}

;Mueve el cursor a las coordenadas de pantalla especificadas
;MouseSetPos / CursorSetPos
MouseSetPos(x := "", y := "", Speed := "", R := 0) {
	if (Speed != "")
		return MouseMove( x, y, Speed, R )
	if (x = "") OR (y = "")
		CursorGetPos(x_, y_)
	return DllCall("User32.dll\SetCursorPos", "Int", x = "" ? x_ : x, "Int", y = "" ? y_ : y)
}
CursorSetPos(x := "", y := "", Speed := 0, R := 0) {
	return MouseSetPos(x, y, Speed, R)
}
MouseMove(x, y, Speed := "", R := -1) {
	MouseMove, %x%, %y%, % Speed > -1 ? Speed : A_DefaultMouseSpeed, % R ? "R" : ""
	return !ErrorLevel
}

;recupera la posicion del cursor
;MouseGetPos / CursorGetPos
MouseGetPos(ByRef x := "", ByRef y := "", ByRef  Win := "", ByRef Control := "", Mode := 0) {
	MouseGetPos, x, y, Win, Control, %Mode%
	i := {}, i.x := x, i.y := y, i.Win := i.hWnd := Win, i.Control := i.ctrl := Control, i.Mode := Mode
	return i
}
CursorGetPos(ByRef x := "",ByRef y := "") { ;recupera la posición del cursor, en coordenadas de pantalla
	VarSetCapacity( lpPoint, 8 + A_PtrSize, 0 ), i := {} ;Ejemplo: MsgBox % "x: " CursorGetPos(, y).x "`ny: " y
	error := DllCall("User32.dll\GetCursorPos", "Ptr", &lpPoint)
	x := i.x := NumGet( lpPoint, 0, "Int"), y := i.y := NumGet( lpPoint, 4, "Int")
	return i, ErrorLevel := !error
}

























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
SysGet(Subcommand, Param3 := "") {
	SysGet, OutputVar, %Subcommand%, %Param3%
	return OutputVar ;DllCall("User32.dll\GetSystemMetrics", "Int", Subcommand)
}

;Opciones de apagado
;Sinraxis: Shutdown( [Código], [¿Forzar?] )
;CÓDIGOS
	;1 = Apagar | 2 = Reiniciar | 3 = Cerrar sesion | 4 = Power down
	;5 = Suspender | 6 = Hibernar
	;7 = Apagar monitor | 8 = Encender monitor | 9 = Poner el monitor en bajo consumo
Shutdown(Code, Force := 0) {
	ProcessSetPrivilege( ProcessExist(-1), "SeShutdownPrivilege", 1 )
	ProcessSetPrivilege( ProcessExist(-1), "SE_SHUTDOWN_NAME", 1 )
	if Between( Code, 5, 6 ) {
		Code := Code = 5 ? 0 : 1
		return DllCall("PowrProf.dll\\SetSuspendState", "int", Code, "int", Force, "int", 0)
	} else if Between( Code, 7, 9 ) {
		Code := Code = 7 ? 2 : Code = 8 ? -1 : 1
		return DllCall("User32.dll\SendMessageTimeoutW", "Ptr", WinExist("Program Manager")
			, "UInt", 0x112, "UInt", 0xF170, "Ptr", Code, "UInt", 0x0002, "UInt", 5000, "UPtrP", 0)
	} else if Between( Code, 1, 4 ) {
		Code := Code = 1 ? 0x00000001 : Code = 2 ? 0x00000002 : Code = 3 ? 0 : 0x00000008
		Code := Force ? Code|0x00000004 : Code
		return DllCall("User32.dll\ExitWindowsEx", "UInt", Code, "UInt", 0)
	}
	return 0
}

;establecer fecha
;EJEMPLO: MsgBox % (i := {}) (i.Year := 2050) SetSystemTime( i )
SetSystemTime(Time) {
	VarSetCapacity(SYSTEMTIME, 16), i := GetSystemTime()
	, NumPut(Time.Year != "" ? Time.Year : i.Year, SYSTEMTIME,  0, "UShort") ;año = Year
	, NumPut(Time.Mon != "" ? Time.Mon : i.Mon, SYSTEMTIME,  2, "UShort") ;mes = Mon
	, NumPut(Time.WD != "" ? Time.WD : i.WD, SYSTEMTIME,  4, "UShort") ;día de la semana = WD
	, NumPut(Time.Day != "" ? Time.Day : i.Day, SYSTEMTIME,  6, "UShort") ;día  = Day
	, NumPut(Time.Hour != "" ? Time.Hour : i.Hour, SYSTEMTIME,  8, "UShort") ;hora = Hour
	, NumPut(Time.Min != "" ? Time.Min : i.Min, SYSTEMTIME, 10, "UShort") ;minutos = Min
	, NumPut(Time.Sec != "" ? Time.Sec : i.Sec, SYSTEMTIME, 12, "UShort") ;segundos = Seg
	, NumPut(Time.MS != "" ? Time.MS : i.MS, SYSTEMTIME, 14, "UShort") ;milisegundos = MS
	return DllCall("kernel32.dll\SetSystemTime", "Ptr", &SYSTEMTIME)
}
SetLocalTime(Time) {
	VarSetCapacity(SYSTEMTIME, 16), i := GetLocalTime()
	, NumPut(Time.Year != "" ? Time.Year : i.Year, SYSTEMTIME,  0, "UShort") ;año = Year
	, NumPut(Time.Mon != "" ? Time.Mon : i.Mon, SYSTEMTIME,  2, "UShort") ;mes = Mon
	, NumPut(Time.WD != "" ? Time.WD : i.WD, SYSTEMTIME,  4, "UShort") ;día de la semana = WD
	, NumPut(Time.Day != "" ? Time.Day : i.Day, SYSTEMTIME,  6, "UShort") ;día  = Day
	, NumPut(Time.Hour != "" ? Time.Hour : i.Hour, SYSTEMTIME,  8, "UShort") ;hora = Hour
	, NumPut(Time.Min != "" ? Time.Min : i.Min, SYSTEMTIME, 10, "UShort") ;minutos = Min
	, NumPut(Time.Sec != "" ? Time.Sec : i.Sec, SYSTEMTIME, 12, "UShort") ;segundos = Seg
	, NumPut(Time.MS != "" ? Time.MS : i.MS, SYSTEMTIME, 14, "UShort") ;milisegundos = MS
	return DllCall("kernel32.dll\SetLocalTime", "Ptr", &SYSTEMTIME)
}

;obtener fecha
;EJEMPLO: GetSystemTime().Year
GetSystemTime() { ;sistema
	VarSetCapacity(lpSystemTime, 16, 0), NumPut(16, lpSystemTime, "UShort")
	ErrorLevel := !DllCall("kernel32.dll\GetSystemTime", "Ptr", &lpSystemTime)
	i := {}, i.Year := NumGet(lpSystemTime, 0, "UShort") ;año = Year
		, i.Mon := NumGet(lpSystemTime, 2, "UShort") ;mes = Mon
		, i.WD := NumGet(lpSystemTime, 4, "UShort") ;día de la semana = WD
		, i.Day := NumGet(lpSystemTime, 6, "UShort") ;día  = Day
		, i.Hour := NumGet(lpSystemTime, 8, "UShort") ;hora = Hour
		, i.Min := NumGet(lpSystemTime, 10, "UShort") ;minutos = Min
		, i.Sec := NumGet(lpSystemTime, 12, "UShort") ;segundos = Seg
		, i.MS := NumGet(lpSystemTime, 14, "UShort") ;milisegundos = MS
	return i
}
GetLocalTime() { ;local
	VarSetCapacity(lpSystemTime, 16, 0), NumPut(16, lpSystemTime, "UShort")
	ErrorLevel := !DllCall("kernel32.dll\GetLocalTime", "Ptr", &lpSystemTime)
	i := {}, i.Year := NumGet(lpSystemTime, 0, "UShort") ;año = Year
		, i.Mon := NumGet(lpSystemTime, 2, "UShort") ;mes = Mon
		, i.WD := NumGet(lpSystemTime, 4, "UShort") ;día de la semana = WD
		, i.Day := NumGet(lpSystemTime, 6, "UShort") ;día  = Day
		, i.Hour := NumGet(lpSystemTime, 8, "UShort") ;hora = Hour
		, i.Min := NumGet(lpSystemTime, 10, "UShort") ;minutos = Min
		, i.Sec := NumGet(lpSystemTime, 12, "UShort") ;segundos = Seg
		, i.MS := NumGet(lpSystemTime, 14, "UShort") ;milisegundos = MS
	return i
}

;Recupera información sobre el uso actual del sistema de memoria tanto física como virtual.
;EJEMPLO: MsgBox % Sys.GlobalMemoryStatusEx().Load " %"
SysGlobalMemoryStatusEx() { ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366589%28v=vs.85%29.aspx
	VarSetCapacity(MEMORYSTATUSEX, 64, 0), NumPut(64, MEMORYSTATUSEX, "UInt")
	ErrorLevel := !DllCall("kernel32.dll\GlobalMemoryStatusEx", "Ptr", &MEMORYSTATUSEX)
	i := {}, i.Lenght := NumGet(MEMORYSTATUSEX, 0, "UInt") ; El tamaño de la estructura, en bytes
		, i.Load := NumGet(MEMORYSTATUSEX, 4, "UInt") ;número entre 0 y 100 que especifica el porcentaje aproximado de la memoria física que está en uso
		, i.TotalPhys := NumGet(MEMORYSTATUSEX, 8, "UInt64") ;cantidad de memoria física real, en bytes
		, i.AvailPhys := NumGet(MEMORYSTATUSEX, 16, "UInt64") ;cantidad de memoria física disponible actualmente, en bytes
		, i.TotalPageFile := NumGet(MEMORYSTATUSEX, 24, "UInt64") ;límite de memoria comprometida actual para el sistema o el proceso actual, en bytes
		, i.AvailPageFile := NumGet(MEMORYSTATUSEX, 32, "UInt64") ;cantidad máxima de memoria que el proceso actual puede usar, en bytes.
		, i.TotalVirtual := NumGet(MEMORYSTATUSEX, 40, "UInt64") ;El tamaño de la parte del modo usuario del espacio de direcciones virtuales del proceso de llamada, en bytes
		, i.AvailVirtual := NumGet(MEMORYSTATUSEX, 48, "UInt64") ; La cantidad de memoria sin reservas y no comprometido actualmente en la parte del modo usuario del espacio de direcciones virtuales del proceso de llamada, en bytes
		;, i.AvailExtendedVirtual := NumGet(MEMORYSTATUSEX, 56, "UInt64") ;Reservado. Este valor es siempre 0.
		, i.RAM := (a:=Get( A_ThisFunc ).RAM) ? a : DllCall("Kernel32.dll\GetPhysicallyInstalledSystemMemory", "UInt64*", TotalMemoryInKilobytes)  ;cantidad de RAM instalada físicamente en el equipo, en kilobytes
	return Set( A_ThisFunc, i )
}

;sistema operativo: información de la versión
SysGetVersion() {
	if Get( A_ThisFunc, i )
		return i
	VarSetCapacity(RTL_OSVIEX, 284, 0), NumPut(284, RTL_OSVIEX, 0, "UInt")
	DllCall("ntdll.dll\RtlGetVersion", "Ptr", &RTL_OSVIEX), i := {}
	i.OSVersionInfoSize := NumGet(RTL_OSVIEX, 0, "UInt")
	i.MajorVersion := NumGet(RTL_OSVIEX, 4, "UInt")
	i.MinorVersion := NumGet(RTL_OSVIEX, 8, "UInt")
	i.BuildNumber := NumGet(RTL_OSVIEX, 12, "UInt")
	i.PlatformId := NumGet(RTL_OSVIEX, 16, "UInt")
	i.CSDVersion := StrGet(&RTL_OSVIEX + 20, 128, "UTF-16") ;SP
	i.ServicePackMajor := NumGet(RTL_OSVIEX, 276, "UShort")
	i.ServicePackMinor := NumGet(RTL_OSVIEX, 278, "UShort")
	i.SuiteMask := NumGet(RTL_OSVIEX, 280, "UShort")
	i.ProductType := NumGet(RTL_OSVIEX,       282, "UChar" )
	return Set( A_ThisFunc, i )
}

;recupera la ruta completa de una carpeta WIN_V+
SHGetKnownFolderPath(GUID) {
	if !Get( GUID, i )
		VarSetCapacity(CLSID, 16, 0), VarSetCapacity(ppszPath, 261 * 2)
		, DllCall("Ole32.dll\CLSIDFromString", "WStr", GUID, "Ptr", &CLSID)
		, DllCall("Shell32.dll\SHGetKnownFolderPath", "Ptr", &CLSID, "UInt", 0, "Ptr", 0, "PtrP", &ppszPath), Path := ppszPath
	return i ? i : Set( GUID, RTrim( StrGet(&ppszPath), "\" ) )
		, x := i ? "" : DllCall("Ole32.dll\CoTaskMemFree", "Ptr", &Path)
}

;recupera la ruta completa de una carpeta WIN_XP+
SHGetFolderPath(CSIDL) {
	if !Get( CSIDL, i )
		VarSetCapacity(pszPath, 261 * 2)
		, DllCall("Shell32.dll\SHGetFolderPathW", "Ptr", 0, "Int", CSIDL, "Ptr", 0, "UInt", 0, "Ptr", &pszPath)
	return i ? i : Set( CSIDL, RTrim( StrGet(&pszPath), "\" ) )
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA: VARIABLES ::::::::::::::::::::::::::::::::::
;NOTA: el valor que devuelve queda guardado en memoria, esto hace que la próxima vez se obtenga al instante.
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Recupera la ruta a la raíz del directorio del usuario actual
A_UserProfile() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, EnvGet( "USERPROFILE" ) )
}

;Recupera la ruta a la raíz del directorio que contiene los datos del programa compartidos por todos los usuarios.
A_AllUsersProfile() {
	if !Get( A_ThisFunc, i )
		DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;Recupera la ruta de acceso al directorio raíz donde se almacenan los perfiles de usuario.
A_Profiles() {
	if !Get( A_ThisFunc, i )
		DllCall("Userenv.dll\GetProfilesDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Userenv.dll\GetProfilesDirectoryW", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;Recupera la ruta de acceso a la raíz del perfil de usuario predeterminado.
A_DefaultUserProfile() {
	if !Get( A_ThisFunc, i )
		DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2)
		, DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera el nombre del usuario actual
A_UserName() {
	if !Get( A_ThisFunc, i )
		DllCall("Advapi32.dll\GetUserNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Advapi32.dll\GetUserNameW", "Str", lpBuffer, "UInt*", uSize + 1)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera el dominio del usuario actual
A_UserDomain() {
	if !Get( A_ThisFunc, i )
		DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", lpBuffer, "UInt*", uSize + 1)
	return i ? i : Set( A_ThisFunc, StrSplit( lpBuffer, "\" )[1] )
}

;Recupera/Establece el nombre NetBIOS del equipo local.
;Este nombre se estableció al inicio del sistema, cuando el sistema lo lee desde el registro.
A_ComputerName(lpComputerName*) {
	if lpComputerName.MaxIndex()
		return DllCall("Kernel32.dll\SetComputerNameW", "Str", lpComputerName[1])
	if !Get( A_ThisFunc, i )
		DllCall("kernel32.dll\GetComputerNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetComputerNameW", "Str", lpBuffer, "UInt*", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta del directorio de sistema utilizado por WOW64.
;NOTA: Este directorio no está presente en Windows de 32 bits.
A_SysDir64() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta del directorio de sistema.
;El directorio del sistema contiene los archivos del sistema, como las bibliotecas y los controladores de vínculos dinámicos.
A_SysDir() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetSystemDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemDirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta del directorio compartido de Windows en un sistema multi-usuario.
A_SysWinDir() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;recupera la ruta de acceso del directorio de Windows.
A_WinDir() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetWindowsDirectoryW", "Str", lpBuffer, "UInt", uSize)
	return i ? i : Set( A_ThisFunc, lpBuffer )
}

;Archivos Temporales
A_Temp() {
	if !Get( A_ThisFunc, i )
		uSize := DllCall("kernel32.dll\GetTempPathW", "UInt", 0, "Ptr", 0)
		, VarSetCapacity(lpBuffer, uSize * 2, 0)
		, DllCall("kernel32.dll\GetTempPathW", "UInt", uSize + 1, "Str", lpBuffer)
	return i ? i : Set( A_ThisFunc, StrLPath( lpBuffer ) )
}

;recupera/establece el directorio de trabajo
A_WorkingDir(WorkingDir*) {
	if WorkingDir.MaxIndex()
		return SetWorkingDir( WorkingDir[1] )
	return GetWorkingDir()
}

;recupera la ruta a la consola de windows (cmd.exe)
A_ComSpec() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, EnvGet( "ComSpec" ) )
}

;recupera el idioma por defecto del sistema
A_Language() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, Format("{:04X}", DllCall("GetSystemDefaultUILanguage", "UShort")) )
}

;recupera el directorio de Archivos De Programa
A_ProgramFiles() {
	CSIDL_PROGRAM_FILES := 0x0026
	return SHGetFolderPath( CSIDL_PROGRAM_FILES )
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio del usuario actual 
A_Programs() {
	CSIDL_PROGRAMS := 0x0002
	return SHGetFolderPath( CSIDL_PROGRAMS )
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio para todos los usuarios
A_ProgramsCommon() {
	CSIDL_COMMON_PROGRAMS := 0X0017
	return SHGetFolderPath( CSIDL_COMMON_PROGRAMS )
}

;directorio de sistema de archivos que contiene los datos de aplicación para el usuario actual
A_AppData() {
	CSIDL_APPDATA := 0x001a
	return SHGetFolderPath( CSIDL_APPDATA )
}

;directorio de sistema de archivos que contiene los datos de aplicación para todos los usuarios
A_AppDataCommon() {
	CSIDL_COMMON_APPDATA := 0x0023
	return SHGetFolderPath( CSIDL_COMMON_APPDATA )
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio del usuario actual
A_Desktop() {
	CSIDL_DESKTOPDIRECTORY := 0x0010
	return SHGetFolderPath( CSIDL_DESKTOPDIRECTORY )
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio para todos los usuarios
A_DesktopCommon() {
	CSIDL_COMMON_DESKTOPDIRECTORY := 0x0019
	return SHGetFolderPath( CSIDL_COMMON_DESKTOPDIRECTORY )
}

;ruta completa y el nombre de la carpeta del menú Inicio del usuario actua
A_StartMenu() {
	CSIDL_STARTMENU := 0x000b
	return SHGetFolderPath( CSIDL_STARTMENU )
}

;ruta completa y el nombre de la carpeta del menú Inicio para todos los usuarios
A_StartMenuCommon() {
	CSIDL_COMMON_STARTMENU := 0x0016
	return SHGetFolderPath( CSIDL_COMMON_STARTMENU )
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio del usuario actual
A_Startup() {
	CSIDL_STARTUP := 0x0007
	return SHGetFolderPath( CSIDL_STARTUP )
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio para todos los usuarios
A_StartupCommon() {
	CSIDL_COMMON_STARTUP := 0x0018
	return SHGetFolderPath( CSIDL_COMMON_STARTUP )
}

A_MyDocuments() {
	CSIDL_PERSONAL := 0x0005
	return SHGetFolderPath( CSIDL_PERSONAL )
}

A_DocumentsCommon() {
	CSIDL_COMMON_DOCUMENTS := 0x002e
	return SHGetFolderPath( CSIDL_COMMON_DOCUMENTS )
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de música
A_MyMusic() {
	CSIDL_MYMUSIC := 0x000d
	return SHGetFolderPath( CSIDL_MYMUSIC )
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de imagen
A_MyPictures() {
	CSIDL_MYPICTURES := 0x0027
	return SHGetFolderPath( CSIDL_MYPICTURES )
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de vídeo
A_MyVideo() {
	CSIDL_MYVIDEO := 0x000e
	return SHGetFolderPath( CSIDL_MYVIDEO )
}

;ancho del monitor actual
A_ScreenWidth() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", 0)
}

;alto del monitor actual
A_ScreenHeight() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", 1)
}

;ruta completa al script
A_ScriptFullPath() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;directorio del script
A_ScriptDir() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;nombre del script
A_ScriptName() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;devuelve 1 si el script se está ejecutando como administrador
A_IsAdmin() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress1() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress2() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress3() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_IPAddress4() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

;directorio de sistema de archivos que contiene accesos directos a los documentos usados recientemente del usuario
A_Recent() {
	CSIDL_RECENT := 0x0008
	return SHGetFolderPath( CSIDL_RECENT )
}

;directorio de sistema de archivos que contiene Enviar a elementos de menú
A_SendTo() {
	CSIDL_SENDTO := 0x0009
	return SHGetFolderPath( CSIDL_SENDTO )
}

A_Time(Delimiter := "") {
	return A_Year Delimiter A_Mon Delimiter A_DD Delimiter A_Hour Delimiter A_Min Delimiter A_Sec
}

A_Cursor() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_OSVersion() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_OSType() {
	return Get( A_ThisFunc, i ) ? i
		: Set( A_ThisFunc, %A_ThisFunc% )
}

A_TickCount(ByRef ElapsedTime := "") {
	static Time
	return _Time := GetTickCount(), ElapsedTime := _Time - Time, Time := _Time
}

A_LastError(SetLastError*) {
	if SetLastError.MaxIndex()
		return SetLastError( SetLastError[1] )
	return GetLastError()
}

;ESPECIALES ######################################
;espacio
A_Space() {
	return Chr( 32 )
}

;tabulación
A_Tab() {
	return Chr( 9 )
}

;comilla ( " )
A_Quote() {
	return Chr( 34 )
}

;obtiene un array con los parámetros usados para ejecutar el script
;EJEMPLO: MsgBox( A_Args()[1] "`n" A_Args()[2] "`n" A_Args()[3] "`n" A_Args()[4] "`n" A_Args()[5] "`n`nTotal: " A_Args()[0] )
A_Args() { ;http://ahkscript.org/boards/viewtopic.php?t=4357 || By SKAN
	if Get( A_ThisFunc, Args )
		return Args
	CommandLineString := DllCall("Kernel32.dll\GetCommandLineW", "Str"), Args := [], Skip := A_IsCompiled ? 1 : 2
	pArgs := DllCall("Shell32.dll\CommandLineToArgvW", "WStr", CommandLineString, "PtrP", nArgs) 
	Loop, %nArgs% {
		if (A_Index > Skip)
			hArgs := NumGet( (A_Index - 1) * A_PtrSize + pArgs )
			, Args[A_Index - Skip] := StrGet( hArgs, "UTF-16" )
	}
	return Args, Args[0] := nArgs - Skip, DllCall("Kernel32.dll\LocalFree", "Ptr", pArgs)
		, Set( A_ThisFunc, Args )
}
;######################################















































/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  ::::::::::::::::::::::::::::::::::::::::::::: VENTANAS ::::::::::::::::::::::::::::::::::
---------------------------------------------------------------------------------------------------------------------------------------------------------------
NOTA: las funciones solo aceptan el ID de la ventana (mas rápido), para el titulo o ahk_xxx usar WinExist( .. )
EJEMPLO: WinCenter( WinExist("Calculadora") )
*/
WinMinimizeAll() {
	WinMinimizeAll
	return 1
}

;recupera una lista con todas las ventanas
WinEnum() {
	List := {}
	WinGet, win, List
	Loop, %win%
		List.InsertAt(A_Index, win%A_Index%)
	return List
}

;centrar ventana
WinCenter(hWnd) {
	if WinMax( hWnd )
		return 0, ErrorLevel := 3
	WinGetPos( hWnd,,, Width, Height )
	return WinMove( hWnd, (A_ScreenWidth/2) - (Width/2), (A_ScreenHeight/2) - (Height/2) )
}

;mover ventana
;Sintaxis: WinMove( [ID], [x], [y], [ancho], [alto], [¿redibujar?] )
WinMove(hWnd, x := "", y := "", Width := "", Height := "", bRepaint := 1) {
	if (x = "") OR (y = "") OR (Width = "") OR (Height = "")
		WinGetPos( hWnd, x_, y_, w_, h_ )
	x := x = "" ? x_ : x, y := y = "" ? y_ : y
	Width := Width = "" ? w_ : Width, Height := Height = "" ? h_ : Height
	return i := DllCall("User32.dll\MoveWindow", "Ptr", hWnd, "Int", x, "Int", y, "Int", Width, "Int", Height, "Int", bRepaint)
		, ErrorLevel := !i
}

;obtener posicion de la ventana
;Sintaxis: WinGetPos( [ID], [xpos], [ypos], [ancho], [alto], [modo] )
;MODOS:
	;1 = excluir los bordes de la ventana
	;0 (defecto) = obtiene el ancho y alto de la ventana entera, incluye los bordes
WinGetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "", Mode := 0) {
	VarSetCapacity(RECT, 16, 0), i := {}
	h := DllCall("User32.dll\GetWindowRect", "Ptr", hWnd, "Ptr", &RECT)
	i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	if Mode { ;obtiene el ancho y alto -Bordes
		VarSetCapacity(RECT2, 16, 0)
		DllCall("User32.dll\GetClientRect", "Ptr", hWnd, "Ptr", &RECT2)
		i.h := i.Height := Height := NumGet(RECT2, 12, "Int")
		i.w := i.Width := Width := NumGet(RECT2,  8, "Int")
	} else { ;obtiene el ancho y alto +Bordes
		i.h := i.Height := Height := NumGet(RECT, 12, "Int") - y
		i.w := i.Width := Width := NumGet(RECT,  8, "Int") - x
	}
	return i, ErrorLevel := !h
}

;obtiene el ancho y alto de los bordes de la ventana
WinGetBorder(hWnd, ByRef Width := "", ByRef Height := "") {
	WinGetPos( hWnd,,, Width, Height ), WinGetPos( hWnd,,, Width2, Height2, 1 )
	i.w := i.Width := Width := Width - Width2, i.h := i.Height := Height := Height - Height2
	return i, ErrorLevel := !h
}

;obtiene el estilo de la ventana
WinGetStyle(hWnd, ByRef Style := "") {
	if !(Style := DllCall("User32.dll\GetWindowLongPtrW", "Ptr", hWnd, "Int", -16))
		Style := DllCall("User32.dll\GetWindowLongW", "Ptr", hWnd, "Int", -16)
	return Hex( Style, 8, 1 ), ErrorLevel := !Style
}

;obtiene el estilo extendido de la ventana
WinGetExStyle(hWnd, ByRef ExStyle := "") {
	if !(ExStyle := DllCall("User32.dll\GetWindowLongPtrW", "Ptr", hWnd, "Int", -20))
		ExStyle := DllCall("User32.dll\GetWindowLongW", "Ptr", hWnd, "Int", -20)
	return Hex( ExStyle, 8, 1 ), ErrorLevel := !ExStyle
}

;Recupera el titulo de la ventana especificada.
;Sintaxis: WinGetTitle( [ID] )
WinGetTitle(hWnd) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633520%28v=vs.85%29.aspx
	nMaxCount := DllCall("User32.dll\GetWindowTextLengthW", "Ptr", hWnd)
	nMaxCount := VarSetCapacity( lpString, (nMaxCount + 1) * 2, 0 ) / 2
	i := DllCall("User32.dll\GetWindowTextW", "Ptr", hWnd, "Str", lpString, "Int", nMaxCount)
	return lpString, ErrorLevel := !i
}

;Recupera el nombre de la clase a la que pertenece la ventana especificada.
WinGetClass(hWnd) {
	nMaxCount := VarSetCapacity( lpClassName, (260 + 1) * 2, 0 ) / 2
	i := DllCall("User32.dll\GetClassNameW", "Ptr", hWnd, "Str", lpClassName, "Int", nMaxCount)
	return lpClassName, ErrorLevel := !i
}

;recupera el PID/ThreadId/ProcessName del proceso de la ventana
;Sintaxis: WinGetPID( [ID], [ThreadId (salida)], [Proceso (salida)] )
WinGetPID(hWnd, ByRef ThreadId := "", ByRef ProcessName := "") {
	VarSetCapacity( lpdwProcessId, A_PtrSize * 2, 0 )
	ThreadId := DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "Ptr", &lpdwProcessId)
	return ProcessId := NumGet( lpdwProcessId, 0, "Ptr" )
		, ProcessName := IsByRef( ProcessName ) ? ProcessName( ProcessId ) : ""
		, ErrorLevel := !ThreadId
}

;establecer el titulo de la ventana espesificada
;Sintaxis: WinSetTitle( [ID], [Titulo] )
WinSetTitle(hWnd, NewTitle) {
	return i := DllCall("User32.dll\SetWindowTextW", "Ptr", hWnd, "Str", NewTitle)
		, ErrorLevel := !i
}

WinSetBottom( hWnd ) {
	WinSet, Bottom,, ahk_id %hWnd%
	return !ErrorLevel
}

;Permite producir efectos especiales al mostrar u ocultar ventanas
;Sintaxis: WinAnimate( [ID], [El tiempo que toma para reproducir la animación , en milisegundos], [Tipo de animación] )
;TIPOS DE ANIMACIÓN (se pueden combinar):
	;S = Mostrar | H = Ocultar | C = Centrar
	;1 = Desvanecer | 2 = Diapositiva (combinar con 3/4 y/o 5/6)
	;3 = Izquierda A Derecha | 4 = Derecha A Izquierda
	;5 = Arriba Abajo | 6 = Abajo Arriba
WinAnimate(hwnd, dwTime := 200, dwFlags := "S1") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632669%28v=vs.85%29.aspx
	Flags_List := {"S" : 0x00020000, 1 : 0x00080000, "C" : 0x00000010, "H" : 0x00010000, 3 : 0x00000001, 4 : 0x00000002, 2 : 0x00040000, 5 : 0x00000004, 6 : 0x00000008}
	For k, v In Flags_List
		If InStr(dwFlags, k)
			Flags += v
	return DllCall("User32.dll\AnimateWindow", "Ptr", hwnd, "UInt", dwTime, "UInt", Flags)
}

;cerrar ventana
;Sintaxis: WinClose( [ID], [Segundos a esperar], [¿Forzar?] )
;NOTA: espesificar 0 segundos para esperar indefinidamente
WinClose(hWnd, Seconds := -1, Force := 0) {
	if Force {
		WinGetPID( hWnd, WinThreadId )
		hThread := DllCall("Kernel32.dll\OpenThread", "UInt", 0x0001, "UInt", 0, "UInt", WinThreadId)
		return i := DllCall("Kernel32.dll\TerminateThread", "Ptr", hThread, "UInt", 0)
			, DllCall("Kernel32.dll\CloseHandle", "Ptr", hThread)
			, WinWaitClose( hWnd, Seconds ), ErrorLevel := !i
	}
	return i := DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", 0x0002, "Ptr", 0, "Ptr", 0, "UInt", 0x0002, "UInt", 5000, "UPtrP", 0)
		, WinWaitClose( hWnd, Seconds )
		, ErrorLevel := !i
}
WinKill(hWnd, Seconds := -1) {
	return WinClose( hWnd, Seconds, 1 ) ? 1
		: DllCall("User32.dll\EndTask", "Ptr", hWnd, "Int", 0, "Int", 1)
}

;espera a que la ventana no exista
;Sintaxis: WinWaitClose( [ID], [segundos], [¿cerrar?] )
;CERRAR: cerrar ventana si han pasado los segundos y sigue existiendo.
	;1 = cerrar | 2 = forzar cierre
WinWaitClose(hWnd, Seconds := 0, Close := 0) {
	if (Seconds = -1)
		return 0
	GetTickCount( StartTime )
	Loop {
		if !IsWindow( hWnd )
			return 1, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds > 0) AND (ElapsedTime >= Seconds)
			return Close ? (i := WinClose( hWnd,, Close = 2 ? 1 : 0 )) : 0, ErrorLevel := Close ? !i : 1
		Sleep( 100 )
	}
}

;comprueba si la ventana está minimizada
WinMin(hWnd) {
	return i := DllCall("User32.dll\IsIconic", "Ptr", hWnd)
		, ErrorLevel := !i
}

;minimiza la ventana
;Sintaxis: WinMinimize( [ID], [¿Forzar?] )
WinMinimize(hWnd, Force := 0) {
	if Force
		DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x112, "UInt", 0xF020, "Ptr", 0)
	SW_FORCEMINIMIZE := 11, SW_MINIMIZE := 6
	nCmdShow := Force = 2 ? SW_FORCEMINIMIZE : SW_MINIMIZE
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;comprueba si la ventana está maximizada
WinMax(hWnd) {
	return i := DllCall("User32.dll\IsZoomed", "Ptr", hWnd)
		, ErrorLevel := !i
}

;maximiza la ventana
;Sintaxis: WinMaximize( [ID], [¿Forzar?] )
WinMaximize(hWnd, Force := 0) {
	if Force
		DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x112, "UInt", 0xF030, "Ptr", 0)
	nCmdShow := SW_MAXIMIZE := 3
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;restaura la ventana a su tamaño y posicion original
;Sintaxis: WinRestore( [ID], [¿Forzar?] )
WinRestore(hWnd, Force := 0) {
	if Force
		DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", 0x112, "UInt", 0xF120, "Ptr", 0)
	nCmdShow := SW_RESTORE := 9
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;oculta la ventana
WinHide(hWnd) {
	nCmdShow := SW_HIDE := 0
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, ErrorLevel := !i
}

;comprueba si la ventana es visible
WinVisible(hWnd) {
	return i := DllCall("User32.dll\IsWindowVisible", "Ptr", hWnd)
		, ErrorLevel := !i
}

;muestra la ventana
;Sintaxis: WinShow( [ID], [¿Activar?], [¿Esperar? (segundos)] )
WinShow(hWnd, Activate := 0, WaitActive := -1) {
	nCmdShow := SW_SHOW := 5
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
		, a := Activate ? WinActivate( hWnd ) : ""
		, WinWaitActive( hWnd, WaitActive )
		, ErrorLevel := !i
}

;cambia el icono de la ventana
;Sintaxis: Icon( [ID], [Icono/DLL/Ejecutable], [Índice (DLL)] )
WinSetIcon(hWnd, lpszExeFileName, nIconIndex := 0) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632643%28v=vs.85%29.aspx
	WM_SETICON := 0x0080, ICON_SMALL := 0, ICON_BIG := 1
	if !(hIcon := DllCall("Shell32.dll\ExtractIconW", "Ptr", A_ScriptHwnd, "Str", lpszExeFileName, "UInt", nIconIndex))
		return 0, ErrorLevel := 1
	if DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", WM_SETICON, "Ptr", ICON_SMALL, "Ptr", hIcon, "UInt", 0x0002, "UInt", 2500, "UPtrP", 0)
		if DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", WM_SETICON, "Ptr", ICON_BIG, "Ptr", hIcon, "UInt", 0x0002, "UInt", 2500, "UPtrP", 0)
			return 1, ErrorLevel := 0
	return 0, DllCall("User32.dll\DestroyIcon", "Ptr", hIcon), ErrorLevel := 1
}
	
;establece la ventana padre de una ventana
WinSetParent(hWndChild, hWndNewParent) {
	return i := DllCall("User32.dll\SetParent", "Ptr", hWndChild, "Ptr", hWndNewParent)
		, ErrorLevel := !i
}

;comprueba si la ventana existe
;NOTAS: 
	;dejar vacio para obtener el ID de la ventana activa
	;si existe, devuelve el ID
IsWindow(hWnd*) {
	if !hWnd.MaxIndex() ;devuelve el ID de la ventana activa
		return DllCall("User32.dll\GetForegroundWindow")
	return (i := DllCall("User32.dll\IsWindow", "Ptr", hWnd[1])) ? hWnd[1] : 0
		, ErrorLevel := !i
}

;activa la ventana
;NOTA: si la ventana está minimizada, las restaura a su tamaño y posicion original
;Sintaxis: WinActivate( [ID], [¿Esperar? (segundos)], [¿Forzar?] )
WinActivate(hWnd, WaitActive := -1, Force := 0) {
	if WinMin( hWnd )
		WinRestore( hWnd )
	if Force {
		CurrentThreadId := ProcessExist( -2 )
		WinGetPID( hWnd, WinThreadId )
		DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 1)
		return DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
			, DllCall("User32.dll\BringWindowToTop", "Ptr", hWnd)
			, DllCall("User32.dll\SetFocus", "Ptr", hWnd)
			, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", 0)
			, WinWaitActive(hWnd, WaitActive)
	}
	return DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
		, WinWaitActive(hWnd, WaitActive)
}

;esperar a que una ventana se active
;Sintaxis: WinWaitActive( [ID], [Segundos] )
WinWaitActive(hWnd, Seconds := 0) {
	if (Seconds = -1)
		return 0
	GetTickCount( StartTime )
	Loop {
		if (hWnd = IsWindow())
			return 1, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds > 0) AND (ElapsedTime >= Seconds)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que una ventana pierda el foco
;Sintaxis: WinWaitNotActive( [ID], [Segundos] )
WinWaitNotActive(hWnd, Seconds := 0) {
	if (Seconds = -1)
		return 0
	GetTickCount( StartTime )
	Loop {
		if (hWnd != IsWindow())
			return 1, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds > 0) AND (ElapsedTime >= Seconds)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;esperar a que una ventana exista
;Sintaxis: WinWait( [Ventana], [Segundos] )
WinWait(hWnd, Seconds := 0) {
	if (Seconds = -1)
		return 0
	GetTickCount( StartTime )
	Loop {
		if WinExist( hWnd )
			return 1, ErrorLevel := 0
		ElapsedTime := (GetTickCount() - StartTime) / 1000
		if (Seconds > 0) AND (ElapsedTime >= Seconds)
			return 0, ErrorLevel := 1
		Sleep( 100 )
	}
}

;establece la ventana siempre al frente
;Sintaxis: WinSetAlwaysOnTop( [ID], [0|1] )
WinSetAlwaysOnTop(hWnd, State := 1) {
	return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", State ? -1 : -2, "Int", 0, "Int", 0 "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
}

;comprueba si la ventana está habilitada
IsWinEnabled(hWnd) {
	return WinEnabled( hWnd )
}
WinEnabled(hWnd) {
	return DllCall("User32.dll\IsWindowEnabled", "UInt", hWnd)
}

;habilita la ventana
WinEnable(hWnd, Activate := 0, WaitActive := -1) {
	i := DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", 1)
	return i
		, a := Activate ? WinActivate( hWnd ) : ""
		, WinWaitActive( hWnd, WaitActive )
		, ErrorLevel := !i
}

;deshabilita la ventana
WinDisable(hWnd) {
	return !DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", 0)
}

WinSetTransparent( hWnd, Transparent ) {
	WinSet, Transparent, %Transparent%, ahk_id %hWnd%
	return !ErrorLevel
}

WinSetRegion( hWnd, Region ) {
	WinSet, Region, %Region%, ahk_id %hWnd%
	return !ErrorLevel
}

;registrar eventos para una ventana
;Sintaxis: WinSetEventHook( [ID], [Funcion], [Evento menor], [Evento mayor] )
;Sintaxis (eliminar): WinSetEventHook( [hEvent] )
;EVENTOS: https://msdn.microsoft.com/en-us/library/windows/desktop/dd318066%28v=vs.85%29.aspx
;EJEMPLO:
	;WinSetEventHook( WinExist("ahk_exe notepad.exe"), "WinEventProc", EVENT_OBJECT_LOCATIONCHANGE := 0x800B )
	;WinEventProc(hWinEventHook, Event, hWnd, idObject, idChild, dwEventThread, dwmsEventTime) {
	;	if !hWnd
	;		return
	;	MsgBox % "Título: " WinGetTitle( hWnd )
	;		. "`nClase: " WinGetClass( hWnd )
	;		. "`nEvento: " Event
	;	return
	;}
WinSetEventHook(hWnd, Func := "", EventMin := "", EventMax := "") {
	if !Func ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd373640%28v=vs.85%29.aspx
		return i := DllCall("User32.dll\UnhookWinEvent", "Ptr", hWnd), ErrorLevel := !i
	if !IsWindow( hWnd ) OR !IsFunc( Func )
		return 0, ErrorLevel := 2
	WINEVENT_OUTOFCONTEXT := 0x0, WINEVENT_SKIPOWNPROCESS := 0x2
	EventMax := EventMax ? EventMax : EventMin, WinGetPID( hWnd, WinThreadId )
	return i := DllCall("User32.dll\SetWinEventHook", "UInt", EventMin, "UInt", EventMax, "Ptr", 0, "Ptr", RegisterCallback( Func )
		, "UInt", 0, "UInt", WinThreadId, "UInt", WINEVENT_OUTOFCONTEXT|WINEVENT_SKIPOWNPROCESS)
		, ErrorLevel := !i
}























































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: MENÚS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener una lista con todos los elementos de los menús de la ventana
;Sintaxis: GetMenuItemList( [ID] )
;NOTA: sólo funciona con aplicaciones que utilizan menús estándar de Windows
;EJEMPLO: ver uso de LoopParse con RegExMatch() en: SelectMenuItem()
GetMenuItemList(hWnd, hMenu := 0, Prefix := "") { ;http://ahkscript.org/boards/viewtopic.php?p=48401#p48401
	hMenu := hMenu ? hMenu : DllCall("User32.dll\GetMenu", "Ptr", hWnd)
	Count := DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
	Loop, %Count% {
		sSize := DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Ptr", 0, "Int", 0, "UInt", 0x00000400)
		sSize := VarSetCapacity( lpString, (sSize + 1) * 2 ) / 2
		if !DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Str", lpString, "Int", sSize, "UInt", 0x00000400)
			continue
		lpString := StrReplace(lpString, "&")
		ItemId := DllCall("User32.dll\GetMenuItemID", "Ptr", hMenu, "Int", A_Index-1)
		if (itemID = -1) AND (hSubMenu := DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", A_Index-1)) {
			List .= GetMenuItemList( "", hSubMenu, Prefix lpString " > " )
			continue
		}
		List .= ItemId "`t" Prefix RegExReplace( lpString, "`t.*" ) "`n"
	}
	return RTrim( List, "`n" )
}

;ejecuta un comando del menu de la ventana
;Sintaxis: SelectMenuItem( [ID], [ID del Menú], [Nombre del Menú] )
;NOTA: espesificar ' > ' para submenús
;Ejemplo: WinSelectMenuItem( IsWindow(),, "Archivo > Abrir..." )
SelectMenuItem(hWnd, MenuItemId := "", MenuItemName := "") {
	if (MenuItemName != "") {
		Loop, Parse, % GetMenuItemList( hWnd ), `n, `r
		{
			RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
			if (MenuItemName = MenuItem2) {
				MenuItemId := MenuItem1
				break
			}
		}
	}
	return DllCall("User32.dll\SendNotifyMessageW", "Ptr", hWnd, "UInt", 0x111, "Ptr", MenuItemId, "Ptr", 0)
}

;comprueba si es un menú válido
IsMenu(hMenu) {
	return DllCall("User32.dll\IsMenu", "Ptr", hMenu)
}

;redibujar el menú de la ventana.
;Sintaxis: MenuRedraw( [ID] )
MenuRedraw(hWnd) {
	return DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd)
}

;añadir menú a un menú existente
;Sintaxis: MenuAdd( [Menú], [Item], [Etiqueta|:SubMenú|Función] )
;NOTA: especificar solo el Menú (primer parámetro) para agregar un separador
;EJEMPLO:
	;MenuAdd(), MenuAdd(, "Salir", Func("ExitApp"))
	;MenuAdd( "i", "Salir Menu", Func("MenuCheck").Bind("i", "Salir Menu", -1))
	;MenuAdd(, "Prueba Menu", ":i")
	;MenuIcon( "Tray", "shell32.dll", 4 )
	;MenuIcon( "i", "Salir Menu", "shell32.dll", 16 )
	;MenuColor( "i", "Green" ), MenuColor( "Tray", "Red" )
	;MenuDefault( "Tray", "Salir" )
	;MenuClick( 2 )
	;MenuCheck( "i", "Salir Menu" )
MenuAdd(MenuName := "Tray", MenuItemName := "", Label := "") {
	if (Label = " ")
		return
	Label := Label ? Label : Func( A_ThisFunc ).Bind( "",, A_Space )
	if (MenuItemName = "")
		try Menu, %MenuName%, Add
	else
		try Menu, %MenuName%, Add, %MenuItemName%, %Label%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;cambiar color
;Sintaxis: MenuColor( [Menú], [Color] )
MenuColor(MenuName, Color, Single := 1) {
	Single := Single ? "Single" : ""
	try Menu, %MenuName%, Color, %Color%, %Single%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;cambiar/quitar icono
;Sintaxis (Tray): MenuColor( [Menú], [Icono], [Indice] )
;Sintaxis (Otros): MenuColor( [Menú], [Item], [Icono], [Indice], [Ancho] )
;NOTAS: 
	;Tray: para ocultar el icono del área de notificacion: obviar el parametro 2 (Icono)
	;Tray: para mostrar el icono del área de notificacion: establecer el parametro 2 en 1
	;Otros: para quitar el icono de un item: obviar el parametro 3 (Icono)
MenuIcon(MenuName, MenuItemName, Icon := 0, IconNumber := 1, IconWidth := "") {
	if (MenuName = "Tray") {
		if MenuItemName {
			if (MenuItemName = 1)
				try Menu, Tray, Icon
			else
				try Menu, Tray, Icon, %MenuItemName%, %Icon%, 1
		} else
			try Menu, Tray, NoIcon
		catch
			return 0, ErrorLevel := 1
	} else {
		if Icon
			try Menu, %MenuName%, Icon, %MenuItemName%, %Icon%, %IconNumber%, %IconWidth%
		else
			try Menu, %MenuName%, NoIcon, %MenuItemName%
		catch
			return 0, ErrorLevel := 1
	}
	return 1, ErrorLevel := 0
}

;clic(s) por defecto para mostrar el menú (área de notificacion)
;Sintaxis: MenuColor( [1|2] )
MenuClick(ClickCount) {
	try Menu, Tray, Click, %ClickCount%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;item por defecto del menu (resaltado en negrita)
;Sintaxis: MenuColor( [Menú], [Item] )
MenuDefault(MenuName, MenuItemName) {
	try Menu, %MenuName%, Default, %MenuItemName%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;añadir/quitar/alternar marca de verificacion
;Sintaxis: MenuCheck( [Menu], [Item], [-1(alternar)|0(quitar)|1(añadir)] )
MenuCheck(MenuName, MenuItemName, Check := 1) {
	if (Check = 1)
		try Menu, %MenuName%, Check, %MenuItemName%
	else if !Check
		try Menu, %MenuName%, UnCheck, %MenuItemName%
	else
		try Menu, %MenuName%, ToggleCheck, %MenuItemName%
	catch
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}







































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SONIDO ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Silencio
;Sintáxis: Mute( [Opcion] )
;OPCIONES:
	;0 = restaurar
	;1 = silenciar
	;2 = alternar
	;[vacio] = devuelve 1 si esta silenciado
SoundMute(Mode := -1) {
	if (Mode = -1)
		return SoundGet(, "MUTE" ) = "On" ? 1 : 0
	return SoundSet( Mode = 2 ? "+1" : Mode,, "MUTE" )
}

;obtener volumen 
SoundGet(ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundGet, OutputVar, %ComponentType%, %ControlType%, %DeviceNumber%
	return OutputVar
}

;establecer volumen
SoundSet(Percent, ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundSet, %Percent%, %ComponentType%, %ControlType%, %DeviceNumber%
	return !ErrorLevel
}

SoundBeep( dwFreq, dwDuration) {
	return DllCall("Kernel32.dll\Beep", "UInt", dwFreq, "UInt", dwDuration)
}

SoundPlay( Filename, Wait := "") {
	SoundPlay, %Filename%, %Wait%
	return !ErrorLevel
}






























;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: SERVICIOS ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;cambiar modo de inicio: boot | system | auto | manual | disable
ServiceSet( IpName, Mode ) {
	mboot := 0, msystem := 1, mauto := 2, mmanual := 3, mdisable := 4
	hService := ServiceOpen( IpName, 0xF003F, 0x0002 )
	return DllCall("Advapi32.dll\ChangeServiceConfigW", "Ptr", hService
		, "UInt", 0xffffffff, "UInt", m%Mode%, "UInt", 0xffffffff, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0) 
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
}

;eliminar
ServiceDelete(IpName) {
	hService := ServiceOpen( IpName, 0xF003F, 0xF01FF )
	return DllCall("Advapi32.lib\DeleteService", "Ptr", hService)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
}

;iniciar
ServiceStart(IpName) {
	StartType := ServiceInfo( IpName ).StartMode
	if (StartType = "disable")
		ServiceSet( IpName, "manual" )
	hService := ServiceOpen( IpName, 0xF003F, 0xF01FF )
	return DllCall("Advapi32.dll\StartServiceW", "Ptr", hService, "UInt", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
}

;detener
ServiceStop(IpName) {
	hService := ServiceOpen( IpName, 0x0020, 0x0020 ), VarSetCapacity(I, 36)
	return DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000001, "UInt", &I)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
}

;obtiene el estado el servicio: STOPPED | RUNNING | PAUSED | PAUSE_PENDING | CONTINUE_PENDING | STOP_PENDING | START_PENDING
;devuelve 0 si ha ocurrido un error
ServiceState(IpName) {
	s1 := "STOPPED", s2 := "START_PENDING", s3 := "STOP_PENDING", s4 := "RUNNING", s5 := "CONTINUE_PENDING", s6 := "PAUSE_PENDING", s7 := "PAUSED"
	hService := ServiceOpen( IpName, 0x0020, 0x0004 )
	VarSetCapacity(lpServiceStatus, 1024, 0)
	hR := DllCall("Advapi32.dll\QueryServiceStatus", "Ptr", hService, "UInt", &lpServiceStatus), i := NumGet(&lpServiceStatus, 4, "UInt")
	return s%i% ? s%i% : 0, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !hR
}
	
;obtener info (tipo de inicio: StartMode)
ServiceInfo(IpName) {
	m0 := "boot", m1 := "system", m2 := "auto", m3 := "manual", m4 := "disable"
	hService := ServiceOpen( IpName, 0xF003F, 0x0001 )
	cbBufSize := VarSetCapacity(lpServiceConfig, 8000, 0)
	DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "UInt", &lpServiceConfig, "UInt", cbBufSize, "UInt*", 0)
	i := {}, i.Type := NumGet(&lpServiceConfig, 0, "UInt") ;tipo | https://msdn.microsoft.com/en-us/library/windows/desktop/ms684950%28v=vs.85%29.aspx
		, i.StartType := a := NumGet(&lpServiceConfig, 4, "UInt") ;tipo de inicio: 0(boot) | 1(system) | 2(auto) | 3(manual) | 4(disable)
		, i.StartMode := m%a% ;tipo de inicio. boot | system | auto | manual | disable
		, i.ErrorControl := NumGet(&lpServiceConfig, 8, "UInt") ;gravedad del error y las medidas adoptadas si este servicio no se puede iniciar
		, i.PathName := StrGet( NumGet(&lpServiceConfig, 12, "UInt") ) ;ruta de acceso completa al archivo binario de servicio
		, i.OrderGroup := StrGet( NumGet(&lpServiceConfig, 16, "UInt") ) ;nombre del grupo de ordenamiento carga a la que pertenece este servicio 
		, i.TagId := NumGet(&lpServiceConfig, 20, "UInt") ;valor de etiqueta única para este servicio en el grupo especificado por el parámetro lpLoadOrderGroup
		, i.Dependencies := NumGet(&lpServiceConfig, 24, "UInt") ;dependencias (array)
		, i.StartName := StrGet( NumGet(&lpServiceConfig, 28, "UInt") ) ;dominio \ usuario
		, i.DisplayName := StrGet( NumGet(&lpServiceConfig, 32, "UInt") ) ;nombre para mostrar para ser utilizado por los programas de control de servicio para identificar el servicio .
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
}

ServiceOpen(lpDisplayName, SCManagerAccess, ServiceAccess) {
	hSCManager := DllCall("AdvApi32.dll\OpenSCManagerW", "Int", 0, "Int", 0, "UInt", SCManagerAccess) 
	lpcchBuffer := VarSetCapacity(lpServiceName, 4000)
	lpServiceName := DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Uint", &lpDisplayName, "Str", lpServiceName, "UIntP", lpcchBuffer) ? lpServiceName : lpDisplayName
	return DllCall("Advapi32.dll\OpenServiceW", "Ptr", hSCManager, "Uint", &lpServiceName, "Uint", ServiceAccess)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hSCManager)
}






















































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: UNIDADES ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;expulsar/retraer unidad de CD/DVD/USB
;Sintaxis: DriveEject( [unidad], [¿cerrar?] )
;NOTA: el script no avanza hasta que la unidad se cierre
DriveEject(IpDrive, Close := 0) { 
	IpDrive := StrLeft( Trim(IpDrive) ) ":"
	IpType := DriveGetType( IpDrive )
	if (IpType = "CDROM") {
		Drive, Eject, %IpDrive%, %Close%
		return !ErrorLevel
	} ;By SKAN: http://ahkscript.org/boards/viewtopic.php?f=6&t=4491
	hDrive := DllCall("Kernel32.dll\CreateFileW", "Str", "\\?\" IpDrive, "UInt", 0, "UInt", 0, "UInt", 0, "UInt", 3, "UInt", 0, "Ptr", 0)
	nOutBufferSize := VarSetcapacity( STORAGE_DEVICE_NUMBER, 8 + A_PtrSize, 0 )
	IpR := DllCall("Kernel32.dll\DeviceIoControl", "Ptr", hDrive, "UInt", 0x2D1080, "Ptr", 0, "UInt", 0, "Ptr", &STORAGE_DEVICE_NUMBER, "UInt", nOutBufferSize, "UIntP", 0, "Ptr", 0 )  
	DllCall("Kernel32.dll\CloseHandle", "Ptr", hDrive)
	IpType := NumGet(STORAGE_DEVICE_NUMBER, "UInt")
	If (IpType = 0x00000007) OR (IpType = 7)
		sPHDRV := "\\\\.\\PHYSICALDRIVE" NumGet(STORAGE_DEVICE_NUMBER, 4, "UInt")
	queryEnum := ComObjGet("winmgmts:").ExecQuery("Select * from Win32_DiskDrive WHERE DeviceID='" sPHDRV "' AND InterfaceType='USB'" )._NewEnum()
	If !queryEnum[ DRV ]
		return 0, ErrorLevel := 1
	nDID := 0, nVT := 1
	DllCall("CfgMgr32.dll\CM_Locate_DevNodeW", "PtrP", nDID, "Str", DRV.PNPDeviceID, "UInt", 0)
	DllCall("CfgMgr32.dll\CM_Get_Parent", "PtrP", nDID, "UInt", nDID, "UInt", 0)
	ulNameLength := VarSetCapacity( VAR, 520, 0 ) / 2
	while % ( nDID and nVT and A_Index < 4 ) 
		DllCall("CfgMgr32.dll\CM_Request_Device_EjectW", "UInt", nDID, "PtrP", nVT, "Str", VAR, "UInt", ulNameLength, "UInt", 0 )
	return nVT ? (ErrorLevel := 1) - 1 : (ErrorLevel := 0) + 1
}

;obtener tipo de unidad: ERROR, Unknown, Removable, Fixed, Network, CDROM, RAMDisk
;Sintaxis: DriveGetType( [Unidad] )
;ErrorLevel: 0(sin errores) | 1(error) | 2(la unidad no existe)
DriveGetType(IpDrive) {
	IpDrive := StrLeft( Trim(IpDrive) ) ":"
	T0 := "Unknown", T1 := "ERROR", T2 := "Removable", T3 := "Fixed", T4 := "Network", T5 := "CDROM", T6 := "RAMDisk"
	IpType := DllCall("Kernel32.dll\GetDriveTypeW", "Str", IpDrive)
	return T%IpType% ? T%IpType% : IpType, ErrorLevel := T%IpType% = "ERROR" ? 2 : T%IpType% ? 0 : 1
}

;cambiar etiqueta de la unidad
DriveSetLabel(IpDrive, lpVolumeName := "") {
	IpDrive := StrLeft( Trim(IpDrive) ) ":\"
	return DllCall("Kernel32.dll\SetVolumeLabelW", "Str", IpDrive, "Str", lpVolumeName)
}

;establece un nombre + icono para la unidad en el registro
;Sintaxis: DriveRegSet( [unidad], [nombre], [icono] )
;NOTAS: 
	;los cambios solo se ven afectados por el SO actual
	;para quitar el icono/nombre poner -1
DriveRegSet(IpDrive, Label := "", Icon := "") {
	IpDrive := StrLeft( Trim(IpDrive) ), ok := 0
	if (Icon = -1) ;quitar icono: -1
		ok += RegDelete( "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultIcon" )
	else if (Icon != "") ;establecer icono si no es [vacio]
		ok += RegWrite(, "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultIcon",, Icon )
	if (Label = -1) ;quitar nombre: -1
		ok += RegDelete( "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultLabel" )
	else if (Label != "") ;establecer nombre si no es [vacio]
		ok += RegWrite(, "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" IpDrive "\DefaultLabel",, Label)
	return ok
}

;obtener informacion de la unidad: Nombre, Sistema de archivos y Número de serie
;Sintaxis: DriveGetInfo( [Unidad], [Nombre (out)], [sistema de archivos (out)], [número de serie (out)] )
;Ejemplo: MsgBox % DriveGetInfo( "C:\" ).Label
;NOTAS: 
	;el número de serie es el signado por el sistema cuando se le dá formato a la unidad; no por el fabricante.
	;si el nombre es [vacio], se intenta obtener desde el registro 'DriveIcons\[unidad]\DefaultLabel'
DriveGetInfo(IpDrive, ByRef lpVolumeNameBuffer := "", ByRef lpFileSystemNameBuffer := "", ByRef lpVolumeSerialNumber := "") {
	IpDrive := StrLeft( Trim(IpDrive) ) ":\", i := {}
	nVolumeNameSize := VarSetCapacity( lpVolumeNameBuffer, 261 * 2, 0 ) / 2 ;label
	nFileSystemNameSize := (VarSetCapacity( lpFileSystemNameBuffer, 60 * 2, 0 ) + 200 + 1) / 2 ;filesystem
	lpMaximumComponentLength := (VarSetCapacity( lpVolumeSerialNumber, 60 * 2, 0 ) - 60) / 2 ;serial
	DriveIcons := "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" StrLeft( IpDrive ) "\DefaultLabel"
	hR := DllCall("Kernel32.dll\GetVolumeInformationW", "Str", IpDrive, "Str", lpVolumeNameBuffer, "UInt", nVolumeNameSize ;Label
	, "Ptr", &lpVolumeSerialNumber, "Ptr", lpMaximumComponentLength ;SerialNumber
	, "Ptr", 0, "Str", lpFileSystemNameBuffer, "UInt", nFileSystemNameSize) ;FileSystem
	i.Label := i.L := lpVolumeNameBuffer != "" ? lpVolumeNameBuffer : RegRead( DriveIcons ) ;nombre de la unidad
	i.FileSystem := i.FS := lpFileSystemNameBuffer ;tipo del sistema de archivos
	i.SerialNumber := i.SN := NumGet( lpVolumeSerialNumber, 0, "UIntP" ) ;número de serie
	return i
		, lpVolumeSerialNumber := i.SerialNumber ;serial
		, lpVolumeNameBuffer := i.Label ;label
		, ErrorLevel := !hR
}

;recupera la cantidad de espacio libre en Bytes (por defecto)
;Sintaxis: DriveSpaceFree( [unidad], [KB|MB|GB] )
;EJEMPLO: 
	;MsgBox % "Bytes: " DriveSpaceFree( "D" ) "`nKB: " DriveSpaceFree( "D", "K" ) "`nMB: " DriveSpaceFree( "D", "M" ) "`nGB: " DriveSpaceFree( "D", "G" )
DriveSpaceFree(IpDrive, Units := 0) {
	uKB := uK := 1024, uMB := uM := 1024**2, uGB := uG := 1024**3
	IpDrive := StrLeft( Trim(IpDrive) ) ":\"
	VarSetCapacity( lpFreeBytesAvailable, 8 + A_PtrSize, 0)
	hR := DllCall("Kernel32.dll\GetDiskFreeSpaceExW", "Str", IpDrive, "UInt64", &lpFreeBytesAvailable, "UInt64", 0, "UInt64", 0)
	lpFreeBytesAvailable := u%Units% ? NumGet(lpFreeBytesAvailable, 0, "UInt64") / u%Units% : NumGet(lpFreeBytesAvailable, 0, "UInt64")
	return lpFreeBytesAvailable, ErrorLevel := !hR
}












































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: MONITOR ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;recupera el nombre del sistema operativo para el número de monitor espesificado
MonGetName(Number := "") {
	SysGet, OutputVar, MonitorName, %Number%
	return OutputVar
}

;Recupera el número total de monitores
MonGetCount() {
	SysGet, OutputVar, MonitorCount
	return OutputVar
}

;Recupera el número del monitor principal
MonGetPrimary() {
	SysGet, OutputVar, MonitorPrimary
	return OutputVar
}

;Monitor: cambia el brillo, contraste y gama
;Sintaxis: MonSet( [brillo], [contraste], [gama] )
MonSet(dwNewBrightness := "", dwNewContrast := "", dwNewGamma := "") {
	;gama
	if (dwNewGamma != "") {
		hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
		Loop, % (VarSetCapacity(GB, 1536) / 6) {
			Number := (dwNewGamma + 128) * (A_Index - 1)
			Number := Number > 65535 ? 65535 : Number
			OffSet := 2 * (A_Index - 1)
			NumPut( Number, GB, OffSet, "UShort") 
		}
		DllCall("RtlMoveMemory", "Ptr", &GB +  512, "Ptr", &GB, "Ptr", 512)
		DllCall("RtlMoveMemory", "Ptr", &GB + 1024, "Ptr", &GB, "Ptr", 512)
		DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC, "Ptr", &GB)
		DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	}
	;brillo y contraste
	if (dwNewBrightness != "") OR (dwNewContrast != "") {
		hMonitor := DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", 0x00000002)
		DllCall("Dxva2.dll\GetNumberOfPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UIntP", pdwNumberOfPhysicalMonitors)
		VarSetCapacity(PHYSICAL_MONITOR, (A_PtrSize + 256) * pdwNumberOfPhysicalMonitors, 0)
		DllCall("Dxva2.dll\GetPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
		hPhysicalMonitor := NumGet(PHYSICAL_MONITOR, 0, "UPtr")
		if (dwNewBrightness != "")
			DllCall("Dxva2.dll\SetMonitorBrightness", "Ptr", hPhysicalMonitor, "UInt", dwNewBrightness)
		if (dwNewContrast != "")
			DllCall("Dxva2.dll\SetMonitorContrast", "Ptr", hPhysicalMonitor, "UInt", dwNewContrast)
		DllCall("Dxva2.dll\DestroyPhysicalMonitors", "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
	}
}

;Monitor: obtener el brillo, contraste y gama
;Sintaxis: MonGet( [brillo (out)], [contraste (out)], [gama (out)] )
MonGet(ByRef pdwCurrentBrightness := "", ByRef pdwCurrentContrast := "", ByRef pdwCurrentGamma := "") {
	i := {}
	;gama
	if IsByRef( pdwCurrentGamma ) {
		hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
		VarSetCapacity(lpRamp, 1536, 0)
		DllCall("Gdi32.dll\GetDeviceGammaRamp", "Ptr", hDC, "Ptr", &lpRamp)
		i.CurrentGamma := pdwCurrentGamma := NumGet(lpRamp, 2, "UShort") - 128
		DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	}
	;brillo y contraste
	if IsByref( pdwCurrentBrightness ) OR IsByref( pdwCurrentContrast ) {
		hMonitor := DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", 0x00000002)
		DllCall("Dxva2.dll\GetNumberOfPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UIntP", pdwNumberOfPhysicalMonitors)
		VarSetCapacity(PHYSICAL_MONITOR, (A_PtrSize + 256) * pdwNumberOfPhysicalMonitors, 0)
		DllCall("Dxva2.dll\GetPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
		hPhysicalMonitor := NumGet(PHYSICAL_MONITOR, 0, "UPtr")
		if IsByref( pdwCurrentBrightness )
			DllCall("Dxva2.dll\GetMonitorBrightness", "Ptr", HPMON, "UIntP", pdwMinimumBrightness, "UIntP", pdwCurrentBrightness, "UIntP", pdwMaximumBrightness, "UInt")
		if IsByref( pdwCurrentContrast )
			DllCall("Dxva2.dll\GetMonitorContrast", "Ptr", HPMON, "UIntP", pdwMinimumContrast, "UIntP", pdwCurrentContrast, "UIntP", pdwMaximumContrast, "UInt")
		i.MinBrightness := pdwMinimumBrightness
		i.MaxBrightness := pdwMaximumBrightness
		i.CurrentBrightness := pdwCurrentBrightness
		i.MinContrast := pdwMinimumContrast
		i.MaxContrast := pdwMaximumContrast
		i.CurrentContrast := pdwCurrentContrast
		DllCall("Dxva2.dll\DestroyPhysicalMonitors", "UInt", pdwNumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR)
	}
	return i
}

/*
Monitors := MDMF_Enum()
Gui, Margin, 20, 20
Gui, +OwnDialogs
Gui, Add, ListView, w660 r10 Grid, HMON|Num|Name|Primary|Left|Top|Right|Bottom|WALeft|WATop|WARight|WABottom
For HMON, M In Monitors {
   LV_Add("", HMON, M.Num, M.Name, M.Primary, M.Left, M.Top, M.Right, M.Bottom, M.WALeft, M.WATop, M.WARight, M.WABottom)
}
Loop, % LV_GetCount("Column")
   LV_ModifyCol(A_Index, "AutoHdr")
Gui, Show, ,Monitors
Return
GuiClose:
ExitApp
*/
; ======================================================================================================================
; Multiple Display Monitors Functions -> msdn.microsoft.com/en-us/library/dd145072(v=vs.85).aspx =======================
; ======================================================================================================================
; Enumerates display monitors and returns an object containing the properties of all monitors or the specified monitor.
; ======================================================================================================================
;http://ahkscript.org/boards/viewtopic.php?f=6&t=4606
MDMF_Enum(HMON := "") {
   Static EnumProc := RegisterCallback("MDMF_EnumProc")
   Static Monitors := {}
   If (HMON = "") ; new enumeration
      Monitors := {}
   If (Monitors.MaxIndex() = "") ; enumerate
      If !DllCall("User32.dll\EnumDisplayMonitors", "Ptr", 0, "Ptr", 0, "Ptr", EnumProc, "Ptr", &Monitors, "UInt")
         Return False
   Return (HMON = "") ? Monitors : Monitors.HasKey(HMON) ? Monitors[HMON] : False
}
; ======================================================================================================================
;  Callback function that is called by the MDMF_Enum function.
; ======================================================================================================================
MDMF_EnumProc(HMON, HDC, PRECT, ObjectAddr) {
   Monitors := Object(ObjectAddr)
   Monitors[HMON] := MDMF_GetInfo(HMON)
   Return True
}
; ======================================================================================================================
;  Retrieves the display monitor that has the largest area of intersection with a specified window.
; ======================================================================================================================
MDMF_FromHWND(HWND) {
   Return DllCall("User32.dll\MonitorFromWindow", "Ptr", HWND, "UInt", 0, "UPtr")
}
; ======================================================================================================================
; Retrieves the display monitor that contains a specified point.
; If either X or Y is empty, the function will use the current cursor position for this value.
; ======================================================================================================================
MDMF_FromPoint(X := "", Y := "") {
   VarSetCapacity(PT, 8, 0)
   If (X = "") || (Y = "") {
      DllCall("User32.dll\GetCursorPos", "Ptr", &PT)
      If (X = "")
         X := NumGet(PT, 0, "Int")
      If (Y = "")
         Y := NumGet(PT, 4, "Int")
   }
   Return DllCall("User32.dll\MonitorFromPoint", "Int64", (X & 0xFFFFFFFF) | (Y << 32), "UInt", 0, "UPtr")
}
; ======================================================================================================================
; Retrieves the display monitor that has the largest area of intersection with a specified rectangle.
; Parameters are consistent with the common AHK definition of a rectangle, which is X, Y, W, H instead of
; Left, Top, Right, Bottom.
; ======================================================================================================================
MDMF_FromRect(X, Y, W, H) {
   VarSetCapacity(RC, 16, 0)
   NumPut(X, RC, 0, "Int"), NumPut(Y, RC, 4, Int), NumPut(X + W, RC, 8, "Int"), NumPut(Y + H, RC, 12, "Int")
   Return DllCall("User32.dll\MonitorFromRect", "Ptr", &RC, "UInt", 0, "UPtr")
}
; ======================================================================================================================
; Retrieves information about a display monitor.
; ======================================================================================================================
MDMF_GetInfo(HMON) {
   NumPut(VarSetCapacity(MIEX, 40 + (32 << !!A_IsUnicode)), MIEX, 0, "UInt")
   If DllCall("User32.dll\GetMonitorInfo", "Ptr", HMON, "Ptr", &MIEX) {
      MonName := StrGet(&MIEX + 40, 32)    ; CCHDEVICENAME = 32
      MonNum := RegExReplace(MonName, ".*(\d+)$", "$1")
      Return {Name:      (Name := StrGet(&MIEX + 40, 32))
            , Num:       RegExReplace(Name, ".*(\d+)$", "$1")
            , Left:      NumGet(MIEX, 4, "Int")    ; display rectangle
            , Top:       NumGet(MIEX, 8, "Int")    ; "
            , Right:     NumGet(MIEX, 12, "Int")   ; "
            , Bottom:    NumGet(MIEX, 16, "Int")   ; "
            , WALeft:    NumGet(MIEX, 20, "Int")   ; work area
            , WATop:     NumGet(MIEX, 24, "Int")   ; "
            , WARight:   NumGet(MIEX, 28, "Int")   ; "
            , WABottom:  NumGet(MIEX, 32, "Int")   ; "
            , Primary:   NumGet(MIEX, 36, "UInt")} ; contains a non-zero value for the primary monitor.
   }
   Return False
}
#Include <ImageButton_Class>
#NoEnv
