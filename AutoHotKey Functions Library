/*
FUNCIONES  AUTOHOTKEY UNICODE 32 & 64 BITS.
-------------------------------------------------------------------------
SO: WIN_XP, WIN_V, WIN_7, WIN_8, WIN_8.1,  WIN_10 ~ 32 & 64 Bits.
Funciones: archivos, carpetas, cadena, criptografía, procesos, internet,
					gui & dialogos, gui controles, registro, control, mouse & teclado, sistema,
					ventanas, servicios, unidades, sonido, monitor, números &
					operaciones matemáticas, menús, ejecutar, barra de tareas,
					escritorio & explorador & menu inicio & papelera de reciclaje,
					notificaciones, fuentes & colores & recursos & DLL, nombres y rutas de archivos,
					tareas programadas, objetos, otros.
Link: http://ahkscript.org/boards/viewtopic.php?f=42&t=5535
AutoHotKey: 1.1.21.01+
Actualizado: AHK1.1.22.09 U32 & U64 || Domingo, 29 de noviembre de 2015
Historial De Cambios: https://github.com/flipeador/AutoHotKey/blob/master/AutoHotKey%20Functions%20Library%20~%20Change%20Log
Notas:
	• si utiliza MUCHO las funciones que utilizan Gdip, iniciarlo antes usando Gdip_Startup().
	• ver INCLUDE al final para links a funciones y clases necesarias.
Codificación: UTF-8 BOM
*/ ;flipeador@gmail.com ################################################################################################
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
; ::::::::::::::::::::::::::::::::::::::::::::: FUNCIONES APARTE (para uso interno) ::::::::::::::::::::::::::::::::::																							   #
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
_mnum(f,s,r:=true){
	return i:=(_:=StrLeft(s:=Trim(s)))!="-"&&_!="+"&&_!="^"?(r?s:(f&s?f:f+s))
	: ((s:=StrTrimLeft(s))?(_="-"?(f&s?f-s:f):_="^"?(f&s?f-s:f+s):(f&s?f:f+s)):f)
	, ErrorLevel := i=f||!f||!s
}_cstr(a,z,m,i){
	_:=i="+"||i="-"||i="|"?0:""
	for k, v in a
		x:=(m="&"?z&v:m="="?z=v:m="~"?InStr(z, k):0)?(m="~"?v:k):(i="-"?0:i="+"?0:i="|"?0:"")
		, x:=i="."?(_.=x):i="|"?(_|=x):i="-"?(_-=x):i="+"?(_+=x):""
	return _, ErrorLevel := _=""
}_cpath(p, ByRef c:=""){
	return c:=(StrLen(i:=GetFullPathName(p))=2?i "\":i)
}_clfm(f,m,r, ByRef ok:=""){
	m := m=0?"F":m=1?"FD":m=2?"D":m=-1?(IsDir(f)?"D":"F"):m, m .= r?"R":""
	return m?m:"", ok := 0, ErrorLevel := m=""
}_wildc(p,r:=0){
	return r||InStr(p,"*")||InStr(p,"?")
}Set(s,v:=""){
	static a:=[]
	if (v=""||s="?"||s="!")
		return s="?"||s="!"?(s="?"?a[v]:s="!"?a:""):a.Delete(s)
	return v,a[s]:=v
}Get(v, ByRef s:=""){
	return s:=Set("?",v)
}_fspdtest(c,f,p*){
	s:=A_TickCount
	Loop, %c%
		%f%(p*)
	return A_TickCount-s
}_fspdtestex(c,f,p*){
	static r
	if !r
		DllCall("Kernel32.dll\QueryPerformanceFrequency", "Int64*", r)
	DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", s)
	Loop, %c%
		%f%(p*)
	DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", u)
	return (u-s)/r
}_getpid(h,z*){
	if z.MaxIndex() {
		p:=z[1],x:=z[2],i:=z[3]
		if p&&InStr(p,".")
			WinGetPID(h?h:x,,i)
		else if p
			i:=WinGetPID(h?h:x)
		return i
	} return Set("LastProcessId",InStr(h,".")||h=-1||h=-2?ProcessExist(h):h=-3?Get("LastProcessId"):h)
}_gethwnd(ByRef h,ByRef c:=""){
	if IsByRef(h)
		h:=h=-1?IsWindow():h=-2?MouseGetPos().Win:h=-3?Get("LastWindowId"):h
		, Set("LastWindowId", h)
	if IsByRef(c)
		c:=c=-1?ControlExist(h,ControlGetFocus(h)):c=-2?MouseGetPos(,,,,2).ctrl
		: c=-3?Get("LastControlId"):ControlExist(h,c), Set("LastControlId", c)
}_getcolor(c) {
	static Colors := {Aqua: "0x00FFFF", Black: "0x000000", Blue: "0x0000FF", Fuchsia: "0xFF00FF", Gray: "0x808080"
		, Green: "0x008000", Lime: "0x00FF00", Maroon: "0x800000", Navy: "0x000080", Olive: "0x808000", Purple: "0x800080"
		, Red: "0xFF0000", Silver: "0xC0C0C0", Teal: "0x008080", White: "0xFFFFFF", Yellow: "0xFFFF00"}
	return (Colors[c]="")?c:Colors[c]
}_vas(obj,ByRef txt){
	for k,v in obj
		if (v=txt)
			return false
	return true
}_variant(ByRef var,type:=0,val:=0){
	return (VarSetCapacity(var,8+2*A_PtrSize)+NumPut(type,var,0,"short")+NumPut(val,var,8,"ptr"))*0+&var
}_vt(p,n){
	return NumGet(NumGet(p+0,"ptr")+n*A_PtrSize,"ptr")
}
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;####################################################################################################################






























;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------  ------------   FUNCIONES	-------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->

;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ARCHIVOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;--------------------------------------------------------------------------------------------------------------------------------------------------
;General
;--------------------------------------------------------------------------------------------------------------------------------------------------
;copiar archivo(s)
;Sintaxis 1: FileCopy( [archivo], [destino\nombre.ext], [¿sobreescribir?] )
;Sintaxis 2: FileCopy( [directorio\*.*], [destino], [¿sobreescribir?], [¿incluir archivos en subcarpetas?] )
FileCopy(Source, Dest, Overwrite := false, Recurse := false) {
	static CopyFlags
	if (CopyFlags="")
		CopyFlags := IsWindowsVistaOrGreater()?0x00001000:0
	Flags := CopyFlags|(Overwrite?0:0x00000001), Count := 0, Dest := GetFullPathName(Dest)
	if  !(Recurse) && !(InStr(Source, "*")) && !(InStr(Source, "?")) {
		Source := GetFullPathName(Source), IsDir(Dest)?(Dest:=Dest "\" SplitPath(Source).FileName):
		return r:=DllCall("Kernel32.dll\CopyFileExW", "Str", "\\?\" Source, "Str", "\\?\" Dest, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags), ErrorLevel := !r
	} Loop, Files, %Source%, % "F" (Recurse?"R":"")
		Count := (Count+!!DllCall("Kernel32.dll\CopyFileExW", "Str", "\\?\" A_LoopFileFullPath, "Str", "\\?\" Dest "\" A_LoopFileName, "UInt", 0, "PtrP", 0, "IntP", 0, "UInt", Flags)), Index := A_Index
	return Count, ErrorLevel := (Count!=Index)
}

;reciclar
;Sintaxis: FileRecycle( [archivo] )
FileRecycle(Filename) {
	FileRecycle, %Filename%
	return !ErrorLevel
}

;eliminar archivo(s)
;Sintaxis: FileDelete( [archivo], [¿operar en subcarpetas?] )
;ErrorLevel: array que contiene los archivos que no se puedieron eliminar (0 si se eliminaron todos).
;Return: array que contiene los archivos eliminados (0 si no se eliminó ninguno).
FileDelete(Filename, Recurse := false) {
	if  !(Recurse) && !(InStr(Filename, "*")) && !(InStr(Filename, "?")) {
		Filename := GetFullPathName(Filename)
		if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" Filename)) {
			FileSetAttrib, -R, %Filename%
			if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" Filename))
				return false, ErrorLevel := [Filename]
		} return [Filename], ErrorLevel := false
	} Result := [], Error := []
	Loop, Files, %Filename%, % (Recurse?"FR":"F")
	{	 if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" A_LoopFileFullPath)) {
			FileSetAttrib, -R, %A_LoopFileFullPath%
			if !(DllCall("Kernel32.dll\DeleteFileW", "Str", "\\?\" A_LoopFileFullPath))
				Error.Push(A_LoopFileFullPath)
			else Result.Push(A_LoopFileFullPath)
		} else Result.Push(A_LoopFileFullPath)
	} return (Result.MaxIndex()?Result:false), ErrorLevel := (Error.MaxIndex()?Error:false)
}

;eliminar archivo al reiniciar
FileRDelete(Filename) {
	Filename := GetFullPathName(Filename)
	return r:=DllCall("Kernel32.dll\MoveFileExW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0x4), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365240%28v=vs.85%29.aspx

;eliminar archivo de forma segura
;Sintaxis: FileSecureDelete( [archivo], [pasadas] )
FileSecureDelete(Filename, Passes := 1) {
	static v := 100000000
	if !(IsObject(obj:=FileOpen(Filename, "rw-rwd"))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "rw-rwd")))
			return false, ErrorLevel := true
	} Bytes := (((Length:=obj.Length)<v)?Length:v), Bytes2 := Mod(Length, v), c := Floor(Length / v)
	Loop, % (Passes) {
		VarSetCapacity(Buffer, Bytes, A_Index)
		Loop, % (c)
			obj.RawWrite(Buffer, Bytes)
		VarSetCapacity(Buffer, Bytes2, A_index), obj.RawWrite(Buffer, Bytes2)
	} obj.Close()
	return FileDelete(Filename)
}

;mover archivo
;Sintaxis: FileMove( [archivo], [destino], [sobreescribir] )
FileMove(FileName, Dest, OverWrite := false) {
	FileMove, %FileName%, %Dest%, %OverWrite%
	return !ErrorLevel
}

;renombrar archivo
;Sintaxis: FileRename( [archivo], [nuevo nombre], [¿sobreescribir?] )
FileRename(FileName, NewName, OverWrite := false) {
	SplitPath, FileName,, DirName
	if !(OverWrite) && (FileExist(DirName "\" NewName))
		return false, ErrorLevel := 2
	FileMove, %FileName%, %DirName%\%NewName%, % !!(OverWrite)
	return !ErrorLevel
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Diálogos
;--------------------------------------------------------------------------------------------------------------------------------------------------
;dialogo para seleccionar archivos
;Sintaxis: FileSelect( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
FileSelect(RootDirFilename := "", Filter := "", Options := 3, Prompt := "") {
	try FileSelectFile, OutputVar, %Options%, %RootDirFilename%, %Prompt%, %Filter%
	catch
		FileSelectFile, OutputVar, %Options%,, %Prompt%, %Filter%
	return OutputVar
}

;dialogo para guardar archivo
;Sintaxis: FileSave( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
FileSave(RootDirFilename := "", Filter := "", Options := 24, Prompt := "") {
	try FileSelectFile, OutputVar, S%Options%, %RootDirFilename%, %Prompt%, %Filter%
	catch
		FileSelectFile, OutputVar, S%Options%,, %Prompt%, %Filter%
	return OutputVar
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Obtener
;--------------------------------------------------------------------------------------------------------------------------------------------------
;obtener fecha de creacion, modificacion y/o último acceso
;Sintaxis: FileGetTime( [archivo/carpeta], [M/C/A] )
FileGetTime(Filename, WhichTime := 0, ByRef ObjTime := "") {
	Filename := RTrim( Filename, "\" ), i := {}
	if WhichTime {
		FileGetTime, Time, %Filename%, %WhichTime%
		if IsByRef( ObjTime )
			FTime := FormatTime( Time )
			, i.Year := SubStr( FTime, 1, 4 ), i.Mon := SubStr( FTime, 5, 2 )
			, i.Day := SubStr( FTime, 7, 2 ), i.Hour := SubStr( FTime, 9, 2 )
			, i.Min := SubStr( FTime, 11, 2 ), i.Sec := SubStr( FTime, 13, 2 )
		return Time, i.Time := Time, ObjTime := i
	} i.M := i.ModificationTime := FileGetTime( Filename, "M" )
	, i.C := i.CreationTime := FileGetTime( Filename, "C" )
	, i.A := i.LastAccessTime := FileGetTime( Filename, "A" )
	return i
}

;obtener version 
;Sintaxis: FileGetVersion( [archivo] )
FileGetVersion(Filename) {
	FileGetVersion, OutputVar, %Filename%
	return OutputVar
}

;obtener tamaño del archivo, en bytes.
;Sintáxis: FileGetSize( [archivo], [KB|MB|GB], [decimales] )
FileGetSize(FileName, Units := "", Places := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	FileGetSize, FileSize, %FileName%
	FileSize := _[Units]?FileSize/_[Units]:FileSize
	return Places=""?FileSize:Round(FileSize, Places)
}

;obtener atributos de un archivo o carpeta
;Sintaxis: FileGetAttrib( [Archivo/Carpeta] )
;ATRIBUTOS: ver FileSetAttrib()
FileGetAttrib(lpFileName, ByRef hAttrib := "", ByRef _cpath := "") {
	static List := {"R": 0x1, "A": 0x20, "S": 0x4, "H": 0x2, "N": 0x80, "D": 0x10, "O": 0x1000, "C": 0x800, "T": 0x100, "E": 0x4000, "V": 0x10000}
	if ((hAttrib:=DllCall("Kernel32.dll\GetFileAttributesW", "Str", "\\?\" _cpath(lpFileName, _cpath)))=-1)
		return false, ErrorLevel := true
	return _cstr(List, hAttrib, "&", "."), ErrorLevel := false
}

;obtener informacion de un acceso directo
;Sintaxis: FileGetShortcut( [acceso directo], [comando], [directorio de trabajo], [parámetros], [descripcion], [icono], [índice], [modo de inicio] )
;Modo de inicio: 1 = normal | 2 = maximizado | 3 = minimizado
;Nota: si el archivo espesificado no es un acceso directo válido, devuelve el archivo espesificado.
FileGetShortcut(ShortcutFile, ByRef OutTarget := "", ByRef OutDir := "", ByRef OutArgs := "", ByRef OutDescription := "", ByRef OutIcon := "", ByRef OutIconNum := "", ByRef OutRunState := "") {
	FileGetShortcut, %ShortcutFile%, OutTarget, OutDir, OutArgs, OutDescription, OutIcon, OutIconNum, OutRunState
	return ErrorLevel?ShortcutFile:(OutTarget?OutTarget:ShortcutFile)
}

;obtiene informacion sobre un archivo
;Sintaxis: FileGetInfo( [archivo], [tipo de informacion] )
;EJEMPLOS:
	;MsgBox % FileGetInfo( comspec ).CompanyName
	;MsgBox % FileGetInfo( comspec, "FileDescription" )
FileGetInfo(FileName, InfoType := "") {
	static InfoList := ["Comments","InternalName","ProductName","CompanyName","LegalCopyright","ProductVersion"
		,"FileDescription","LegalTrademarks","PrivateBuild","FileVersion","OriginalFilename","SpecialBuild"]
	InfoSize := DllCall("Version.dll\GetFileVersionInfoSizeW", "Str", FileName, "Ptr", 0)
	if (ErrorLevel)
		InfoSize := DllCall("Version.dll\GetFileVersionInfoSizeExW", "UInt", 0x01, "Str", FileName, "Ptr", 0)
	VarSetCapacity(InfoData, InfoSize * 2, 0)
	DllCall("Version.dll\GetFileVersionInfoW", "Str", FileName, "UInt", 0, "UInt", InfoSize, "Ptr", &InfoData)
	if (ErrorLevel)
		DllCall("Version.dll\GetFileVersionInfoExW", "UInt", 0x01, "Str", FileName, "UInt", 0, "UInt", InfoSize, "Ptr", &InfoData)
	DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\VarFileInfo\Translation", "PtrP", aInfoData, "PtrP", InfoSize+1)
	, Lang := NumGet(aInfoData+0, "UShort"), CodePage := NumGet(aInfoData+2, "UShort"), Lang_CodePage := Format("{:04X}{:04X}", Lang, CodePage)
	if InfoType {
		DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\StringFileInfo\" Lang_CodePage "\" InfoType, "PtrP", aInfoData, "PtrP", InfoSize)
		return StrGet(aInfoData, InfoSize)
	} FileInfo := {}
	for Index, InfoType in InfoList
		if DllCall("Version.dll\VerQueryValueW", "Ptr", &InfoData, "Str", "\StringFileInfo\" Lang_CodePage "\" InfoType, "PtrP", aInfoData, "PtrP", InfoSize)
			FileInfo[InfoType] := StrGet(aInfoData, InfoSize)
	return FileInfo
} FileGetInfo2(Filename, ValidatePath := 0) {
	Filename := ValidatePath ? GetValidPathName(Filename) : Filename
	if !IsFile( Filename )
		return "", ErrorLevel := 1
	Filename := RegExReplace(Filename, "\\+", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Datafile WHERE Name = '" Filename "'")
		i.AccessMask := a.AccessMask, i.Archive := a.Archive, i.Caption := a.Caption, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod, i.CreationClassName := a.CreationClassName, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName, i.CSName := a.CSName, i.Description := a.Description, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName, i.Encrypted := a.Encrypted, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension, i.FileName := a.FileName, i.FileSize := a.FileSize, i.FileType := a.FileType, i.Writeable := a.Writeable
		, i.FSCreationClassName := a.FSCreationClassName, i.FSName := a.FSName, i.Hidden := a.Hidden, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount, i.LastAccessed := a.LastAccessed, i.LastModified := a.LastModified, i.ManuFacturer := a.Manufacturer
		, i.Name := a.Name, i.Path := a.Path, i.Readable := a.Readable, i.Status := a.Status, i.System := a.System, i.Version := a.Version
	return i, ErrorLevel := !i.Name
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Establecer
;--------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: FileSetTime( [fecha], [archivo], [M|C|A], [0(F)|1(FD)|2(D)], [0|1(R)] )
FileSetTime(Time := "", FilePattern := "", WhichTimeMCA := "M", OperateOnFolders := false, Recurse := false) {
	Loop, Parse, % WhichTimeMCA
		FileSetTime, %Time%, %FilePattern%, %A_LoopField%, %OperateOnFolders%, %Recurse%
	return !ErrorLevel
}

;cambiar atributo(s) a carpetas y archivos.
;Sintaxis: FileSetAttrib( [+/- atributos], [archivo], [modo] )
;Modo: F = incluir archivos | D = incluir directorios | R = incluir subdirectorios.
;Nota: devuelve el número de archivos/carpetas modificadas
;Atributos (ejemplo: R-SH+A): 
	;R = solo lectura (modificable)
	;A = archivo | modificado (modificable)
	;S = sistema (modificable)
	;H = oculto (modificable)
	;N = normal (modificable, único)
	;D = directorio | carpeta
	;O = fuera de linea (modificable)
	;C = comprimido
	;T = temporal (modificable)
	;E = encriptado
	;V = virtual
;Ejemplo:
	;MsgBox % FileSetAttrib("+RS", A_Desktop "\file.txt")
	;MsgBox % FileSetAttrib("-R+H", A_Desktop "\file.txt")
	;MsgBox % FileSetAttrib("-HS", A_Desktop "\file.txt")
FileSetAttrib(Attributes, FilePattern, Mode := "FD") {
	static l := {R: 0x1, A: 0x20, S: 0x4, H: 0x2, N: 0x80, O: 0x1000, T: 0x100}
	if !(ok:=0) && !(_wildc(FilePattern, Recurse)) {
		FileGetAttrib(FilePattern, hAttrib, lpFileName)
		Loop, Parse, % Attributes,, %A_Space%%A_Tab%
			if (l[A_LoopField])
				hAttrib := _mnum(hAttrib, Mode l[A_LoopField], false)
			else Mode := A_LoopField="-"||A_LoopField="^"?A_LoopField:""
		return i := DllCall("Kernel32.dll\SetFileAttributesW", "Str",  "\\?\" lpFileName, "UInt", hAttrib), ErrorLevel := !i
	} Loop, Files, %FilePattern%, %Mode%
		ok += FileSetAttrib(Attributes, A_LoopFileLongPath), i := A_Index
	return ok, ErrorLevel := (ok!=i)
}

;crear acceso directo
;Sintaxis: FileCreateShortcut( [comando], [acceso directo], [parámetros], [descricpion], [icono], [tecla de acceso], [índice], [modo de inicio] )
;Modo de inicio: 1 = normal | 2 = maximizado | 3 = minimizado
;Nota: espesificar A_Tab ("	") en el 4to parametro (descripcion) para establecer la descripcion por defecto del archivo.
FileCreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := "", ShortcutKey := "", IconNumber := 1, RunState := 1) {
	Description := Description=A_Tab?FileGetInfo(Target, "FileDescription"):Description
	FileCreateShortcut, %Target%, %ShortcutFile%, %WorkingDir%, %Args%, %Description%, %IconFile%, %ShortcutKey%, %IconNumber%, %RunState%
	return !ErrorLevel
}

;establecer seguridad para el archivo/carpeta
;Sintaxis: FileSetSecurity( [archivo/carpeta], [usuario], [acceso], [opcion] )
;Usuario: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379637%28v=vs.85%29.aspx
;Accesos: 2032127 = FULL | 1179817 = READ | 1179958 = WRITE | 1245631 = CHANGE
;Opcion: 0 = carpeta | 1 = carpeta+archivos | 2 = carpeta+subcarpetas | 3 = carpeta+subcarpetas+archivos
FileSetSecurity(File, Trustee := "S-1-1-0", AccessMask := 2032127, Flags := 0) {
	dacl := ComObjCreate("AccessControlList"), sd := ComObjCreate("SecurityDescriptor")
	, newAce := ComObjCreate("AccessControlEntry"), sdutil := ComObjCreate("ADsSecurityUtility")
	, sd := sdUtil.GetSecurityDescriptor(File, true, true), dacl := sd.DiscretionaryAcl, newAce.Trustee := Trustee
	, newAce.AccessMask := AccessMask, newAce.AceFlags := Flags, newAce.AceType := false, dacl.AddAce(newAce)
	return sdutil.SetSecurityDescriptor(File, true, sd, true)
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Escribir
;--------------------------------------------------------------------------------------------------------------------------------------------------
;escribir en un archivo (añadir)
;Sintáxis: FileAppend( [Texto], [*Archivo], [codificación] )
FileAppend(Text, Filename, Encoding := "") {
	FileAppend, %Text%, %Filename%, %Encoding%
	if (ErrorLevel) {
		FileSetAttrib, -R, %Filename%
		FileAppend, %Text%, %Filename%, %Encoding%
	} return !ErrorLevel
}

;añadir texto a una linea espesífica.
;Sintáxis: FileAppendLine( [Texto], [Archivo], [Número de linea], [codificación], [L (añadir a la izquierda)] )
FileAppendLine(Text, Filename, LineNum, Encoding := "", Pos := "") {
	if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding)))
			return false, ErrorLevel := true
	} _ := obj.Read(), Lines := StrSplit(_, "`n", "`r").MaxIndex()
	if ((Lines?Lines:0)<LineNum) {
		Loop, % (LineNum-(Lines?Lines:0))
			_ .= "`n"
	} Loop, Parse, % _, `n, `r
		NewText .= (A_Index=1?"":"`n") (Pos="L"?"":A_LoopField) (A_Index=LineNum?Text:"") (Pos="L"?A_LoopField:"")
	obj.Length := StrLen(NewText), obj.Seek(0)
	return (bytes:=obj.Write(NewText)), ErrorLevel := !(bytes)
}

;escribir en un archivo (mismo efecto que eliminar el archivo y volver a crearlo).
;Sintáxis: FileWrite( [Texto], [Archivo], [codificación] )
FileWrite(Text, Filename, Encoding := "") {
	if !(IsObject(obj:=FileOpen(Filename, "w`n-rwd", Encoding))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "w`n-rwd", Encoding)))
			return false, ErrorLevel := true
	} obj.Length := StrLen(Text)
	return (bytes:=obj.Write(Text)), ErrorLevel := !(bytes)
}

;escribir en una linea espesifica (reemplazar linea entera).
;Sintáxis: FileWriteLine( [Texto], [Archivo], [Número de linea], [codificación], [¿eliminar linea?] )
FileWriteLine(Text, Filename, LineNum, Encoding := "", DeleteLine := false) {
	if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding))) {
		FileSetAttrib, -R, %Filename%
		if !(IsObject(obj:=FileOpen(Filename, "rw`n-rwd", Encoding)))
			return false, ErrorLevel := true
	} _ := obj.Read(), Lines := StrSplit(_, "`n", "`r").MaxIndex()
	if ((Lines?Lines:0)<LineNum) {
		Loop, % (LineNum-(Lines?Lines:0))
			_ .= "`n"
	} Loop, Parse, % _, `n, `r
		NewText .= (DeleteLine&&(A_Index=LineNum))?"":((A_Index=1?"":"`n") (A_Index=LineNum?Text:A_LoopField))
	obj.Length := StrLen(NewText), obj.Seek(0)
	return (bytes:=obj.Write(NewText)), ErrorLevel := !(bytes)
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Leer
;--------------------------------------------------------------------------------------------------------------------------------------------------
;leer archivo
;Sintáxis: FileRead( [Archivo] )
FileRead(Filename) {
	try FileRead, OutputVar, %Filename%
	catch {
		return OutputVar, ErrorLevel := true
	} return OutputVar, ErrorLevel := false
}

;leer texto en la línea espesificada.
;Sintaxis: FileReadLine( [Archivo], [Linea] )
FileReadLine(FileName, LineNum, Encoding := "") {
	if !(IsObject(obj:=FileOpen(Filename, "r`n-wd", Encoding)))
		return false, ErrorLevel := true
	Loop, % (LineNum-1)
		obj.ReadLine()
	return obj.ReadLine(), ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Otros
;--------------------------------------------------------------------------------------------------------------------------------------------------
;comprueba si es archivo
;Sintaxis: IsFile( [archivo] )
IsFile(Filename, ByRef FullPathName := "") {
	if IsByRef(FullPathName)
		FullPathName := GetFullPathName(Filename)
	return (!InStr(i:=FileExist(Filename),"D")&&i)
}

;comparar dos versiones 
;Sintaxis: VersionCompare( [version1], [version2], [resultado] )
;Resultado: +(ver1 > ver2) | -(ver1 < ver2) | =(ver1 = ver2)
;Return: 0(Ver1 = Ver2) | 1(Ver1 > Ver2) | 2(Ver1 < Ver2)
VersionCompare(version1, version2, ByRef OutputVar := "") {
	if !(v2:=Trim(RegExReplace(version2, "[^0-9.]"), "."))
		return true, OutputVar := "+"
	if !(v1:=Trim(RegExReplace(version1, "[^0-9.]"), "."))
		return 2, OutputVar := "-"
	vA := StrSplit(v1, "."), vB := StrSplit(v2, ".")
	Loop, % (vA.MaxIndex()>vB.MaxIndex()?vA.MaxIndex():vB.MaxIndex()) {
		if (vA.MaxIndex()<A_Index)
			vA[A_Index] := 0
		if (vB.MaxIndex()<A_Index)
			vB[A_Index] := 0
		if (vA[A_Index]>vB[A_Index])
			return true, OutputVar := "+"
		if (vB[A_Index]>vA[A_Index])
			return 2, OutputVar := "-"
	} return false, OutputVar := "="
} FileVersionCompare(v1, v2) {
	return VersionCompare(v1, v2)
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=5959

;comparar el tamaño de varios archivos
;RESULTADO:
	;0: todos tienen el mismo tamaño
	;1: el primer tamaño (1º archivo) es mayor al segundo (2º archivo)
	;2: el primer tamaño (1º archivo) es menor al segundo (2º archivo)
	;3+: devuelve la posicion de larchivo con el tamaño diferente
FileSizeCompare(Files*) {
	if !(Files.MaxIndex() >= 2)
		return 0, ErrorLevel := 1
	Loop, % Files.MaxIndex() {
		CurrentFileSize := FileGetSize(Files[A_Index])
		, FirstFileSize := A_Index=1?CurrentFileSize:FirstFileSize
		, SecondFileSize := A_Index=2?CurrentFileSize:SecondFileSize
		if (A_Index > 1) && (CurrentFileSize != LastFileSize)
			return FirstFileSize>SecondFileSize?1:(FirstFileSize<SecondFileSize?2:A_Index)
		LastFileSize := CurrentFileSize
	} return ErrorLevel := 0
}

;separa un nombre de archivo o URL en su nombre, directorio, la extensión y la unidad.
;Sintaxis: SplitPath( [Nombre / URL], [nombre.ext], [directorio], [extension], [nombre], [unidad] )
SplitPath(InputVar, ByRef OutFileName := "", ByRef OutDir := "", ByRef OutExtension := "", ByRef OutNameNoExt := "", ByRef OutDrive := "") {
	SplitPath, InputVar, OutFileName, OutDir, OutExtension, OutNameNoExt, OutDrive
	i := {}, i.FileName := (i.FN:=OutFileName), i.Dir := OutDir, i.Ext := (i.Extension:=OutExtension), i.Name := OutNameNoExt, i.Drive := OutDrive
	return i
}

FileFNPath(Filename, Start := "(", End := ")") {
	Filename := GetFullPathName(Filename), SplitPath(Filename, FullName, Dir, Ext, Name)
	, Filename := Dir "\" Name, Ext := Ext=""?"":"." Ext
	Loop {
		if FileExist((tmppath?tmppath:Filename) Ext)
			tmppath := tmppath?StrReplace(tmppath, Start (A_Index-1) End, Start A_Index End):Filename Start true End
		else return (tmppath?tmppath:Filename) Ext
}}

;esperar a que un archivo exista o no
;Sintaxis: FileWait( [archivo], [segundos], [¿esperar a que no exista?] )
FileWait(FileName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	FileName := GetFullPathName(FileName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsFile(FileName))||(!NotExist&&IsFile(FileName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
}}

;leer/escribir/eliminar en archivos .ini
IniRead(Filename := "", Section := "", Key := "", OutputVar := " ") {
	static _
	if (Key!=""&&Section!="")
		IniRead, OutputVar, % (_:=((Filename="")?_:Filename)), %Section%, %Key%, %OutputVar%
	else if (Key=""&&Section!="")
		IniRead, OutputVar, % (_:=((Filename="")?_:Filename)), %Section%
	else IniRead, OutputVar, % (_:=((Filename="")?_:Filename))
	return OutputVar
} IniWrite(Value := "", Filename := "", Section := "", Key := "") {
	static _
	if (Key="")
		IniWrite, %Value%, % (_:=((Filename="")?_:Filename)), %Section%
	else IniWrite, %Value%, % (_:=((Filename="")?_:Filename)), %Section%, %Key%
	return !ErrorLevel
} IniDelete(Filename := "", Section := "", Key := "") {
	static _
	if (Key="")
		IniDelete, % (_:=((Filename="")?_:Filename)), %Section%
	else IniDelete, % (_:=((Filename="")?_:Filename)), %Section%, %Key%
	return !ErrorLeveL
}

;crear acceso directo
;Sintaxis: CreateShortcut( [archivo al que hace referencia], [acceso directo], [directorio de trabajo], [argumentos], [descripcion], [icono], [tecla], [inicio] )
;Icono: espesificar el icono o un Array con el icono y el indice [Icono, Indice].
;Tecla: tecla de método abreviado.
;Inicio: modo de inicio. 1 = Normal (defecto). 3 = Maximizado. 7 = Minimizado.
;Nota: si el acceso directo ya existe, lo sobreescribe.
CreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := -1, ShortcutKey := "", RunState := 1) {
	try WshShell := ComObjCreate("WScript.Shell")
	, oShellLink := WshShell.CreateShortcut(GetFullPathName(ShortcutFile))
	, oShellLink.TargetPath := Target, oShellLink.Arguments := Args
	, oShellLink.WorkingDirectory := WorkingDir, oShellLink.Description := Description
	, oShellLink.IconLocation := (IsObject(IconFile)?(IconFile[1] ", " (IconFile[2]>0?IconFile[2]:0)):(((IconFile=-1)?Target:IconFile) ", 0"))
	, oShellLink.Hotkey := ShortcutKey, oShellLink.WindowStyle := ((RunState=3)||(RunState=7))?RunState:1, oShellLink.Save
	catch, OutputVar
		return false, ErrorLevel := (OutputVar?OutputVar:true)
	return true, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/xk6kst2k%28v=vs.84%29.aspx

;Sintaxis: CreateFile( [archivo], [acceso], [acceso compartido], [SECURITY_ATTRIBUTES], [accion], [opciones y atributos], [TEMPLATEFILE])
;Accesos: Read=0x80000000 | Write=0x40000000 | EXECUTE=0x20000000 | ALL=0x10000000
;Accesos compartido: Read=1 | Write=2 | DELETE=4 | ALL=7 | 0
;SECURITY_ATTRIBUTES: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
;Accion: CREATE_ALWAYS=2 | CREATE_NEW=1 | OPEN_ALWAYS=4 | OPEN_EXISTING=3 | TRUNCATE_EXISTING=5
CreateFile(Filename, DesiredAccess := 0x10000000, ShareMode := 7, SecurityAttributes := 0, CreationDisposition := 2, FlagsAndAttributes := 0, TemplateFile := 0) {
	hFile := DllCall("Kernel32.dll\CreateFileW", "Ptr", &Filename, "UInt", DesiredAccess, "UInt", ShareMode
	, "Ptr", SecurityAttributes, "UInt", CreationDisposition, "UInt", FlagsAndAttributes, "Ptr", TemplateFile, "Ptr")
	return hFile, ErrorLevel := !hFile
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx

;Sintaxis: WriteFile( [hFile], [data], [bytes], [bytes out], [OVERLAPPED] )
;OVERLAPPED: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684342(v=vs.85).aspx
WriteFile(hFile, Buffer, Bytes := 0, ByRef BytesOut := 0, ByRef Overlapped := 0) {
	r := DllCall("Kernel32.dll\WriteFile", "Ptr", hFile, "Ptr", Buffer, Bytes?"UInt":"Ptr", Bytes, "UIntP", BytesOut, "Ptr", Overlapped, "UInt")
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx

CloseHandle(HANDLE*) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx
	r := ErrorLevel
	Loop, % (HANDLE.MaxIndex())
		DllCall("Kernel32.dll\CloseHandle", "Ptr", HANDLE[A_Index])
	return "", ErrorLevel := r
} GetHandleInformation(Handle) { ;Return: HANDLE_FLAG_INHERIT=1 | HANDLE_FLAG_PROTECT_FROM_CLOSE=2 | 0
	r := DllCall("Kernel32.dll\GetHandleInformation", "Ptr", Handle, "UIntP", Flags)
	return Flags, ErrorLevel := !r ;ErrorLevel = 1 => Invalid HANDLE
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724329(v=vs.85).aspx

;abrir un directorio en el explorador de windows y seleccionar archivo(s)
;Sintaxis: OpenFolderAndSelectItems( [directorio], [archivos, espesificar un array para varios archivos], [opciones] )
;Opciones:
	;0x0001 = selecciona un archivo y poner su nombre en el modo de edición. solo válido para un archivo.
	;0x0002 = selecciona el archivo(s) en el escritorio en lugar de en una ventana del Explorador de Windows. si el escritorio se oculta detrás de las ventanas abiertas, no se hará visible
;Ejemplo: MsgBox % OpenFolderAndSelectItems(A_WinDir, ["explorer.exe", "hh.exe", "nonexistsfile.ext"]) "`n" ErrorLevel
;Nota: archivos inválidos se omiten (no existen)
OpenFolderAndSelectItems(DirName, Files, Flags := 0x0) {
	if !(DirExist(DirName)) || !(Files:=GetValidArrayFiles(Files,, DirName "\"))
		return false, ErrorLevel := 2
	DllCall("Ole32.dll\CoInitialize", "Ptr", 0), VarSetCapacity(PidlArray, Files.MaxIndex() * A_PtrSize, 0) ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms678543(v=vs.85).aspx
	for k, v in Files
		NumPut(ParseDisplayName(DirName "\" v), PidlArray, (k - 1) * A_PtrSize, "Ptr")
	r := DllCall("Shell32.dll\SHOpenFolderAndSelectItems", "Ptr", FolderPidl:=ParseDisplayName(DirName), "UInt", Files.MaxIndex(), "Ptr", &PidlArray, "UInt", Flags)
	for k, v in Files
		DllCall("Ole32.dll\CoTaskMemFree", "Ptr", NumGet(PidlArray, (k - 1) * A_PtrSize), "Ptr") ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680722(v=vs.85).aspx
	DllCall("Ole32.dll\CoTaskMemFree", "Ptr", FolderPidl), DllCall("Ole32.dll\CoUninitialize") ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms688715(v=vs.85).aspx
	return !r, ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762232(v=vs.85).aspx













































































;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: EJECUTAR ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;ejecutar archivo, abrir carpeta/URL
;Sintáxis: Run( [Archivo], [directorio de trabajo], [opciones], [PID] )
Run(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	if !Contains(Target, Chr(34) ",*,?,/,<,>,|")&&FileExist(Target)
		Target := Chr(34) Target Chr(34)
	Run, %Target%, %WorkingDir%, UseErrorLevel %Options%, OutputVarPID
	return ErrorLevel?0:(OutputVarPID?OutputVarPID:true)
}

;ejecutar archivo (esperar)
;Sintáxis: RunWait( [Archivo], [directorio de trabajo], [opciones], [PID] )
RunWait(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	if !Contains(Target, Chr(34) ",*,?,/,:,<,>,|")&&FileExist(Target)
		Target := Chr(34) Target Chr(34)
	RunWait, %Target%, %WorkingDir%, UseErrorLevel %Options%, OutputVarPID
	return ErrorLevel?0:(OutputVarPID?OutputVarPID:true)
}

;ejecuta como
;Sintáxis: RunAs( [usuario], [contraseña], [dominio|@YourComputerName] )
RunAs(User := "", Password := "", Domain*) {
	if (User="")&&(Password="")&&!Domain.MaxIndex()
		RunAs
	else if Domain.MaxIndex()
		RunAs, %User%, %Password%, % Domain[1]
	else RunAs, %User%, %Password%
} Start(Target := "", Param*) {
	Loop, % Param.MaxIndex()
		_ .= (A_Index=1?"":A_Space) (RegExMatch(Param[A_Index], "\s")?Chr(34) Param[A_Index] Chr(34):Param[A_Index])
	return StrLeft(Target)="*"?RunWait(Chr(34) StrTrimLeft(Target,1) Chr(34) " " _):Run(Chr(34) Target Chr(34) " " _)
}

;abrir propiedades de un archivo/carpeta
;Sintaxis: Properties( [archivo/carpeta], [esperar (segundos)], [¿AlwaysOnTop?] )
;Notas: 
	;• para esperar indefinidamente, espesificar 0 (segundo parametro)
	;• cuando se espesifica tiempo fuera, primero busca y cierra todas las demás ventanas
		;de propiedades abiertas por el proceso actual; ya que sino, esperaría a que todas las
		;ventanas se cierren, y solo queremos esperar la que espesificamos para el archivo.
;Ejemplo: Properties(comspec, false, true), ExitApp()
Properties(Target, WaitClose := -1, AlwaysOnTop := false) {
	if !FileExist(Target)
		return 0, ErrorLevel := 2
	if (WaitClose>-1) {
		CurrentProcessId := ProcessExist()
		, WinCloseEx(, "#32770", CurrentProcessId, true)
		, Run("Properties " Chr(34) Target Chr(34))
		, hWnd := WinWait(, 5, "#32770", CurrentProcessId)
		if (AlwaysOnTop)
			WinSet(hWnd, "+AlwaysOnTop")
		return WinWaitClose(hWnd, WaitClose)
	} r := Run("Properties " Chr(34) Target Chr(34))
	if (AlwaysOnTop&&(hWnd:=WinWait(, 5, "#32770", ProcessExist())))
		WinSet(hWnd, "+AlwaysOnTop")
	return hWnd?hWnd:r, ErrorLevel := !r
}

;ejecuta un comando en la consola y devuelve el resultado
;Sintaxis: CMD( [ID], [comando], [¿cerrar al finalizar?] )
;Ejemplo: MsgBox % CMD("tasklist")
	;o usar el portapapeles: RunWait(ComSpec " /c tasklist | CLIP",, "Hide"), MsgBox(Clipboard)
CMD(hWnd := "", CMD := "", Close := true) {
	if (CMD="")
		CMD := hWnd, hWnd := false
	if !(hWnd)
		hWnd := Run(ComSpec,, "Hide")
	WinWait(hWnd, 5), DllCall("Kernel32.dll\AttachConsole", "UInt", hWnd)
	, WshShell := ComObjCreate("Wscript.Shell")
	, output := WshShell.Exec(CMD).StdOut.ReadAll()
	if (Close)
		ProcessClose(hWnd)
	return output, DllCall("Kernel32.dll\FreeConsole")
} Exec(cmd, WaitClose := false) {
	WshShell := ComObjCreate("WScript.Shell")
	, r := (IsObject(oExec:=WshShell.Exec(cmd)))
	Loop
		Sleep, % WaitClose?100:0
	until !(WaitClose) || (oExec.Status=1)
	return WaitClose?r:oExec, ErrorLevel := !r
}





















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CARPETAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;eliminar directorio
;Sintaxis: DirDelete( [carpeta], [¿eliminar archivos y subcarpetas?] )
DirDelete(DirName, Recurse := false) {
	FileRemoveDir, %DirName%, %Recurse%
	return !ErrorLevel
} DirRemove(DirName, Recurse := false) {
	FileRemoveDir, %DirName%, %Recurse%
	return !ErrorLevel
}

;vaciar directorio sin eliminarlo
;Sintaxis: DirEmpty( [directorio], [¿incluir subdirectorios?] )
;Return: array que contiene los archivos y carpetas eliminados (0 si no se eliminó nada).
;ErrorLevel: array que contiene los archivos y carpetas que no se puedieron eliminar (0 si se eliminó todo).
DirEmpty(DirName, Recurse := false) {
	Error := [], OutputVar := []
	Loop, Files, %DirName%\*.*, FD
	{	if IsFile(A_LoopFileFullPath) {
			if !(FileDelete(A_LoopFileFullPath))
				Error.Push(A_LoopFileFullPath)
			else OutputVar.Push(A_LoopFileFullPath)
		} else {
			if !(DirDelete(A_LoopFileFullPath, Recurse))
				Error.Push(A_LoopFileFullPath)
			else OutputVar.Push(A_LoopFileFullPath)
	}} return OutputVar.MaxIndex()?OutputVar:false, ErrorLevel := Error.MaxIndex()?Error:false
}

;eliminar directorio de forma segura
;Sintáxis: DirSecureDelete( [directorio], [pasadas] )
DirSecureDelete(DirName, Passes := 1) {
	Loop, Files, % RTrim(DirName, "\") "\*.*", FR
		FileSecureDelete(A_LoopFileFullPath, Passes)
	return DirDelete(DirName, true)
}

;renombrar directorio
;Sintaxis: Rename( [directorio], [nuevo nombre], [¿eliminar si ya existe una carpeta con el mismo nombre?], [¿eliminar si la carpeta no está vacía?] )
DirRename(Dirname, NewName, OverWrite := false, Recurse := false) {
	SplitPath, Dirname,, Dir
	if (FileExist(Dir "\" NewName)) {
		if !(OverWrite)
			return false, ErrorLevel := 2
		if !(DirDelete(Dir "\" NewName, Recurse))
			return false, ErrorLevel := 3
	} FileMoveDir, %Dirname%, %Dir%\%NewName%, R
	return !ErrorLevel
}

;mover directorio
;Sintaxis: DirMove( [directorio], [destino], [opciones], [¿eliminar si el directorio no está vacio?] )
;Opciones: 1 = sobreescribir archivos | 2 = eliminar destino antes de copiar.
DirMove(DirName, Dest, OverWrite := false, Recurse := true) {
	if (OverWrite=2)
		DirDelete(Dest, Recurse)
	FileMoveDir, %DirName%, %Dest%, % ((OverWrite="R")?"R":!!(OverWrite))
	return !ErrorLevel
}

;copiar directorio
;Sintaxis: DirCopy( [directorio], [destino], [opciones] )
;Opciones: 1 = sobreescribir archivos | 2 = eliminar destino antes de copiar.
DirCopy(Source, Dest, OverWrite := false) {
	if (OverWrite=2)
		DirDelete(Dest, true)
	FileCopyDir, % RTrim(Source, "\"), % RTrim(Dest, "\"), % OverWrite?true:false
	return !ErrorLevel
}

;crear carpeta
;Sintaxis: DirCreate( [directorio], [¿crear subdirectorios?], [eliminar antes si existe 0|1] )
DirCreate(DirName, Recurse := true, Remove := "") {
	if (Remove=0) || (Remove=1)
		DirRemove(DirName, Remove)
	if (Recurse) {
		FileCreateDir, %DirName%
		return !ErrorLevel
	} return r:=DllCall("Kernel32.dll\CreateDirectoryW", "Str", "\\?\" DirName, "Ptr", 0), ErrorLevel := !r
}

;dialogo: seleccionar carpeta
;Sintaxis: DirSelect( [Directorio], [Opciones/VentanaID], [Título] )
DirSelect(StartingFolder := "", Options := 1,  Prompt := "") {
	try FileSelectFolder, OutputVar, %StartingFolder%, %Options%, %Prompt%
	catch
		FileSelectFolder, OutputVar,, %Options%, %Prompt%
	if (Options=1) && !(OutputVar)
		ErrorLevel := true
	return RTrim(OutputVar, "\")
}

;comprueba si es carpeta
;Sintaxis: IsDir( [carpeta] )
IsDir(DirName, ByRef FullPathName := "") {
	if IsByRef(FullPathName)
		FullPathName := GetFullPathName(DirName)
	return InStr(FileExist(DirName),"D")
} IsFolder(DirName, ByRef FullPathName := "") {
	return IsByRef(FullPathName)?IsDir(DirName, FullPathName):IsDir(DirName)
}

;comprueba si el directorio existe, quita \ al final, si lo tiene.
DirExist(ByRef Path) {
	Path := Trim(RegExReplace(Trim(Path), "\\+$"))
	return InStr(FileExist(Path), "D")?Path:""
}

;abrir carpeta con explorer.exe
;Sintaxis: DirOpen( [carpeta], [abrir en una nueva ventana] ) 
DirOpen(Dir, NewWindow := false) {
	if !DirExist(Dir)
		return false, ErrorLevel := true
	return Run(A_WinDir "\explorer.exe " (NewWindow?"/n,":"") Chr(34) Dir Chr(34))
}

;obtiene informacion sobre un directorio
;EJEMPLO: MsgBox % DirGetInfo( A_WinDir ).CSName
DirGetInfo(Dirname, ValidatePath := 0) {
	if !DirExist( Dirname )
		return "", ErrorLevel := 1
	Dirname := StrReplace(Dirname, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Directory WHERE Name = '" Dirname "'")
		i.AccessMask := a.AccessMask, i.Archive := a.Archive, i.Caption := a.Caption, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod, i.CreationClassName := a.CreationClassName, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName, i.CSName := a.CSName, i.Description := a.Description, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName, i.Encrypted := a.Encrypted, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension, i.FileName := a.FileName, i.FileType := a.FileType, i.LastAccessed := a.LastAccessed
		, i.FSName := a.FSName, i.InstallDate := a.InstallDate, i.InUseCount := a.InUseCount, i.FileSize := a.FileSize, i.Hidden := a.Hidden
		, i.LastModified := a.LastModified, i.Name := a.Name, i.Path := a.Path, i.Readable := a.Readable, i.Status := a.Status
		, i.System := a.System, i.Version := a.Version, i.Writeable := a.Writeable, i.FSCreationClassName := a.FSCreationClassName
	return i, ErrorLevel := !i.Name
}

;esperar a que un directorio exista o no
;Sintaxis: DirWait( [directorio], [segundos], [¿esperar a que no exista?] )
DirWait(DirName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	DirName := GetFullPathName(DirName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsDir(DirName))||(!NotExist&&IsDir(DirName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
}}

;obtener tamaño de un directorio
;Sintaxis: DirGetSize( [directorio], [KB|MB|GB], [¿incluir subcarpetas?] )
DirGetSize(DirName, Units := "", Recurse := true) {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	Size := 0
	Loop, Files, %DirName%\*.*, % Recurse?"FR":"F"
		Size += A_LoopFileSize
	return _[Units]?Size/_[Units]:Size, ErrorLevel := !IsFolder(DirName)
}



















































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: NÚMEROS & OPERACIONES MATEMÁTICAS ::::::::::::::::::::::::::::::::::
Links:
	• http://ahkscript.org/boards/viewtopic.php?t=3925
	• https://dl.dropboxusercontent.com/u/186419968/html/BaseConversion/index.html
#############################################################################################################################################
*/
;elevar un numero (potenciación)
;Sintaxis: Power( [base], [exponente] )
;Ejemplo: MsgBox % Power(99, 999) ;99^999
;Nota: números >999 puede ser muy lento.
Power(Base, Exponent) {
	SLB := StrLen(Base), VarSetCapacity(B, SLB, 0)
	Loop, Parse, % Base
		NumPut(A_LoopField, B, SLB - A_Index, "UChar")
	VarSetCapacity(P, SLB, 0), DllCall("RtlMoveMemory", "Ptr", &P, "Ptr", &B, "Ptr", PL := SLB)
	Loop, % (Exponent - 1) {
		V := 0, VarSetCapacity(R, RL := PL + SLB + 1, 0)
		Loop, %SLB% { ; multiply
			If (I := NumGet(B, A_Index - 1, "UChar")) {
				Loop, %PL%
					N := NumGet(R, J := A_Index + V - 1, "UChar") + (NumGet(P, A_Index - 1, "UChar") * I)
					, NumPut(SubStr(N, 0), R, J++, "UChar")
					, NumPut(NumGet(R, J, "UChar") + SubStr("0" . N, -1, 1), R, J, "UChar")
			} V++
		} VarSetCapacity(P, RL, 0), DllCall("RtlMoveMemory", "Ptr", &P, "Ptr", &R, "Ptr", PL := RL)
		while !NumGet(P, PL - 1, "UChar") ; remove trailing zeroes
			PL--
	} VarSetCapacity(V, RL, 0)
	Loop, %RL%
		V .= NumGet(R, --RL, "UChar")
	return LTrim(V, "0")
} ;http://ahkscript.org/boards/viewtopic.php?p=49693#p49693

;convierte cualquier número a la forma perfecta, es decir, elimina ceros adicionales y agrega requeridos.
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
Prefect(num) {
	if !num
		return 0
	if InStr(num, "-")
		num := Substr(num, 2), neg := "-"
	if InStr(num, ".") {
		num := Trim(num, 0)
		if (Substr(num, 1, 1) = ".")
			num := "0" num
		if (Substr(num, 0) = ".")
			num := Substr(num, 1, -1)
		return neg num
	} return Trim(num, 0)?neg LTrim(num, 0):0
}

;redondear un número
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
RoundEx(num, places := 0) {
	if !(dot:=InStr(num, "."))
		return num
	ndec := ((len:=StrLen(num))-dot)=0?len:dot
	if (ndec>places) {
		if ((dig:=Substr(num, dot+places+1, 1))>=5)
			Loop, % (places-1)
				z .= "0"
		num := Add(Substr(num, 1, InStr(num, ".")+places), (dig>=5)?"0." z "1":"0")
	} else {
		Loop, % (places-ndec)
			z .= "0"
		num .= z
	} return Rtrim(num, ".")
}

;multiplicar dos números.
;Sintaxis: Multiply( [(-)valor 1], [(-)valor2] )
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
Multiply(num1, num2) {
	ps := (mnum2:=InStr(num2, "-"))?0:1, ps := (mnum1:=InStr(num1, "-"))?!ps:ps
	, num1 := SubStr(num1, mnum1?2:1), num2 := Substr(num2, mnum2?2:1)
	, dec := (dot1:=InStr(num1, "."))?StrLen(num1)-dot1:0, dec := (dot2:=InStr(num2, "."))?dec+StrLen(num2)-dot2:dec
	, num1 := StrReplace(num1, "."), num2 := StrReplace(num2, ".")
	Loop, % StrLen(num2)
		tnum2 .= SubStr(num2, 1-A_Index, 1)
	num2 := tnum2, pr := "0"
	Loop, Parse, % num2
	{ rw := "0", zr := ""
		if A_LoopField
			Loop, %A_LoopField%
				rw := Add(rw, num1)
		else
			Loop, % (StrLen(num1)-1)
				rw .= "0"
		Loop, % (A_Index-1)
			zr .= "0"
		rw .= zr, pr := Add(pr, rw)
	} if dec
		pr := Prefect(SubStr(pr, 1, StrLen(pr)-dec) "." SubStr(pr, 1-dec))
	return (ps?"":"-") pr
}

;comprueba si num1>num2. si el 3er parametro es verdadero, devuelve 1 si ambos números son iguales.
;Sintaxis: IsGreater( [valor mayor], [valor menor], [param3] )
;NOTA: aceptar números muy grandes. (los números de mas de 18 cifras deben estar en comillas)
IsGreater(num1, num2, teq := false) {
	neg1 := InStr(num1, "-"), neg2 := InStr(num2, "-")
	if !neg1&&neg2
		return true
	if neg1&&!neg2
		return false
	num1 := Prefect(num1), num2 := Prefect(num2), dot1 := InStr(num1, "."), dot2 := InStr(num2, ".")
	, dec1 := dot1?StrLen(num1)-dot1:0, dec2 := dot2?StrLen(num2)-dot2:0
	if (dec1>dec2)
		Loop, % (dec1-dec2)
			num2 .= "0"
	else if (dec2 > dec1)
		Loop, % (dec2-dec1) 
			num1 .= "0"
	num1 := StrReplace(num1, "."), num2 := StrReplace(num2, ".")
	if ((len1:=StrLen(num1))>(len2:=StrLen(num2)))
		return neg1?0:1
	else if (len2>len1)
		return neg1?1:0
	else Loop {
			if ((sub1:=SubStr(num1, A_Index, 1))>(sub2:=Substr(num2, A_index, 1)))
				return neg1?0:1
			else if (sub2>sub1)
				return neg1?1:0
			else if (A_Index=len1)
				return teq?1:0
}}

;sumar o restar dos números. para restar, agregar '-' al inicio del segundo número.
;Sintaxis: Add( [(-)valor 1], [(-)valor2] )
;Ejemplo: Add("99999999999999999999999999999999999999", "9999999999999")
Add(num1, num2, Prefect := false) {
	count := (dneg2:=InStr(num2, "--"))?2:InStr(num2, "-")?1:0, count := count+((neg1:=InStr(num1, "-"))?1:0)
	, cnum1 := num1, cnum2 := num2, num1 := StrReplace(num1, "-"), num2 := StrReplace(num2, "-")
	, dec1 := (dot1:=InStr(num1, "."))?StrLen(num1)-dot1:0, dec2 := (dot2:=InStr(num2, "."))?StrLen(num2)-dot2:0
	if (dec1>dec2) {
		dec := dec1
		Loop, % (dec1-dec2)
			num2 .= "0"
	} else if (dec2>dec1) {
		dec := dec2
		Loop, % (dec2-dec1)
			num1 .= "0"
	} else dec := dec1
	num1 := StrReplace(num1, "."), num2 := StrReplace(num2, ".")
	if ((len1:=StrLen(num1))>=(len2:=StrLen(num2)))
		Loop, % (len1-len2)
			num2 := "0" num2
	else Loop, % (len2-len1)
		num1 := "0" num1
	if (count!=1&&count!=3)&&((len1:=StrLen(num1))!="*") {
		Loop {
			digit := SubStr(num1, 1-A_Index, 1)+SubStr(num2, 1-A_index, 1)+(cr?1:0)
			if (A_Index=len1) {
				sm := digit sm
				break
			} else if (digit>9)
				cr := true, digit := SubStr(digit, 0, 1)
			else cr := false
			sm := digit sm
		} if neg1&&InStr(cnum2, "-")
			sm := "-" sm
	} else if ((len1:=StrLen(num1))!="*") {
		if !(nc:=IsGreater(num1, num2, true))
			tnum2 := num2, num2 := num1, num1 := tnum2
		Loop {
			digit := SubStr(num1, 1-A_Index, 1)-SubStr(num2, 1-A_index, 1)+(bw?-1:0)
			if (A_Index=len1) {
				sm := StrReplace(digit, "-") sm
				break
			} else if InStr(digit, "-")
				bw := true, digit += 10
			else bw := false
			sm := digit sm
		} if ((dneg2||InStr(cnum1, "-"))&&nc)||(InStr(cnum2, "-")&&!nc)
			sm := "-" sm
	} if (sm = "-")
		sm := 0
	sm := dec&&sm?SubStr(sm, 1, StrLen(sm)-dec) "." SubStr(sm, 1-dec):sm
	return Prefect?Prefect(sm):sm
}

BitShiftLeft(Value, Bit, BitwiseAnd := "") { ;MsgBox % (54992<<0xC) "`n" BitShiftLeft(54992, 0xC) 
	return (BitwiseAnd=""?Round(Value*Power(2, Bit)):Round(Value*Power(2, Bit))&BitwiseAnd)
} BitShiftRight(Value, Bit, BitwiseAnd := "") { ;MsgBox % (54992>>0xC) "`n" BitShiftRight(54992, 0xC)
	return (BitwiseAnd=""?Round(Value/Power(2, Bit)):Round(Value/Power(2, Bit))&BitwiseAnd)
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;obtiene el mayor numero
;Sintaxis: Max( [números separados por coma] )
;Ejemplo: MsgBox % Max( 7, 9, 0, -11, 6, 3, 5, 8 ) "`n" Max("5,2,8,-44,7")
Max(n*) {
	n := ((n.MaxIndex()=1)?StrSplit(n[1], ",", A_Space A_Tab):n), _ := n[1]
	Loop, % (n.MaxIndex())
		_ := ((_<n[A_Index+1])?n[A_Index+1]:_)
	return _
}

;obtiene el menor numero
;Sintaxis: Min( [números separados por coma] )
;Ejemplo: MsgBox % Min( 7, 9, 0, 222, -0.2 ) "`n" Min("5,2,8,-44,7")
Min(n*) {
	n := ((n.MaxIndex()=1)?StrSplit(n[1], ",", A_Space A_Tab):n), _ := n[1]
	Loop, % (n.MaxIndex())
		_ := ((_>n[A_Index+1])?((n[A_Index+1]="")?_:n[A_Index+1]):_)
	return _
}

LOWORD(l) {
    return (l & 0xffff)
} HIWORD(l, Extract := true) {
    return (Extract?((l >> 16) & 0xffff):(l << 16))
} LOBYTE(w) {
    return (w & 0xff)
} HIBYTE(w, Extract := true) {
    return (Extract?((w >> 8) & 0xff):((w << 8) & 0xff))
}

;MsgBox % RNum(0) "," RNum(10) "," RNum(5) ;0-5
;MsgBox % RNum(1) "," RNum(4) ;1~4
;MsgBox % RNum(6) "," RNum(9) ;6~9
;MsgBox % RNumEx(0) "," RNumEx(10) "," RNumEx(5) ;0-5
;MsgBox % RNumEx(1) "," RNumEx(3) ;1~3
;MsgBox % RNumEx(4) "," RNumEx(6) ;4~6
;MsgBox % RNumEx(7) "," RNumEx(9) ;7~9
RNum(Num, Min := 1, Max := 9, ms := 5) {
	return between(ln:=StrRight(Num), Min, Max)?(ms=""||ln!=ms?(StrLen(Num)=1?(ln<ms?0:Num+(10-ln)):(ms=""?StrTrimRight(Num) 0:(ln<ms?StrTrimRight(Num) 0:Num+(10-ln)))):Num):Num
} RNumEx(n) {
	if (StrLen(n)=1) && (n!=0) && (n!=5) {
		n := n=1||n=2||n=3?0:n=4||n=5||n=6?5:n+(10-n)
	} else {
		if ((l:=StrRight(n))!=0) && (l!=5) {
			n := (l=1||l=2||l=3?StrTrimRight(n) 0:l=4||l=5||l=6?StrTrimRight(n) 5:n+(10-l))
	}} return n
}

Abs64(Num) {
	return DllCall("msvcrt.dll\_abs64", "Int64", Num) ;Abs() --> DllCall("msvcrt.dll\_abs", "Int", Num)
} ;https://msdn.microsoft.com/en-us/library/kw1ee768.aspx

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;if [value] between [low] [high]
;comprueba si un número esta contenido entre otros dos valores (inclusive)
;Sintaxis: Between( [número], [valor menor], [valor mayor], [valores a excluir*] ) 
;Valores a excluir: valores separados por coma (si es alguno de estos valores devuelve 0)
Between(value, low, high, nval*) {
	nval := ((nval.MaxIndex()=1)?StrSplit(nval[1], ",", A_Space A_Tab):nval)
	Loop, % (nval.MaxIndex())
		if (value=nval[A_Index])
			return false
	return ((value>=low)&&(value<=high))
}

;si el número es par devuelve 1, caso contrario 0 (impar)
IsEven(num) {
	return !(num&1) ;Mod(num, 2)
}

;determina si es Número
;Sintaxis: IsNumber( [número], [carácteres no permitidos separados por coma] )
;EJEMPLO: MsgBox % IsNumber(-23.02) "`n" IsNumber("*1") "`n" IsNumber(-1) "`n" IsNumber(0xF,"*") "`n" IsNumber(+1)
IsNumber(num, IfChars := "*,x") {
	return ((Contains(num,IfChars)||((num+1)=""))?false:true)
}

IsPrime(N) {
  Loop, % Floor(Sqrt(N))
    If (A_Index > 1 && !Mod(N, A_Index))
      Return false
  return true
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir a hexadecimal
;Sintaxis: Hex( [número], [max num], [¿mayúscula?], [prefijo] )
Hex(Int, Length := 0, May := false, Prefix := "0x") {
	return Format(Prefix "{:" ((Length>0)?0 LTrim(Length,0):"") (May?"X":"x") "}", Int)
}

;convertir a Unsigned Integer
;Sintaxis: Int( [número], [¿Signed?] )
Int(hex, Signed := false) {
	return Format("{:" (Signed?"d":"u") "}", hex)
} HexToInt(hex, Signed := false) {
	return Format("{:" (Signed?"d":"u") "}", hex)
}

;convertir a Float
;Sintaxis: Float( [valor], [max.decimales] )
Float(num, Type := "0.2") {
	return Format("{:" Type "f}", num)
}

;convertir a RGB | extraer rojo, verde, azul
;Sintaxis: RGB( [color], [rojo (salida)], [verde (salida)], [azul (salida)] )
;Ejemplos:
	;MsgBox % RGB(8454016)
	;MsgBox % "R: " RGB(0x80FF80,, G, B) ", G: " G ", B: " B
	;MsgBox % "R: " RGB("#DECAFE",, G, B) ", G: " G ", B: " B
RGB(Color := "", ByRef R := "", ByRef G := "", ByRef B := "") {
	if (Color="") {
		DllCall("msvcrt.dll\sprintf", "Str", V:="000000", "Str", "#%06X", "UInt", (R<<16)+(G<<8)+B)
		return V
	} if (IsByRef(R)) || (IsByRef(G)) || (IsByRef(B)) {
		if (InStr(Color, "#")) {
			NumPut("0x" SubStr(Color, -5), V:="000000")
			return R := NumGet(V,2,"UChar"), G := NumGet(V,1,"UChar"), B := NumGet(V,0,"UChar")
		} Color := Hex(Color, 6)
		return R := (Color & 0xFF), G := ((Color & 0xFF00) >> 8), B := ((Color & 0xFF0000) >> 16)
	} Color := (Color & 255) << 16 | (Color & 65280) | (Color >> 16), Color := SubStr(Color, 1)
	return Hex(Color, 6, true)
} ;R := ((Color & 0xFF0000) >> 16), G := ((Color & 0xFF00) >> 8), B := (Color & 0xFF)

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir twips a píxeles
TwipToPixel(Twip, Round := false, Places := 0) {
	Twips := (Twip * (1.0 / 1440.0) * A_ScreenDPI)
	return (Round?Round(Twips, Places):Twips)
} ;https://es.wikipedia.org/wiki/Twip

;convertir pixeles a twips
PixelToTwip(Pixel, Round := false, Places := 0) {
	Pixels := (Pixel / (1.0 / 1440.0) / A_ScreenDPI)
	return (Round?Round(Pixels, Places):Pixels)
} ;https://es.wikipedia.org/wiki/Píxel

;convertir entero a hexadecimal
IntToHex(Int, Prefix := "0x") {
	h := 8.000000
	while (h--)
		n := ((Int >> (h * 4)) & 0xf), v .= n>9?Chr(0x37+n):n
		, v .= h=0&&(h//(8/4))=0?A_Space:""
	return Prefix v
}

;convertir binario a hexadecimal
BinToHex(Bin, Prefix := "0x") {
	static h := "0123456789ABCDEF"
	d := 0, l := StrLen(Bin)
   Loop, Parse, % Bin,, %A_Space%%A_Tab%`n
	{ d += (d + A_LoopField)
		If ((A_Index&3)=(l&3))
			x := x SubStr(h, d+1, 1), d := 0
   } return Prefix x
}

;convertir binario a octal
BinToOct(Bin) {
    i := Oct := Dec := 0
    while (Bin != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		} Dec += Mod(Bin, 10) * z
        i++
        Bin /= 10
    } i := 1
    while (Dec != 0) {
        Oct += Mod(Dec, 8) * i
        Dec /= 8
        i *= 10
    } return Oct
}

;convertir binario a decimal
BinToDec(Bin) {
    i := Dec := 0
    while (Bin != 0) {
        rem := Mod(Bin, 10)
		Bin /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		} Dec += rem * z
		i++
    } return Dec
}

;convertir binario a string
;Ejemplo: MsgBox % BinToStr("01000010 01101001 01101110 01010100 01101111 01010011 01110100 01110010")
BinToStr(Bin) {
	Bin := RegExReplace(Bin, "[^0-1]") ;extraer 0 y 1
	Loop {
		if (v:=128) && !(a:=0) && !(StrLen(b:=SubStr(Bin, -7))=8)
			break
		Loop, Parse, % b
			a := A_LoopField=1?(a+v):a, v /= 2
		OutputVar := Chr(a) OutputVar, Bin := SubStr(Bin, 1, -8)
	} return OutputVar
}

;convertir string a binario
;Ejemplo: MsgBox % StrToBin("StrToBin") "`n" StrToBin("StrToBin", "")
StrToBin(String, Prefix := " ") {
	Loop, Parse, % String
	{ v := 128, b := Asc(A_LoopField)
		Loop, 8
			b := (l:=(Log(b-v)=""))?b:(b-v), OutputVar .= l?0:1, v /= 2
		OutputVar .= Prefix
	} return Trim(OutputVar)
}

;convertir decimal a binario
DecToBin(Dec) {
    Bin := !(i:=1)
    while (Dec != 0) {
        rem := Mod(Dec, 2)
        Dec /= 2
        Bin += rem * i
        i *= 10
	} return Bin
}

;convertir decimal a hexadecimal
DecToHex(Dec) {
    VarSetCapacity(s, 66, 0)
    , value := DllCall("msvcrt.dll\_wcstoui64", "Str", 119, "UInt", 0, "UInt", Dec, "CDECL Int64")
    , DllCall("msvcrt.dll\_i64tow", "Int64", value, "Str", s, "UInt", 16, "CDECL")
    return s
}

;convertir decimal a octal
DecToOct(Dec) {
    Oct := !(i:=1)
    while (Dec > 0) {
        rem := Mod(Dec, 8)
        Dec /= 8
        Oct += rem * i
        i *= 10
    } return Oct
}

;convertir octal a decimal
OctToDec(Oct) {
    i := Dec := 0
    while (Oct != 0) {
        rem := Mod(Oct, 10)
        Oct /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		} Dec += rem * z
        i++
    } return Dec
}

;convertir octal a binario
OctToBin(Oct) {
    i := Dec := Bin := 0
    while (Oct != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		} Dec += Mod(Oct, 10) * z
        i++
        Oct /= 10
    } i := 1
    while (Dec != 0) {
        Bin += Mod(Dec, 2) * i
        Dec /= 2
        i *= 10
    } return Bin
}

;convertir hexadecimal a decimal
HexToDec(Hex) {
    VarSetCapacity(s, 66, 0)
    , value := DllCall("msvcrt.dll\_wcstoui64", "Str", 77, "UInt", 0, "UInt", Hex, "CDECL Int64")
    , DllCall("msvcrt.dll\_i64tow", "Int64", value, "Str", s, "UInt", 10, "CDECL")
    return s
}

;convertir hexadecimal a string
;Ejemplo: MsgBox % HexToStr("0x53 0x74 0x72 0x54 0x6f 0x48 0x65 0x78") "`n" HexToStr("537472546f486578") "`n" HexToStr("0x530x740x720x540x6f0x480x650x78")
HexToStr(Hex) {
	Hex := RegExReplace(StrReplace(Hex, "0x"), "[^0-9a-zA-Z]") ;extraer números y letras y quitar prefijo 0x (si lo tiene)
	Loop, Parse, % Hex 
	{ h .= A_LoopField
		if (StrLen(h)=2)
			OutputVar .= Chr(DllCall("msvcrt.dll\_wcstoui64", "WStr", h, "Ptr", 0, "Int", 16, "CDECL Int64")), h := ""
	} return OutputVar
}

;convertir hexadecimal a RGB
;Sintaxis: HexToRGB( [hex], [R (salida)], [G (salida)], [B (salida)] )
HexToRGB(Hex, ByRef R := "", ByRef G := "", ByRef B := "") {
    H := InStr(Hex, "0x")?Hex:(InStr(Hex, "#")?"0x" SubStr(Hex, 2):"0x" Hex)
	return (R := (H & 0xFF0000) >> 16) "," (G := (H & 0xFF00) >> 8) "," (B := (H & 0xFF))
}

;convertir RGB a hexadecimal
;Sintaxis 1: RGBToHex( [rojo], [verde], [azul], [prefijo] )
;Sintaxis 2: RGBToHex( [RGB],,, [prefijo] )
RGBToHex(R, G := "", B := "", Prefix := "0x") {
	if (G="") || (B="")
		RGB(R, R, G, B)
    VarSetCapacity(Hex, 34, 0)
    , DllCall("Shlwapi.dll\wnsprintf", "Str", Hex, "Int", 17, "Str", "%016I64X", "UInt64", (R << 16) + (G << 8) + B, "Int")
    return Prefix SubStr(Hex, StrLen(Hex) - 6 + 1)
}

;convertir RGB a entero
;Sintaxis 1: RGBToInt( [rojo], [verde], [azul] )
;Sintaxis 2: RGBToInt( [RGB] )
RGBToInt(R, G := "", B := "") {
	return Int(RGBToHex(R, G, B))
}

;convertir cadena de carácteres a hexadecimal
;MsgBox % StrToHex("StrToHex") "`n" StrToHex("StrToHex", "")
StrToHex(Str, Prefix := " 0x") {
    Loop, Parse, % Str
	{	DllCall("msvcrt.dll\_i64tow_s", "Int64", Asc(A_LoopField), "WStr", l, "UInt", VarSetCapacity(l, 65, 0), "Int", 16, "CDECL")
		if (ErrorLevel) || (l="")
			DllCall("msvcrt.dll\_i64tow", "Int64", Asc(A_LoopField), "WStr", l, "Int", 16, "CDECL")
		OutputVar .= Prefix l
	} return Trim(OutputVar)
} ;https://msdn.microsoft.com/en-us/library/0we9x30h.aspx

;Convierte una cadena que representa un número decimal o hexadecimal a un entero
StrToInt(String, Flags := 0x1) {
	DllCall("shlwapi.dll\StrToIntEx", "Ptr", &String, "Int", Flags, "Int*", Ret)
	return Ret
}

;Convierte una cadena que representa un valor decimal o hexadecimal a un entero de 64 bits
StrToInt64(String, Flags := 0x1) {
	DllCall("shlwapi.dll\StrToInt64Ex", "Ptr", &String, "Int", Flags, "Int64*", Ret)
	return Ret
}

;convertir Float a Integer.
FloatToInt(Float) {
	return DllCall("MulDiv", "Float", Float, "Int", 1, "Int", 1, "UInt")
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir tiempo. hora, minuto, segundo, milisegundo, dias, mes, año.
;Sintaxis: ConvertTime( [tiempo], [de], [a], [decimales 0~14] )
;Uso: ConvertTime( [h:m:s|hora|min|sec|ms|dia|mes|año], [time|hour|min|sec|ms|day|mon|year], [hour|min|sec|ms|day|mon|year] )
;EJEMPLOS (ver funcion): MsgBox % ConvertTime( 0xFFF, "ms", "sec", 0 )
ConvertTime(time, from, to, Places := 2) {
	;--------------------------------------------------------------------------------------------------------------------------------
	;tiempo: ConvertTime( "01:60:3600", "time", "hour" ) ;1hora 60min 3600seg = 3horas
	if (from = "time")
		RegExMatch(time, "(?<h>\d+):(?<m>\d+):(?<s>\d+)", _)
		, time_hour := _h+(_m/60)+(_s/3600), time_min := (_h*60)+_m+(_s/60)
		, time_sec := (_h/3600)+(_m*60)+_s, time_ms := (_h*3600000)+(_m*60000)+(_s*1000)
		, time_day := (_h/24)+(_m/1440)+(_s/86400), time_mon := (_h/730.484398)+(_m/43829.0639)+(_s/2629743.83)
		, time_year := (_h/8765.81277)+(_m/525948.766)+(_s/31556926)
	;--------------------------------------------------------------------------------------------------------------------------------
	;milisegundos: ConvertTime( 60000, "ms", "min" ) ;60000ms = 1min
	else if (from = "ms")
		ms_hour := time/3600000, ms_min := time/60000, ms_sec := time*0.001
		, ms_day := time/86400000, ms_mon := time/2629743830, ms_year := time/31556926000
	;--------------------------------------------------------------------------------------------------------------------------------
	;segundos: ConvertTime( 3600, "sec", "min" ) ;3600seg = 60minutos
	else if (from = "sec")
		sec_hour := time/3600, sec_min := time/60, sec_ms := time*1000
		, sec_day := time/86400, sec_mon := time/2629743.83, sec_year := time/31556926
	;--------------------------------------------------------------------------------------------------------------------------------
	;minutos: ConvertTime( 1, "min", "sec" ) ;1min = 60seg
	else if (from = "min")
		min_hour := time/60, min_sec := time*60, min_ms := time*60000
		, min_day := time/1440, min_mon := time/43829.0639, min_year := time/525948.766
	;--------------------------------------------------------------------------------------------------------------------------------
	;horas: ConvertTime( 2, "hour", "min" ) ;2horas = 120min
	else if (from = "hour")
		hour_min := time*60, hour_sec := time*3600, hour_ms := time*3600000
		, hour_day := time/24, hour_mon := time/730.484398, hour_year := time/8765.81277
	;--------------------------------------------------------------------------------------------------------------------------------
	;días: ConvertTime( 1, "day", "hour" ) ;1dia = 24horas
	else if (from = "day")
		day_hour := time*24, day_min := time*1440, day_sec := time*86400, day_ms := time*86400000
		, day_mon := time/30, day_year := time/365.242199
	;--------------------------------------------------------------------------------------------------------------------------------
	;mes: ConvertTime( 1, "mon", "hour" ) ;1mes = 730,48horas
	else if (from = "mon")
		mon_hour := time*730.484398, mon_min := time*43829.0639, mon_sec := time*2629743.83, mon_ms := time*2629743830
		, mon_day := time*30, mon_year := time/12
	;--------------------------------------------------------------------------------------------------------------------------------
	;año: ConvertTime( 1, "year", "mon" ) ;1año = 12meses
	else if (from = "year")
		year_hour := time*8765.81277, year_min := time*525948.766, year_sec := time*31556926, year_ms := time*31556926000
		year_day := time*365.242199, year_mon := time*12
	;--------------------------------------------------------------------------------------------------------------------------------
	return Round(%from%_%to%, Places)
}

;añadir marca decimal a un numero (coma o punto, por defecto: automatico dependiendo del idioma del sistema)
;Sintaxis 1: GetNumberFormat( [número], [codigo de idioma, punto o coma] )
;Sintaxis 2 (WIN_V+): GetNumberFormatEx( [número], [cadena de idioma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;Cadenas de idioma: https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
;EJEMPLO: MsgBox % GetNumberFormat(1000000.99, ".") "`n" GetNumberFormatEx(1024.75, "en-US")
GetNumberFormat(Number, Locale := 0x0400) {
	Locale := Locale="."?0x0456:Locale=","?0x0409:!Locale?0x0400:Locale
	, Size := DllCall("Kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Ptr", 0, "Int", 0)
    , VarSetCapacity(OutputVar, Size * 2)
	, r := DllCall("Kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Str", OutputVar, "Int", Size)
    return OutputVar
} GetNumberFormatEx(Number, Locale := "!x-sys-default-locale") { ;WIN_V+ (recomendado)
	Size := DllCall("Kernel32.dll\GetNumberFormatEx", "Ptr", &Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Ptr", 0, "Int", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, r := DllCall("Kernel32.dll\GetNumberFormatEx", "Ptr", &Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Str", OutputVar, "Int", Size)
	return OutputVar
} ;http://ahkscript.org/boards/viewtopic.php?p=56005#p56005

;Formatea una serie de números como una cadena de moneda para un entorno local especificado
;Sintaxis 1: GetCurrencyFormat( [cadena], [código de idioma] )
;Sintaxis 2 (WIN_V+): GetCurrencyFormatEx( [cadena], [cadena de idioma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;Cadenas de idioma: https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
;EJEMPLO: MsgBox % GetCurrencyFormat(0.99) "`n" GetCurrencyFormatEx(2.75, "en-US")
GetCurrencyFormat(String, Locale := 0x0400) {
	Size := DllCall("Kernel32.dll\GetCurrencyFormatW" , "UInt", Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Ptr", 0, "Int", 0) 
	, VarSetCapacity(OutputVar, Size * 2,  0)
	, r := DllCall("Kernel32.dll\GetCurrencyFormatW" , "UInt", Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Str", OutputVar, "Int", Size)
    return OutputVar, ErrorLevel := !r
} GetCurrencyFormatEx(String, Locale := "!x-sys-default-locale") { ;WIN_V+ (recomendado)
	Size := DllCall("Kernel32.dll\GetCurrencyFormatEx" , "Ptr", &Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Ptr", 0, "Int", 0) 
	, VarSetCapacity(OutputVar, Size * 2,  0)
	, r := DllCall("Kernel32.dll\GetCurrencyFormatEx" , "Ptr", &Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Str", OutputVar, "Int", Size)
    return OutputVar, ErrorLevel := !r
} ;http://ahkscript.org/boards/viewtopic.php?p=56005#p56005

;saca el promedio
NumAverage(num*) {
	Sum := 0, num := num.MaxIndex()=1?StrSplit(num[1], ",", A_Space A_Tab):num
	Loop, % num.MaxIndex()
		Sum += num[A_Index]
	return Sum/(num.MaxIndex()+0.0)
}

;genera un número pseudo-aleatorio
;Sintaxis 1: Random( [min (-2147483648)], [max (2147483647)], [1~4294967295] )
;Sintaxis 2: RandomEx( [min], [max], [decimales] )
Random(Min := -2147483648, Max := 2147483647, NewSeed := 0) {
	if (NewSeed) {
		Random,, %NewSeed%
		return NewSeed
	} Random, RandNum, %Min%, %Max%
	return RandNum
} RandomEx(Min, Max, Round := 0, Bits := 52) {
    DllCall("Advapi32.dll\CryptAcquireContextW", "Ptr*", hProv:=0, "Ptr", 0, "Ptr", 0, "UInt", 1, "UInt", 0xF0000000|0x40)
    , Bytes := Ceil(Bits/8), VarSetCapacity(Data, Bytes)
    , DllCall("Advapi32.dll\CryptGenRandom", "Ptr", hProv, "UInt", Bytes, "Ptr", &Data)
    , NumPut(((0xff >> (7-Mod(Bits-1, 8))) & NumGet(Data, Bytes-1, "UChar")), Data, Bytes-1, "UChar")
    , DllCall("Advapi32.dll\CryptReleaseContext", "Ptr", hProv, "UInt", 0)
	, r := ((NumGet(Data, 0, "UInt64") / 0xfffffffffffff) * (Max - Min)) + Min
    return (Round>-1)?Round(r, Round):r
} ;http://www.autohotkey.com/board/topic/70530-random-number-crypt-secure-rand-numberbuffer/

;determinar el porcentaje
;Sintaxis: Percent( [numero], [procentaje], [porcentaje (salida)], [decimales] )
;Ejemplo: MsgBox % "100 menos su 10%: " Percent(100, 10, Percent) "`n10% de 100: " Percent
;Return: devuelve la resta resultante del numero espesificado y el porncentaje espesificado de ese valor.
;3er Parámetro: devuelve el porcentaje espesificado para el valor espesificado.
Percent(num, Percent, ByRef OutputPercent := "", Places := 2) {
	return Float(num-(i:=(num/100)*Percent), "0." Places), OutputPercent := IsByRef(OutputPercent)?Round(i, Places):""
}

;descomposición prima
Factor(n, Delimiter := "`n") {
    if (n=1)
        return
    f := 2
	while (f<=n) {
        if (Mod(n, f)=0)
            return f Delimiter Factor(n/f)
        f++
}} ;http://rosettacode.org/wiki/Prime_decomposition#AutoHotkey

;convertir radian a grado sexagesimal/centesimal
;Sintaxis: RadianToDegree( [radianes], [¿centesimal?] )
;Ejemplo: MsgBox % RadianToDegree(120) "`n" RadianToDegree(120, true) ;6875.493542 | 7639.437268
RadianToDegree(Radians, Centesimal := false) {
	if (Centesimal)
		return Radians*63.6619772368 ;200/pi | 200/3.14159265359 = 63.6619772368
	return Radians*57.2957795131 ;180/pi | 180/3.14159265359 = 57.2957795131
}

;convertir grado sexagesimal/centesimal a radian
;Sintaxis: RadianToDegree( [grados], [¿centesimal?] )
;MsgBox % DegreeToRadian(6875.493542) "`n" DegreeToRadian(7639.437268, true) ;120 | 120
DegreeToRadian(Degrees, Centesimal := false) {
	if (Centesimal)
		return Degrees*0.01570796326 ;pi/200 | 3.14159265359/200 = 0.01570796326
	return Degrees*0.01745329251 ;pi/180 | 3.14159265359/180 = 0.01745329251
}




























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: FUENTES & COLORES & RECURSOS & DLL ::::::::::::::::::::::::::::::::::
;Recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff468901(v=vs.85).aspx
	;Parámetros:
		;hModule = LoadLibrary("C:\File.exe", 0x2)
		;HANDLE = BeginUpdateResource()
		;hResData = FindResource()
		;hResLoad = LoadResource()
		;Info/data/lpResLock = LockResource() / Binary DATA
	;Ejemplo de uso: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648008(v=vs.85).aspx#_win32_Updating_Resources
;#############################################################################################################################################
;recupera un HANDLE que puede ser utilizado por la función UpdateResource para agregar, eliminar o reemplazar los recursos en un módulo binario.
;Sintaxis: BeginUpdateResource( [archivo], [¿eliminar recursos existentes?] )
;Return: HANDLE
BeginUpdateResource(FileName, DeleteExistingResources := false) {
	return r:=DllCall("Kernel32.dll\BeginUpdateResourceW", "Ptr", &FileName, "Int", !!DeleteExistingResources, "Ptr"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648030(v=vs.85).aspx

;aplica o descarta los cambios hechos antes de una llamada a UpdateResource
;Sintaxis: EndUpdateResource( [HANDLE], [¿descartar cambios?] )
;Return: 0|1
EndUpdateResource(hModule, Discard := false) {
	return r:=DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hModule, "Int", !!Discard, "Int"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648032(v=vs.85).aspx

;EndUpdateResource() + BeginUpdateResource()
;Sintaxis: ReUpdateResource( [HANDLE nuevo (salida)], [archivo], [¿eliminar recursos existentes?], [¿descartar cambios?] )
;Return: HANDLE
ReUpdateResource(ByRef hModule, FileName, DeleteExistingResources := false, Discard := false) {
	EndUpdateResource(hModule, Discard)
	return hModule := BeginUpdateResource(FileName, DeleteExistingResources)
}

;recupera un HANDLE que se puede utilizar para obtener un puntero al primer byte del recurso especificado en la memoria
;Sintaxis: LoadResource( [hModule], [hResInfo] )
;Return: hResLoad
LoadResource(hModule, hResInfo) {
	DllCall("Kernel32.dll\LoadResource", "Ptr", hModule, "Ptr", hResInfo, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648046(v=vs.85).aspx

;recupera un puntero al recurso especificado en la memoria
;Sintaxis: LockResource( [hResLoad] )
;Return: Pointer / ResLock / data / info
LockResource(hResLoad) {
	return r:=DllCall("Kernel32.dll\LockResource", "Ptr", hResLoad, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648047(v=vs.85).aspx

;determina la ubicación del recurso con el tipo, nombre y lenguaje espesificado en el módulo especificado
;Sintaxis: FindResource( [hModule], [nombre del recurso], [tipo de recurso], [lenguaje ID] )
;Tipos de recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx
;Return: hResInfo
FindResource(hModule, ResName, ResType, Language := "") {
	ResName := StrSplit(ResName, A_Space, A_Tab), ResName := ResName.MaxIndex()>1?[ResName[1], ResName[2]]:[ResName[1]+0=""?"Str":"Ptr", ResName[1]]
	, ResType := StrSplit(ResType, A_Space, A_Tab), ResType := ResType.MaxIndex()>1?[ResType[1], ResType[2]]:[ResType[1]+0=""?"Str":"Ptr", ResType[1]]
	if (Language="")
		r := DllCall("Kernel32.dll\FindResourceW", "Ptr", hModule, ResName[1], ResName[2], ResType[1], ResType[2], "Ptr")
	else r := DllCall("Kernel32.dll\FindResourceExW", "Ptr", hModule, ResName[1], ResName[2], ResType[1], ResType[2], "UInt", Language, "Ptr")
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648043(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx

;agrega, elimina o sustituye a un recurso en un archivo ejecutable portable (PE)
;Sintaxis: UpdateResource( [HANDLE], [tipo de recurso], [nombre del recurso], [lenguaje ID], [info], [tamaño, en bytes] )
;Tipos de recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx
;Return: 0|1
UpdateResource(hModule, ResType, ResName, Language, Data := 0, Size := "") {
	ResName := StrSplit(ResName, A_Space, A_Tab), ResName := ResName.MaxIndex()>1?[ResName[1], ResName[2]]:[ResName[1]+0=""?"Str":"Ptr", ResName[1]]
	, ResType := StrSplit(ResType, A_Space, A_Tab), ResType := ResType.MaxIndex()>1?[ResType[1], ResType[2]]:[ResType[1]+0=""?"Str":"Ptr", ResType[1]]
	, Size := StrSplit(Size, A_Space, A_Tab), Size := Size.MaxIndex()>1?[Size[1], Size[2]]:[Size[1]+0=""?"Ptr":"UInt", Size[1]]
	, r:=DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hModule, ResType[1], ResType[2], ResName[1], ResName[2], "UShort", Language, "Ptr", Data?Data:0, Size[1], Size[2], "Int")
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648049(v=vs.85).aspx

;recupera el tamaño, en bytes, del recurso espesificado
;Sintaxis: SizeofResource( [hModule, hResInfo] )
;Return: Bytes
SizeofResource(hModule, hResInfo) {
	return r:=DllCall("Kernel32.dll\SizeofResource", "Ptr", hModule, "Ptr", hResInfo, "UInt"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648048(v=vs.85).aspx

CreateResourceIndexer(projectRoot, extensionDllPath) { ;WIN_10+
	r:=DllCall("Mrmsupport.dll\CreateResourceIndexer", "WStr", projectRoot, "WStr", extensionDllPath, "PtrP", resourceIndexer, "UInt")
	return resourceIndexer, ErrorLevel := r ;S_OK = 0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/mt219668(v=vs.85).aspx

DestroyResourceIndexer(resourceIndexer) { ;WIN_10+
	return true, DllCall("Mrmsupport.dll\DestroyResourceIndexer", "PtrP", resourceIndexer), ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/mt219670(v=vs.85).aspx

;añadir icono, reemplaza si existe
;Sintaxis: InsertIconResource( [HANDLE], [icono], [ID], [lenguaje ID] )
InsertIconResource(hModule, Icon, ID, Language := 0x409) {
	if !(hFile:=FileOpen(Icon, "r"))
		return false, ErrorLevel := 2
	VarSetCapacity(Data, 8, 0), hFile.RawRead(Data, 6)
	if !(NumGet(Data, 0, "UShort")=0) || !(NumGet(Data, 2, "UShort")=1)
		return false, ErrorLevel := 3
	IGs := VarSetCapacity(IG, 6 + (Count:=NumGet(Data, 4, "UShort"))*14, 0)
	, NumPut(NumGet(Data, 0,"Int64"), IG, 0, "Int64"), IGe := &IG + 6
	Loop, % (Count) {
		thisID := (ID - 1) + A_Index, hFile.RawRead(IGe+0, 12), NumPut(thisID, IGe+12, 0, "UShort")
		, imgOffset := hFile.ReadUInt(), oldPos := hFile.Pos, hFile.Pos := imgOffset
		, ICDs := VarSetCapacity(ICD, NumGet(IGe+8, 0, "UInt")),  hFile.RawRead(ICD, ICDs)
		, hFile.Pos := oldPos, UpdateResource(hModule, 3, thisID, Language, &ICD, ICDs), IGe += 14
	} return thisID + 1, UpdateResource(hModule, 14, ID, Language, &IG, IGs)
} 

;-------------------------------------------------------------------------------------------------------------------

;crear .DLL vacía
;Sintaxis: DllCreateEmpty( [directorio\nombre.dll] )
Dll_CreateEmpty(DllFile) {    
	TS := A_NowUTC
	TS -= 1970, S
	VarSetCapacity(Trg, 1536, 0), Numput(TS, Trg, 192)
	Loop, Parse, % "0X5A4DY3CXB8YB8X4550YBCX2014CYCCX210E00E0YD0X7010BYD8X400YE4X1000YE8X1000YECX78A"
		. "E0000YF0X1000YF4X200YF8X10005YFCX10005Y100X4Y108X3000Y10CX200Y114X2Y118X40000Y11CX2000Y120X10"
		. "0000Y124X1000Y12CX10Y140X1000Y144X10Y158X2000Y15CX8Y1B0X7273722EY1B4X63Y1B8X10Y1BCX1000Y1C0X"
		. "200Y1C4X200Y1D4X40000040Y1D8X6C65722EY1DCX636FY1E0X8Y1E4X2000Y1E8X200Y1ECX400Y1FCX42000040", XY
		if Mod(A_Index, 2)
			O := "0x" A_LoopField
		else NumPut("0x" A_LoopField, Trg, O, "UInt")
	if !(hFile:=CreateFile(DllFile, 0x40000000, 2))
		return false, ErrorLevel := 2
	return WriteFile(hFile, &Trg, 1536), CloseHandle(hFile)
}

;añadir «un icono o un conjunto de iconos en un directorio» a una libreria .DLL
;Sintaxis: Dll_InsertIcon( [DLL], [icono o directorio que contiene los iconos], [¿sobreescribir iconos?], [¿incluir iconos en subdirectorios?] )
Dll_InsertIcons(DllFile, Data, Overwrite := false, Recurse := false) {
	if (Overwrite)
		hModule := BeginUpdateResource(DllFile)
	if !(Count:=0) && !(Index:=0) && (IsFile(Data)) {
		Index++
		if !(Overwrite) {
			if (FindResource(hFile:=LoadLibrary(DllFile, 0x2), Index, 14)) {
				Loop
					Index++
				until !(FindResource(hFile, Index, 14))
			} FreeLibrary(hFile), hModule := BeginUpdateResource(DllFile)
		} InsertIconResource(hModule, Data, Index)
		return EndUpdateResource(hModule)
	} else if (IsDir(Data)) {
		Loop, Files, %Data%\*.ico, % Recurse?"FR":"F"
		{ if !(Overwrite) {
			Index++
			if (FindResource(hFile:=LoadLibrary(DllFile, 0x2), Index, 14)) {
				Loop
					Index++
				until !(FindResource(hFile, Index, 14))
			} FreeLibrary(hFile), ReUpdateResource(hModule, DllFile, Count:=0)
			} Count++, InsertIconResource(hModule, A_LoopFileFullPath, Overwrite?A_Index:Index)
			if (Count=40)
				ReUpdateResource(hModule, DllFile, Count:=0)
		} return EndUpdateResource(hModule)
	} return false, ErrorLevel := true
}

;-------------------------------------------------------------------------------------------------------------------

;dialogo para elegir color
;Sintaxis: ColorSelect( [ID ventana propietaria], [color], [¿mostrar todos los colores?] )
;Color: espesificar el color por defecto RGB o Nombre
;Notas: 
	;ErrorLevel es 1 si el usuario canceló el diálogo
	;la paleta de colores elegidos por el usuario se guarda en:  %A_AppData%\usercolorpalette.ini
;EJEMPLO: MsgBox % "Color: " ColorSelect(, "Red", true)
ColorSelect(hWnd := 0, Color := "", ShowAll := "") {
	static File := A_AppData "\usercolorpalette.ini"
	Color := RGBToInt(_getcolor(Color)), VarSetCapacity(CUSTOM, 16*A_PtrSize, 0)
	Loop, 16 ;obtener colores
		NumPut(IniRead(File, "Color", A_Index, false), CUSTOM, (A_Index-1)*4, "UInt")
	lStructSize := VarSetCapacity(CHOOSECOLOR, 9*A_PtrSize, 0)
	, NumPut(lStructSize, CHOOSECOLOR, 0, "UInt"), NumPut(hWnd, CHOOSECOLOR, A_PtrSize, "Ptr")
	, NumPut(Color=""?IniRead(File, "Default", "Color", false):Color, CHOOSECOLOR, 3*A_PtrSize, "Ptr")
	, NumPut(&CUSTOM, CHOOSECOLOR, 4*A_PtrSize, "PtrP")
	, NumPut(0x1|0x100|(ShowAll=0?0x4:ShowAll?0x2:0x0), CHOOSECOLOR, 5*A_PtrSize, "UInt")
	, i := DllCall("comdlg32.dll\ChooseColorW", "UPtr", &CHOOSECOLOR, "UInt")
	Loop, 16 ;guardar colores
		IniWrite(NumGet(custom, (A_Index-1)*4, "UInt"), File, "Color", A_Index)
	return RGB(Color:=NumGet(CHOOSECOLOR, 3*A_PtrSize, "UInt"))
		, i:=i?IniWrite(Color, File, "Default", "Color"):"", ErrorLevel := !i
}

;-------------------------------------------------------------------------------------------------------------------

;enumera todas las fuentes instaladas.
FontEnum(lfCharSet := 1, lfFaceName := "") {
	hDC := DllCall("User32.dll\GetDC", "Ptr", 0), VarSetCapacity(LOGFONT, 92, 0), NumPut(lfCharSet, LOGFONT, 23, "UChar")
	if (lfFaceName!="")
		DllCall("Kernel32.dll\lstrcpynW", "Ptr", &LOGFONT+28, "Str", lfFaceName, "Int", StrLen(lfFaceName)+1)
	lpEnumFunc := RegisterCallback("EnumFontFamExProc", "Fast", 4), Param := {List: ""}
	, DllCall("Gdi32.dll\EnumFontFamiliesExW", "Ptr", hDC, "Ptr", &LOGFONT, "Ptr", lpEnumFunc, "Ptr", &Param, "UInt", 0)
	, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), DllCall("Kernel32.dll\GlobalFree", "Ptr", lpEnumFunc)
	return Sort(Param.List, "U")
} EnumFontFamExProc(lpelfe, lpntme, FontType, lParam) {
	Param := Object(lParam), Ip := lpelfe+28, nSize := DllCall("Kernel32.dll\lstrlenW", "UInt", Ip)
	, VarSetCapacity(lfFaceName, nSize * 2, 0), DllCall("Kernel32.dll\lstrcpynW", "Str", lfFaceName, "Ptr", Ip, "Int", nSize+1)
	return true, Param.List .= (Param.List?"`n":"") lfFaceName
} FontExist(FontName, lfCharSet := 1, lfFaceName := "") {
	Loop, Parse, % FontEnum(lfCharSet, lfFaceName), `n, `r
		if (A_LoopField=FontName)
			return true
	return false
}

;crea una fuente con las caracteristicas espesificadas.
;Sintaxis: FontCreate( [fuente], [tamaño], [negrita], [¿cursiva?], [¿subrayado?], [¿tachado?], [Calidad] )
;Fuente: dejar vacio para usar la fuente por defecto
;Tamaño: dejar en 0 para usar el tamaño por defecto
;Negrita: 0 | 100 | 200 | 300 | 400 (normal) | 500 | 600 | 700 (negrita) | 800 | 900
;Calidad: 
	;DEFAULT_QUALITY = 0 | DRAFT_QUALITY = 1 | PROOF_QUALITY = 2
	;NONANTIALIASED_QUALITY = 3 | ANTIALIASED_QUALITY = 4 | CLEARTYPE_QUALITY = 5
;NOTA: cuando ya no use la fuente, eliminarla con FontDelete()
FontCreate(FontName := "", Size := 0, Bold := 400, Italic := false, Underline := false, StrikeOut := false, Quality := 2) {
	FontName := FontName?FontName:FontGetName()
	, Size := Size>0?Size:FontGetSize()
	, hDC := DllCall("Gdi32.dll\CreateDC", "Str", "DISPLAY", "Ptr", 0, "Ptr", 0, "Ptr", 0)
    , nHeight := Round(Size*DllCall("Gdi32.dll\GetDeviceCaps", "Ptr", hDC, "Int", 90)/72)*-1
    , DllCall("DeleteDC", "Ptr", hDC)
	return r:=DllCall("Gdi32.dll\CreateFontW", "Int", nHeight, "Int", 0, "Int", 0, "Int", 0, "Int", Bold
		,"UInt", Italic, "UInt", Underline,"UInt", StrikeOut, "UInt", 1, "UInt", 4, "UInt", 0
		,"UInt", Quality, "UInt", 0, "Str", FontName), ErrorLevel := !r
} FontGetSize(hFont := 0, ByRef LogPixelsY := "") {
	hFont := hFont?hFont:DllCall("Gdi32.dll\GetStockObject", "Int", 17)
	, hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
	, hFont2 := DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont)
	, LogPixelsY:=DllCall("Gdi32.dll\GetDeviceCaps", "Ptr", hDC, "Int", 90)
	, VarSetCapacity(TEXTMETRIC, 60, 0)
	, DllCall("Gdi32.dll\GetTextMetricsW", "Ptr", hDC, "Ptr", &TEXTMETRIC)	
	, Height := NumGet(TEXTMETRIC,0,"Int"), IntLeading := NumGet(TEXTMETRIC,12,"Int")
	, FontSize := Round((Height-IntLeading)*72/LogPixelsY)
	, DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont2)
	, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	return FontSize
} FontGetName(hFont := 0) {
	hFont := hFont?hFont:DllCall("Gdi32.dll\GetStockObject", "Int", 17)
	, hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
	, hFont2 := DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont)
    , VarSetCapacity(FontName, 32*2)
    , DllCall("Gdi32.dll\GetTextFace", "Ptr", hDC, "Int", 32, "Ptr", &FontName)
	, VarSetCapacity(FontName, -1)
	, DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont2)
	, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	return FontName
} FontGetMetrics(hFont := 0, ByRef FontSize := "") {
	static TEXTMETRIC
	hFont := hFont?hFont:DllCall("Gdi32.dll\GetStockObject", "Int", 17)
    , hDC := DllCall("User32.dll\GetDC", "Ptr", 0), VarSetCapacity(TEXTMETRIC, 60, 0)
    , hFont2 := DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont)
	, DllCall("Gdi32.dll\GetTextMetrics", "Ptr", hDC, "Ptr", &TEXTMETRIC)
	, DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont2)
	, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), hp := &TEXTMETRIC
	, FontSize := Round((NumGet(hp+0,0,"Int")-NumGet(hp+0,12,"Int"))*72)
	return &TEXTMETRIC
} FontDelete(hFont) {
	return r:=DllCall("Gdi32.dll\DeleteObject", "Ptr", hFont), ErrorLevel := !r
}

;dialogo para seleccionar fuente
;Sintaxis: FontSelect( [hWnd], [fuente], [opciones], [efectos 0|1], [opciones adicionales] )
;hWnd: ventana propietaria
;Opciones: array que contiene las opciones por defecto a mostrar, en el siguiente orden:
	;Color del texto = RGB o nombre
	;Tamaño,Tamaño Minimo, Tamaño Máximo = separados por coma, tamaño por defecto y MaxMin permitidos.
	;Negrita = 700 es negrita, 400 es normal.
	;Cursiva = 0|1
	;Subrayado = 0|1
	;Tachado = 0|1
;Efectos: permite al usuario seleccionar el tipo de letra (subrayado y tachado) y el color del texto (defecto=1)
;NOTAS: 
	;devuelve un Array con la informacion, en el mismo orden del 3er parametro (opciones).
		;Array[0] contiene la fuente seleccionada
	;ErrorLevel es 1 si el usuario canceló el diálogo
;EJEMPLO:
	;FontInfo := FontSelect(, "Arial", ["Lime", "12,10,20", 700, true, true, true])
	;MsgBox %  "Fuente: " FontInfo[0]
	;	. "`nColor: " FontInfo[1]
	;	. "`nTamaño: " FontInfo[2] "`nNegrita: " FontInfo[3] "`nCursiva: " FontInfo[4]
	;	. "`nSubrayado: " FontInfo[5] "`nTachado: " FontInfo[6] "`n`nErrorLevel: " ErrorLevel
FontSelect(hWnd := 0, FontName := "", Options := "", Effects := true, Flags := 0x0) {
	FontName := FontName?FontName:FontGetName()
	, Color := RGBToInt(_getcolor(Options[1]))
	, Size := (s:=StrSplit(Options[2], ",", A_Space)[1])&&s>0?s:FontGetSize()
	, MinSize := (s:=StrSplit(Options[2], ",", A_Space)[2])&&s>0?s:0
	, MaxSize := (s:=StrSplit(Options[2], ",", A_Space)[3])&&s>0?s:0
	, Bold := between(Options[3], 0, 900)?Options[3]:400
	, Italic := !!Options[4], Underline := !!Options[5], StrikeOut := !!Options[6]
	, hDC := DllCall("Gdi32.dll\CreateDC", "Str", "DISPLAY", "Ptr", 0, "Ptr", 0, "Ptr", 0)
	, LogPixelsY := DllCall("Gdi32.dll\GetDeviceCaps", "Ptr", hDC, "Int", 90)
	, DllCall("Gdi32.dll\DeleteDC", "Ptr", hDC)
	, Flags := Flags|0x1|0x40|(Effects?0x100:0x0)|(((MinSize||MaxSize)&&MinSize<MaxSize)?0x2000:0x0)|0x10000
    VarSetCapacity(LOGFONT, 92, 0) , NumPut(Round(Size*LogPixelsY/72)*-1, LOGFONT, 0, "Int")
    , NumPut(Bold, LOGFONT, 16, "Int"), NumPut(Italic, LOGFONT, 20, "UChar")
    , NumPut(Underline, LOGFONT, 21, "UChar"), NumPut(StrikeOut, LOGFONT, 22, "UChar")
	, DllCall("Kernel32.dll\lstrcpynW", "Ptr", &LOGFONT+28, "Str", FontName, "Int", StrLen(FontName)+1)
	, CFSize := VarSetCapacity(CHOOSEFONT, A_PtrSize=8?104:60, 0)
	, NumPut(CFSize, CHOOSEFONT, 0, "UInt"), NumPut(hWnd, CHOOSEFONT, A_PtrSize, "Ptr")
	, NumPut(&LOGFONT, CHOOSEFONT, A_PtrSize=8?24:12, "Ptr")
	, NumPut(Flags, CHOOSEFONT, A_PtrSize=8?36:20, "UInt")
	, NumPut(Color, CHOOSEFONT, A_PtrSize=8?40:24, "UInt")
	, NumPut(MinSize, CHOOSEFONT, A_PtrSize=8?92:52, "Int")
	, NumPut(MaxSize, CHOOSEFONT, A_PtrSize=8?96:56, "Int")
	, r := DllCall("comdlg32.dll\ChooseFontW", "Ptr", &CHOOSEFONT)
	, VarSetCapacity(FontName, LF_FACESIZE*2), nSize := DllCall("lstrlenW", "Ptr", &LOGFONT+28)
	, DllCall("Kernel32.dll\lstrcpynW", "Str", FontName, "Ptr", &LOGFONT+28, "Int", nSize+1)
	, VarSetCapacity(FontName, -1), OutPutVar := [], OutPutVar[0] := FontName
	, OutPutVar[1] := RGB(NumGet(CHOOSEFONT, A_PtrSize=8?40:24, "UInt"))
	, OutPutVar[2] := NumGet(CHOOSEFONT, A_PtrSize=8?32:16, "Int")//10
	, OutPutVar[3] := NumGet(LOGFONT, 16, "Int"), OutPutVar[4] := NumGet(LOGFONT, 20, "UChar")
	, OutPutVar[5] := NumGet(LOGFONT,21,"UChar"), OutPutVar[6] := NumGet(LOGFONT, 22, "UChar")
	return OutPutVar, ErrorLevel := !r
}

;obtener tamaño dependiendo de la fuente y texto
;Sintaxis: FontGetStringSize( [fuente], [texto], [ancho (out)], [alto (out)], [ajustar ancho y alto] )
;Fuente: espesificar el nombre de una fuente o usar FontCreate()
FontGetStringSize(hFont := 0, String := "", ByRef Width := "", ByRef Height := "", Convert := true) {
	static Size
	hFont := hFont?hFont:DllCall("Gdi32.dll\GetStockObject", "Int", 17)
	, hDC := DllCall("User32.dll\GetDC", "Ptr", 0), VarSetCapacity(Size, 8, 0)
	, hFont2 := DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont)
    , RC := DllCall("Gdi32.dll\GetTextExtentPoint32W", "Ptr", hDC, "Str", String, "Int", StrLen(String), "Ptr", &Size)
	, DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", hFont2), DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
	, Width := NumGet(&Size+0, 0, "Int"), Height := NumGet(&Size+0, 4, "Int")
	if (Convert)
		Width := Width + (NumGet(FontGetMetrics(hFont), 20, "Int")*3)
		, Height := Floor((NumGet(FontGetMetrics(hFont), 0, "Int")*Convert)+(NumGet(FontGetMetrics(hFont),16, "Int")*(Floor(Convert+0.5)-1))+0.5)+8
	return &Size, ErrorLevel := !(RC)
}



























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: STRING ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;obtiene opciones representadas por carácter(es) y separadas por espacios.
;Sintaxis: SplitFlags( [texto], [opciones], [carácteres*] )
;Opciones: \d = incluir números | \w incluir letras | [\Q carácteres \E]
	;por defecto obtiene: números, letras, puntos, +, -, ^, ~, comas
;NOTAS: 
	;devuelve un Array con las opciones en el mismo orden en que se espesificó;
	;si se espsificó solo 1, devuelve directamente el texto recuperado
	;si no se espesifico nada en el 3er parametro, lo obtiene del 2do
;EJEMPLOS:
	;MsgBox % SplitFlags("c100 x350", "x") "`n" SplitFlags("c100 x350",, "c1")
	;MsgBox % (i:=SplitFlags("c1,00 x35.0002 f+150",, "c", "x", "f")) i[1] "`n" i[2] "`n" i[3]
SplitFlags(String, Options := "\d\Q,.+-^~\E\w", Chars*) {
	Flags := []
	if !(Chars.MaxIndex())
		Chars := [Options], Options := "\d\Q,.+-^~\E\w"
	Loop, % Chars.MaxIndex()
		RegExMatch(String, "i)\Q" Chars[A_Index] "\E\K[" Options "]+", Flag), Flags[A_Index] := Flag
	return Chars.MaxIndex()>1?Flags:Flags[1]
}

StrPutVar(String, Encoding := "UTF-16", ByRef Length := "") {
    VarSetCapacity(Var, StrPut(String, Encoding)
	* (Encoding="UTF-16"||Encoding="CP1200"?2:1))
    , Length := StrPut(String, &Var, Encoding)
	return &Var
}

StrNormalize(String) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd319093%28v=vs.85%29.aspx
    len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", 0, "Int", 0)
    Loop {
        VarSetCapacity(buf, len * 2)
        , len := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", String, "Int", StrLen(String), "Ptr", &buf, "Int", len)
        if (len >= 0)
            break
        if (A_LastError != 122) ;ERROR_INSUFFICIENT_BUFFER
            return
        len *= -1
    } return RegExReplace(StrGet(&buf, len, "UTF-16"), "\pM")
}

;quitar caracteres de izquierda a derecha
;Sintaxis : StrTrimLeft( [Var], [Limite] )
StrTrimLeft(String, Length := 1) {
	return SubStr(String, Length+1)
}

;quitar caracteres de derecha a izquierda
;Sintaxis : StrTrimRight( [Var], [Limite] )
StrTrimRight(String, Length := 1) {
	return SubStr(String, 1, -Length)
}

;obtener caracteres de izquierda a derecha
;Sintaxis : StrLeft( [Var], [Limite] )
StrLeft(String, Length := 1) {
	return SubStr(String, 1, Length)
}
	
;obtener caracteres de derecha a izquierda
;Sintaxis : StrRight( [Var], [Limite] )
StrRight(String, Length := 1) {
	return SubStr(String, -(Length-1))
}

;If [var] in [ .. ]
;comprueba si el contenido de la variable coincide exactamente con los elementos espesificados
;Sintaxis: InVar( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
InVar(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := false) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (!(CaseSensitive) && (Haystack=A_LoopField)) || ((CaseSensitive) && (Haystack==A_LoopField))
			return true
	return false
}

;If [var] contains [ .. ]
;comprueba si el contenido de la variable coincide exactamente o parcialmente con los elementos espesificados
;Sintaxis: Contains( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
Contains(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := false) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (InStr(Haystack, A_LoopField, !!CaseSensitive))
			return true
	return false
}

;obtener un nombre válido para un archivo
ValidateName(ByRef IpName) {
	return IpName := RegExReplace(IpName, "[\Q*/\:?" Chr(34) "<>|`n\E]")
}

;obtener una ruta válida para un directorio
;EJEMPLOS: 
	;MsgBox % ValidatePath( "\<`n||\ " A_WinDir "\/\ \ *Sys/t<e>m?32\c::md.:exe|`n\\" )
	;MsgBox % SetWorkingDir(A_WinDir) ValidatePath( "\system32\\cmd.:exe\ " )
ValidatePath(ByRef IpPath) {
	IpPath := RegExReplace(IpPath, "[\Q*/?" Chr(34) "<>|`n\E]")
	, IpPath := Trim(IpPath), IpPath := Trim(IpPath, "\"), IpPath := Trim(IpPath)
	, IpDrive := StrLeft(IpPath, 2) 
	if FileExist( IpDrive ) AND InStr(IpDrive, ":")
		IpPath := IpDrive StrReplace( StrTrimLeft( IpPath, 2 ), ":" )
	else
		IpPath := A_WorkingDir "\" StrReplace( IpPath, ":" )
	IpPath := StrReplace(IpPath, "\\", "\"), IpPath := StrReplace(IpPath, " \ ", "\")
	, IpPath := Trim(IpPath), IpPath := Trim(IpPath, "\"), IpPath := Trim(IpPath)
	return IpPath := StrReplace(IpPath, "\\", "\")
}

Sort(VarName, Options := "") {
	Sort, VarName, %Options%
	return VarName
}

;convertir texto en minúscula 
StrLower(String, T := false) {
	return Format(T?"{:T}":"{:L}", String)
}

;comprueba si es minúscula
IsLower(String) {
	if String is LOWER
		return true
	return false
}

;convertir texto en mayúscula
StrUpper(String, T := false) {
	return Format(T?"{:T}":"{:U}", String)
}

;comprueba si es mayúscula
IsUpper(String) {
	if String is UPPER
		return true
	return false
}

;reemplaza variables literales.
;Sintaxis: ReplaceLiteralVar( [Var], [archivo] )
;Ejemplo: MsgBox % ReplaceLiteralVar("Version: %A_FileVersion%`nSystem: %SysDir%`nCopyright: %LegalCopyright%", ComSpec)
ReplaceLiteralVar(String, FileName := false) {
	static _ := []
	static Env, St
	if !Env
		Env := {"HKCU": "Environment", "HKLM": "SYSTEM\ControlSet001\Control\Session Manager\Environment"}
	for k, v in Env
		Loop, Reg, %k%\%v%, V
			String := StrReplace(String, "%" A_LoopRegName "%", _[A_LoopRegName]?_[A_LoopRegName]:(_[A_LoopRegName]:=EnvGet(A_LoopRegName)))
	if !St
		St := {"Temp": (_0:=A_Temp), "ProgramFiles" : (_9:=A_ProgramFiles), "CommonProgramFiles": (i7:=A_ProgramsCommon), "AppData": (i0:=A_AppData), "OS": (_8:=A_OSVersion)
		, "COMPUTERNAME": (i5:=A_ComputerName), "HOMEDRIVE": SubStr(_1:=A_WinDir, 1, 2), "LOCALAPPDATA": (_2:=A_AppDataCommon), "desktop": (i2:=A_Desktop)
		, "WINDIR": _1, "USERNAME": (i4:=A_UserName), "SYSTEMROOT": _1, "PROCESSOR_ARCHITECTURE": A_Is64bitOS?"64":"32", "LOCALAPPDATA": _2
		, "CMDEXTVERSION": A_OSType, "StartMenu": (i3:=A_StartMenu), "MyDocuments": (_3:=A_MyDocuments), "Documents": _3, "Cursor": (i8:=A_Cursor), "SendTo": A_SendTo()
		, "Recent": A_Recent(), "MyVideo": A_MyVideo(), "MyPictures": A_MyPictures(), "MyMusic": A_MyMusic(), "DocumentsCommon": A_DocumentsCommon()
		, "Programs": (i6:=A_Programs), "ComSpec": A_ComSpec(), "SysWinDir": A_SysWinDir(), "SysDir": A_SysDir(), "SysDir64": A_SysDir64(), "DefaultUserProfile": A_DefaultUserProfile()
		, "Profiles": A_Profiles(), "AllUsersProfile": A_AllUsersProfile(), "UserProfile": A_UserProfile(), "UserDomain": A_UserDomain(), "A_Temp": _0, "A_AhkVersion": A_AhkVersion
		, "A_ScriptName": A_ScriptName, "A_ScriptFullPath": A_ScriptFullPath, "A_ScriptFullPath": A_ScriptFullPath, "A_ScriptDir": A_ScriptDir, "A_Space": A_Space, "A_Tab": A_Tab
		, "A_OSVersion": _8, "A_WinDir": _1, "A_ProgramFiles": _9, "A_AppData": i0, "A_Language": A_Language, "A_Desktop": i2, "A_StartMenu": i3, "A_UserName": i4
		, "A_AppDataCommon": _2, "A_ComputerName": i5, "A_StartMenuCommon": A_StartMenuCommon, "A_Programs": i6, "A_ProgramsCommon": i7, "A_Cursor": i8, "A_Startup": A_Startup
		, "A_DesktopCommon": A_DesktopCommon, "A_IsAdmin": A_IsAdmin, "A_StartupCommon": A_StartupCommon, "A_IPAddress4": A_IPAddress4, "A_IPAddress1": A_IPAddress1
		, "A_IPAddress2": A_IPAddress2, "A_IPAddress3": A_IPAddress3, "A_MyDocuments": _3}
	for k, v in St
		String := StrReplace(String, "%" k "%", v)
	Ot := {"CD": A_WorkingDir, "DATE": (_1:=A_DD) "/" (_2:=A_Mon) "/" (_3:=A_Year), "TIME": (_4:=A_Hour) ":" (_5=A_Min) ":" (_6:=A_Sec), "DateTime": _1 "_" _2 "_" _3 "_" _4 "_" _5 "_" _6
	, "A_DDD": A_DDD, "A_DDDD": A_DDDD, "A_MMM": A_MMM, "A_MMMM": A_MMMM, "A_MM": A_MM, "A_YYYY" : A_YYYY, "A_DD": _1, "A_WorkingDir": A_WorkingDir
	, "A_Year": _3, "A_Mon": _2, "A_WDay": A_WDay, "A_YDay": A_YDay, "A_Hour": _4,  "A_YWeek": A_YWeek, "A_Min": _5, "A_Sec": _6, "A_Now": A_Now, "A_MSec": A_MSec
	, "A_LastError": A_LastError, "A_ScreenHeight": A_ScreenHeight, "A_ScreenWidth": A_ScreenWidth}
	for k, v in Ot
		String := StrReplace(String, "%" k "%", v)
	if InStr(String, "%Clipboard%")
		String := StrReplace(String, "%Clipboard%", Clipboard)
	if (FileName) {
		String := StrReplace(String, "%A_FileVersion%", (_1:=FileGetVersion(FileName)))
		, String := StrReplace(String, "%FileVersion%", _1)
		if Contains(String, _2:="%Comments%,%InternalName%,%ProductName%,%CompanyName%,%LegalCopyright%,%FileDescription%,"
			. "%ProductVersion%,%LegalTrademarks%,%PrivateBuild%,%FileVersion%,%OriginalFilename%,%SpecialBuild%") {
			VerInfo := FileGetInfo(FileName)
			Loop, Parse, % _2, `,
				String := StrReplace(String, A_LoopField, VerInfo[StrReplace(A_LoopField, "%")])
	}} return String
}

















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CRIPTOGRAFÍA ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
Base32Encode(Decoded, UseHex := 0, Len := 0) { 
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	If (Len = 0)
		Len := StrPut(Decoded, "UTF-8") - 1
		, VarSetCapacity(UTF8, Len, 0)
		, StrPut(Decoded, &UTF8, "UTF-8")
		, BinAddr := &UTF8
	else BinAddr := &Decoded
	VarSetCapacity(Endcoded, Len * 2, 0), I := 0
	while (I < Len) {
		J := N := 0
		S := 40
		Loop, 5
			N += NumGet(BinAddr + I++, "UChar") << (8 * (5 - ++J))
		Until (I >= Len)
		Loop, % Ceil((8 * J) / 5)
			Encoded .= SubStr(Chars, ((N >> (S -= 5)) & 0x1F) + 1, 1)
	} Loop, % ((40 - (J * 8)) // 5)
		Encoded .= "="
	return Encoded
}

Base64Encode(Text) {
	VarSetCapacity(Bin, StrPut(Text, "UTF-8")), nSize := StrPut(Text, &Bin, "UTF-8") - 1
	, DllCall("Crypt32.dll\CryptBinaryToStringW", "Ptr", &Bin, "UInt", nSize, "UInt", 0x40000001, "Ptr", 0, "UInt*", Length)
	, VarSetCapacity(OutputVar, Length * 2)
	, r:=DllCall("Crypt32.dll\CryptBinaryToStringW", "Ptr", &Bin, "UInt", nSize, "UInt", 0x40000001, "Str", OutputVar, "UInt*", Length)
	return OutputVar, ErrorLevel := !r
}

;codificar URL
UriEncode(String) {
    obj := ComObjCreate("ScriptControl"), obj.Language := "JScript"
    , obj.ExecuteStatement("var Encoded = encodeURIComponent(" Chr(34) String Chr(34) ")")
    return obj.Eval("Encoded")
}

;----------------------------------------

Base32Decode(Encoded, UseHex := 0, ByRef Decoded := "") {
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	, Len := StrLen(Encoded)
	, VarSetCapacity(Decoded, Len * 2, 0)
	, I := J := K := 0
	Loop, Parse, % Encoded
	{ If !(N := InStr(Chars, A_LoopField))
			break
		K += --N << (5 * (8 - ++J))
		If (J = 8) {
			S := 40
			Loop, 5
				NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
			J := K := 0
	}} If (J < 8) {
		S := 40
		Loop, % Ceil((5 * J) / 8)
			NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
	} return IsByRef(Decoded) ? I : StrGet(&Decoded, I, "UTF-8")
}

Base64Decode(Text) {
	DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &Text, "UInt", StrLen(Text), "UInt", 0x1, "Ptr", 0, "UInt*", Length, "Ptr", 0, "Ptr", 0)
	, VarSetCapacity(OutputVar, Length)
	, r:=DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &Text, "UInt", StrLen(Text), "UInt", 0x1, "Str", OutputVar, "UInt*", Length, "Ptr", 0, "Ptr", 0)
	return StrGet(&OutputVar, Length, "UTF-8"), ErrorLevel := !r
}

;decodificar URL
UriDecode(String) {
    obj := ComObjCreate("ScriptControl"), obj.Language := "JScript"
    , obj.ExecuteStatement("var Decoded = decodeURIComponent(" Chr(34) String Chr(34) ")")
    return obj.Eval("Decoded")
}





















































/*#############################################################################################################################################
  ::::::::::::::::::::::::::::::::::::::::::::: PROCESOS ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
Notas:
	• espesificar -1 para referirse al proceso actual.
	• espesificar -2 para referirse al Thread actual. http://www.rastersoft.com/OS2/CURSO/THREAD.HTM
	• espesificar -3 para referirse al último proceso espesificado.
;Parámetros:
	ID / ProcessName = ID o Nombre del proceso
*/
;devuelve una lista de todos los procesos (PID+Nombre)
;Ejemplo:
	;for k, v in ProcessEnum()
	;	MsgBox % k ": " v
ProcessEnum() {
	dwSize := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0), NumPut(dwSize, lppe, 0, "UInt")
	, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
	, DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe), List := []
	Loop
		List[NumGet(lppe, 8, "UInt")] := StrGet(&lppe+(A_PtrSize=4?36:44), 260, "CP0")
	until !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
	return hSnapshot?List:false, ErrorLevel := !hSnapshot, CloseHandle(hSnapshot)
}

;Recupera información sobre el uso de memoria del proceso especificado en bytes
ProcessMemoryInfo(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410)
	, Size := VarSetCapacity(memCounters, A_PtrSize=8?72:40), NumPut(Size, memCounters)
	if !(DllCall("Psapi.dll\GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", Size)) {
		memCounters := "", Size := VarSetCapacity(memCounters, A_PtrSize=8?80:44), NumPut(Size, memCounters)
		if !(DllCall("Kernel32.dll\K32GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", Size))
			return false, ErrorLevel := true
	} i := {}, i.PageFaultCount := NumGet(memCounters, 4, "UInt")
		, i.PeakWorkingSetSize := NumGet(memCounters, 8, "Ptr")
		, i.WorkingSetSize := NumGet(memCounters, A_PtrSize = 8 ? 16 : 12, "Ptr") 
		, i.QuotaPeakPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 24 : 16, "Ptr")
		, i.QuotaPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 32 : 20, "Ptr")
		, i.QuotaPeakNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 40 : 24, "Ptr")
		, i.QuotaNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 48 : 28, "Ptr")
		, i.PagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 56 : 32, "Ptr")
		, i.PeakPagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 64 : 36, "Ptr")
		, i.PrivateUsage := NumGet(memCounters, A_PtrSize = 8 ? 72 : 40, "Ptr")
	return i, ErrorLevel := false, CloseHandle(hProcess)
}

;uso de CPU del proceso
ProcessCPULoad(ProcessName) {
		Static oldKrnlTime, oldUserTime, newKrnlTime, newUserTime
		ProcessId := _getpid(ProcessName)
		, oldKrnlTime := newKrnlTime, oldUserTime := newUserTime
		, hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		, DllCall("Kernel32.dll\GetProcessTimes", "Uint", hProcess, "int64P", CreationTime, "int64P", ExitTime, "int64P", newKrnlTime, "int64P", newUserTime) 
		return (((newKrnlTime-oldKrnlTime)+(newUserTime-oldUserTime))/10000000)*100, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;comprueba si el proceso existe
;Sintaxis: ProcessExist( [ProcessName] )
;Return: devuelve el PID o 0 en caso de error
;Notas:
	;epsesificar -1 para obtener el PID del proceso actual.
	;espesificar -2 para obtener el ThreadId del proceso actual.
	;espesificar -3 para obtener el PID del último proceso espesificado/encontrado.
ProcessExist(Proc*) {
	if !(ProcessName:=Trim(Proc[1])) && (Proc.MaxIndex())
		return false, ErrorLevel := true
	;---------------------------------------------------------------------------------------------------------------------
	if (ProcessName = -1) || !(Proc.MaxIndex())
		return DllCall("Kernel32.dll\GetCurrentProcessId")
	if (ProcessName = -2)
		return DllCall("Kernel32.dll\GetCurrentThreadId")
	if (ProcessName = -3)
		return Get("LastProcessId")
	;---------------------------------------------------------------------------------------------------------------------
	Size := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0), NumPut(Size, lppe, 0, "UInt")
	, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
	, DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
	Loop {
		ProcessId := NumGet(lppe, 8, "UInt"), ProcessExe := StrGet(&lppe + (A_PtrSize=4?36:44), 260, "CP0")
		if (ProcessId = ProcessName) || (ProcessExe = ProcessName)
			return Set("LastProcessId", ProcessId), CloseHandle(hSnapshot), ErrorLevel := false
		if !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
			return false, ErrorLevel := true, CloseHandle(hSnapshot)
}}

;esperar a que el proceso exista
;Sintaxis: ProcessWait( [Proceso], [Segundos a esperar] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no existe; caso contrario devuelve el PID
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWait(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return 0
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (ProcessId:=ProcessExist(ProcessName))
			return ProcessId, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep(100)
}}

;esperar a que el proceso finalize
;Sintaxis: ProcessWaitClose( [Proceso], [Segundos] )
;NOTAS:
	;devuelve 0 si han pasado los segundos y el proceso aun no se ha cerrado; caso contrario devuelve 1
	;especificar 0 segundos para esperar indefinidamente (defecto)
ProcessWaitClose(ProcessName, Seconds := 0) {
	if (Seconds = -1)
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !ProcessExist(ProcessName)
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep(100)
}} WaitForSingleObject(ProcessName, Seconds := 0) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032%28v=vs.85%29.aspx
	if (Seconds = -1)
		return false
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00100000)
	, r := DllCall("Kernel32.dll\WaitForSingleObject", "Ptr", hProcess, "UInt", Seconds>0?Seconds:0xFFFFFFFF)
	return (i=0)||(i=-1)?(ProcessId?ProcessId:true):false, ErrorLevel := (i=0)||(i=-1)?false:true, CloseHandle(hProcess)
}

;obtener/establecer prioridad 
;Sintaxis: ProcessPriority( [Nombre o PID], [Prioridad] )
;Prioridades: Low|BelowNormal|Normal|AboveNormal|High|RealTime
;Nota: dejar vacio el segundo parametro para recuperar la prioridad
ProcessPriority(ProcessName, Priority := "") {
	static p := {"Normal": 32, "Low": 64, "High": 128, "RealTime": 256, "BelowNormal": 16384, "AboveNormal": 32768}
	static rs := {32: "Normal", 64: "Low", 128: "High", 256: "RealTime", 16384: "BelowNormal", 32768: "AboveNormal"}
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, p[Priority]=""?0x0400:0x0200)
	if (p[Priority]="")
		return rs[DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess)], CloseHandle(hProcess), ErrorLevel := !Priority
	return r := DllCall("kernel32.dll\SetPriorityClass", "Ptr", hProcess, "UInt", p[Priority]), ErrorLevel := !r, CloseHandle(hProcess)
}

;cerrar proceso(s)
;Sintaxis: ProcessClose( [PID/Nombre*], [¿Esperar? (segundos)], [¿Terminar SubProcesos?], [código de salida] )
;NOTAS: 
	;espesificar * para terminar todos los procesos que coincidan con el nombre espesificado
	;espesificar 0 segundos para esperar indefinidamente
;Terminar SubProcesos: 
	;1 = terminar el proceso junto con todos los procesos que inició
	;2 = teminar todos los procesos que el proceso espesificado inició
ProcessClose(ProcessName, WaitClose := -1, SubProcess := 0, uExitCode := 0) {
	if (InStr(ProcessName, "*")) { ;terminar procesos que coincidan con el mismo nombre
		ProcessName := StrReplace(ProcessName, "*"), dwSize := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0)
		, NumPut(dwSize, lppe, 0, "UInt"), hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		if (DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe))
			Loop {
				ProcessId := NumGet(lppe, 8, "UInt"), ProcessExe := StrGet(&lppe + (A_PtrSize=4?36:44), 260, "CP0")
				if (ProcessExe=ProcessName)
					hList .= ProcessClose(ProcessId, WaitClose, SubProcess, uExitCode) "`n"
				if !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
					return RTrim(hList, "`n"), CloseHandle(hSnapshot)
	}} ProcessId := _getpid(ProcessName)
	if (SubProcess) { ;termina el proceso junto con todos sus subprocesos
		dwSize := VarSetCapacity(lppe, A_PtrSize=4?296:304, 0), NumPut(dwSize, lppe, 0, "UInt")
		, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0)
		, DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &lppe)
		Loop {
			Process_ID := NumGet(lppe, 8, "UInt"), Parent := NumGet(lppe, A_PtrSize=4?24:32, "UInt")
			if !(Process_ID=ProcessId) && (Parent=ProcessId)
				hList .= ProcessClose(Process_ID, WaitClose,, uExitCode) "`n"
			if !(DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &lppe))
				return SubProcess=1?hList ProcessClose(ProcessId, WaitClose,, uExitCode):RTrim(hList, "`n"), CloseHandle(hSnapshot)
	}} hProcess := OpenProcess(ProcessId, 0x0001), r := DllCall("Kernel32.dll\TerminateProcess", "Ptr", hProcess, "UInt", uExitCode)
	return r?ProcessId:0, ErrorLevel := !r, CloseHandle(hProcess), ProcessWaitClose(ProcessId, WaitClose)
} ;----------------------------------------------------------------------------------------------------------------------------------------------------------------

;recupera la ruta completa al archivo ejecutable del proceso
;Sintaxis: ProcessPath( [ID] )
ProcessPath(ProcessName, ByRef ProcessEName := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410), VarSetCapacity(OutputVar, (260 + 1) * 2, 0)
	if !(r:=DllCall("Psapi.dll\GetModuleFileNameExW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1))
		if !(r:=DllCall("Kernel32.dll\K32GetModuleFileNameExW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1))
			r := DllCall("Kernel32.dll\QueryFullProcessImageNameW", "Ptr", hProcess, "UInt", 1, "Str", OutputVar, "UIntP", 260 + 1)
	return OutputVar, ErrorLevel := !r, CloseHandle(hProcess), ProcessEName := IsByRef(ProcessEName)?ProcessName(ProcessId):""
}

;recupera el nombre del archivo ejecutable del proceso
;Sintaxis: ProcessName( [PID] )
ProcessName(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410), VarSetCapacity(OutputVar, (260 + 1) * 2, 0)
	if !(r:=DllCall("Psapi.dll\GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1))
		r := DllCall("Kernel32.dll\K32GetModuleBaseNameW", "Ptr", hProcess, "Ptr", 0, "Str", OutputVar, "UInt", 260 + 1)
	return OutputVar, CloseHandle(hProcess)
}

;establece el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessSetWorkingSetSize( [Proceso], [Min], [Max] )
ProcessSetWorkingSetSize(ProcessName, Min := -1, Max := -1) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0100)
	, r := DllCall("Kernel32.dll\SetProcessWorkingSetSize", "Ptr", hProcess, "Ptr", Min, "Ptr", Max)
	return r, ErrorLevel := !r, CloseHandle(hProcess)
}

;obtiene el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessGetWorkingSetSize( [Proceso], [Min (salida)], [Max (salida)] )
ProcessGetWorkingSetSize(ProcessName, ByRef Min := "", ByRef Max := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), i := {}
	, r := DllCall("Kernel32.dll\GetProcessWorkingSetSize", "Ptr", hProcess, "PtrP", Min, "PtrP", Max)
	return r?{Min: Min, Max: Max}:0, ErrorLevel := !r, CloseHandle(hProcess)
}

;habilitar/deshabilitar/eliminar privilegios para el proceso espesificado
;Sintaxis: ProcessAdjustPrivileges( [proceso], [Array o Privilegios separados por coma], [estado], [¿deshabilitar todos los privilegios?] )
;Array: espesificar los privilegios y el estado para cada uno.
	;Sintaxis: [	["privilegio 1", "estado 1"], ["privilegio 2", "estado 2"], ["privilegio 3", "estado 3"], ...	 ]
;Privilegios separados por coma: espesificar los privilegios separados por coma. el estado en el 3er parámetro que se aplica a todos
;Estados: Enable | Disable | Delete. Nota: el 3er parámetro solo es válido cuando se espesifican los privilegios separados por coma
;Deshabilitar todos los privilegios: establecer en verdadero para deshabilitar todos los privilegios. el 2do y 3er parámetro no tienen efecto
;Privilegios: https://msdn.microsoft.com/en-us/library/windows/desktop/bb530716(v=vs.85).aspx
	;SeChangeNotifyPrivilege|SeCreateGlobalPrivilege|SeDebugPrivilege|SeShutdownPrivilege|SeSystemtimePrivilege|SeCreatePagefilePrivilege
	;SeImpersonatePrivilege|SeIncreaseQuotaPrivilege|SeTimeZonePrivilege|SeIncreaseBasePriorityPrivilege|SeManageVolumePrivilege|SeRemoteShutdownPrivilege
	;SeCreateSymbolicLinkPrivilege|SeSecurityPrivilege|SeTakeOwnershipPrivilege|SeBackupPrivilege|SeProfileSingleProcessPrivilege|SeRestorePrivilege
	;SeSystemEnvironmentPrivilege|SeSystemProfilePrivilege|SeUndockPrivilege|SeIncreaseWorkingSetPrivilege|SeLoadDriverPrivilege
;Ejemplo:
	;MsgBox % ProcessAdjustPrivileges("notepad.exe", [["SeDebugPrivilege", "Enable"], ["SeRestorePrivilege", "Enable"]]) ;Array
	;MsgBox % ProcessAdjustPrivileges("notepad.exe", "SeDebugPrivilege,SeRestorePrivilege", "Disable") ;Privilegios separados por coma, uso del 3er parámetro
	;MsgBox % ProcessAdjustPrivileges("notepad.exe",,, true) ;deshabilitar todos los privilegios. NOTA: los privilegios habilitados por defecto no se deshabilitan
;Nota: para comprobar los cambios, puede usar ProcessHacker, doble clic en el proceso, en la pestaña «Token». items en verde oscuro no se pueden deshabilitar.
ProcessAdjustPrivileges(ProcessName, Privileges := "", State := "Enable", DisableAllPrivileges := false) {
	static States := {Enable: 0x00000002, Disable: 0x00000000, Delete: 0x00000004}
	ProcessId := _getpid(ProcessName), Privileges := IsObject(Privileges)?Privileges:StrSplit(Privileges, ",", A_Space A_Tab)
	, hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x00000028), c := 4
	, VarSetCapacity(TOKEN_PRIVILEGES, 16*Privileges.MaxIndex(), 0), NumPut(Privileges.MaxIndex(), TOKEN_PRIVILEGES, 0, "UInt")
	for Index, Info in Privileges {
		DllCall("Advapi32.dll\LookupPrivilegeValueW", "Ptr", 0, "Str", IsObject(Info)?Info[1]:Info, "Int64P", lpLuid)
		, NumPut(lpLuid, TOKEN_PRIVILEGES, c, "Ptr"), NumPut(States[IsObject(Info)?Info[2]:State], TOKEN_PRIVILEGES, c+8, "UInt"), c += 12
	} DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", hToken, "Int", !!DisableAllPrivileges, "Ptr", &TOKEN_PRIVILEGES, "UInt", 0, "Ptr", 0, "Ptr", 0)
	return !(r:=A_LastError), ErrorLevel := r, CloseHandle(hToken, hProcess) ;AdjustTokenPrivileges --> A_LastError --> ERROR_SUCCESS = 0
} ;https://msdn.microsoft.com/en-us/library/aa375202(VS.85).aspx | https://msdn.microsoft.com/en-us/library/aa379306(v=vs.85).aspx

;obtener privilegios del proceso
;Sintaxis: ProcessQueryPrivileges( [ID], [devuelve la cantidad de privilegios] )
;Return: devuelve un Array [[priv 1, estado 1], [priv 2, estado 2], ...], ver ejemplo.
;Estados: Enabled | Disabled | Default (habilitado por defecto) | Access. Info: https://msdn.microsoft.com/en-us/library/aa379630(v=vs.85).aspx
;Ejemplo:
	;for k, v in ProcessQueryPrivileges("notepad.exe", Count)
	;	MsgBox % "#" k " ~ " Count " ------------`nPrivilegio: " v[1] "`nEstado: " v[2]
ProcessQueryPrivileges(ProcessName, ByRef Count := "") {
	static States := {0x00000002: "Enabled", 0x00000000: "Disabled", 0x00000001: "Default", 0x80000000: "Access"}
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x0008)
	, DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", 3, "Ptr", 0, "UInt", 0, "UIntP", Size)
	, VarSetCapacity(TOKEN_PRIVILEGES, Size * 2, 0), c := 4, Array := []
	, r:=DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", 3, "Ptr", &TOKEN_PRIVILEGES, "UInt", Size, "UIntP", Size)
	Loop, % (Count:=NumGet(TOKEN_PRIVILEGES, 0, "UInt")) ;PrivilegeCount
		Array.Push([LookupPrivilegeName(NumGet(TOKEN_PRIVILEGES, c, "Int64P")), States[NumGet(TOKEN_PRIVILEGES, c+8, "UInt")]]), c += 12
	return Array, ErrorLevel := !r, CloseHandle(hToken, hProcess)
} LookupPrivilegeName(lpLuid) {
	Loop, Parse, % "SeChangeNotifyPrivilege|SeCreateGlobalPrivilege|SeDebugPrivilege|SeShutdownPrivilege|SeSystemtimePrivilege|SeCreatePagefilePrivilege"
		. "|SeImpersonatePrivilege|SeIncreaseQuotaPrivilege|SeTimeZonePrivilege|SeIncreaseBasePriorityPrivilege|SeManageVolumePrivilege|SeRemoteShutdownPrivilege"
		. "|SeCreateSymbolicLinkPrivilege|SeSecurityPrivilege|SeTakeOwnershipPrivilege|SeBackupPrivilege|SeProfileSingleProcessPrivilege|SeRestorePrivilege"
		. "|SeSystemEnvironmentPrivilege|SeSystemProfilePrivilege|SeUndockPrivilege|SeIncreaseWorkingSetPrivilege|SeLoadDriverPrivilege", |
	{ DllCall("Advapi32.dll\LookupPrivilegeValueW", "Ptr", 0, "Str", A_LoopField, "Int64P", cLuid)
		if (lpLuid=cLuid)
			return A_LoopField
}}
MsgBox % ProcessElevation("smss.exe") "`n" ProcessElevation(-1)
ExitApp
;determina si el proceso tiene privilegios elevados
;Sintaxis: ProcessElevation( [ID] )
;Return: 0|1
ProcessElevation(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x0008)
	, DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", 20, "Ptr", 0, "UInt", 0, "UIntP", Size)
	, VarSetCapacity(TOKEN_ELEVATION, Size * 2, 0)
	, r:=DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", 20, "Ptr", &TOKEN_ELEVATION, "UInt", Size, "UIntP", Size)
	return r?NumGet(TOKEN_ELEVATION, 0, "Int"):false, ErrorLevel := !r, CloseHandle(hToken, hProcess)
}

;suspender
ProcessSuspend(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0800)
	, DllCall("ntdll.dll\NtSuspendProcess", "Ptr", hProcess)
	return hProcess, CloseHandle(hProcess)
}
	
;reanudar
ProcessResume(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0800)
	, DllCall("ntdll.dll\NtResumeProcess", "Ptr", hProcess)
	return hProcess, CloseHandle(hProcess)
}
	
;obtiene el SID, opcional también el nombre de usuario y dominio del proceso
;Sintaxis: ProcessGetSid( [proceso], [nombre de usuario (salida)], [dominio (salida)] )
ProcessGetSid(ProcessName, ByRef UserName := "", ByRef UserDomain := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x00000008)
	, DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", 0x1, "PtrP", 0, "UInt", 0, "UIntP", Length)
	, VarSetCapacity(TokenInformation, Length * 2, 0), DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
	, r:=DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", 0x1, "UInt", &TokenInformation, "UInt", Length, "UIntP", 0)
	if (Sid:=NumGet(TokenInformation, 0, "UInt")) && ((IsByRef(UserName)) || (IsByRef(UserDomain)))
		VarSetCapacity(UserName, 512), VarSetCapacity(UserDomain, 512)
		, DllCall("Advapi32.dll\LookupAccountSidW", "Ptr", 0, "Ptr", Sid, "Str", UserName, "UIntP", 512, "Str", UserDomain, "UIntP", 512, "UIntP", 0)
	return Sid, ErrorLevel := !r, CloseHandle(hToken, hProcess)
}

;obtener una lista de los Threads del proceso espesificado
;Sintaxis: ProcessThreadList( [ID], [Delimitador] )
;EJEMPLO:
	;for k, v in ProcessThreadList()
		;if (i:=ProcessName(v.ProcessId))
			;MsgBox % "ThreadId: " v.ThreadId ", OwnerProcessId: " v.ProcessId " (" i ")"
ProcessThreadList(ProcessName := "", Delimiter := "`n") {
	ProcessName := _getpid(ProcessName), dwSize := VarSetCapacity(THREADENTRY32, A_PtrSize=4?28:40, 0)
	, NumPut(dwSize, THREADENTRY32, 0, "UInt"), hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000004, "UInt", 0)
	, DllCall("Kernel32.dll\Thread32First", "Ptr", hSnapshot, "Ptr", &THREADENTRY32)
	Loop {
		th32OwnerProcessID := NumGet(THREADENTRY32, A_PtrSize=4?12:20, "UInt")
		, th32ThreadID := NumGet(THREADENTRY32, 8, "UInt")
		if (ProcessName) {
			if (ProcessName=th32OwnerProcessID)
				ThreadList .= (A_Index=1?"":Delimiter) th32ThreadID
		} else {
			if !IsObject(ThreadList)
				ThreadList := []
			ThreadInfo := [], ThreadInfo.ThreadId := th32ThreadID
			, ThreadInfo.ProcessId := th32OwnerProcessID, ThreadList.InsertAt( A_Index, ThreadInfo )
		} if !(DllCall("Kernel32.dll\Thread32Next", "Ptr", hSnapshot, "UInt", &THREADENTRY32))
			return ThreadList, ErrorLevel := hSnapshot=-1, CloseHandle(hSnapshot)
}}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;otros
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: OpenProcess( [ID], [acceso] )
;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx
OpenProcess(ProcessId, DesiredAccess := 0x001F0FFF, InheritHandle := false) {
	return DllCall("Kernel32.dll\OpenProcess", "UInt", DesiredAccess, "Int", !!InheritHandle, "UInt", ProcessId, "Ptr")
} 

;Sintaxis: OpenProcessToken( [hProces], [acceso] )
;Accesos:
	;STANDARD_RIGHTS_REQUIRED = 0x000F0000
	;TOKEN_ASSIGN_PRIMARY = 0x0001
	;TOKEN_DUPLICATE = 0x0002
	;TOKEN_IMPERSONATE = 0x0004
	;TOKEN_QUERY = 0x0008
	;TOKEN_QUERY_SOURCE = 0x0010
	;TOKEN_ADJUST_PRIVILEGES = 0x0020
	;TOKEN_ADJUST_GROUPS = 0x0040
	;TOKEN_ADJUST_DEFAULT = 0x0080
	;TOKEN_ADJUST_SESSIONID = 0x0100
OpenProcessToken(hProcess, DesiredAccess := 0xF01FF) {
	DllCall("Advapi32.dll\OpenProcessToken", "Ptr", hProcess, "UInt", DesiredAccess, "UIntP", hToken)
	return hToken
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379295(v=vs.85).aspx





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: INTERNET ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;descargar archivo
;Sintaxis: Download( [URL], [Archivo], [¿sobreescribir?], [¿recuperar de la memoria caché cuando sea posible?] )
;Nota: omitir el 2do parámetro para obtener el texto sin crear el archivo.
Download(URL, Filename := "", OverWrite := true, UseCache := false) {
	static param := 0
	param++
	if (Filename="") {
		whr := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, whr.Open("GET", Trim(URL) (UseCache?"":"?f=" param), true), whr.Send(), whr.WaitForResponse()
		return whr.ResponseText
	} if !(OverWrite) && (FileExist(Filename))
		return false, ErrorLevel := 2
	URLDownloadToFile, % Trim(URL) (UseCache?"":"?f=" param), %Filename%
	return !ErrorLevel
} InternetGetString(URL) {
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1"), i.Open("GET", URL), i.Send()
	return i.ResponseText
}

;comprueba la conexion a internet
InternetGetState(lpdwFlags := 0x40) {
	i := DllCall("Wininet.dll\InternetGetConnectedState", "UInt*", 0x40, "UInt", 0)
	return i, ErrorLevel := !i
}

;obtener tamaño del archivo
;Sintaxis: InternetGetFileSize( [URL], [KB|MB|GB] )
InternetGetFileSize(URL, Units := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	if !(GetModuleHandle("Wininet.dll"))
		hModule := LoadLibrary("Wininet.dll")
	hInternet := DllCall("Wininet.dll\InternetOpenW", "Str", "Microsoft Internet Explorer", "UInt", 4, "Ptr", 0, "Ptr", 0, "UInt", 0)
	, hInternetUrl := DllCall("Wininet.dll\InternetOpenUrlW", "Ptr", hInternet, "Str", URL, "Ptr", 0, "UInt", 0, "UInt", 0x84000000, "UInt", 0)
	if (StrLeft(URL, 4)="ftp:")
		FileSize := DllCall("Wininet.dll\FtpGetFileSize", "Ptr", hInternetUrl, "UIntP", 0)  
	else DllCall("Wininet.dll\HttpQueryInfoW", "Ptr", hInternetUrl, "UInt", 0x20000005, "UIntP", FileSize, "UIntP", 4, "UIntP", 0)
	DllCall("Wininet.dll\InternetCloseHandle", "Ptr", hInternetUrl), DllCall("Wininet.dll\InternetCloseHandle", "Ptr", hInternet)
	if (hModule)
		FreeLibrary(hModule)
	return _[Units]?FileSize/_[Units]:FileSize, ErrorLevel := !FileSize
}

;enviar e-mail
;Sintáxis: EmailSend( [email], [contraseña], [email destino], [cuerpo], [asunto] )
;NOTA: para gmail activar el Acceso De Aplicaciones Menos Seguras: https://www.google.com/settings/security/lesssecureapps
EmailSend(User, Pass, To, Body, Subject := "", CC := "", BCC := "", Attach := "") {
	pmsg := ComObjCreate("CDO.Message")
	, pmsg.From := User
	, pmsg.To := To, pmsg.BCC := BCC, pmsg.CC := CC
	, pmsg.Subject := Subject, pmsg.TextBody := Body
	, sAttach := Attach
	Loop, Parse, % sAttach, `n, `r
		pmsg.AddAttachment(A_LoopField)
	fields := Object()
	, fields.smtpserver := "smtp.gmail.com" ; specify your SMTP server
	, fields.smtpserverport := 465 ; 25
	, fields.smtpusessl := True ; False
	, fields.sendusing := 2 ; cdoSendUsingPort
	, fields.smtpauthenticate := 1 ; cdoBasic
	, fields.sendusername := User
	, fields.sendpassword := Pass
	, fields.smtpconnectiontimeout := 60
	, schema := "http://schemas.microsoft.com/cdo/configuration/"
	, pfld := pmsg.Configuration.Fields
	for field, value in fields
		pfld.Item(schema . field) := value
	pfld.Update()
	try pmsg.Send()
	catch
		return false
	return true
}




































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: BARRA DE TAREAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establecer porcentaje de progreso en la barra de tareas
;Sintaxis: TaskBarProgress( [ESTADO], [Ventana ID] )
;ESTADOS: 0~100, Normal, Paused, Indeterminate, Error
TaskBarProgress(hWnd, State := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=48329#p48329
	_gethwnd(hWnd)
	static ppv
	if !(ppv)
		ppv := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf}")
	static s0 := 0, sI := sIndeterminate := 1, sN := sNormal := 2, sE := sError := 4, sP := sPaused := 8
	if InVar(State, "0,N,P,E,I,Normal,Paused,Error,Indeterminate")
		return DllCall(NumGet(NumGet(ppv+0)+10*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "UInt", s%State%)
	return DllCall(NumGet(NumGet(ppv+0)+9*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "Int64", State * 10, "Int64", 1000)
} ;https://msdn.microsoft.com/en-us/library/dd391698(v=vs.85).aspx

;quitar ventana de la barra de tareas
;Sintaxis: TaskBarRemove( [ID], [¿mostrar?] )
TaskBarRemove(hWnd, Show := false) {
	_gethwnd(hWnd)
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	, DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (Show?4:5)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd), ObjRelease(hTaskBar)
}

;activa la ventana en la barra de tareas
;TaskBarActivate( [ID], [¿marcar siempre como activo (no visualmente)?] )
TaskBarActivate(hWnd, SetActiveAlt := 0) {
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	, DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (SetActiveAlt?7:6)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd), ObjRelease(hTaskBar)
}

;obtiene posicion de la barra de tareas
;Sintaxis: TaskBarGetPos( [xpos], [ypos], [ancho], [alto] )
TaskBarGetPos(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	return WinGetPos(GetTaskBar(), x, y, Width, Height)
}

;obtiene hWnd de la barra de tareas, opcional: área de notificacion, reloj y boton inicio
;Sintaxis: GetTaskBar( [área de notificacion], [área de notificacion (iconos ocultos)], [reloj], [boton inicio] )
;EJEMPLO: leer hora que indica el reloj de la barra de tareas. para otro ejemplo ver TaskBarGetPos()
	;MsgBox % ControlGetText(GetTaskBar(), "TrayClockWClass1") ;[control], [ventana id o hWnd]
GetTaskBar(ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0)
	if IsByRef(hNotifArea)||IsByRef(hOverFNotifArea)||IsByRef(hTrayClock) {
		hNotify := DllCall("User32.dll\FindWindowExW", "Ptr", hTaskBar, "Ptr", 0, "Str", "TrayNotifyWnd", "Ptr", 0)
		, hSyspager := DllCall("User32.dll\FindWindowExW", "Ptr", hNotify, "Ptr", 0, "Str", "SysPager", "Ptr", 0)
		if !(hNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hSyspager, "Ptr", 0, "Str", "ToolbarWindow32", "Str", "User Promoted Notification Area"))
			if !(hNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hSyspager, "Ptr", 0, "Str", "ToolbarWindow32", "Str", "Notification Area"))
				hNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hSyspager, "Ptr", 0, "Str", "ToolbarWindow32", "Ptr", 0)
		if IsByRef(hOverFNotifArea)
			hNotifIcon := DllCall("User32.dll\FindWindowW", "Ptr", 0, "Str", "NotifyIconOverflowWindow")
			, hOverFNotifArea := DllCall("User32.dll\FindWindowExW", "Ptr", hNotifIcon, "Ptr", 0, "Str", "ToolbarWindow32", "Str", "Overflow Notification Area")
	} return hTaskBar, hTrayClock := IsByRef(hTrayClock)?DllCall("User32.dll\FindWindowExW", "Ptr", hNotify, "Ptr", 0, "Str", "TrayClockWClass", "Ptr", 0):""
		, hStartButton := IsByRef(hStartButton)?DllCall("User32.dll\FindWindowExW", "Ptr", hTaskBar, "Ptr", 0, "Str", "Button", "Ptr", 0):""
}

;redibujar barra de tareas, área de notificacion, reloj y boton inicio.
TaskBarRedraw(ByRef hTaskBar := "", ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := GetTaskBar(hNotifArea, hOverFNotifArea, hTrayClock, hStartButton)
	return i:=WinRedraw(hTaskBar)+WinRedraw(hNotifArea)+WinRedraw(hOverFNotifArea)+WinRedraw(hTrayClock)+WinRedraw(hStartButton)
		, ErrorLevel := i!=5
}

;obtiene los iconos en el area de notificacion +info.
;Nota: requiere WIN_V+
;Ejemplo:
	;for k, v in TaskBarTrayIconsEnum() {
	;	TaskBarTrayIconHide(v.CMD,, v.Hidden)
	;	MsgBox % "hWnd: " v.hWnd "`nCommand: " v.CMD "`nIcon: " v.Icon "`nMsg: " v.Msg "`nHidden: " v.Hidden "`nID: " v.ID "`nTip: " v.Tip
	;	TaskBarTrayIconHide(v.CMD, false, v.Hidden)
	;}
TaskBarTrayIconsEnum() {
	List := [], GetTaskBar(hNotifArea, hOverFNotifArea)
	Loop, Parse, % (hNotifArea "." hOverFNotifArea), .
	{	ProcessId := WinGetPid(A_LoopField), Index := A_Index
		, hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x38, "Int", 0 , "UInt", ProcessId)
		, pAddress := DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "Ptr", 0, "UPtr", 20, "UInt", 0x00001000, "UInt", 0x04)
        , Size := VarSetCapacity(TBBUTTON, A_PtrSize=4?24:32, 0), VarSetCapacity(v2, Size, 0), s3 := VarSetCapacity(v3, 128 * 2, 0)
		, Count := SendMessage(A_LoopField, 0x418) ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb760478%28v=vs.85%29.aspx
		Loop, % (Count) {
			SendMessage(A_LoopField, 0x417, "Int", A_Index-1, "UInt", pAddress)
			, DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, "UInt", pAddress, "Ptr", &TBBUTTON, "UPtr", Size, "UPtr", 0)
            , Bitmap := NumGet(TBBUTTON, 0, "Int"), Command := NumGet(TBBUTTON, 4, "Int"), Statyle := NumGet(TBBUTTON, 8, "UInt")
			, Data := NumGet(TBBUTTON, A_PtrSize=4?12:16, "Ptr"), String := NumGet(TBBUTTON, A_PtrSize=4?16:24, "Ptr")
			, DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, "Ptr", Data, "Ptr", &v2, "UPtr", Size, "UPtr", 0)
            , hWnd := NumGet(v2, 0, "Ptr"), ID := NumGet(v2, A_PtrSize), Msg  := NumGet(v2, A_PtrSize=4?8:12), hIcon := NumGet(v2, A_PtrSize=4?20:24, "Ptr")
			, DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, "Ptr", String, "Ptr", &v3, "UPtr", s3, "UPtr", 0)
			, List.Push({hWnd: hWnd, CMD: Command, ID: ID, Msg: Msg, Icon: hIcon, Hidden: (Index=2), Tip: StrGet(&v3, s3, "UTF-16")})
		} DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", pAddress, "UPtr", 0, "UInt", 0x8000), DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
	} return List
} ;http://ahkscript.org/boards/viewtopic.php?p=54388#p54388

;ocultar/mostrar icono en el área de notificación.
;Sintaxis: TaskBarTrayIconHide( [hWnd], [0|1] )
TaskBarTrayIconHide(CMD, Hide := true, Hidden := false) {
	GetTaskBar(hNotifArea, hOverFNotifArea)
	if (Hidden) || !(SendMessage(hNotifArea, 0x404,, CMD, "Int", !!Hide))
		return SendMessage(hOverFNotifArea, 0x404,, CMD, "Int", !!Hide), SendMessage(hOverFNotifArea, 0x1A)
	return true, SendMessage(hNotifArea, 0x1A)
}

;habilitar/deshabilitar icono en el área de notificación.
;Sintaxis: TaskBarTrayIconEnable( [hWnd], [0|1] )
TaskBarTrayIconEnable(CMD, Enable := true, Hidden := false) {
	GetTaskBar(hNotifArea, hOverFNotifArea)
	if (Hidden) || !(SendMessage(hNotifArea, 0x400+1,, CMD, "Int", !!Enable))
		return SendMessage(hOverFNotifArea, 0x400+1,, CMD, "Int", !!Enable)
	return true
}





















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ESCRITORIO, EXPLORADOR, PAPELERA DE RECICLAJE & MENU INICIO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recupera el tamaño de la papelera de reciclaje (en bytes) y el número de elementos que contiene para una unidad especificada.
;Sintaxis: RecycleBinGetSize( [unidad], [unidades (KB|MB|GB)], [elementos (salida)] )
RecycleBinGetSize(Path, Units := "", ByRef i64NumItems := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	cbSize := VarSetCapacity(SHQUERYRBINFO, A_PtrSize=4?20:36, 0), NumPut(cbSize, SHQUERYRBINFO, 0, "UInt")
	, Result :=  DllCall("Shell32.dll\SHQueryRecycleBinW", "Str", StrLeft(Trim(Path)) ":\", "Ptr", &SHQUERYRBINFO)
	, i64Size := NumGet(SHQUERYRBINFO, 4, "Int64"), i64NumItems := IsByRef(i64NumItems)?NumGet(SHQUERYRBINFO, 12, "Int64"):""
	return _[Units]?i64Size/_[Units]:i64Size, ErrorLevel := Result
}

;vacía la Papelera de reciclaje en la unidad especificada.
;Sintaxis: RecycleBinEmpty( [unidad], [¿ocultar dialgos de confirmacion?], [¿ocultar dialogos de progreso?], [¿no reproducir sonidos?] )
RecycleBinEmpty(Path, NoConfirmation := true, NoProgressUI := true, NoSound := true) {
	r := DllCall("Shell32.dll\SHEmptyRecycleBinW", "Ptr", A_ScriptHwnd, "Str", StrLeft(Trim(Path)) ":\"
	, "UInt", (NoConfirmation?0x00000001:0)|(NoProgressUI?0x00000002:0)|(NoSound?0x00000004:0))
	return !r, ErrorLevel := r
}

;reiniciar explorador de windows
RestartWindowsExplorer() {
	if ProcessClose("explorer.exe*", 5)
		return Run(A_WinDir "\explorer.exe")
	return false, ErrorLevel := true
}

;muestra el menú inicio
ShowStartMenu() {
	return PostMessage(IsWindow(), 0x112, "UInt", 0xF130)
}

;muestra el escritorio y establece foco en él
;Sintaxis: ShowDesktop( [¿esperar? (segundos)], [¿redibujar?] )
ShowDesktop(Wait := -1, Redraw := false) {
	ComObjCreate("shell.application").ToggleDesktop()
	, i := WinActivate(GetDesktop(), Wait, true)
	if (Redraw)
		DesktopRedraw()
	return i, ErrorLevel := !i
}

;obtener hWnd del control SysListView32 del escritorio (control de los iconos)
GetDesktop(ByRef ShellWindow := "", ByRef DesktopWindow := "", ByRef hProgman := "") {
	hProgman := DllCall("User32.dll\FindWindowW", "Str", "Progman", "Ptr", 0)
	, hSDDefView := DllCall("User32.dll\FindWindowExW", "Ptr", hProgman, "Ptr", 0, "Str", "SHELLDLL_DefView", "Ptr", 0)
	if !(hDesktop := DllCall("User32.dll\FindWindowExW", "Ptr", hSDDefView, "Ptr", 0, "Str", "SysListView32", "Str", "FolderView"))
		hDesktop := DllCall("User32.dll\FindWindowExW", "Ptr", hSDDefView, "Ptr", 0, "Str", "SysListView32", "Ptr", 0)
	return hDesktop, ShellWindow := IsByRef(ShellWindow)?DllCall("User32.dll\GetShellWindow"):""
		, DesktopWindow := IsByRef(DesktopWindow)?DllCall("User32.dll\GetDesktopWindow"):""
}

;redibujar escritorio
DesktopRedraw(ByRef hDesktop := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop()
	return WinRedraw(hDesktop)
}

;obtener cantidad de iconos en el escritorio
DesktopIconCount(ByRef hDesktop := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop()
	return LV_GetItemCount(hDesktop)
}

;obtener una lista con todos los iconos visibles del escritorio
DesktopIconList(ByRef hDesktop := "", ByRef ProcessId := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop(), Count := DesktopIconCount(hDesktop)
	, ProcessId := ProcessId?ProcessId:WinGetPid(hDesktop)
	Loop, %Count%
		List .= LV_GetItemTextEx(hDesktop, A_Index,, ProcessId) "`n"
	return Rtrim(List, "`n")
}

;guardar captura de pantalla
;Sintaxis: SaveScreenshot( [archivo destino], [coordenadas] )
;Archivo destino:  .bmp, .jpg, .png, .tif, .gif
;Coordenadas:
	;--> Array con las coordenadas: [x, y, ancho, alto].
	;--> Toda la pantalla: Screen. Defecto.
	;--> Ventana activa: Window | A. Nota: la ventana debe estar visible.
	;--> Array con el ID de una ventana: ["ID", hWnd]. Nota: la ventana debe estar visible.
;Ejemplos:
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_1.jpg", [0, 0, 500, 350]) ;por coordenadas.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_2.jpg", "Screen") ;pantalla entera.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_3.jpg", "Window") ;ventana activa.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_4.jpg", ["ID", GetTaskbar()]) ;ventana espesificada (barra de tareas).
SaveScreenshot(Filename, Pos := "Screen") {
	if !(GetModuleHandle("Gdiplus"))
		pToken := Gdip_Startup()
	if (Pos="Window") || (Pos="A") || (Pos[1]="ID") 
		WinGetPos(IsObject(Pos)?Pos[2]:-1, x, y, w, h)
	else x := ((Pos="Screen")||(Pos[1]="")||!(Pos[1]>-1))?0:Pos[1], y := ((Pos="Screen")||(Pos[2]="")||!(Pos[2]>-1))?0:Pos[2]
	, w := ((Pos="Screen")||(Pos[3]="")||!(Pos[3]>0))?A_ScreenWidth:Pos[3], h := ((Pos="Screen")||(Pos[4]="")||!(Pos[4]>0))?A_ScreenHeight:Pos[4]
	pBitmap := Gdip_BitmapFromScreen(x "|" y "|" w "|" h, 0x40000000+0x00CC0020), Gdip_SaveBitmapToFile(pBitmap, Filename, 100), Gdip_DisposeImage(pBitmap)
	if (pToken)
		Gdip_Shutdown(pToken)
	return true
}

;guarda la posición de los iconos del escritorio.
;Ejemplo: 
	;for k, v in DesktopGetIconsPos()
	;	MsgBox %  "Nombre: " k "`nPosición: " v[1] "x" v[2]
DesktopGetIconsPos(ByRef hDesktop := "", ByRef ProcessId := "") {
	Array := []
	Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
		Pos := LV_GetItemPosEx(hDesktop, A_Index,,, ProcessId)
		, Array[A_LoopField] := [Pos[1], Pos[2]]
	return Array
}

;restaura la posición de los iconos del escritorio.
;Ejemplo:
	;DesktopIconsPos := DesktopGetIconsPos(hDesktop, ProcessId)
	;MsgBox mueva un icono en el escritorio!
	;DesktopSetIconsPos(DesktopIconsPos, hDesktop, ProcessId)
	;MsgBox los iconos han sido restaurados a su posición original!
	;ExitApp
DesktopSetIconsPos(IconsPos, ByRef hDesktop := "", ByRef ProcessId := "") {
	i := 0
	Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
	{	if (IconsPos[A_LoopField][1]!="") {
			IconIndex := "", ItemName := A_LoopField
			Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
			{	if (A_LoopField=ItemName) {
					IconIndex := A_Index
					break
			}} if (IconIndex="")
					continue
			i+=LV_SetItemPosEx(hDesktop, IconIndex, IconsPos[A_LoopField][1], IconsPos[A_LoopField][2], ProcessId)
			, r := A_Index
	}} return i=r, ErrorLevel := !(i=r)
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DesktopGetShellWindows() {
	static SWDesktop
	if !(IsObject(SWDesktop)) {
		ShellWindows := ComObjCreate("Shell.Application").Windows
		VarSetCapacity(_hwnd, 4, 0), SWDesktop := ShellWindows.FindWindowSW(0, "", 8, ComObj(0x4003, &_hwnd), 1)
	} return SWDesktop, ErrorLevel := !IsObject(SWDesktop)
}

;refrezcar escritorio
DesktopRefresh() {
	return IsObject(SWDesktop:=DesktopGetShellWindows()), SWDesktop.Refresh()
}

;obtener elementos seleccionados
;Sintaxis: DesktopSelectedItems( [total], [¿quitar seleccion?] )
;Ejemplo:
	;Loop, Parse, % DesktopSelectedItems(c), `n
	;	MsgBox % A_LoopField
	;MsgBox % "Total: " c
DesktopSelectedItems(ByRef Count := "", Deselect := false) {
	sfv := DesktopGetShellWindows().Document, items := sfv.SelectedItems
    Loop % (Count:=items.Count) {
		List .= (List=""?"":"`n") items.Item(A_Index-1).Name
		if (Deselect)
			sfv.SelectItem(items.Item(A_Index-1), false)
	} return List, ErrorLevel := !IsObject(items)
} ;http://msdn.microsoft.com/en-us/library/dd894076
	
;seleccionar/deseleccionar item
;Sintaxis: DesktopSelectItem( [nombre], [0|1] )
DesktopSelectItem(Name, State := true) {
	sfv := DesktopGetShellWindows().Document, items := sfv.SelectedItems
	return !(ErrorLevel:=!IsObject(items)), sfv.SelectItem(items.Item(Name), !!State)
}























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: NOTIFICACIONES ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;registra los clics o movimientos del mouse en el icono del área de notificacion
;Sintaxis: RegisterTrayIconClickNotification( [funcion a llamar al hacer clic] )
;Mensajes que recibe la funcion:
	;Parametro 1: Normal | RightClick | DoubleClick | MouseOver
	;Parametro 2: Valor original sin modificar
RegisterTrayIconClickNotification(Func, lParam := "*") {
	static Event := {514: "Normal", 517: "RightClick", 515: "DoubleClick", 512: "MouseOver"}
	static Call
	if (lParam!="*") {
		if IsFunc(Call)
			return %Call%(Event[lParam], lParam), NormalClickCount := 0
	} else if !IsFunc(Func)
		return true, OnMessage(0x404, Call:="")
	else
		return OnMessage(0x404, A_ThisFunc), Call := Func
}

;registra el estado de la tapa del portatil
;Sintaxis: RegisterPowerSettingNotification( [funcion a llamar cuando la tapa se abra/cierre] )
;Mensajes que recibe la funcion:
	;Parametro 1: Closed | Opened
	;Parametro 2: Mensaje
;EJEMPLO:
	;RegisterPowerSettingNotification("WM_POWERBROADCAST")
	;WM_POWERBROADCAST(wParam, lParam){
	;	SoundBeep, % wParam="Opened"?750:250
	;}
RegisterPowerSettingNotification(Func, lParam := "*") {
	static Call, hPower
	if (lParam!="*") {
		if IsFunc(Call) {
			if (NumGet(lParam+0, 0, "UInt")=0xBA3E0F4D)
				%Call%(Func=0x8013?(Numget(lParam+0, 20, "UChar")?"Opened":"Closed"):"", lParam)
	}} else if !IsFunc(Func) {
		return DllCall("User32.dll\UnregisterPowerSettingNotification", "Ptr", hPower), OnMessage(0x218, Call:="")
	} else {
		VarSetCapacity(GLSC, 16), DllCall("ole32\CLSIDFromString", "Str", "{BA3E0F4D-B817-4094-A2D1-D56379E6A0F3}", "Ptr", &GLSC)
		return hPower:=DllCall("User32.dll\RegisterPowerSettingNotification", "Ptr", A_ScriptHwnd, "Ptr", &GLSC, "UInt", 0)
			, OnMessage(0x218, A_ThisFunc), Call := Func
}} ;http://ahkscript.org/boards/viewtopic.php?p=51804#p51804

;registra para recibir notificaciones de cambio de sesión
;Sintaxis: RegisterSessionNotification( [estado], [sesion], [funcion que recibe las notificaciones] )
;Estado: 1 = activar | 0 = desactivar || Sesion: 1 = todas las sesiones | 0 = solo la sesion actual
;Notificaciones: http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
;Param1=valor modificado | param2=valor sin modificar
RegisterSessionNotification(Status, Session := 1, Func := "") { ;http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
	if Status&&IsFunc(Func)&&DllCall("wtsapi32.dll\WTSRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd, "UInt", Session)
        return 1, OnMessage(0x02B1, "WM_WTSSESSION_CHANGE"), WM_WTSSESSION_CHANGE(0,0,Func), ErrorLevel := 0
    else if DllCall("wtsapi32.dll\WTSUnRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd)
		return 1, OnMessage(0x02B1, ""), ErrorLevel := 0
    return 0, Func := "", ErrorLevel := 1
} WM_WTSSESSION_CHANGE(wParam, lParam, SetFunc := "*") {
	static Func
	static code := {0x1: "CONSOLE_CONNECT", 0x2: "CONSOLE_DISCONNECT", 0x4: "REMOTE_CONNECT"
		, 0x4: "REMOTE_DISCONNECT", 0x5: "SESSION_LOGON", 0x6: "SESSION_LOGOFF"
		, 0x7: "SESSION_LOCK", 0x8: "SESSION_UNLOCK", 0x9: "SESSION_REMOTE_CONTROL"}
	return true, i:=SetFunc!="*"?(Func:=SetFunc):%Func%(code[wParam], wParam)
} ;https://msdn.microsoft.com/library/aa383828%28vs.85,en-us%29






















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: NOMBRES Y RUTAS DE ARCHIVOS/DIRECTORIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recupera la ruta y el nombre completo del archivo/carpeta especificado.
GetFullPathName(Filename) {
	Size := DllCall("Kernel32.dll\GetFullPathNameW", "Str", Filename, "UInt", 0, "Ptr", 0, "PtrP", 0), VarSetCapacity(OutputVar, Size * 2, 0) 
	, r := DllCall("Kernel32.dll\GetFullPathNameW", "Str", Filename, "UInt", Size, "Str", OutputVar, "PtrP", 0)
	return r?RTrim(OutputVar, "\"):Filename, ErrorLevel := !r
}

;convierte la ruta especificada a su forma larga
GetLongPathName(Filename) {
	Size := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0), VarSetCapacity(OutputVar, Size * 2, 0)
	, r := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" Filename, "Str", OutputVar, "UInt", Size)
	return r?LTrim(OutputVar, "\\?\"):Filename, ErrorLevel := !r
}

;convierte la ruta especificada a su forma corta
GetShortPathName(Filename) {
	Size := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0), VarSetCapacity(OutputVar, Size * 2, 0)
	, r := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" Filename, "Str", OutputVar, "UInt", Size)
	return r?LTrim(OutputVar, "\\?\"):Filename, ErrorLevel := !r
}

;obtiene una ruta valida (solo archivos) removiendo caracteres no permitidos, espacios, parámetros y comillas.
GetValidPathName(Filename) {
	Filename := Trim(RegExReplace(Filename, "[\Q*/?" Chr(34) "<>|`n\E]"))
	if (IsFile(Filename))
		return Filename, ErrorLevel := false
	if IsFile(i:=StrLeft(Filename, InStr(Filename, A_Space)-1))
		return i, ErrorLevel := 0
	Loop, Parse, % Filename, %A_Space%, %A_Tab%
	{ _ .= (A_Index=1?"":" ") A_LoopField 
		if (IsFile(_))
			return _, ErrorLevel := false
	} return Filename, ErrorLevel := true
} 

;recupera la ruta completa de un directorio
;Sintaxis: GetKnownFolderPath( [GUID] )
;GUID:
	;WIN_V+ = https://msdn.microsoft.com/en-us/library/windows/desktop/dd378457%28v=vs.85%29.aspx
	;WIN_XP = https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494(v=vs.85).aspx
		;constantes: https://www.omniref.com/ruby/gems/windows-pr/1.0.0/symbols/Windows::Shell::CSIDL_ADMINTOOLS
;Ejemplo: MsgBox % GetKnownFolderPath(IsWindowsVistaOrGreater()?"{724EF170-A42D-4FEF-9F26-B60E846FBA4F}":0x0030) "`n" ErrorLevel
GetKnownFolderPath(GUID) {
	if (VarSetCapacity(Path, (260 + 1) * 2, 0)) && (IsWindowsVistaOrGreater()) && (VarSetCapacity(CLSID, 16, 0)) {
		DllCall("Ole32.dll\CLSIDFromString", "Str", GUID, "Ptr", &CLSID)
		, r := DllCall("Shell32.dll\SHGetKnownFolderPath", "Ptr", &CLSID, "UInt", 0, "Ptr", 0, "PtrP", Path)
		return StrGet(Path, 260 + 1, "UTF-16"), DllCall("Ole32.dll\CoTaskMemFree", "Ptr", Path), ErrorLevel := r
	} r := DllCall("Shell32.dll\SHGetFolderPathW", "Ptr", 0, "Int", GUID, "Ptr", 0, "UInt", 0, "Str", Path)
	return Path, ErrorLevel := r ;S_OK = 0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762188(v=vs.85).aspx

;convertir una cadena a un puntero a una lista de identificadores de elemento (PIDL).
;Sintaxis: ParseDisplayName( [ruta] )
;Return: PIDL
ParseDisplayName(Path) {
	r := DllCall("Shell32.dll\SHParseDisplayName", "WStr", Path, "Ptr", 0, "PtrP", Path, "UInt", 0, "UIntP", 0)
	return Path, ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762236(v=vs.85).aspx

;hace la operacion inversa de ParseDisplayName()
;Sintaxis: GetPathFromIDList( [PIDL], [¿usar nombres cortos?] )
;Return: Ruta
GetPathFromIDList(pidl, UsesShortFileNames := false) {
	VarSetCapacity(Path, 260 * 2, 0)
	r := DllCall("Shell32.dll\SHGetPathFromIDListEx", "Ptr", pidl, "WStr", Path, "UInt", 260, "UInt", UsesShortFileNames?0x0001:0x0000)
	return RTrim(Path, "\"), ErrorLevel := !r
}

GetValidArrayFiles(Files, Exist := true, Path := "") {
	Items := [], Files := IsObject(Files)?Files:StrSplit(Files, "`n", "`r")
	for k, v in Files
		if (Exist && IsFile(Path v)) || !(Exist)
			Items.Push(v)
	return Items.MaxIndex()?Items:0, ErrorLevel := Items.MaxIndex()?0:1
}











































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: OBJETOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;Devuelve una matriz asociativa de objetos COM activos,donde cada tecla es el apodo, artículo o sufijo del objeto.
;Si se especifica un prefijo, sólo los objetos cuyos apodos del elemento que coincida con el prefijo dado son devueltos, y el prefijo se omite de las teclas devueltas.
GetActiveObjects(Prefix := "", CaseSensitive := false) {
    DllCall("ole32.dll\CoGetMalloc", "UInt", 1, "Ptr*", malloc), objects := {}
    , DllCall("ole32.dll\CreateBindCtx", "UInt", 0, "Ptr*", bindCtx)
    , DllCall(NumGet(NumGet(bindCtx+0)+8*A_PtrSize), "Ptr", bindCtx, "Ptr*", rot)
    , DllCall(NumGet(NumGet(rot+0)+9*A_PtrSize), "Ptr", rot, "Ptr*", enum)
    while DllCall(NumGet(NumGet(enum+0)+3*A_PtrSize), "Ptr", enum, "UInt", 1, "Ptr*", mon, "Ptr", 0) = 0
    {	DllCall(NumGet(NumGet(mon+0)+20*A_PtrSize), "Ptr", mon, "Ptr", bindCtx, "Ptr", 0, "Ptr*", pname) 
        , name := StrGet(pname, "UTF-16"), DllCall(NumGet(NumGet(malloc+0)+5*A_PtrSize), "Ptr", malloc, "Ptr", pname)
        if InStr(name, Prefix, CaseSensitive) = 1 {
            DllCall(NumGet(NumGet(rot+0)+6*A_PtrSize), "Ptr", rot, "Ptr", mon, "Ptr*", punk)
            if (pdsp := ComObjQuery(punk, "{00020400-0000-0000-C000-000000000046}"))
                obj := ComObject(9, pdsp, 1), ObjRelease(punk)
            else obj := ComObject(13, punk, 1)
            objects[SubStr(name, StrLen(Prefix) + 1)] := obj
        } ObjRelease(mon)
    } ObjRelease(enum), ObjRelease(rot), ObjRelease(bindCtx), ObjRelease(malloc)
    return objects
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=6494

;registra un objeto como el objeto activo para su clase (permite manejar un script desde otro proceso)
;Sintaxis: RegisterActiveObject( [obj], [CLSID], [opciones], [nombre] )
;CLISD: CLSID del objeto activo o dejar vacio para poner fin a un objeto activo
;Nombre: espesificar un nombre para agregar el CLSID al registro
;Ejemplo:
	;obj := new MyClass("{436cf066-cf70-4ca9-990f-c7083fea8367}", "AHK") ;crear objeto [CLSID, Nombre]
	;x := ComObjActive("{436cf066-cf70-4ca9-990f-c7083fea8367}") ;obtener objeto (usado desde otro proceso/script) -->
	;x.MyFunc("Test!") ;llama a la funcion MyFunc() dentro de la clase MyClass, igual que obj.MyFunc("Test!") <--
	;ExitApp
	;class MyClass {
	;	__New(CLSID, Name) {
	;		RegisterActiveObject(this, CLSID,, Name) ;«this» es el objeto (MyClass)
	;	} MyFunc(String) {
	;		MsgBox %String%
	;	}
	;}
RegisterActiveObject(Object, CLSID := "", Flags := 0, AppId := "") {
	static l := {}
	if !(CLSID) && !((r:=l.Remove(Object))="") ;eliminar objeto activo
		return !(r:=DllCall("OleAut32.dll\RevokeActiveObject", "UInt", r, "Ptr", 0)), ErrorLevel := r
	if !(CLSID) || (I[Object]) || !(VarSetCapacity(c, 16, 0)) 
		return false, ErrorLevel := I[Object]?2:true ;ErrorLevel 2 = el objeto ya se encuentra registrado
	if ((h:=DllCall("Ole32.dll\CLSIDFromString", "WStr", CLSID, "Ptr", &c))<0)
		return false, ErrorLevel := 3 ;ErrorLevel 3 = CLSID inválido
	if ((h:=DllCall("OleAut32.dll\RegisterActiveObject", "Ptr", &Object, "Ptr", &c, "UInt", Flags, "UInt*", r, "UInt"))<0)
		return false, ErrorLevel := Format("0x{:x}", h) ;ErrorLevel X = RegisterActiveObject ERROR
	if !(AppId="") ;agregar al registro con el nombre espesificado (usuario actual)
		RegWrite(, "HKCU\Software\Classes\" AppId,, AppId)
		, RegWrite(, "HKCU\Software\Classes\" AppId "\CLSID",, CLSID)
		, RegWrite(, "HKCU\Software\Classes\CLSID\" CLSID,, AppId)
	return r, ErrorLevel := !r, l[Object] := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221551(v=vs.85).aspx



































































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: OTROS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;ejecuta el script como administrador
RunAsAdmin() {
	if !(A_IsAdmin) && (%true%!=A_ScriptFullPath) && (IsWindowsVistaOrGreater()) {
		_ := A_IsCompiled?A_ScriptFullPath:A_AhkPath
		Run, *RunAs "%_%" "%A_ScriptFullPath%" "%A_ScriptFullPath%",, UseErrorLevel
		if !(ErrorLevel)
			ExitApp
		return false
	} return true
} RunAsAdminInit() { ;} ;<-- //RunAsAdmin
	static RunAsAdminInit := RunAsAdminInit()
	ProcessSetPrivilege := ProcessAdjustPrivileges(ProcessExist(), "SeDebugPrivilege,SeShutdownPrivilege,SeTakeOwnershipPrivilege")
	ComObjError(false) ;desactivar las notificaciones de errores COM (Component Object Model).
	SetWorkingDir, %A_ScriptDir% ;establece el directorio de trabajo.
	SetBatchLines, -1 ;hace que el script trabaje a la máxima velocidad posible (afecta y es afectada por al uso de CPU).
	SetTitleMatchMode, 2 ;el título de una ventana puede contener «WinTitle» en cualquier lugar dentro para ser valido.
	SendMode, Input ;SendInput es generalmente mas rápido y mas fiable.
	CoordMode, Mouse, Screen
	SetControlDelay, 10 ;establece algunos retrasos para mejorar la fiabilidad y/o velocidad de respuesta entre cada comando. -->
	SetKeyDelay, 10, 10, 10
	SetMouseDelay, 0
	SetWinDelay, 50 ;<--
}

;determina si el script ya se está ejecutando en el mismo directorio y con igual nombre.
;Ejemplo de uso:
	;#SingleInstance Off
	;#Persistent
	;MsgBox % Instance()
Instance(Close := false) {
	static hMutex ;ERROR_ALREADY_EXISTS = 183 | ERROR_ACCESS_DENIED = 0x00000005
	if (Close)
		return DllCall("Kernel32.dll\ReleaseMutex", "Ptr", hMutex)+DllCall("Kernel32.dll\CloseHandle", "Ptr", hMutex)
	Name := "_" StrLeft(StrReplace(StrReplace(A_ScriptFullPath, "\"), ":"), 259)
	, hMutex := DllCall("Kernel32.dll\CreateMutexW", "Ptr", 0, "Int", false, "Str", "Local\" Name)
	return A_LastError=183?(hMutex?hMutex:false):false
		, ErrorLevel := hMutex=""?true:(A_LastError=0x00000005?true+1:false)
}

;bloquear mouse y teclado
;Sintaxis: BlockInput( [Enable|Disable] )
BlockInput(OnOff, Delay := 500, DisableTaskManager := true, Suspend := true) {
	static TaskManager
	static BlockInput := Func("BlockInput").Bind("Enable")
	if (OnOff="Enable"||OnOff="Disable") { ;Enable | Disable = bloquear/desbloquear normal
		return DllCall("User32.dll\BlockInput", "Int", OnOff="Enable"?true:false)
	} else if (OnOff=0||OnOff="Off") { ;Off = desbloquear
		SetTimer(BlockInput,  "Off")
		if (DisableTaskManager) {
			if !(TaskManager)
				RegDelete( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger" )
			else RegWrite(, "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger", TaskManager)
		} if (Suspend)
			Suspend, Off
		return DllCall("User32.dll\BlockInput", "Int", false)
	} else if (OnOff=1||OnOff="On") { ;On = bloquear
		if (Suspend)
			Suspend, On
		if (Delay>0)
			SetTimer(BlockInput, Delay)
		if (DisableTaskManager)
			TaskManager := RegRead("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger")
			, RegWrite(, "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe", "Debugger", "Disable")
		return DllCall("User32.dll\BlockInput", "Int", true)
}}

;Define el contenido de la variable de entorno especificada para el proceso actual.
;Sintaxis: EnvAdd( [nombre], [valor], [user|system] )
EnvAdd(lpName, lpValue, Type := "") {
	return Type="User"?RegWrite(, "HKCU\Environment", lpName, lpValue)
		: Type="System"?RegWrite(, "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", lpName, lpValue)
		: DllCall("Kernel32.dll\SetEnvironmentVariableW", "Str", lpName, "Str", lpValue)
}	

;Recupera el contenido de la variable especificada desde el bloque de entorno del proceso invocador
EnvGet(EnvVarName, ByRef UserEnv := "", ByRef SystemEnv := "") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683188%28v=vs.85%29.aspx
	UserEnv := IsByRef(UserEnv)?RegRead("HKCU\Environment", EnvVarName):""
	, SystemEnv := IsByRef(SystemEnv)?RegRead("HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment", EnvVarName):""
	, nSize := DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Ptr", 0, "UInt", 0)
	, VarSetCapacity(lpBuffer, nSize * 2, 0) ;max 32767
	, DllCall("Kernel32.dll\GetEnvironmentVariableW", "Str", EnvVarName, "Str", lpBuffer, "UInt", nSize)
	return lpBuffer, ErrorLevel := !nSize
}

;Notifica el sistema operativo y todas las aplicaciones que se ejecutan que las variable(s) del sistema han cambiado .
EnvUpdate() {
	return SendMessage(0xFFFF, 0x001A,,, "Str", "Environment")
}

;cambiar imagen de fondo del escritorio
;Sintaxis: SetDesktopWallpaper( [imagen], [ancho], [alto] )
SetDesktopWallpaper(Image, Width := "", Height := "") {
	Path := A_AppData "\Microsoft\Windows\Themes\TranscodedWallpaper.bmp", DirCreate(A_AppData "\Microsoft\Windows\Themes")
    if !IsFile(Image)
        return false, ErrorLevel := 2
	SplitPath, Image,,, Ext
	if !(Ext="bmp") {
		if !(GetModuleHandle("Gdiplus"))
			pToken := Gdip_Startup()
		ImageConvert(Image, Path, Width, Height)
		if (pToken)
			Gdip_Shutdown(pToken)
	} else FileCopy(Image, Path, true)
	return r:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0014, "UInt", 0, "Str", Path, "UInt", 0x0001|0x0002), ErrorLevel := !r
}

;obtener ruta de la imagen de fondo del escritorio
;Sintaxis: GetDesktopWallpaper()
GetDesktopWallpaper() {
	VarSetCapacity(OutputVar, 260 * 2, 0)
	, r := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0073, "UInt", 260, "Str", OutputVar, "UInt", 0)
	return OutputVar, ErrorLevel := !r
}

;crea un objeto que se puede utilizar para pasar un valor ByRef
	;ComVar[] --> recupera el valor
	;ComVar[] := Val --> establece el valor.
	;ComVar.ref --> recupera un objeto ByRef para pasar a una función COM
ComVar() {
	static base := {__Get: "ComVarGet", __Set: "ComVarSet", __Delete: "ComVarDel"}
	static ComObjParam := A_AhkVersion<2?"ComObjParameter":"ComObject"
	r := DllCall("OleAut32.dll\SafeArrayAccessData", "Ptr", ComObjValue(arr:=ComObjArray(0xC, 1)), "PtrP", data)
	return {ref: %ComObjParam%(0x400C, data), _: arr, base: base}, ErrorLevel := r
} ComVarGet(cv, p*) {
	if !(p.MaxIndex())
		return cv._[0]
} ComVarSet(cv, v, p*) {
	if !(p.MaxIndex())
		return cv._[0] := v
} ComVarDel(cv) {
	DllCall("OleAut32.dll\SafeArrayUnaccessData", "Ptr", ComObjValue(cv._))
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3964

;obtener sugerencias de una palabra vía google
GoogleSuggest(query) { ;http://ahkscript.org/boards/viewtopic.php?f=6&t=7182
	if !query
		return
    i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, i.Open("GET", "http://suggestqueries.google.com/complete/search?output=firefox&q=" query, 1)
		, i.Send(), i.WaitForResponse()
    s := StrReplace(i.ResponseText, Chr(34) ",[" Chr(34), "`r`n")
		, s := StrReplace(s, Chr(34) "," Chr(34), "`r`n"), s := StrReplace(s, Chr(34))
		, s := StrReplace(s, "["), s := StrReplace(s, "]"), s := StrReplace(s, query,,, 1)
	return StrReplace(s, "`r`n",,, 1)
}

;SendMessage / SendMessageTimeOut / SendMessageCallback
;envía el mensaje especificado a una ventana
;Sintaixs: SendMessage( [ID], [mensaje], [wtipo], [wParam], [Itipo], [IParam], [CallBackFunc/tiempo fuera (ms 1~15000)], [CallBackData] )
SendMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0, TimeOut := 5000, CallBackData := "") {
	if (CallBackData!="")
		r1 := DllCall("User32.dll\SendMessageCallbackW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam, "Ptr", TimeOut, "UPtr", CallBackData)
	else if (TimeOut>0)
		r1 := DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam, "UInt", 0x0002, "UInt", TimeOut, "UPtrP", r2)
	else r1 := DllCall("User32.dll\SendMessageW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam)
	return TimeOut>0&&CallBackData=""?r2:r1, ErrorLevel := !r1
}

;PostMessage
;Sintaixs: PostMessage( [ID], [mensaje], [tipo], [wParam], [tipo], [IParam] )
PostMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0) {
	r1 := DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam)
	return r1, ErrorLevel := !r1
}

;hModule := GetModuleHandle("User32.dll"), hModule := hModule?hModule:LoadLibrary("User32.dll")
;Address := GetProcAddress(hModule, "GetSysColor") ;DllCall("User32.dll\GetSysColor", "Int", 16, "UInt")
;MsgBox % DllCall(Address, "Int", 16, "UInt") ". ErrorLevel: " ErrorLevel "`n`nFreeLibrary: " FreeLibrary(hModule)
GetModuleHandle(DllFile, Flags := 0x00000002) { ;GetModuleHandle( [dll] )
	r := DllCall("Kernel32.dll\GetModuleHandleExW", "UInt", Flags, "Str", DllFile, "Ptr*", hModule)
	return hModule, ErrorLevel := !(r)
} GetProcAddress(hModule, Function) { ;GetProcAddress( [hModule --> GetModuleHandle()/LoadLibrary()], [func] )
	return r:=DllCall("Kernel32.dll\GetProcAddress", "Ptr", hModule, "AStr", Function), ErrorLevel := !(r)
} LoadLibrary(DllFile, Flags := 0x00000000) { ;LoadLibrary( [dll] )
	return r:=DllCall("Kernel32.dll\LoadLibraryExW", "Str", DllFile, "UInt", 0, "UInt", Flags), ErrorLevel := !(r)
} FreeLibrary(hModule) {
	r := ErrorLevel
	return DllCall("Kernel32.dll\FreeLibrary", "Ptr", hModule), ErrorLevel := r
}

;Sintaxis: SetTimer( [Etiqueta], [Período], [Prioridad -2147483648~2147483647] )
SetTimer(Label := "", PeriodOnOffDelete := "On", ThreadPriority := 0, Wait := true) {
	if !(Wait)
		SetTimer, %Label%, -1, %ThreadPriority%
	SetTimer, %Label%, %PeriodOnOffDelete%, %ThreadPriority%
}

;saltar a la etiqueta, hotkey o hotstring espesificada.
;Sintaxis: gosub( [etiqueta], [0|1] )
gosub(Label, Check := true) {
	if (Check&&IsLabel(Label))
		gosub, %Label%
}

;esperar (ms)
;Sintaxis: Sleep( [milisegundos], [¿usar mayor precisión?] )
;Nota: para usar mayor precisión por defecto, usar Sleep( [-2 | -3] )
Sleep(Delay := 0, pc := false) {
	static Frequency, DefaultMode
	if (Delay>=-1) {
		if !(pc) && !(DefaultMode) {
			Sleep, %Delay%
		} else {
			if !Frequency
				DllCall("Kernel32.dll\QueryPerformanceFrequency", "Int64*", Frequency)
			DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Start)
			, Finish := Start+(Frequency*(Delay/1000))
			Loop
				DllCall("Kernel32.dll\QueryPerformanceCounter", "Int64*", Current)
			until (Current >= Finish)
	}} else if (Delay=-2||Delay=-3) ;-2 = QueryPerformanceCounter. -3 = Normal
		DefaultMode := Delay=-2?true:false
}

;reiniciar script
Reload(Force := false, ExitCode := 0) {
	Instance(true)
	if (Force) {
		if A_IsCompiled
			Run, "%A_ScriptFullPath%"
		else Run, "%A_AhkPath%" "%A_ScriptFullPath%"
		ExitApp( Force, ExitCode )
	} Reload
}

;termina el script
;Sintaxis: ExitApp( [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
ExitApp(Force := false, ExitCode := 0) {
	if (Force)
		ProcessClose(ProcessExist(),,, ExitCode)
	ExitApp, %ExitCode% ;DllCall("User32.dll\PostQuitMessage", "Int", 0)
}

;tiempo fuera en el que el script finaliza
;Sintaxis: ExitAppTimer( [segundos], [¿forzar?], [codigo de salida (-2147483648~2147483647)] )
;EJEMPLO:
	;ExitAppTimer(5)
	;Loop {
		;ToolTip % ExitAppTimer()
		;Sleep 100
	;}
ExitAppTimer(Seconds := "", Force := 0, ExitCode := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=46906#p46906
    static ending
	static ExitAppTimer := Func("ExitAppTimer")
    if (Seconds="ExitApp")
        ExitApp(Force, ExitCode)
    if !(Seconds)
        return (ending - A_TickCount) / 1000.0
    SetTimer(ExitAppTimer.Bind("ExitApp", Force, ExitCode), -(Seconds*1000))
    ending := A_TickCount+(Seconds*1000)
}

;potapapeles
;Sintaxis: Clipboard( [texto], [¿copiar seleccionado al portapapeles? (segundos a esperar)] )
Clipboard(String := "", Selected := 0) {
	if Selected {
		try {
			Temp := ClipboardAll, Clipboard()
			, Send("{LCtrl Down}c{LCtrl Up}")
			, ClipWait(Selected>0?Selected:1)
			return Clipboard, Clipboard := Temp
		} catch {
			return ""
	}} else if (String="") {
		if !DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd) {
			ElapsedTime := A_TickCount+3000
			Loop {
				if DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd)
					break
				if (A_TickCount>=ElapsedTime)
					return 0
				Sleep, 100
		}} return DllCall("User32.dll\EmptyClipboard"), DllCall("User32.dll\CloseClipboard")
	} try return Clipboard := String
}

;recupera el tiempo que ha pasado (ms) desde que el script se inició
GetTickCount(ByRef TickCount := "") {
	return TickCount := DllCall("Kernel32.dll\GetTickCount")
}

;espera a que el portapapeles contenga datos
;Sintaxis: ClipWait( [segundos], [¿cualquier tipo de datos?] )
ClipWait(Seconds := -1, AnyFormats := true) {
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (AnyFormats&&DllCall("User32.dll\CountClipboardFormats"))
		||(!AnyFormats&&(DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 1)
		||DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 15)))
			return true, ErrorLevel := false
		if (Seconds>=0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 50
}}

;establece el directorio de trabajo.
SetWorkingDir(DirName) {
	return DllCall("kernel32.dll\SetCurrentDirectoryW", "Str", DirName)
}

;obtiene el directorio de trabajo
GetWorkingDir() {
	uSize := VarSetCapacity(lpBuffer, (260 + 1) * 2) / 2
	, DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt*", uSize, "Str", lpBuffer)
	return lpBuffer
}

GetLastError(ByRef FormatMessage := "", dwFlags := 0x1000) {
	return LastError := DllCall("Kernel32.dll\GetLastError")
		, FormatMessage := IsByRef(FormatMessage)?FormatMessage(LastError, dwFlags):""
} SetLastError(num) {
	return DllCall("User32.dll\SetLastErrorEx", "UInt", num, "UInt", 0)
} FormatMessage(dwMessageId := "", dwFlags := 0x1000) {
	dwMessageId := dwMessageId!=""?dwMessageId:GetLastError()
	, nSize := VarSetCapacity(lpBuffer, 2024) - 1524
	, DllCall("Kernel32.dll\FormatMessageW", "UInt", dwFlags, "Ptr", 0, "UInt", dwMessageId, "UInt", 0x800, "Str", lpBuffer, "UInt", nSize, "UInt", 0)
	return lpBuffer
}

FormatTime(Time, Format := "yyyyMMddHmmss") {
	FormatTime, hTime, %Time%, % Format=""?"dd/MM/yyyy (HH:mm:ss tt)":Format
	return hTime
}

;ejecutar script
;Sintaxis: ExecScript( [script], [parámetros], [ejecutableAHK], [nombre] )
ExecScript(Script, Params := "", AhkPath := "", Name := "") {
	Name := Name=""?"AutoHotKey" A_AhkVersion:Name, AhkPath := FileExist(AhkPath)?AhkPath:A_AhkPath
	, Call := Chr(34) AhkPath Chr(34) A_Space "/CP65001" A_Space Chr(34) "\\.\pipe\" Name Chr(34), Pipe := []
	, Pipe[1] := DllCall("Kernel32.dll\CreateNamedPipeW", "Str", "\\.\pipe\" Name, "UInt", 2, "UInt", 0, "UInt", 255, "UInt", 0, "UInt", 0, "UPtr", 0, "UPtr", 0, "UPtr")
	, Pipe[2] := DllCall("Kernel32.dll\CreateNamedPipeW", "Str", "\\.\pipe\" Name, "UInt", 2, "UInt", 0, "UInt", 255, "UInt", 0, "UInt", 0, "UPtr", 0, "UPtr", 0, "UPtr")
	, Shell := ComObjCreate("WScript.Shell"), Exec := Shell.Exec(Call A_Space Params)
	, DllCall("Kernel32.dll\ConnectNamedPipe", "UPtr", Pipe[1], "UPtr", 0), DllCall("Kernel32.dll\CloseHandle", "UPtr", Pipe[1])
	, r := DllCall("Kernel32.dll\ConnectNamedPipe", "UPtr", Pipe[2], "UPtr", 0), FileOpen(Pipe[2], "h", "UTF-8").Write(Script)
	return r, DllCall("Kernel32.dll\CloseHandle", "UPtr", Pipe[2]), ErrorLevel := !r
}

;traducir texto vía google translate
;Sintaxis: Translate( [texto], [entrada], [salida] )
;EJEMPLO: MsgBox % Translate("Hello, this is a test", "en", "es")
Translate(String, From := "", To := "") {
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	, url := "https://translate.google.com/translate_a/single?client=t&sl=" From "&tl=" To
	     . "&dt=bd&dt=ex&dt=ld&dt=md&dt=qca&dt=rw&dt=rm&dt=ss&dt=t&dt=at&ie=UTF-8&oe=UTF-8&otf=2&srcrom=0&ssel=0&tsel=3&q=" string
	, i.Open("GET", url, true)
	, i.SetRequestHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko)")
	, i.Send(), i.WaitForResponse()
	return RegExReplace(i.ResponseText, "^.*?" Chr(34) "(.*?)" Chr(34) ".*$")
}

ImageWaterCtrl(hWnd := "", Mode := "Enable", Option*) {
	static LoadLibrary, LibraryPath
	if (Mode="SETPATH")
		return (i:=FileExist(hWnd))?(LibraryPath:=hWnd):0, ErrorLevel := !i
	if !LibraryPath&&!FileExist(A_ScriptDir "\waterctrl.dll")
		return 0, ErrorLevel := 2 ;ErrorLevel 2 = waterctrl.dll no se encuentra
	if LoadLibrary&&(Mode="EXIT"||Mode="FREE") {
		ImageWaterCtrl(, "DETACH")
		return i:=FreeLibrary(LoadLibrary), ErrorLevel := !i, LoadLibrary := ""
	}
	if !LoadLibrary&&!(LoadLibrary:=LoadLibrary(LibraryPath?LibraryPath:A_ScriptDir "\waterctrl.dll"))
		return 0, ErrorLevel := 3 ;ErrorLevel 3 = error al cargar waterctrl.dll
	if (Mode="ATTACH"||Mode="ENABLE") {
		if FileExist(Option[1])
			SplitPath(Option[1],,, Ext)
			, Img := DllCall("User32.dll\LoadImageW", "Int", 0, "Str", Option[1], "UInt", Ext="Ico"?1:0, "Int", 0, "Int", 0, "UInt", 0x2010)
		return i:=DllCall("waterctrl\enablewater", "Ptr", hWnd, "Int", Option[2]=""?0:Option[2]
			, "Int", Option[3]=""?0:Option[3], "Ptr", Img?Img:Option[1], "Int", Option[3]=""?3:Option[3]
			, "Int", Option[4]=""?20:Option[4]), ErrorLevel := !i
	} else if (Mode="DETACH"||Mode="DISABLE") {
		return i:=DllCall("waterctrl\disablewater"), ErrorLevel := !i
	} else if (Mode="BLOB") {
		return i:=DllCall("waterctrl\waterblob", "Int", Option[1]=""?0:Option[1], "Int", Option[2]=""?0:Option[2]
		, "Int", Option[3]=""?30:Option[3], "Int", Option[4]=""?30:Option[4]), ErrorLevel := !i
	} else if (Mode="SETPARENT") {
		return i:=DllCall("waterctrl\setwaterparent", "Ptr", hWnd), ErrorLevel := !i
	} else if (Mode="FLATTEN")
		return i:=DllCall("waterctrl\flattenwater"), ErrorLevel := !i
	return 0, ErrorLevel := 1 ;ErrorLevel 1 = el modo espesificado es inválido
} ;http://ahkscript.org/boards/viewtopic.php?f=22&t=3302&p=16261&hilit=waterctrl#p16261

;separar tiempo
;Sintaxis: SplitTime( [YYYYMMDDHH24MISS], [año], [mes], [dia], [hora], [min], [seg], [AM/PM] )
;Nota: devuelve un Array con el tiempo en el siguiente orden: año, mes, día, hora, min, seg, am/pm.
;Ejemplo: MsgBox % (i:=SplitTime()) i[3] "/" i[2] "/" i[1] " (" i[4] ":" i[5] ":" i[6] ")"
SplitTime(Time := "", ByRef Year := "", ByRef Mon := "", ByRef Day := "", ByRef Hour := "", ByRef Min := "", ByRef Sec := "", ByRef Mark := "") {
	FormatTime, Time, %Time%, yyyy,MM,dd,HH,mm,ss,tt
	Time := StrSplit(Time, ",")
	Loop, Parse, % "Year,Mon,Day,Hour,Min,Sec,Mark", `,
		%A_LoopField% := Time[A_Index]
	return Time
}

;obtener color de fondo por defecto de cada Gui
GetGuiDefaultColor() {
	return RGB((((l:=DllCall("User32.dll\GetSysColor","Int",15,"UInt"))>>16)&0xFF)|(l&0x00FF00)|((l&0xFF)<<16))
}

;crear ventana
;Sinstaxis: CreateWindow( [x], [y], [ancho], [alto], [titulo], [estilo], [estilo extendido], [parent], [menu], [clase] )
;Return: devuelve el hWnd
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx
;Estilos exentido: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543(v=vs.85).aspx
CreateWindow(x, y, Width, Height, Caption := "", Style := 0x10cb0000, ExStyle := 0x0, Parent := 0x0, Menu := 0x0, Class := "MDIClient") {
	hWnd := DllCall("User32.dll\CreateWindowExW", "UInt", ExStyle, "Ptr", &Class, "Ptr", &Caption, "UInt", Style
		, "Int", x, "Int", y, "Int", Width, "Int", Height, "Ptr", Parent, "Ptr", Menu, "Ptr", A_ScriptHwnd, "PtrP", 0)
	return hWnd, ErrorLevel := !hWnd
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx

;crear control
;Sintaxis: CreateControl( [hWnd ventana], [clase], [x], [y], [ancho], [alto], [texto], [estilo], [estilo extendido] )
;Return: devuelve el hWnd
;Clases: Button, ComboBox, Edit, ListBox, RichEdit, RICHEDIT_CLASS, SCROLLBAR, STATIC
CreateControl(hWnd, Class, x, y, Width, Height, Caption := "", Style := 0x56000000, ExStyle := 0x0) {
	return CreateWindow(x, y, Width, Height, Caption, Style, ExStyle, hWnd,, Class)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632679(v=vs.85).aspx































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: REGISTRO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
SetRegView(RegView := "Default") {
	SetRegView, %RegView%
}

;leer en el registro
;Sintáxis: RegRead( [Clave\SubClave], [Valor] )
;Nota: para leer el valor por defecto, no espesificar el 2do parámetro.
RegRead(Key, ValueName*) {
	if (ValueName.MaxIndex())
		RegRead, Value, %Key%, % ValueName[1]
	else RegRead, Value, %Key%
	return Value
}

;elimina en el registro
;Sintáxis: RegDelete( [Clave\SubClave], [Valores*] )
;NOTAS: para eliminar el valor por defecto, espesificar un valor vacio
	;para eliminar la clave entera, no espesificar el 2do parámetro.
RegDelete(Key, ValueName*) {
	if !(Key)
		return false, ErrorLevel := true
	if (ValueName.MaxIndex()) {
		hRegKey := RegOpenKey(Key, 0x0002)
		for k, v in ValueName
			Result := DllCall("Advapi32.dll\RegDeleteValueW", "Ptr", hRegKey, "Str", v)
		DllCall("Advapi32.dll\RegCloseKey", "Ptr", hRegKey), ErrorLevel := Result?true:false
	} else RegDelete, %Key%
	return ErrorLevel?false:Key
}

;escribe en el registro
;Sintáxis 1: RegWrite( [Tipo], [Clave\SubClave], [Valor], [Datos] )
;Sintáxis 2: RegWrite( [Clave\SubClave] )
;Tipos: BINARY|DWORD|EXPAND|MULTI|SZ
RegWrite(ValueType := 0, Key := "", ValueName := "", Value*) {
	static ValueTypes := {"REG_BINARY": "REG_BINARY", "BINARY": "REG_BINARY"
		, "REG_DWORD": "REG_DWORD", "DWORD": "REG_DWORD"
		, "REG_EXPAND_SZ": "REG_EXPAND_SZ", "EXPAND": "REG_EXPAND_SZ"
		, "REG_MULTI_SZ": "REG_MULTI_SZ", "MULTI": "REG_MULTI_SZ"
		, "REG_SZ": "REG_SZ", "SZ": "REG_SZ"}
	if !(Type:=ValueTypes[ValueType])
		Key := Key?Key:ValueType, Type := "REG_SZ"
	if !(Key)
		return false
	if (ValueName="") && !(Value.MaxIndex()) 
		RegWrite, %Type%, %Key%
	else if (ValueName="")
		RegWrite, %Type%, %Key%,, % Value[1]
	else if (Value.MaxIndex())
		RegWrite, %Type%, %Key%, %ValueName%, % Value[1]
	else RegWrite, %Type%, %Key%, %ValueName%
	return ErrorLevel?false:Key
}

;importar clave
;sintaxis: RegImport( [Archivo], [¿Esperar?] )
RegImport(FileName, Wait := false) {
	if !IsFile(FileName)
		return false, ErrorLevel := true
	if Wait
		RunWait, %A_WinDir%\regedit.exe -v -s "%FileName%",, UseErrorLevel
	else Run, %A_WinDir%\regedit.exe -v -s "%FileName%",, UseErrorLevel
	return !ErrorLevel
}

;exportar clave
;sintaxis: RegExport( [Clave], [Archivo], [¿Esperar?], [¿reescribir si ya existe el archivo?] )
RegExport(Key, FileName, Wait := false, OverWrite := true) {
	if !(OverWrite) && (FileExist(FileName))
		return false, ErrorLevel := true
	Key := RegFormatKey(Key, true)
	if (Wait)
		RunWait, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%",, UseErrorLevel
	else Run, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%",, UseErrorLevel
	return !ErrorLevel
}

;renombrar una clave
;Sintaxis: RegRenameKey( [clave\subclave], [nuevo nombre], [¿sobreescribir si ya existe una clave con el mismo nombre?] )
;ErrorLevel: 2 = ya existe una clave con el mismo nombre | 3 = el nuevo nombre espesificao no es válido | 4 = la clave a renombrar no es válida
;Ejemplo: RegRenameKey("HKLM\Software\AutoHotKey", "AutoHotKey_Rename")
RegRenameKey(Key, NewName, OverWrite := false) {
	NewName := StrReplace(NewName, "\")
	if (NewName="") || !(InStr(Key, "\"))
		return false, ErrorLevel := NewName=""?3:4
	SplitPath, Key,, BKey
	return RegMoveKey(Key, BKey "\" NewName, OverWrite)
}

;mover clave junto con todos los valores y subclaves
;Sintaxis: RegMoveKey( [clave\subclave], [clave\subclave destino], [¿sobreescribir?] )
;ErrorLevel: 2 = ya existe la clave destino
;Ejemplo: 
	;MsgBox % RegMoveKey("HKLM\Software\AutoHotKey", "HKCU\AutoHotKey") "," ErrorLevel
	;MsgBox % RegMoveKey("HKCU\AutoHotKey", "HKLM\Software\AutoHotKey") "," ErrorLevel
RegMoveKey(Key, KeyDest := "", OverWrite := false) {
	if (RegExistKey(KeyDest)) {
		if !(OverWrite)
			return false, ErrorLevel := 2
		RegDelete(KeyDest)
	} Result := RegCopyKey(Key, KeyDest)
	if (Result)
		return Result, RegDelete(Key), ErrorLevel := !Result
	return false
}

;copiar clave junto con todos los valores, opcional incluir subclaves
;Sintaxis: RegCopyKey( [clave\subclave], [clave\subclave destino], [¿copiar subclaves?=true] )
;Nota: si la clave destino no existe, la crea.
;Ejemplo: RegCopyKey("HKLM\Software\AutoHotKey", "HKCU\AutoHotKey")
RegCopyKey(Key, KeyDest, Recurse := true) { ;KEY_READ = 0x20019 | KEY_ALL_ACCESS = 0xF003F
	hRegKey := RegOpenKey(Key, 0x20019, Result:=false), hRegKeyDest := RegOpenKey(KeyDest,, true)
	if (Recurse) {
		if (IsWindowsVistaOrGreater()) ;if OS Version >= Win V | ERROR_SUCCESS = 0
			Result := DllCall("Advapi32.dll\RegCopyTreeW", "Ptr", hRegKey, "Ptr", 0, "Ptr", hRegKeyDest) ;WIN_V+
		Result := DllCall("Shlwapi.dll\SHCopyKeyW", "Ptr", hRegKey, "Ptr", 0, "Ptr", hRegKeyDest, "UInt", 0) ;WIN_2000+
	} else {
		Loop, Reg, %Key%, V
			RegWrite(A_LoopRegType, KeyDest, A_LoopRegName, RegRead(Key, A_LoopRegName))
		if (Value:=RegRead(Key))
			RegWrite(, KeyDest,, Value)
	} return !Result, RegCloseKey(hRegKeyDest, hRegKey), ErrorLevel := Result
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379768(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/bb773482(v=vs.85).aspx

;comprueba si existe una clave 
;Sintaxis: RegExistKey( [clave], [¿buscar en subclaves?] )
RegExistKey(Key, Recurse := false) {
	SplitPath, Key, KeyName, BKey
	Loop, Reg, %BKey%, % Recurse?"KR":"K"
		if (A_LoopRegName=KeyName)
			return true, ErrorLevel := false
	return false, ErrorLevel := true
}

;transforma una clave en su forma larga/corta
;Sintaxis: RegFormatKey( [clave], [modo] )
;Modos: 0 = forma corta | 1 = forma larga
RegFormatKey(Key, Mode := 0) {
	static _0 := {"HKEY_CLASSES_ROOT": "HKCR", "HKEY_CURRENT_CONFIG": "HKCC", "HKEY_CURRENT_USER": "HKCU", "HKEY_LOCAL_MACHINE": "HKLM", "HKEY_USERS": "HKU"}
	static _1 := {"HKCR": "HKEY_CLASSES_ROOT", "HKCC": "HKEY_CURRENT_CONFIG", "HKCU": "HKEY_CURRENT_USER", "HKLM": "HKEY_LOCAL_MACHINE", "HKU": "HKEY_USERS"}
	if (p:=InStr(Key:=Trim(Key, "`r`n" A_Space "\" A_Tab), "\"))
		s := StrTrimLeft(Key, p-1), Key := StrLeft(Key, p-1)
	return (Mode?(_1[Key]?_1[Key]:Key):(_0[Key]?_0[Key]:Key)) s
}

;separa una clave en clave, subclave
;Sintaxis: SplitKey( [clave], [clave (salida)], [subclave (salida)] )
SplitKey(_Key, ByRef Key := "", ByRef SubKey := "") {
	_Key := Trim(_Key)
	return (Key:=(KeyPos:=InStr(_Key, "\"))?SubStr(_Key, 1, KeyPos-1):_Key)
		. (SubKey:=Trim(KeyPos?"\" SubStr(_Key, (KeyPos+1)):"", "\"))
}

;devuelve una clave o valor que no exista
;Sintaxis: RegFNKey( [clave], [valor], [inicio], [fin] )
;Ejemplo:
	;RegDelete("HKCU\Lol"),RegDelete("HKCU\Lol(1)"),MsgBox(RegFNKey("HKCU\Lol")),RegWrite("HKCU\Lol"),MsgBox(RegFNKey("HKCU\Lol"))
	;,RegWrite("HKCU\Lol(1)"),MsgBox(RegFNKey("HKCU\Lol")),RegDelete("HKCU\Lol"),RegDelete("HKCU\Lol(1)"),ExitApp()
RegFNKey(Key, Value := "", Start := "(", End := ")") {
	if (Value="") {
		Loop {
			if RegExistKey(tmpkey?tmpkey:Key)
				tmpkey := tmpkey?StrReplace(tmpkey, Start (A_Index-1) End, Start A_Index End):Key Start 1 End
			else return tmpkey?tmpkey:Key
	}} else {
		Loop {
			if RegExistKey(Key, tmpkey?tmpkey:Value)
				tmpkey := tmpkey?StrReplace(tmpkey, Start (A_Index-1) End, Start A_Index End):Value Start 1 End
			else return tmpkey?tmpkey:Value
}}}

;abrir clave en regedit
;Sintaxis: RegOpen( [clave\subclave] )
;Ejemplo: MsgBox % RegOpen("HKLM\SOFTWARE\Classes\*") "," ErrorLevel
RegOpen(Key) {
	if !(RegExistKey(Key:=Trim(Key)))
		return false, ErrorLevel := true
	Key := RegFormatKey(Key, true), ProcessClose("regedit.exe*")
	, RegWrite(, "HKCU\Software\Microsoft\Windows\CurrentVersion\Applets\Regedit", "LastKey", Key)
	Run, %A_WinDir%\regedit.exe
	return !ErrorLevel
	;if !(PID:=ProcessWait("regedit.exe", 5)) ;seleccionar valores --->
	;	return false, ErrorLevel := true
	;Loop, 30 ;3s
	;	Sleep, 100
	;until (ID:=WinExist("ahk_pid " PID))
	;if !(IsWindow(hWnd:=ControlExist(ID, "SysListView321")))
	;	return false, ErrorLevel := true
	;Loop, 50 ;5s
	;	Sleep, 100
	;until ((Count:=LV_GetItemCount(hWnd))>0)
	;if !(Count>1) ;valor defecto + otro(s)
	;	return true, ErrorLevel := false
	;MsgBox % Count ;cantidad de valores en la clave actual {...} <--
}

;abre una clave
;Sintaxis: RegOpenKey( [clave\subclave], [acceso], [¿crear la clave si no existe?] )
;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724878%28v=vs.85%29.aspx
;Claves: HKCR|HKCU|HKLM|HKU|HKPD|HKCC
RegOpenKey(Key, DesiredAccess := 0xF003F, CreateIfNotExist := false) {
	static Keys := {"HKEY_CLASSES_ROOT": 0x80000000, "HKCR": 0x80000000
		, "HKEY_CURRENT_USER": 0x80000001, "HKCU": 0x80000001
		, "HKEY_LOCAL_MACHINE": 0x80000002, "HKLM": 0x80000002
		, "HKEY_USERS": 0x80000003, "HKU": 0x80000003
		, "HKEY_PERFORMANCE_DATA": 0x80000004, "HKPD": 0x80000004
		, "HKEY_CURRENT_CONFIG": 0x80000005, "HKCC": 0x80000005}
	RegView := A_RegView="32"?0x0200:A_RegView="64"?0x0100:0x0000, SplitKey(Key, Key, SubKey)
	if !(Keys[Key]) ;KEY_WOW64_32KEY = 0x0200 | KEY_WOW64_64KEY = 0x0100 | Default = 0x0
		return false, ErrorLevel := true
	if (CreateIfNotExist) ;ERROR_SUCCESS = 0 (RegCreateKeyExW y RegOpenKeyExW devuelven 0 si no hubo errores)
		Result := DllCall("Advapi32.dll\RegCreateKeyExW", "UInt", Keys[Key], "Str", SubKey, "UInt", 0, "Ptr", 0, "UInt", 0, "UInt", DesiredAccess|RegView, "Ptr", 0, "PtrP", hRegKey, "Ptr", 0)
	else Result := DllCall("Advapi32.dll\RegOpenKeyExW", "UInt", Keys[Key], "Str", SubKey, "UInt", 0, "UInt", DesiredAccess|RegView, "PtrP", hRegKey)
	return hRegKey, ErrorLevel := Result 
} RegCloseKey(Key*) {
	l := 0
	Loop, % (Key.MaxIndex())
	l += !DllCall("Advapi32.dll\RegCloseKey", "Ptr", Key[A_Index]) ;ERROR_SUCCESS = 0
	return l=Key.MaxIndex(), ErrorLevel := l!=Key.MaxIndex()
}

;establecer seguridad para la clave
;Sintaxis: RegSetSecurity( [clave\subclave], [usuario], [acceso] )
;Usuario: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379637%28v=vs.85%29.aspx
;Accesos: 2032127 = FULL | 1179817 = READ | 1179958 = WRITE | 1245631 = CHANGE
RegSetSecurity(RegKey, Trustee := "S-1-1-0", AccessMask := 2032127) {
	dacl := ComObjCreate("AccessControlList"), sd := ComObjCreate("SecurityDescriptor")
	, newAce := ComObjCreate("AccessControlEntry"), sdutil := ComObjCreate("ADsSecurityUtility")
	, sd := sdUtil.GetSecurityDescriptor(RegKey, 3, true), dacl := sd.DiscretionaryAcl
	, newAce.Trustee := Trustee, newAce.AccessMask := AccessMask
	, newAce.AceType := false, dacl.AddAce(newAce)
	return sdutil.SetSecurityDescriptor(RegKey, 3, sd, true)
}



















































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: EDIT CONTROL ::::::::::::::::::::::::::::::::::
NOTAS:
	;para establecer o quitar un estilo, usar WinSetStyle(hWnd, Estilo)
	;para obtener el estilo, usar WinGetStyle(hWnd)
#############################################################################################################################################
*/
;obtiene el número de líneas
;Sintaxis: Edit_GetLineCount( [hWnd] )
;Nota: si no hay texto en el control, devuelve 1. el valor nunca será inferior a 1.
Edit_GetLineCount(hWnd) {
	return SendMessage(hWnd, 0x00BA)
}

;obtiene el texto de una linea
;Sintaxis: Edit_GetLineText( [hWnd], [Linea] )
Edit_GetLineText(hWnd, Line := -1) {
	nSize := 32767 ;SendMessage(hWnd, 0x00C1,, Line-1)
	, Line := Line=-1?Edit_GetCurrentLine(hWnd):Line
	, VarSetCapacity(LineText, nSize, 0), NumPut(nSize, LineText, 0, "UShort")
	, SendMessage(hWnd, 0x00C4,, Line-1,, &LineText)
	return LineText 
}

;obtiene el índice de la línea que contiene el índice de caracteres especificado en un control de edición multilínea
;Sintaxis: Edit_GetCurrentLine( [hWnd], [índice] )
;Nota: por defecto obtiene la linea actual.
Edit_GetCurrentLine(hWnd, Line := -1) {
	return SendMessage(hWnd, 0x00C9,, Line=-1?-1:Line-1)+1
}

;obtiene el número de columna en el que reside el cursor (punto de inserción de texto). 
;Sintaxis: Edit_GetColumn( [hWnd], [inicio (salida)], [fin (salida)] )
;Inicio: columna donde empieza la seleccion
;Fin: columna donde termina la seleccion
;Notas: 
	;si no hay texto seleccionado, el 2do y 3er parametro devuelven el mismo resultado.
	;la primera columna es 1.
	;si hay texto seleccionado en el control, devuelve el número de columna donde comienza la selección.
Edit_GetColumn(hWnd, ByRef Starting := "", ByRef End := "") {
	VarSetCapacity(s, 4), VarSetCapacity(e, 4)
	, SendMessage(hWnd, 0x00B0,, &s,, &e)
	, Starting := NumGet(s, 0, "UInt")+1, End := NumGet(e, 0, "UInt")+1
	return Starting
}

;obtiene el hWnd del Edit de un ComboBox. opcional también el del DropDownList
;Sintaxis: Edit_GetComboBox( [hWnd], [ComboBox (salida)], [DropDownList (salida)] )
Edit_GetComboBox(hWnd, ByRef DropDownList := "", ByRef EditRect := "", ByRef DDLRect := "") {
	nSize := VarSetCapacity(COMBOBOXINFO, 40+(A_PtrSize*3), 0)
	, NumPut(nSize, COMBOBOXINFO, 0, "UInt")
	, r:=DllCall("User32.dll\GetComboBoxInfo", "Ptr", hWnd, "Ptr", &COMBOBOXINFO)
	return NumGet(COMBOBOXINFO, 40+A_PtrSize, "UPtr")
		, DropDownList := IsByRef(DropDownList)?NumGet(COMBOBOXINFO, 44+A_PtrSize, "UPtr"):""
		, EditRect := IsByRef(EditRect)?NumGet(COMBOBOXINFO, 28+A_PtrSize, "Ptr"):""
		, DDLRect := IsByRef(DDLRect)?NumGet(COMBOBOXINFO, 12+A_PtrSize, "Ptr"):""
		, ErrorLevel := !r
}

;obtiene el texto
;Sintaxis: Edit_GetText( [hWnd] )
Edit_GetText(hWnd) {
	nSize := SendMessage(hWnd, 0x000E)
	, VarSetCapacity(Text, (nSize * 2) + 1, 0)
	, SendMessage(hWnd, 0x000D, "UInt", nSize+1,, &Text)
	return Text
}

;recupera informacion de la barra de desplazamiento.
;Sintaxis: Edit_GetScrollBarInfo( [hWnd], [barra], [enabled], [pressed], [offscreen], [visible], [coordenadas] )
;Barra: 0 = horizontal | 1 = vertical (defecto)
;Enabled: la barra está deshabilitada. (0|1)
;Pressed: se pulsa sobre la barra. (0|1)
;OffScreen: la ventana tiene un tamaño tal que la barra no se muestra actualmente. (0|1)
;Visible: indica que la barra existe. (0|1)
Edit_GetScrollBarInfo(hWnd, ScrollBar := 1, ByRef Enabled := "", ByRef Pressed := "", ByRef OffScreen := "", ByRef Visible := "", ByRef RECT := "") {
	VarSetCapacity(SCROLLBARINFO, 60, 0), NumPut(60, SCROLLBARINFO, 0, "UInt")
	return r:=DllCall("User32.dll\GetScrollBarInfo", "Ptr", hWnd
		, "Int", ScrollBar=0?0xFFFFFFFA:ScrollBar=1?0xFFFFFFFB:ScrollBar
		, "Ptr", &SCROLLBARINFO), SBInfo := NumGet(SCROLLBARINFO, 36, "UInt")
	, RECT := IsByRef(RECT)?NumGet(SCROLLBARINFO, 16, "Ptr"):"", Visible := SBInfo&0x8000?false:true, ErrorLevel := !r
	, Pressed := SBInfo&0x8?true:false, OffScreen := SBInfo&0x10000?true:false, Enabled := SBInfo&0x1?false:true
}

;obtiene la señal textual que se muestra por el control de edición
;Sintaxis: Edit_GetCueBannerText( [hWnd] )
Edit_GetCueBannerText(hWnd, nSize := 2048) {
	VarSetCapacity(Text, nSize, 0)
	, SendMessage(hWnd, 0x1502,, &Text, "UInt", nSize)
	return Text
}

;obtiene el carácter de contraseña que se muestra en el control
;Sintaxis: Edit_GetPasswordChar( [hWnd] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_GetPasswordChar(hWnd) {
	SendMessage(hWnd, 0x00D2)
}

;obtiene las coordenadas del control
;Sintaxis: Edit_GetPos( [hWnd], [x], [y], [ancho], [alto] )
Edit_GetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 16, 0)
	, r:=DllCall("User32.dll\GetWindowRect", "Pr", hWnd, "Ptr", &RECT)
    , i := {}, i.w := i.Width := Width := NumGet(RECT, 8, "Int")-NumGet(RECT, 0, "Int")
	, i.h := i.Height := Height := NumGet(RECT, 12, "Int")-NumGet(RECT, 4, "Int")
	, DllCall("User32.dll\ScreenToClient", "Ptr", DllCall("User32.dll\GetParent", "Ptr", hWnd), "Ptr", &RECT)
	, i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	return i, ErrorLevel := !r
}

;obtener ancho de los margenes izquierdo y derecho
;Sintaxis: Edit_GetMargins( [hWnd], [margen izquierdo (out)], [margen derecho (out] )
Edit_GetMargins(hWnd, ByRef Left := "", ByRef Right := "") {
	OutputVar := SendMessage(hWnd, 0x00D4)
	return [Left := OutputVar & 0xffff, Right := OutputVar >> 16]
}

;--------------------------------------------------------------------------------------------------------------------------

;establece el límite de texto
;Sintaxis: Edit_SetLimitText( [hWnd], [limite de caracteres 1~64000] )
Edit_SetLimitText(hWnd, Limit := 64000) {
	return SendMessage(hWnd, 0x00C5,, Limit)
}

;establece la señal textual que se muestra por el control de edición para pedir al usuario para obtener información
;Sintaxis: Edit_SetCueBannerText( [hWnd], [texto], [¿mostrar siempre?] )
;Nota: no se puede establecer en un control de edición multilínea.
Edit_SetCueBannerText(hWnd, Text := "", Flag := false) {
	return SendMessage(hWnd, 0x1501, "Int", Flag,, &Text)
}

;selecciona un rango de caracteres en un control de edición
;Sintaxis: Edit_SetSel( [hWnd], [inicio], [fin] )
;Notas:
	;espesificar -1 en el 1er parametro para deseleccionar todo.
	;espesificar 0 en el 1er parametro y -1 en el 2do para seleccionar todo (defecto).
Edit_SetSel(hWnd, Starting := 0, End := -1) {
	return SendMessage(hWnd, 0x00B1,, Starting>0?Starting-1:Starting,, End>0?End-1:End)
}

;establecer el estilo ReadOnly (el usuario no puede cambiar el texto)
;Sintaxis: Edit_SetReadOnly( [hWnd], [0|1] )
Edit_SetReadOnly(hWnd, State := true) {
	return SendMessage(hWnd, 0x00CF, "Int", State)
}

;muestra un asterisco (*) (o el carácter espesificado) para cada carácter escrito en el control de edición.
;Sintaxis: Edit_SetPasswordChar( [hWnd], [0|1|Carácter] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_SetPasswordChar(hWnd, PassChar := true) {
	return r:=SendMessage(hWnd, 0x00CC,, PassChar=0?0:Asc(PassChar=1?"*":PassChar))
		, WinRedraw(hWnd), ErrorLevel := !r
}

;establece el texto espesificado
;Sintaxis: Edit_SetText( [hWnd], [Texto] )
;Nota: puede usar Edit_ReplaceSelText() como alternativa.
Edit_SetText(hWnd, Text := "") {
	return SendMessage(hWnd, 0x000C,,,, &Text)
}

;establecer ancho de los margenes derecho y/o izquierdo
;Sintaxis: Edit_SetMargins( [hWnd], [margen izquierdo], [margen derecho] )
Edit_SetMargins(hWnd, Left := "", Right := "") {
	if (Left="") || (Right="")
		Edit_GetMargins(hWnd, L, R), Left := Left=""?L:Left, Right := Right=""?R:Right
	return true, SendMessage(hWnd, 0x00D3, "UInt", 0x0001|0x0002,, (Left & 0xffff) + (Right << 16))
}

;establecer icono en el lado izquierdo o derecho
;Sintaxis: Edit_SetIcon( [hWnd], [Icono], [color], [etiqueta al hacer clic en la imagen], [¿lado derecho?] )
;Icono: espesificar el icono o un Array con el [icono, indice]
;Color: espesificar un Array. [color de fondo del Gui, color de fondo del control]
;Return: devuelve un Array. [hWnd de la ventana, hWnd del Picture control] 
;Nota: destruir la ventana cuando se deje de usar. Usar WinDestroy(hWnd de la ventana)  o GuiDestroy
;Ejemplo:
	;Gui, Add, Edit, w300 h21 HWNDhEdit, This is an Edit Control!
	;Gui, Show
	;Info := Edit_SetIcon(hEdit, ["shell32", 32],, "MyLabel")
	;return
	;MyLabel:
	;MsgBox
	;return
	;GuiClose:
	;WinDestroy(Info[1]) ;destruir ventana
	;ExitApp
Edit_SetIcon(hWnd, Icon, Color := "", Label := "", Right := false) {
	Index := IsObject(Icon)?(Icon[2]>1?Icon[2]:1):1, Icon := IsObject(Icon)?Icon[1]:Icon
	, WinGetPos(hWnd,,, w, h, 1), h := h-5, Color := IsObject(Color)?Color:["", "White"]
	try {
		Gui, New, +HWNDID -Caption +Parent%hWnd%
		Gui, %ID%:Color, % Color[1], % Color[2]
		Gui, %ID%:Margin, 0, 0
		Gui, %ID%:Add, Picture, % "HWNDhPic h" h " w" h " Icon" Index (IsLabel(Label)?" g" Label:""), %Icon%
		Gui, %ID%:Show, % "x" (Right?w-h-2:2) " y2 h" h " w" h
	} catch
		return false, WinDestroy(ID), ErrorLevel := true
	return [ID, hPic], WinSetStyle(hWnd, "+" 0x02000000), Edit_SetMargins(hWnd, Right?"":h+4, Right?h+4:""), ErrorLevel := !(ID)
}

;--------------------------------------------------------------------------------------------------------------------------

;comprueba si el control tiene el foco del teclado.
;Sintaxis: Edit_HasFocus( [hWnd], [hWnd del control que tiene el foco (salida)] )
Edit_HasFocus(hWnd, ByRef hWndFocus := "") {
	nSize := VarSetCapacity(GUITHREADINFO, A_PtrSize=4?48:72, 0)
	, NumPut(nSize, GUITHREADINFO, 0, "UInt")
	, DllCall("User32.dll\GetGUIThreadInfo", "Ptr", 0, "Ptr", &GUITHREADINFO)
	, hWndFocus := NumGet(GUITHREADINFO, A_PtrSize=4?12:16, "Ptr")
	return (r:=hWnd=hWndFocus), ErrorLevel := !r
}

;comprueba si el control admite multilinea
;Sintaxis: Edit_IsMultiline( [hWnd] )
Edit_IsMultiline(hWnd) {
	return WinGetStyle(hWnd)&0x0004
}

;comprueba si tiene el estilo ReadOnly (el usuario no puede cambiar el texto)
;Sintaxis: Edit_ReadOnly( [hWnd] )
Edit_ReadOnly(hWnd) {
	return WinGetStyle(hWnd)&0x0800
}

;compruea si tiene el estilo ES_PASSWORD
;Sintaxis: Edit_PasswordChar( [hWnd] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_PasswordChar(hWnd) {
	return WinGetStyle(hWnd)&0x0020
}

;muestra/oculta un globo de informacion asociado con un control de edición
;Sintaxis: Edit_ShowBalloonTip( [hWnd], [Título], [Texto], [Icono] )
;Iconos: Informacion = 1-4 | advertencia = 2-5 | error = 3-6
;Nota: para ocultar, no espesificar ningún parámetro.
Edit_ShowBalloonTip(hWnd, Info*) {
	if !Info.MaxIndex()
		return SendMessage(hWnd, 0x1504)
	Title := Info[1], Text := Info[2], Icon := Info[3]?Info[3]:0
	, nSize := VarSetCapacity(EDITBALLOONTIP, A_PtrSize=4?16:32, 0)
	, NumPut(nSize, EDITBALLOONTIP, 0, "UInt"), NumPut(&Title, EDITBALLOONTIP, A_PtrSize, "Ptr")
	, NumPut(&Text, EDITBALLOONTIP, A_PtrSize*2, "Ptr"), NumPut(Icon, EDITBALLOONTIP, A_PtrSize*3, "Int")
	return SendMessage(hWnd, 0x1503,,,, &EDITBALLOONTIP)
}

;habilita/deshabilita las barras de desplazamiento.
;Sintaxis: Edit_EnableScrollBar( [hWnd], [barra], [modo], [otras opciones, ver nota] )
;Barra: 0 = horizontal | 1 = vertical | 3 = ambas
;Modo: 0 = deshabilitar | 1 = habilitar (defecto)
;Nota: para mas opciones ver: https://msdn.microsoft.com/en-us/library/windows/desktop/bb787579%28v=vs.85%29.aspx
Edit_EnableScrollBar(hWnd, wSBflags, Enable := true, wArrow := -1) {
	return DllCall("User32.dll\EnableScrollBar", "Ptr", hWnd, "UInt", wSBflags
		, "UInt", wArrow=-1?(Enable?0x0:0x3):wArrow)
}

;muestra/oculta las barras de desplazamiento.
;Sintaxis: Edit_ShowScrollBar( [hWnd], [barra], [modo] )
;Barra: 0 = horizontal | 1 = vertical | 3 = ambas
;Modo: 0 = ocultar | 1 = mostrar (defecto)
Edit_ShowScrollBar(hWnd, ScrollBar, Show := true) {
	return DllCall("User32.dll\ShowScrollBar", "Ptr", hWnd, "UInt", ScrollBar, "Int", !!Show)
}

;sustituye el texto seleccionado
;Sintaxis: Edit_ReplaceSelText( [hWnd], [texto] )
Edit_ReplaceSelText(hWnd, Text := "") {
	return SendMessage(hWnd, 0x00C2, "Int", true,, &Text)
}

;eliminar el texto seleccionado
;Sintaxis: Edit_SelClear( [hWnd] )
Edit_SelClear(hWnd) {
	return SendMessage(hWnd, 0x0303)
}

;copiar el texto seleccionado al portapapeles
;Sintaxis: Edit_SelCopy( [hWnd] )
Edit_SelCopy(hWnd) {
	return SendMessage(hWnd, 0x0301)
}

;cortar el texto seleccionado al portapapeles
;Sintaxis: Edit_SelCut( [hWnd] )
Edit_SelCut(hWnd) {
	return SendMessage(hWnd, 0x0300)
}

;pegar el texto del portapapeles
;Sintaxis: Edit_SelPaste( [hWnd] )
Edit_SelPaste(hWnd) {
	return SendMessage(hWnd, 0x0302)
}

;muestra un dialogo para elegir la fuente y la aplica al control
;Sintaxis: Edit_SelectFont( [hWnd], [calidad (ver FontCreate)], [¿redibujar?] )
;EJEMPLO:
	;Gui, Add, Edit, x5 y5 w490 h270 HWNDhWnd +HScroll, Fuente ~ Edit Control, AutoHotKey %A_AhkVersion%
	;Gui, Add, Button, x20 y280 w455 h25 gSelectFont, Cambiar Fuente
	;Gui, Show, w500 h315
	;Gui, +OwnDialogs +AlwaysOnTop ;OwnDialogs impide interactuar con la ventana hasta cerrar el dialogo
	;return
	;GuiClose:
	;ExitApp
	;SelectFont:
	;Edit_SelectFont(hWnd, 5, true)
	;return
Edit_SelectFont(hWnd, Quality := 2, Redraw := false) {
	static Color := [], Font := [], List := []
	for k, v in List
		if !IsWindow(k)
			FontDelete(v), List.RemoveAt(A_Index)
	FontInfo := ControlGetFont(false, hWnd)
	, FontInfo := FontSelect(DllCall("User32.dll\GetParent", "Ptr", hWnd), Font[hWnd]
		, [Color[hWnd], FontInfo[2], FontInfo[3], FontInfo[4], FontInfo[5], FontInfo[6]])
	if (ErrorLevel)
		return false
	ControlSetColor(false, hWnd, FontInfo[1]), Color[hWnd] := FontInfo[1]
	, Font[hWnd] := FontInfo[0], hFont := FontCreate(FontInfo[0], FontInfo[2], FontInfo[3]
		, FontInfo[4], FontInfo[5], FontInfo[6], Quality), List[hWnd] := hFont
	return ControlSetFont(false, hWnd, hFont, Redraw)?hFont:false
}




























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: BUTTON CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece un icono a un boton
;Sintaxis: BC_SetIcon( [hWnd], [Icono], [opciones] )
;Opciones: espesificar la letra seguida de un valor.
	;W = ancho | H = alto
	;L = margen izquierdo | R = margen derecho
	;T = margen superior | B = margen inferior
	;A = alineación (0 = izquierda, 1 = derecha, 2 = superior, 3 = inferior, 4 = centro)
;Icono: espesificar una lista de imágenes, una imagen o un array [imagen, indice]
	;Indice 1 = Normal
	;Indice 2 = Al posicionar el cursor por encima del boton
	;Indice 3 = Al precionar
	;Indice 4 = Deshabilitado
	;Indice 5 = Defecto (para evitar que el boton quede sin imagen, espesificar la misma imagen que en el indice 1)
;Ejemplo:
	/*
	Gui, Add, Button, HWNDB1 w100 h25, Button1
		BC_SetIcon(B1, A_AhkPath) ;normal
	Gui, Add, Button, HWNDB2 w25
		BC_SetIcon(B2, [A_WinDir "\explorer.exe", 1]) ;Array [imagen, indice]
	ImageList := IL_Create(5, 1, 1) ;usar imagenes grandes
	IL_Add(ImageList, A_Windir "\regedit.exe") ;indice 1 = NORMAL
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 2 = CURSOR
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 3 = CLIC
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 4 = DESHABILITADO
	IL_Add(ImageList, A_Windir "\regedit.exe") ;indice 5 = DEFECTO --> NORMAL
	Gui, Add, Button, HWNDB3 w100 h45
		BC_SetIcon(B3, ImageList, "A4") ;ImageList
	Gui, Show
	return
	GuiClose:
	Exitapp
	*/
BC_SetIcon(hWnd, ImageList, Options := "L2") {
	Flag := SplitFlags(Options, "\d", "w", "h", "l", "t", "r", "b", "a")
	if !(ImageList+0)
		v := IL_Create(1, 1,, Flag[1]>0?Flag[1]:16, Flag[2]>0?Flag[2]:16)
		, IL_Add(v, IsObject(ImageList)?ImageList[1]:ImageList, ImageList[2]>1?ImageList[2]:1), ImageList := v
	VarSetCapacity(BUTTON_IMAGELIST, 20 + A_PtrSize, 0)
	, NumPut(ImageList, BUTTON_IMAGELIST, 0, "Ptr")
	, NumPut(Flag[3]?Flag[3]:0, BUTTON_IMAGELIST, 0 + A_PtrSize, "UInt")
	, NumPut(Flag[4]?Flag[4]:0, BUTTON_IMAGELIST, 4 + A_PtrSize, "UInt")
	, NumPut(Flag[5]?Flag[5]:0, BUTTON_IMAGELIST, 8 + A_PtrSize, "UInt")
	, NumPut(Flag[6]?Flag[6]:0, BUTTON_IMAGELIST, 12 + A_PtrSize, "UInt")
	, NumPut(Flag[7]?Flag[7]:0, BUTTON_IMAGELIST, 16 + A_PtrSize, "UInt")
	return SendMessage(hWnd, 0x1602,,,, &BUTTON_IMAGELIST)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb775975(v=vs.85).aspx

;simula clic en el boton.
;Sintaxis: BC_Click( [hWnd] )
;Nota: la ventana debe estar activa.
BC_Click(hWnd) {
	return SendMessage(hWnd, 0x00F5)
}






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: STATUS BAR CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recuperar el texto
;Sintaxis: SB_GetText( [hWnd], [parte] )
SB_GetText(hWnd, Index := 1) {
	Size := SendMessage(hWnd, 0x040C, "Int", Index-1) & 0xffff ;LOWORD
	, VarSetCapacity(Text, Size * 2, 0)
	, SendMessage(hWnd, 0x040D, "Int", Index-1, "Str", Text)
	return Text
}

;obtener cantidad de partes
;Sintaxis: SB_GetParts( [hWnd] )
SB_GetParts(hWnd) {
	return SendMessage(hWnd, 0x0406)
}

;obtener color de fondo RGB
;Sintaxis: SB_GetBKColor( [hWnd] )
SB_GetBKColor(hWnd) {
	WinSetRedraw(hWnd, false)
	, Color := SB_SetBKColor(hWnd, "Red")
	, SB_SetBKColor(hWnd, Color)
	return Color, WinSetRedraw(hWnd)
}

;-------------------------------------------------------------------------------------------------------------------------------------------

;cambiar color de fondo
;Sintaxis: SB_SETBKCOLOR( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB
;Return: devuelve el color anterior
;Nota: usar -Theme en las opciones al crear el control.
SB_SetBKColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x2001,,, "UInt", RGBToInt(_getcolor(Color))))
}













































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: LISTVIEW CONTROL ::::::::::::::::::::::::::::::::::
;Parámetros:
	;hWnd = hwnd del control
	;Item = Indice. 0 = todos
;#############################################################################################################################################
;obtiene la cantidad de items
LV_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1000+4)
}

;elimina item. dejar vacio el segundo parámetro para eliminar todos los items
LV_DeleteItem(hWnd, Item := 0) {
	return SendMessage(hWnd, 0x1000+(Item>0?8:9),, Item>0?Item-1:0)
}

;eliminar columna
LV_DeleteColumn(hWnd, Column := 1) {
	return SendMessage(hWnd, 0x1000+28,, Column-1)
}

;actualiza un item
LV_Update(hWnd, Item) {
	return SendMessage(hWnd, 0x1000+42,, Item-1)
}

;redibujar items
LV_RedrawItem(hWnd, ItemFirst := 0, ItemLast := "") {
	If (ItemFirst > 0)
		ItemLast := ItemLast=""?ItemFirst:ItemLast
	else ItemLast := (ItemFirst:=SendMessage(hWnd, 0x1027))+SendMessage(hWnd, 0x1028)
	return SendMessage(hWnd, 0x1000+21,, ItemFirst-1,, ItemLast-1), DllCall("User32.dll\UpdateWindow", "Ptr", hWnd)
}

;cambiar texto a un item
;Sintaxis: LV_SetItemText( [LV], [texto], [item], [columna] )
LV_SetItemText(hWnd, pszText := "", Item := 1, Column := 1) {
	VarSetCapacity(LVITEM, A_PtrSize=4?60:80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	, NumPut(&pszText, LVITEM, A_PtrSize=4?20:24, "Ptr"), NumPut(StrLen(pszText)+1, LVITEM, A_PtrSize=4?24:32, "Int")
	return SendMessage(hWnd, 0x1000+116,, Item-1,, &LVITEM)
}

;obtener texto de un item
;Sintaxis: LV_GetItemText( [LV], [item], [columna] )
LV_GetItemText(hWnd, Item := 0, Column := 1, MaxChars := 514) {
	VarSetCapacity(LVITEM, A_PtrSize = 4 ? 60 : 72, 0)
	, NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int"), cchTextMax := (VarSetCapacity(pszText, MaxChars, 0) / 2) + 1
	, NumPut(&pszText, LVITEM, A_PtrSize = 4 ? 20 : 24, "Ptr"), NumPut(cchTextMax, LVITEM, A_PtrSize = 4 ? 24 : 32, "Int")
	, TextLength := SendMessage(hWnd, 0x1000+115,, Item-1,, &LVITEM)
	return StrGet(&pszText, TextLength)
} LV_GetItemTextEx(hWnd, Item, Column := 1, ByRef ProcessId := "") {
	ProcessId := ProcessId?ProcessId:WinGetPid(hWnd)
	, hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0008|0x0010|0x0020, "Int", 0 , "UInt", ProcessId)
	, pAddress := DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "Ptr", 0, "UPtr", A_PtrSize=4?60:80, "UInt", 0x00001000, "UInt", 0x04)
	, pAddress2 := DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "Ptr", 0, "UPtr", cchTextMax:=(1024+1), "UInt", 0x00001000, "UInt", 0x04)
	, VarSetCapacity(LVITEM, A_PtrSize=4?60:80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	, VarSetCapacity(pszText, cchTextMax * 2, 1), NumPut(pAddress2, LVITEM, A_PtrSize=4?20:24, "Ptr"), NumPut(cchTextMax, LVITEM, A_PtrSize=4?24:32, "Int") 
	, DllCall("Kernel32.dll\WriteProcessMemory", "Ptr", hProcess, "UInt", pAddress, "Ptr", &lvItem, "UPtr", A_PtrSize=4?60:80, "UPtr", 0)
	, i := SendMessage(hWnd, 0x1000+115,, Item-1, "UInt", pAddress)
	, DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, "UInt", pAddress2, "Ptr", &pszText, "UPtr", cchTextMax, "UPtr", 0)
	return pszText, DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", pAddress, "UPtr", 0, "UInt", 0x8000)
		, DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", pAddress2, "UPtr", 0, "UInt", 0x8000), DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess), ErrorLevel := !i
} ;http://www.autohotkey.com/board/topic/81820-how-to-get-specific-row-text-in-a-syslistview32-easily/

;busca items uno por uno.
;Sintaxis: LV_GetNextItem( [LV], [modo] )
;Modos: F = foco | S = seleccionado
LV_GetNextItem(hWnd, Item := 0, Mode := "") {
	Index := SendMessage(hWnd, 0x1000+12,, Item,, Mode="S"?0x0002:Mode="F"?0x0001:0x0000)
	return Index, ErrorLevel := Index=-1
}

;establece/quita/alterna estilos extendidos a la ventana.
;Sintaxis: LV_SetExStyle( [hWnd], [+-^Estilos] )
;ESTILOS: https://msdn.microsoft.com/en-us/library/windows/desktop/bb774732(v=vs.85).aspx
	;0x010000 = dibujo vía doble búfer, lo que reduce el parpadeo
	;0x00000004 = activa las casillas de verificación para los elementos (checkbox)
	;0x00000001 = muestra líneas de cuadrícula alrededor de los elementos y subelementos (grid)
LV_SetExStyle(hWnd, ExStyle) {
	Key := SubStr(ExStyle:=Trim(ExStyle), 1, 1), ExStyle := (Key="+"||Key="-"||Key="^")?SubStr(ExStyle, 2):ExStyle
	if (Key="-")
		return SendMessage(hWnd, 0x1036, "UInt", ExStyle)
	if (Key="^")
		return LV_SetExStyle(hWnd, ((LV_GetExStyle(hWnd)&ExStyle)?"-":"") ExStyle)
	return SendMessage(hWnd, 0x1036, "UInt", ExStyle, "UInt", ExStyle)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761165%28v=vs.85%29.aspx
 
;obtener estilo extendido.
;Sintaxis: LV_GetExStyle( [hWnd] )
LV_GetExStyle(hWnd) {
	return SendMessage(hWnd, 0x1037)
}

;recupera texto en un item espesificado
;Sintaxis: LV_GetSelected( [columna], [F|C] )
LV_GetSelected(Col := 1, Type := "F", RowNumber := 0) {
	while (RowNumber:=LV_GetNext(RowNumber, Type)) {
		LV_GetText(Text, RowNumber, Col) 
		Result .= (A_Index=1?"":"`n") Text
	} return Result
}

;determina si un item es visible
;Sintaxis: LV_IsItemVisible( [ID], [item] )
LV_IsItemVisible(hWnd, Item) {
	return SendMessage(hWnd, 0x10B6,, Item-1)
}

;Establece el espacio entre iconos en la vista de iconos.
;Sintaxis: LV_SetIconSpacing( [ID], [eje x, distancia en pixeles], [eje y, distancia en pixeles] )
LV_SetIconSpacing(hWnd, cx, cy) {
	cx := ((cx<4)&&(cx!=-1))?4:cx, cy := ((cy<4)&&(cy!=-1))?4:cy
	return SendMessage(hWnd, 0x1035,,,, LOWORD(cx)+HIWORD(cy, false))
}

;obtiene el espacio entre iconos en la vista de iconos.
;Sintaxis: LV_GetIconSpacing( [ID], [eje x, distancia en pixeles (salida)], [eje y, distancia en pixeles (salida)] )
LV_GetIconSpacing(hWnd, ByRef cx := "", ByRef cy := "") {
	IcSp := SendMessage(hWnd, 0x1033)
   return [cx:=(IcSp & 0xFFFF), cy:=(IcSp >> 16)]
}

;obtener posicion de un item
;Sintaxis: LV_GetItemPos( [ID], [item], [x (salida)], [y (salida)] )
;Nota: devuelve un Array con la posicion xy.
LV_GetItemPos(hWnd, Item, ByRef x := "", ByRef y := "") {
	VarSetCapacity(POINT, A_PtrSize*2, 0), SendMessage(hWnd, 0x1010,, Item-1,, &POINT)
	return [x:=NumGet(POINT, 0, "Int"), y:=NumGet(POINT, 4, "Int")]
} LV_GetItemPosEx(hWnd, Item, ByRef x := "", ByRef y := "", ByRef ProcessId := "") {
	ProcessId := ProcessId?ProcessId:WinGetPid(hWnd)
	, hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0008|0x0010|0x0020, "Int", 0 , "UInt", ProcessId)
	, pAddress := DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "Ptr", 0, "UInt", 0x00001000, "UInt", 0x00001000, "UInt", 0x04)
	, SendMessage(hWnd, 0x1000+16,, Item-1,, pAddress), r:=ErrorLevel, VarSetCapacity(RECT, 16, 0)
	, DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, "UInt", pAddress, "Ptr", &RECT, "UInt", 16, "UPtr", 0)
	return [x:=NumGet(RECT, 0, "Int"), y:=NumGet(RECT, 4, "Int")], DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", pAddress, "UPtr", 0, "UInt", 0x8000)
		, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess), ErrorLevel := r
} ;http://www.autohotkey.com/board/topic/9760-lvm-geticonposition/

;establece la posicion de un item
;Sintaxis: LV_SetItemPos( [ID], [item], [x], [y] )
LV_SetItemPos(hWnd, Item, x := "", y := "") {
	if (x="") || (y="")
		LV_GetItemPos(hWnd, Item, _x, _y)
	return SendMessage(hWnd, 0x100F,, Item-1,, LOWORD(x=""?_x:x)+HIWORD(y=""?_y:y, false))
} LV_SetItemPosEx(hWnd, Item, x := "", y := "", ProcessId := "") {
	if (x="") || (y="")
		LV_GetItemPosEx(hWnd, Item, _x, _y, ProcessId)
	return SendMessage(hWnd, 0x100F,, Item-1,, LOWORD(x=""?_x:x)+HIWORD(y=""?_y:y, false))
}

;obtiene el número de columna en las coordenadas espesificadas.
;Sintaxis: LV_SubItemHitTest( [hWnd], [x], [y] )
;Nota: si no espesifica las coordenadas, por defecto usa las del cursor.
LV_SubItemHitTest(hWnd, x := -1, y := -1, ScreenToClient := false) {
	if !(x>0) || !(y>0)
		CursorGetPos(_x, _y,, ((x=-1)&&(y=-1))?hWnd:(ScreenToClient?hWnd:false))
	, VarSetCapacity(LVHITTESTINFO, 24, 0), NumPut((x>0)?x:_x, LVHITTESTINFO, 0, "Int")
	, NumPut((y>0)?y:_y, LVHITTESTINFO, 4, "Int"), r:=SendMessage(hWnd, 0x1039,,,, &LVHITTESTINFO)
	return (r=-1)?0:NumGet(LVHITTESTINFO, 16, "Int")+1, ErrorLevel := (r=-1)
}

;buscar elementos en el control que contengan el texto expesificado, los demás son eliminados.
;Sintaxis: LV_SearchEx( [items], [texto a buscar], [columnas], [elementos máximos a mostrar], [hWnd del control] )
;Items: espesificar un array con los items en el control. Sintaxis: [["item 1, col 1", "item 1, col 2"], ["item 2, col 1"]]
;Columna: espesificar las columnas en las que buscar separadas por coma. por defecto busca en todas (-1).
;Notas: usar LV_SetExStyle(hWnd, 0x00010000) para reducir el parpadeo. usar SetTimer() para cuando haya muchos items.
;Return: devuelve un array con la cantidad de items encontrados.
/* ::::: EJEMPLO DE USO :::::
Gui, Add, ListView, x0 y0 w585 h180 HWNDhWnd, Nombre|Descripción
Gui, Add, Edit, x0 y185 w585 h25 gFind HWNDFind
Gui, Show, w586 h242, Test LV_SearchEx()
Items := [], LV_SetExStyle(hWnd, 0x00010000), WinSetRedraw(hWnd, false)
Loop, 50 {
	LV_Add(, "Item " A_Index " (" Chr(A_Index) ")", "Descripción " A_Index " (" Chr(A_Index*2) ")")
	Items.Push(["Item " A_Index " (" Chr(A_Index) ")", "Descripción " A_Index " (" Chr(A_Index*2) ")"])
} LV_ModifyCol(1, "AutoHdr"), WinSetRedraw(hWnd)
return
GuiClose:
ExitApp
Find:
LV_SearchEx(Items, ControlGetText(0, Find), -1, -1, hWnd)
return
*/
LV_SearchEx(Items, Text := "", Col := -1, Max := -1, hWnd := "") {
	static Func := Func("LV_SearchExFind")
	if !(LV_GetCount()>40) ||!XXX
		return LV_SearchExFind(Items, Text, Col, Max, hWnd)
	return SetTimer(Func.Bind(Items, Text, Col, Max, hWnd), -350)
} LV_SearchExFind(Items, Text, Col, Max, hWnd) {
	static Func := Func("LV_SearchEx_Find")
	WinSetRedraw(hWnd=""?A_DefaultListView:hWnd, false), LV_Delete(), OuputVar := []
	while (LV_GetCount())
		Sleep, -1
	Loop, % ((Text="")?0:Items.MaxIndex()) {
		if (CurrentItemIndex:=A_Index) && (OuputVar.MaxIndex()>=Max) && (Max!=-1)
			break
		CurrentItemText := IsObject(Items[A_Index])?Items[A_Index]:[Items[A_Index]]
		Loop, % CurrentItemText.MaxIndex() {
			if (Col!=-1) && !(Contains(Col, A_Index, ",", A_Space A_Tab))
				continue
			if (InStr(CurrentItemText[A_Index], Text)) && ((Max=-1) || !(OuputVar.MaxIndex()>=Max)) {
				OuputVar.Push(LV_Add(, Items[CurrentItemIndex]*))
				break
	}}} if !(OuputVar.MaxIndex()) && (Text="") {
		Loop, % (Items.MaxIndex())
			LV_Add(, Items[A_Index]*)
	} return OuputVar, WinSetRedraw(hWnd=""?A_DefaultListView:hWnd)
}

;buscar elemento en el control que contenga el texto expesificado y lo selecciona.
;Sintaxis 1: LV_Search( [texto a buscar], [columnas separadas por coma, por defecto busca en todas], [hWnd control] )
;Return: 0 si no se encontraron items.
;Nota: usar SetTimer() para cuando haya muchos items.
LV_Search(Text, Col := -1) {
	static Func := Func("LV_SearchSelect")
	if !(LV_GetCount()>40) ||!XXX
		return LV_SearchSelect(Text, Col)
	return SetTimer(Func.Bind(Text, Col), -350)
} LV_SearchSelect(Text, Col) {
	return LV_SearchFind(Text, Col, 1) || LV_SearchFind(Text, Col, 0) || LV_SearchFind(Trim(Text), Col, 0)
} LV_SearchFind(Text, Col, CaseSensitive) {
	if !(Count:=LV_GetCount())
		return false
	Loop, % (Count)
		LV_Modify(A_Index, "-Select")
	Loop, % (Count) {
		RowNumber := A_Index
		Loop, % (LV_GetCount("Col")) {
			if !(Col=-1) && !(contains(Col, A_Index, ",", A_Space A_Tab))
				continue
			LV_GetText(CurrentItemText, RowNumber, A_Index)
			if (CurrentItemText="")
				continue
			if (InStr(CurrentItemText, Text, CaseSensitive))
				return RowNumber, LV_Modify(RowNumber, "+Select +Vis")
	}} return false
}

LV_SetItemState(hWnd, Item, State, Set := "*") {
	VarSetCapacity(LVITEM, A_PtrSize=4?60:72, 0), NumPut(0x00000008, LVITEM, 0, "UInt")
	, NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Set="*"?State:Set, LVITEM, 12, "UInt"), NumPut(State, LVITEM, 16, "UInt")
	return SendMessage(hWnd, 0x102B, "Int", Item-1,, &LVITEM)
}





























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: TREEVIEW CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;Obtener item
;Sintaxis: TV_GetNextItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773622%28v=vs.85%29.aspx
;Nota: espesificar 'CARET' para obtener el item seleccionado (3er parametro)
TV_GetNextItem(hWnd, Item := 0, Mode := "NEXT") {
	static Modes := {"CARET": 0x0009, "CHILD": 0x0004, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "LASTVISIBLE": 0x000A, "NEXT": 0x0001
	, "NEXTSELECTED": 0x000B, "NEXTVISIBLE": 0x0006, "PARENT": 0x0003, "PREVIOUS": 0x0002, "PREVIOUSVISIBLE": 0x0007, "ROOT": 0x0000}
	return SendMessage(hWnd, 0x110A, "UInt", Modes[Mode],, Item)
}

;obtiene la cantidad de items
;Sintaxis: TV_GetItemCount( [ID], [Modo] )
;Modos: ALL|SELECTED|VISIBLE
TV_GetItemCount(hWnd, Mode := "ALL") {
	if (Mode="ALL")
		return SendMessage(hWnd, 0x1105)
	else if (Mode="VISIBLE")
		return SendMessage(hWnd, 0x1110)
	else if (Mode="SELECTED") {
		ItemSelectedCount := 0
		while TV_GetNextItem(hWnd,, "NEXTSELECTED")
			ItemSelectedCount++
		return ItemSelectedCount
	} return 0, ErrorLevel := 1
}

;seleccionar item
;TV_SelectItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773736%28v=vs.85%29.aspx
TV_SelectItem(hWnd, Item := 0, Mode := "CARET") {
	static Modes := {"CARET": 0x0009, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "NOSINGLEEXPAND": 0x8000}
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x110B, "UInt", Modes[Mode],, Item-1)
}

;hacer visible un item
;TV_VisibleItem( [ID], [Item] )
TV_VisibleItem(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1114,,,, Item-1)
}

;editar etiqueta del item
;TV_EditLabel( [ID], [Item] )
TV_EditLabel(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1141,,,, Item-1)
}

;eliminar un item o 'todos (defecto)'
;Sintaxis: TV_DeleteItem( [ID], [Item] )
TV_DeleteItem(hWnd, Item := 0) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1101,,,, -65536)
	return SendMessage(hWnd, 0x1101,,,, Item-1)
}

;expandir/contraer/invertir items
;Sintaxis: TV_Expand( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773568%28v=vs.85%29.aspx
TV_Expand(hWnd, Item := 0, Mode := "EXPAND") {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	static Modes := {"COLLAPSE": 0x0001, "COLLAPSERESET": 0x8000, "EXPAND": 0x0002, "EXPANDPARTIAL": 0x4000, "TOGGLE": 0x0003}
	return SendMessage(hWnd, 0x1102, "UInt", Modes[Mode],, Item-1)
}

;cambiar nombre
;Sintaxis: TV_SetItemText( [ID], [texto], [Item] )
TV_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	, VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	, NumPut(0x0001, TVITEMEX, 0, "UInt"), NumPut(Item-1, TVITEMEX, 4, "Ptr")
	, NumPut(&NewText, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
	, NumPut(StrLen(NewText), TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
	return return SendMessage(hWnd, 0x113F,,,, &TVITEMEX)
}

;obtener nombre
;Sintaxis: TV_GetItemText( [ID], [Item] )
TV_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	, VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	, NumPut(0x0001, TVITEMEX, 0, "UInt"), NumPut(Item-1, TVITEMEX, 4, "Ptr")
    , VarSetCapacity(TVTEXT, 256 * 2, 0), NumPut(&TVTEXT, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
    , NumPut(256, TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
    , SendMessage(hWnd, 0x113E,,,, &TVITEMEX)
    return StrGet(NumGet(TVITEMEX, A_PtrSize = 4 ? 16 : 20, "UPtr"))
}
























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: TAB CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;obtener cantidad de items
;Sintaxis: TC_GetItemCount( [ID] )
TC_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1304)
}

;obtener posicion del item que tiene el foco o el item seleccionado.
;Sintaxis: TC_GetItemFocus( [ID], [¿seleccionado=true?] )
TC_GetItemFocus(hWnd, Selected := true) {
	return SendMessage(hWnd, Selected?0x130B:0x132F)+1
}

;obtener texto de un item
;Sintaxis: TC_GetItemText( [ID], [Item] )
TC_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	, VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	, NumPut(0x0001, TCITEM, 0, "UInt"), VarSetCapacity(TCTEXT, 256 * 2, 0)
	, NumPut(&TCTEXT, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	, NumPut(256, TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	, SendMessage(hWnd, 0x133C,, Item-1,, &TCITEM)
	return StrGet(NumGet(TCITEM, A_PtrSize = 4 ? 12 : 16, "UPtr"))
}

;cambiar texto de un item
;Sintaxis: TC_SetItemText( [ID], [Texto], [Item] )
TC_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	, VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	, NumPut(0x0001, TCITEM, 0, "UInt"), NumPut(&NewText, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	, NumPut(StrLen(NewText), TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	return SendMessage(hWnd, 0x133D,, Item-1,, &TCITEM)
}

;dar foco a un item o seleccionarlo
;Sintaxis: TC_SetItemFocus( [ID], [Item], [¿seleccionar?] )
;Notas: si se omite el 2do parametro, auto-selecciona el item anterior o 'siguiente si no hay anterior'.
TC_SetItemFocus(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		Item := ((i:=TC_GetItemFocus(hWnd, Select))-1)>0?i-1:(i=1?i+(TC_GetItemCount(hWnd)>1?1:0):1)
	return SendMessage(hWnd, Select?0x130C:0x1330,, Item-1)
}

;deselecciona todos los items o todos menos el item seleccionado
;Sintaxis: TC_Reset( [ID], [¿evitar deseleccionar el item seleccionado?] )
TC_Reset(hWnd, Mode := 0) {
	return SendMessage(hWnd, 0x1332,, Mode)
}

;eliminar un item, opcional seleccionar el anterior (o siguiente si no hay anterior)
;Sintaxis: TC_DeleteItem( [ID], [Item], [¿seleccionar el item anterior?] )
;Nota: dejar vacio el 2do parametro (o establecerlo <0) para eliminar todos los items.
TC_DeleteItem(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1309)
	i := SendMessage(hWnd, 0x1308,, Item-1)
	if Select
		TC_SetItemFocus(hWnd, ((Item-1)>0?(Item-1):1))
	return i, ErrorLevel := !i
}

;resalta el item
;Sintaxis: TC_HighlightItem( [ID], [Item], [Estado 0|1] )
TC_HighlightItem(hWnd, Item := 0, State := 1) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	return SendMessage(hWnd, 0x1333, "Int", Item-1, "Int", State)
}

;resalta la pestaña al posicionar el mouse por encima
TC_HighlightStyle(hWnd) {
	Control, Style, 0x54010040,, ahk_id %hWnd%
}






































 







/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: COMBOBOX & DROPDOWNLIST CONTROL ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
*/
;renombrar item
;Sintaxis: CB_SetText( [hWnd], [texto], [posición], [¿seleccionar item?] )
;Nota: si no espesifica el 3er parámetro, no se modifica ningún item, solo cambia el texto en el control.
CB_SetText(hWnd, Text := "", Index := 0, Select := false) {
	if !(Index)
		return ControlSetText(0, hWnd, Text)
	CB_DeleteString(hWnd, Index)
	return CB_AddString(hWnd, Text, Index), i:=Select?CB_SelectItem(hWnd, Index):""
}

;establece la señal textual que se muestra por el control de edición para pedir al usuario para obtener información
;Sintaxis: CB_SetCueBanner( [hWnd], [texto] )
CB_SetCueBanner(hWnd, Text := "") {
	Result := SendMessage(hWnd, 0x1703,,,, &Text)
	return (Result=1), ErrorLevel := (Result!=1)
}

;ajustar la altura del campo de selección o la altura de los elementos de lista.
;Sintaxis: CB_SetItemHeight( [hWnd], [Altura], [modo] )
;Modos: por defecto modifica ambos.
	;1 = modificar la altura del campo de selección.
	;2 = modificar  la altura de los elementos de lista.
CB_SetItemHeight(hWnd, Height, Mode := 3) {
	If (Mode=1)
		return !!(PostMessage(hWnd, 0x153, "Int", -1, "UInt", Height))
	if (Mode=2)
		return !!(PostMessage(hWnd, 0x153, "Int", 0, "UInt", Height))
	return r:=(CB_SetItemHeight(hWnd, Height, 1)+CB_SetItemHeight(hWnd, Height, 2)), ErrorLevel := (r!=2)
}

;seleccionar texto.
;Sintaxis: CB_SetEditSel( [hWnd], [inicio], [fin] )
;Uso:
	;Quitar seleccion: CB_SetEditSel(hWnd, -1, -1)
	;Seleccionar todo (defecto): CB_SetEditSel(hWnd, 1, -1)
	;Seleccionar parte del texto: CB_SetEditSel(hWnd, 3, 5)
CB_SetEditSel(hWnd, Start := 1, End := -1) {
	return r:=SendMessage(hWnd, 0x0142,,, "UInt", LOWORD(Start-1)+HIWORD(End-1, false)), ErrorLevel := !r
}

;---------------------------------------------------------------------------------------------------------------------

;limita el número de caracteres que el usuario puede ingresar en el control.
;Sintaxis: CB_LimitText( [hWnd], [caracteres máximos permitidos 1~2147483646] )
;Nota: el mensaje no afecta a los item en el control.
CB_LimitText(hWnd, Limit := 30000) {
	return SendMessage(hWnd, 0x0141, "UShort", Limit)
}

;selecciona el item por texto
;Sintaxis: CB_SelectString( [hWnd], [texto] )
;Nota: si se encuentra el item, devuelve la posición.
CB_SelectString(hWnd, Text) {
	List := []
	Loop, % (Count:=CB_GetCount(hWnd)) {
		if ((List[A_Index]:=CB_GetText(hWnd, A_Index))==Text) {
			Index := A_Index
			break
	}} if !(Index) {
		Loop, % (Count) {
			if (List[A_Index]=Text) {
				Index := A_Index
				break
	}}} Index := SendMessage(hWnd, 0x014D, "Int", Index?Index-1:-1,, &Text)
	return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}

;selecciona el item por posición
;Sintaxis: CB_SelectString( [hWnd], [posición] )
;Nota: si se encuentra el item, devuelve la posición.
;ErrorLevel: 1 = error | 2 = la posición ingresada es mayor al número de items
CB_SelectItem(hWnd, Pos) {
	if ((Count:=CB_GetCount(hWnd))<Pos)
		return false, ErrorLevel := 2
	Loop, % (Count) {
		if (A_Index=Pos) {
			Text := CB_GetText(hWnd, A_Index), Index := SendMessage(hWnd, 0x014D, "Int", A_Index-2,, &Text)
			return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}}}

;añadir item
;Sintaxis: CB_AddString( [hWnd], [texto], [posición], [¿seleccionar?] )
;Posición: si no se espesifica y el control no tiene el estilo CBS_SORT, se añade al final de la lista.
	;si se espesifica -1, se añade al final de la lista.
;Nota: devuelve la posición del item.
;ErrorLevel: 1 = error al añadir | 2 = espacio insuficiente.
CB_AddString(hWnd, Text := "", Pos := 0, Select := false) {
	Index := SendMessage(hWnd, Pos?0x014A:0x0143, Pos?"Int":"Ptr", Pos?(Pos=-1?-1:Pos-1):0,, &Text)
	return (Index=-1)||(Index=-2)?0:Index+1, i:=Select?CB_SelectItem(hWnd, Index+1):"", ErrorLevel := (Index=-1)?1:(Index=-2)?2:0
}

;eliminar item
;Sintaxis: CB_DeleteString( [hWnd], [indice] )
;Indice: espesificar -1 para eliminar todos los items (defecto).
;Nota: devuelve la cantidad de items restantes en el control.
CB_DeleteString(hWnd, Index := -1) {
	Index := SendMessage(hWnd, (Index=-1)?0x014B:0x0144, (Index=-1)?"Ptr":"Int", (Index=-1)?0:(Index-1))
	return Index, ErrorLevel := (Index=-1)
}

;obtiene la posición del item mediante el texto espesificado; ya sea exacto, desde una posición espesífica o contenido.
;Sintaxis: CB_FindString( [hWnd], [texto], [inicio] )
;Inicio: espesificar la posición en la que empezar la busqueda, al terminar, retoma desde el inicio.
	;por defecto (-1), busca desde el primer item.
;Nota: devuelve la posición del item.
CB_FindString(hWnd, Text, Pos := -1) {
	Count := CB_GetCount(hWnd), Pos := (Pos=-1)?-1:((Pos>Count)||(Pos<1)?-1:Pos)
	if !((Index:=SendMessage(hWnd, 0x0158, "Int", (Pos=-1)?-1:(Pos-1),, &Text))>-1) || (Count<Index) {
		if !((Index:=SendMessage(hWnd, 0x014C, "Int", (Pos=-1)?-1:(Pos-1),, &Text))>-1) || (Count<Index) {
			List := []
			Loop, % (Count:=CB_GetCount(hWnd)) {
				if (InStr(List[A_Index]:=CB_GetText(hWnd, A_Index), Text, true)) {
					Index := A_Index-1
					break
			}} if !(Index>-1) {
				Loop, % (Count) {
					if (InStr(List[A_Index], Text)) {
						Index := A_Index-1
						break
	}}}}} return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}

;---------------------------------------------------------------------------------------------------------------------

;recupera la cantidad de items en el control
;Sintaxis: CB_GetCount( [hWnd] )
CB_GetCount(hWnd) {
	return SendMessage(hWnd, 0x0146)
}

;obtiene el texto seleccionado, opcional la posición inicial y final del texto seleccionado
;Sintaxis: CB_GetSelected( [hWnd], [inicio], [fin] )
;Nota: si no hay texto seleccionado, el 2do y 3er parámetro devuelven la posición del cursor.
CB_GetSelected(hWnd, ByRef Start := "", ByRef End := "") {
	Pos := SendMessage(hWnd, 0x0140), Text := CB_GetText(hWnd)
	, Start := LOWORD(Pos)+1, End := HIWORD(Pos)+1
	return (Start=End)?"":StrTrimLeft(StrLeft(Text A_Space, End-1), Start-1)
}

;obtiene el texto actual o de un item.
;Sintaxis: CB_GetText( [hWnd], [posición] )
;Posición: por defecto (-1) obtiene el texto actual.
CB_GetText(hWnd, Index := -1) {
	if (Index=-1)
		return ControlGetText(0, hWnd)
	Length := SendMessage(hWnd, 0x0149, "Int", Index-1)
	, VarSetCapacity(Text, (Length * 2) + 1, 0)
	, SendMessage(hWnd, 0x0148, "Int", Index-1, "Str", Text)
	return Text
}





















































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: PROGRESS BAR CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece el valor mínimo y máximo.
;Sintaxis: PB_SetRange( [hWnd], [min], [max] )
PB_SetRange(hWnd, Min := 0, Max := 100) {
	Min := (Min>-1)?Min:0, Max := (Max>Min)?Max:(Min+1)
	return SendMessage(hWnd, 0x0406, "Int", Min, "Int", Max)
}

;establecer estado.
;Sintaxis: PB_SetState( [hWnd], [estado] )
;Estado: Normal | Error | Paused
PB_SetState(hWnd, State := 1) {
	if (State="Normal") || (State="N") || (State=1)
		return SendMessage(hWnd, 0x0410, "Int", 1)
	if (State="Error") || (State="E") || (State=2)
		return SendMessage(hWnd, 0x0410, "Int", 2)
	if (State="Paused") || (State="P") || (State=3)
		return SendMessage(hWnd, 0x0410, "Int", 3)
	return false, ErrorLevel := true
}

;establecer/incrementar/decrementar valor.
;Sintaxis: PB_SetPos( [hWnd], [+/- valor] )
;Devuelve: la posición anterior.
;Nota: si el valor está fuera del rango del control, la posición se establece en el límite más cercano.
PB_SetPos(hWNd, Value := "+10") {
	M := InStr(Value, "+"), L := InStr(Value, "-")
	if (M) || (L) ;+/-
		Pos := PB_GetPos(hWnd), Value := (M?(Pos+StrReplace(Value, "+")):(Pos-StrReplace(Value, "-")))
	return SendMessage(hWnd, 0x0402, "Int", Value)
}

;establece el color de la barra de indicador de progreso.
;Sintaxis: PB_SetBarColor( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB.
;Nota: devuelve el color anterior.
PB_SetBarColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x0409,,,, RGBToInt(_getcolor(Color))))
}

;establee el color de fondo de la barra de progreso.
;Sintaxis: PB_SetBKColor( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB.
;Nota: devuelve el color anterior.
PB_SetBKColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x2001,,,, RGBToInt(_getcolor(Color))))
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;establece la barra de progreso para el modo de marquesina. esto hace que la barra de progreso para moverse como una marquesina.
;Sintaxis: PB_SetMarquee( [hWnd], [0|1], [retraso, en milisegundos] )
PB_SetMarquee(hWnd, State := true, Delay := 0) {
	WinSetStyle(hWnd, (State?"+":"-") 0x08)
	return SendMessage(hWnd, 0x040A, "Int", !!State, "UInt", (Delay>-1)?Delay:0)
}

;muestra el progreso en una barra de desplazamiento suave.
;Sintaxis: PB_SetSmooth( [hWnd], [0|1], [¿reverse?] )
;Reverse: el comportamiento de animación que la barra de progresa lo utiliza cuando se mueve hacia atrás
PB_SetSmooth(hWnd, State := true, Reverse := false) {
	Pos := PB_GetPos(hWnd), r:=WinSetStyle(hWnd, (State?"+":"-") (Reverse?0x10:0x01))
	return r, PB_SetPos(hWnd, Pos), ErrorLevel := !r
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;obtener el valor minimo y maximo.
;Sintaxis: PB_GetRange( [hWnd], [min (out)], [max (out)] )
;Nota: devuelve un Array con los valores [min, max].
PB_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	VarSetCapacity(PBRANGE, 8, 0), SendMessage(hWnd, 0x0407,,,, &PBRANGE)
	return [Min:=NumGet(PBRANGE, 0, "Int"), Max:=NumGet(PBRANGE, 4, "Int")]
}

;obtener estado.
;Sintaxis: PB_GetState( [hWnd] )
;Devuelve: Normal | Error | Paused
PB_GetState(hWnd) {
	State := SendMessage(hWnd, 0x0411)
	return (r:=(State=1)?"Normal":(State=2)?"Error":(State=3)?"Paused":""), ErrorLevel := !r
}

;obtener valor.
;Sintaxis: PB_GetPos( [hWnd] )
PB_GetPos(hWnd) {
	return SendMessage(hWnd, 0x0408)
}

;obtiene el color RGB de la barra de indicador de progreso.
;Sintaxis: PB_GetBarColor( [hWnd] )
PB_GetBarColor(hWnd) {
	return RGB(SendMessage(hWnd, 0x040F))
}

;obtiene el color RGB de fondo de la barra de progreso.
;Sintaxis: PB_GetBKColor( [hWnd] )
PB_GetBKColor(hWnd) {
	return RGB(SendMessage(hWnd, 0x040E))
}
























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: SLIDER CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establecer posicion
;Sintaxis: TB_SetPos( [hWnd], [valor], [¿redibujar?] )
TB_SetPos(hWnd, Value, Redraw := true) {
	return SendMessage(hWnd, 0x0405, "Int", !!Redraw, "Int", Value)
}

;establecer valor minimo y maximo.
;Sintaxis: TB_SetRange( [hWnd], [min], [max], [¿redibujar?] )
TB_SetRange(hWnd, Min := 0, Max := 100, Redraw := true) {
	Min := (Min>-1)?Min:0, Max := (Max>Min)?Max:(Min+1)
	return SendMessage(hWnd, 0x0406, "Int", !!Redraw,, LOWORD(Min)+HIWORD(Max, false))
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;obtener posicion
;Sintaxis: TB_GetPos( [hWnd] )
TB_GetPos(hWnd) {
	return SendMessage(hWnd, 0x0400)
}

;obtener valor minimo y maximo.
;Sintaxis: TB_GetRange( [hWnd], [min (out)], [max (out)] )
;Nota: devuelve un Array [min, max].
TB_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	return [Min:=SendMessage(hWnd, 0x0401), Max:=SendMessage(hWnd, 0x0402)]
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: UPDOWN CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece el control "compañero"
;Sintaxis: UD_SetBuddy( [hWnd], [hWnd compañero] )
;Nota: devuelve el hWnd del compañero anterior
UD_SetBuddy(hWnd, Buddy) {
	return SendMessage(hWnd, 0x0469,, Buddy)
}

;establece el rango minimo y maximo
;Sintaxis: UD_SetRange( [hWnd], [min -2147483648], [max 2147483647] )
;Nota: dejar vacío para no modificar
UD_SetRange(hWnd, Min := "", Max := "") {
	if (Min="") || (Max="")
		UD_GetRange(hWnd, mi, ma)
	SendMessage(hWnd, 0x046F, "Int", Min=""?mi:Min, "Int", Max=""?ma:Max)
	return !ErrorLevel
}

;------------------------------------------------------------------------------------------------------------------------------------------

;obtiene el hWnd del control "compañero"
;Sintaxis: UD_GetBuddy( [hWnd] )
UD_GetBuddy(hWnd) {
	return SendMessage(hWnd, 0x046A)
}

;recupera el rango minimo y maximo
;Sintaxis: UD_GetRange( [hWnd], [min (out)], [max (out)] )
UD_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	VarSetCapacity(Min, 16, 0), VarSetCapacity(Max, 16, 0)
	, SendMessage(hWnd, 0x0470,, &Min,, &Max)
	return [Min:=NumGet(Min, 0, "Int"), Max:=NumGet(Max, 0, "Int")]
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: GUI & DIALOGOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;MessageBox
;Sintaxis: MsgBox( [opciones], [titulo], [texto], [tiempo fuera] )
;NOTA: la variable global A_MsgBoxResult contiene el resultado.
;EJEMPLO:
	;MsgBox % "Resultado: " MsgBox() "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(0) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox("") "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(4112, "ERROR!",, 1 ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(20, "Título" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(34,, "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(16694, "Título", "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
MsgBox(Info*) {
	global A_MsgBoxResult
	if !(Info.MaxIndex())
		MsgBox, 0, *, Press OK to continue., % Info[4]
	else if (Info[1]!=""&&Info[2]=""&&Info[3]="")
		MsgBox, 0, *, % Info[1], % Info[4]
	else MsgBox, % Info[1], % Info[2]=""?"*":Info[2], % Info[3], % Info[4]
	Loop, Parse, % "Yes,No,Ok,Cancel,Abort,Ignore,Retry,Timeout,Continue,TryAgain", `,
		IfMsgBox, %A_LoopField%
			return ErrorLevel:=A_MsgBoxResult:=A_LoopField
} MsgBoxEx(l*) {
	static r := {3: "Abort", 2: "Cancel", 11: "Continue", 5: "Ignore", 7: "No", 1: "OK", 4: "Retry", 10: "TryAgain", 6: "Yes"} ;1: "Timeout"
	if !(l.MaxIndex())
		return r[DllCall("User32.dll\MessageBoxTimeoutW", "Ptr", 0, "Str", "Press OK to continue.", "Str", "*", "UInt", 0, "Short", 0, "UInt", l[4]=""?0xFFFFFFFF:l[4])]
	if (l[1]!="") && (l[2]="") && (l[3]="")
		return r[DllCall("User32.dll\MessageBoxTimeoutW", "Ptr", 0, "Str", l[3], "Str", "*", "UInt", 0, "Short", 0, "UInt", l[4]=""?0xFFFFFFFF:l[4])]
	return r[DllCall("User32.dll\MessageBoxTimeoutW", "Ptr", 0, "Str", l[3], "Str", l[2], "UInt", l[1], "Short", 0, "UInt", l[4]=""?0xFFFFFFFF:l[4])]
}

;Sintaxis: ToolTip( [texto], [xpos], [ypos], [tiempo fuera, en segundos] )
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
ToolTip(Text := "", xpos := "", ypos := "", TimeOut := 0) {
	static ToolTip := Func("ToolTip").Bind()
	SetTimer(ToolTip, "Off")
	if (Text="") {
		ToolTip,,,, 20
	} else {
		ToolTip, %Text%, %xpos%, %ypos%, 20
		if (TimeOut)
			SetTimer(ToolTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
}}

;cambiar fuente y color de los ToolTips.
;Sintaxis 1: ToolTipFont( [opciones], [fuente] )
;Sintaxis 2: ToolTipColor( [color de fondo], [color del texto] )
ToolTipFont(Options := "", FontName := "", hWnd := "") {
    static hFont := 0
	if (hWnd)
		SendMessage, 0x30, hfont, 0,, ahk_id %hwnd%
	else  hfont := Options="Default"?0:ToolTipChange("Font", Options, FontName), ToolTipHook()
} ToolTipColor(Background := "", Text := "", hWnd := "") {
    static bc := "", tc := ""
    if !(hWnd)
		bc := ((Background="")||(Background="Default"))?"":ToolTipChange("Color", Background)
		, tc := ((Text="")||(Text="Default"))?"":ToolTipChange("Color", Text), ToolTipHook()
    else {
        VarSetCapacity(empty, 2, 0)
        , DllCall("UxTheme.dll\SetWindowTheme", "Ptr", hWnd, "Ptr", 0, "Ptr", ((bc!="")||(tc!=""))?&empty:0)
        if (bc!="")
            SendMessage, 1043, %bc%,,, ahk_id %hWnd%
        if (tc!="")
            SendMessage, 1044, %tc%,,, ahk_id %hWnd%
}} ToolTipHook() {
    static hook := 0
    if !(hook)
        hook := DllCall("User32.dll\SetWindowsHookExW", "Int", 4
            , "Ptr", RegisterCallback("ToolTipWndProc", "Fast", 3), "Ptr", 0
            , "UInt", DllCall("Kernel32.dll\GetCurrentThreadId"), "Ptr")
} ToolTipWndProc(nCode, _wp, _lp) {
    Critical, 999 ;lParam  := NumGet(_lp+0*A_PtrSize) | wParam  := NumGet(_lp+1*A_PtrSize)
    uMsg    := NumGet(_lp+2*A_PtrSize), hWnd    := NumGet(_lp+3*A_PtrSize)
    if ((nCode>=0) && ((uMsg=1081) || (uMsg=1036)) && WinExist("ahk_class tooltips_class32 ahk_id " hWnd))
        ToolTipColor(,, hwnd), ToolTipFont(,, hwnd)
    return DllCall("User32.dll\CallNextHookEx", "Ptr", 0, "Int", nCode, "Ptr", _wp, "Ptr", _lp, "Ptr")
} ToolTipChange(Cmd, Arg1, Arg2 := "") {
    static htext := 0, hgui := 0, hWnd := 0
    if !htext {
		Gui, New:+HWNDhWnd +E0x20 +0x40000000
        Gui, %hWnd%: Add, Text, +hwndhtext
    } Gui %hWnd%: %Cmd%, %Arg1%, %Arg2%
    if (Cmd = "Font") {
        GuiControl, Font, %htext%
        SendMessage, 0x31, 0, 0,, ahk_id %htext%
        return ErrorLevel
    } if (Cmd = "Color") {
        hdc := DllCall("User32.dll\GetDC", "ptr", htext, "ptr")
        SendMessage, 0x138, hdc, htext,, ahk_id %hWnd%
        clr := DllCall("Gdi32.dll\GetBkColor", "ptr", hdc, "uint")
        , DllCall("User32.dll\ReleaseDC", "ptr", htext, "ptr", hdc)
        return clr
}} ;http://ahkscript.org/boards/viewtopic.php?p=55014#p55014

;muestra un mensaje cerca del icono del área de notificacion.
;Sintaxis: TrayTip( [titulo], [texto], [tiempo fuera, en segundos], [opciones] )
;OPCIONES:
	;0 = sin icono | 1 = Info (defecto) | 2 = Advertencia | 3 = Error | M/16 = sin sonido (0M, 1M, 2M, 3M, 3+16, etc...)
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
TrayTip(Title := "", Text := "", TimeOut := 0, Options := 1) {
	static x
	static TrayTip := Func("TrayTip").Bind()
	if !(x)
		RegWrite("REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "EnableBalloonTips", 2)
		, RegWrite("REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "Start_NotifyNewApps", x:=1)
	SetTimer(TrayTip, "Off")
	if (Text="") && (Title="") {
		TrayTip
	} else {
		TrayTip, %Title%, %Text%, 30, % RegExReplace(Options, "[^0-9]")+(InStr(Options, "M")?16:0)
		if (TimeOut)
			SetTimer(TrayTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
}}

;color para los controles
;conversor de colores: http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
;Sintaxis: GuiControlColor( [control], [color del texto], [color de fondo] )
GuiControlColor( ControlId, TextColor := "Black", BackgroundColor := "White", Force := 0 ) {
	if (Force)
		CtlColors.Detach(ControlId)
	CtlColors.Change(ControlId, BackgroundColor, TextColor)
} 

GuiControlGetHwnd(ControlId) {
	GuiControlGet, hWnd, HWND, %ControlId%
	return hWnd ? hWnd : ControlId
}

GuiControlSetFont(hWnd, Type, Font) {
   Gui, Font, %Type%, %Font%
   GuiControl, Font, %hWnd%
}

;dialogo Abrir Con...
;Sintaxis: OpenWithDialog( [owner window hwnd], [archivo] )
OpenWithDialog(hWnd, Filename) {
	VarSetCapacity(OPENASINFO,  (StrLen(Filename) * 2) + 4, 0)
	, NumPut(&Filename, OPENASINFO, 0, "Ptr"), NumPut(5, OPENASINFO, 2 * A_PtrSize)
	, r := DllCall("Shell32.dll\SHOpenWithDialog", "Ptr", hWnd, "Ptr", &OPENASINFO)
	if (ErrorLevel)
		return DllCall("shell32\OpenAs_RunDLLW", "Ptr", hWnd, "UInt", 0, "WStr", Filename)
	return r>0, ErrorLevel := r<0
}


































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: LISTA DE IMÁGENES (ImageList), IMÁGENES & ICONOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;elimina una lista de imágenes 
;Sintaxis: IL_Destroy( [ID] )
IL_Destroy(ImageList) {
	return (r:=DllCall("Comctl32.dll\ImageList_Destroy", "Ptr", ImageList)), ErrorLevel := !r
}

;elimina una imagen de una lista de imágenes
;Sintaxis: IL_Remove( [ID], [Posición] )
;NOTA: si el segundo parametro es 0, elimina todas las imágenes
IL_Remove(ImageList, Pos := 0) {
	return (r:=DllCall("ComCtl32.dll\ImageList_Remove", "Ptr", ImageList, "Int", (Pos - 1))), ErrorLevel := !r
}

;crea una lista de imágenes 
;Sintaxis: IL_Create( [cantidad inicial], [aumento al pasar el limite], [¿iconos grandes?], [ancho], [alto] )
IL_Create(InitialCount := 2, GrowCount := 5, LargeIcons := false, cx := 0, cy := 0) {
	static SM_CXICON, SM_CXSMICON, SM_CYICON, SM_CYSMICON
	!(SM_CXICON)?(SM_CXICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 11)): ;el ancho predeterminada de un icono, en píxeles.
	!(SM_CXSMICON)?(SM_CXSMICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 49)): ;el ancho recomendado de un icono pequeño, en píxeles.
	!(SM_CYICON)?(SM_CYICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 12)): ;la altura predeterminada de un icono, en píxeles.
	!(SM_CYSMICON)?(SM_CYSMICON:=DllCall("User32.dll\GetSystemMetrics", "Int", 50)): ;la altura recomendada de un icono pequeño, en píxeles.
	, i := DllCall("Comctl32.dll\ImageList_Create", "UInt", ((cx>0)?cx:(LargeIcons?SM_CXICON:SM_CXSMICON)) ;el ancho en píxeles de las imagenes.
		, "UInt", ((cy>0)?cy:(LargeIcons?SM_CYICON:SM_CYSMICON)) ;la altura en píxeles de las imagenes.
		, "UInt", 0x00000001|0x00000020 ;opciones
		, "Int", InitialCount ;el número de imágenes que la lista de imágenes contiene inicialmente.
		, "Int", GrowCount) ;el número de iconos por el que la lista crecerá cada ves que se supere el limite.
	return i, ErrorLevel := !i
}

;crea un duplicado de una lista de imágenes existente
;Sintaxis: IL_Duplicate( [ID] )
IL_Duplicate(ImageList) {
	return (r:=DllCall("Comctl32.dll\ImageList_Duplicate", "Ptr", ImageList)), ErrorLevel := !r
}

;recupera el número de imágenes en una lista de imágenes
;Sintaxis: IL_GetCount( [ID] )
IL_GetCount(ImageList) {
	return (r:=DllCall("ComCtl32.dll\ImageList_GetImageCount", "Ptr", ImageList)), ErrorLevel := !r
}

;recupera las dimensiones de las imágenes en una lista de imágenes
;NOTA: todas las imágenes tienen las mismas dimensiones
;Sintaxis: IL_GetSize( [ID], [Ancho, en pixeles], [Alto, en pixeles] )
IL_GetSize(ImageList, ByRef Width := "", ByRef Height := "") {
	i := DllCall("ComCtl32.dll\ImageList_GetIconSize", "Ptr", ImageList, "IntP", Width, "IntP", Height)
	, s := {}, s.h := s.Height := Height, s.w := s.Width := Width
	return s, ErrorLevel := !i
}

;obtener HANDLE de una imagen en la lista de imagenes
;Sintaxis: IL_GetIcon( [ID], [Indice], [estilo de dibujo] )
;Estilos de dibujo: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761533(v=vs.85).aspx
IL_GetIcon(ImageList, Index := 1, Flags := 0x0) {
	return r:=DllCall("Comctl32.dll\ImageList_GetIcon", "Ptr", ImageList, "Int", Index-1, "UInt", Flags), ErrorLevel := !r
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------------------------------------------------

;obtener ancho y alto de una imagen
;Sintaxis: ImageGetDimension( [imagen], [ancho (out)], [alto (out)] )
ImageGetDimension(Image, ByRef Width := "", ByRef Height := "") {
	if !(GetModuleHandle("Gdiplus"))
		pToken := Gdip_Startup()
	pBitmap := Gdip_CreateBitmapFromFile(Image), pGraphics := Gdip_GraphicsFromImage(pBitmap)
	, x:=Gdip_GetImageDimensions(pBitmap, Width, Height), Gdip_DeleteGraphics(pGraphics)
	, Gdip_DisposeImage(pBitmap), i := {}, i.w := i.Width := Width, i.h := i.Height := Height
	if (pToken)
		Gdip_Shutdown(pToken)
	return i, ErrorLevel := !x
}

;convertir imágenes
;Sintaxis: ImageConvert( [imagen], [directorio\nombre.ext], [ancho], [alto], [¿preservar la relacion de aspecto?], [profundidad de bits 24/32 (solo .bmp)] )
;Extensiones soportadas: png, bmp, jpg, tiff, gif
ImageConvert(Image, Output := "", Width := "", Height := "", PreserveAspectRatio := true, BitDepth := 32) {
	if !(GetModuleHandle("Gdiplus"))
		pToken := Gdip_Startup()
	SplitPath, Output, NewImgDir, NewImgExt
	pBitmapFile := Gdip_CreateBitmapFromFile(Image)
	, CurrentWidth := Gdip_GetImageWidth(pBitmapFile), CurrentHeight := Gdip_GetImageHeight(pBitmapFile)
	, NewWidth := Width=""?CurrentWidth:Width, NewHeight := Height=""?CurrentHeight:Height
	if (PreserveAspectRatio) && ((r1:=CurrentWidth/NewWidth)>(r2:=CurrentHeight/NewHeight))
		NewHeight := CurrentHeight/r1
	else if (PreserveAspectRatio)
		NewWidth := CurrentWidth/r2
	if !(FileExist(NewImgDir))
		FileCreateDir, %NewImgDir%
	pBitmap := Gdip_CreateBitmap(NewWidth, NewHeight, NewImgExt="bmp"&&BitDepth=24?0x00021808:0x26200A)
	, pGraphics := Gdip_GraphicsFromImage(pBitmap), Gdip_SetSmoothingMode(pGraphics, 4), Gdip_SetInterpolationMode(pGraphics, 7)
	, Gdip_DrawImage(pGraphics, pBitmapFile, false, false, NewWidth, NewHeight), Gdip_DisposeImage(pBitmapFile)
	, Gdip_SaveBitmapToFile(pBitmap, Output), Gdip_DisposeImage(pBitmap), Gdip_DeleteGraphics(pGraphics) 
	if (pToken)
		Gdip_Shutdown(pToken)
	return true
} ;http://ahkscript.org/boards/viewtopic.php?f=6&p=49878&sid=8974c43be898318cea6b8dc509f2e6df#p49878

;----------------------------------------------------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------------------------------------------------

;extraer icono
;Sintaxis 1: ExtractIcon( [archivo], [índice | -1 para eliminar | 0 para obtener el número de iconos] )
;Sintaxis 2:ExtractIconEx( [archivo], [indice], [ancho], [alto] )
ExtractIcon(Icon, Index := 1) {
	if (Index=-1)
		return r:=DllCall("User32.dll\DestroyIcon", "UPtr", Icon), ErrorLevel := !r
	if !(hIcon:=DllCall("Shell32.dll\ExtractIconW", "Ptr", A_ScriptHwnd, "Str", Icon, "UInt", Index-1))
		hIcon := ExtractIconEx(Icon, Index)
	return hIcon, ErrorLevel := !hIcon
} ExtractIconEx(Icon, Index := 1, Width := 16, Height := 16) {
	r := DllCall("User32.dll\PrivateExtractIconsW", "Str", Icon, "Int", Index-1, "Int", Width, "Int", Height, "UIntP", hIcon, "UInt", 0, "UInt", 1, "UInt", 0)
	return hIcon, ErrorLevel := !r || (r=0xFFFFFFFF)
} ExtractIcon2(Icon, Index := 1, LargeIcons := false) {
	ImageList := IL_Create(1, 1, !!LargeIcons), IL_Add(ImageList, Icon, Index)
	return IL_GetIcon(ImageList, Index), IL_Destroy(ImageList)
}

;extraer icono pequeño/grande
;Sintaxis: DefExtractIcon( [archivo], [indice], [icono pequeño (out)], [icono grande (out)] )
DefExtractIcon(IconFile, Index := 1, ByRef iconSmall := "", ByRef iconLarge := "") {
	r:=DllCall("Shell32.dll\SHDefExtractIconW", "Ptr", &IconFile, "Int", Index-1, "UInt", 0, "PtrP", iconSmall, "PtrP", iconLarge, "UInt", 0)
	return !r, ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762149(v=vs.85).aspx

;duplicar icono
DuplicateIcon(hIcon) {
	return r:=DllCall("Shell32.dll\DuplicateIcon", "Ptr", A_ScriptHwnd, "Ptr", hIcon), ErrorLevel := !r
}












































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: CONTROL ::::::::::::::::::::::::::::::::::
NOTAS:
	• espesificar -1 en el 2do parametro para referirse al control que tiene el foco en la ventana espesificada.
	• espesificar -2 en el 2do parametro para referirse al control bajo el cursor.
	• espesificar -3 en el 2do parametro para referirse al último control espesificado.
	• el 1er parametro (hWnd) solo es necesario si se epesifica la claseN del control (Ej. Static1) en el 2do.
	• Parámetros:
		;--> hWnd = hWnd/ID de la ventana que contiene el control.
		;--> Control = hWnd o nombre (classN) del control.
#############################################################################################################################################
*/
;destruir control en una ventana creada por el script
;Sintaxis: ControlDestroy( [hWnd], [control] )
;Nota: para destruir todos los controles en una ventana, usar WinDestroy( [hWnd], true)
ControlDestroy(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinDestroy(Control)
}

;obtener posicion
;Sintaxis: ControlGetPos( [hWnd], [control], [x], [y], [ancho], [alto] )
ControlGetPos(hWnd, Control, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	_gethwnd(hWnd, Control)
	ControlGetPos, x, y, Width, Height,, ahk_id %Control%
	i := {}, i.w := i.Width := Width, i.h := i.Height := Height, i.x := x, i.y := y
	return i
}

;enviar pulsaciones de teclas a un control
;Sintaxis: ControlSend( [hWnd], [Control], [Teclas], [Repeticiones], [retraso (ms)] )
ControlSend(hWnd, Control, Keys, Count := 1, Delay := -2) {
	_gethwnd(hWnd, Control)
	if !(ok := 0) AND (Count <= 1) {
		ControlSend,, %Keys%, ahk_id %Control%
		return !ErrorLevel, Sleep(Delay)
	} Loop, %Count%
		ok += ControlSend(hWnd, Control, Keys,, A_Index=Count?-2:Delay)
	return ok=Count?Control:false, ErrorLevel := ok=Count?false:true
} ControlSendRaw(hWnd, Control, Text, Count := 1, Delay := -2) {
	return ControlSend(hWnd, Control, "{raw}" Text, Count, Delay)
}

;establece foco en un control
;Sintaxis: ControlFocus( [hWnd], [Control] )
ControlFocus(hWnd, Control) {
	_gethwnd(hWnd, Control), CurrentThreadId := ProcessExist(-2), WinGetPID(hWnd, WinThreadId)
	, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", true)
	return (i:=DllCall("User32.dll\SetFocus", "Ptr", Control))?Control:false
		, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", false)
		, ErrorLevel := !i
}

;establecer texto
;Sintaxis: ControlSetText( [hWnd], [Control], [Texto] )
ControlSetText(hWnd, Control, NewText := "") {
	_gethwnd(hWnd, Control)
	return SendMessage(Control, 0x000C,,, "Str", NewText)?Control:false
}

;obtener texto
;Sintaxis: ControlGetText( [hWnd], [Control] )
ControlGetText(hWnd, Control) {
	_gethwnd(hWnd, Control), Size := SendMessage(Control, 0x000E)
	, VarSetCapacity(Text, (Size+1) * 2)
	, SendMessage(Control, 0x000D, "UInt", Size + 1, "Str", Text)
	return Text
} 

;recupera el control que tiene el foco, si lo hay.
;Sintaxis: ControlGetFocus( [hWnd] )
ControlGetFocus(hWnd) {
	_gethwnd(hWnd)
	ControlGetFocus, OutputVar, ahk_id %hWnd%
	return OutputVar
}

;comprueba si un control existe en una ventana espesifica.
;Sintaxis: ControlExist( [hWnd], [control] )
;Nota: devuelve el id del control.
ControlExist(hWnd, Control) {
	_gethwnd(hWnd)
	ControlGet, ControlId, hWnd,, %Control%, ahk_id %hWnd%
	return ControlId?ControlId:Control
}

;enviar un boton del raton o evento de la rueda.
;Sintaixs: ControlClick( [hWnd], [control], [left|right|middle|wheelleft|wheelright], [clics], [opciones] )
ControlClick(hWnd, Control, WhichButton := "LEFT", ClickCount := 1, Options := 0) {
	_gethwnd(hWnd, Control)
	ControlClick,, ahk_id %Control%,, %WhichButton%, %ClickCount%, %Options%
	return ErrorLevel?false:Control
}

;mover control
;Sintaxis: ControlMove( [hWnd], [control], [x], [y], [ancho], [alto] )
ControlMove(hWnd, Control, x := "", y := "", Width := "", Height := "", Redraw := false) {
	_gethwnd(hWnd, Control)
	ControlMove,, %x%, %y%, %Width%, %Height%, ahk_id %Control%
	Error := ErrorLevel
	if (Redraw)
		WinRedraw(Control)
	return Error?false:Control, ErrorLevel := Error
}

;hace una variedad de cambios en un control.
;Sintaxis: Control( [hWnd], [control], [comando], [valor] )
Control(hWnd, Control, Cmd, Value) {
	_gethwnd(hWnd, Control)
	if (Cmd="TabSelect")
		SendMessage(Control, 0x1330,, Value), ErrorLevel := !SendMessage(Control, 0x130C,, Value)
	else Control, %Cmd%, %Value%,, ahk_id %Control%
	return ErrorLevel?false:Control
}

;deshabilitar control
;Sintaxis: ControlDisable( [hWnd], [Control] )
ControlDisable(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinDisable(Control)
}

;habilitar control
;Sintaxis: ControlEnable( [hWnd], [Control] )
ControlEnable(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinEnable(Control)
} 

;determina si el control está habilitado
;Sintaxis: ControlEnabled( [hWnd], [Control] )
ControlEnabled(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinEnabled(Control)
}

;ocultar control
;Sintaxis: ControlHide( [hWnd], [Control] )
ControlHide(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinHide(Control)
}

;mostrar control
;Sintaxis: ControlShow( [hWnd], [Control] )
ControlShow(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinShow(Control)
}

;determina si el control es visible
;Sintaxis: ControlVisible( [hWnd], [Control] )
ControlVisible(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinVisible(Control)
}

;redibujar control
;Sintaxis: ControlRedraw( [hWnd], [Control] )
ControlRedraw(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinRedraw(Control)
}

;cambiar la fuente de un control
;Sintaxis: ControlSetFont( [hWnd], [control], [fuente], [¿redibujar?] )
;Fuente: crear la fuente con FontCreate()
;EJEMPLO:
	;Gui, Add, Edit, x15 y45 w465 h395 HWNDhWnd, Fuente ~ Edit Control, AutoHotKey %A_AhkVersion%
	;ControlSetFont(0, hWnd, FontCreate("Times New Roman", 17, true, true, true, 5))
	;Gui, Show, w500 h500
	;return
	;GuiEscape:
	;GuiClose:
	;ExitApp
ControlSetFont(hWnd, Control, hFont := "", Redraw := false) {
	_gethwnd(hWnd, Control)
	return SendMessage(Control, 0x30,, hFont,, !!Redraw)
}

;obtiene la fuente del control
;Sintaxis: ControlGetFont( [hWnd], [control] )
;NOTA: devuelve un array con la informacion, en el siguiente orden:
	;["", Tamaño, Negrita 400|600|700|XXX, Cursiva 0|1, Subrayado 0|1, Tachado 0|1]
;EJEMPLO: ver Edit_SelectFont()
ControlGetFont(hWnd, Control) {
	_gethwnd(hWnd, Control)
	, hFont := SendMessage(Control, 0x31), OutPutVar := []
	, hDC := DllCall("Gdi32.dll\CreateDC", "Str", "DISPLAY", "Ptr", 0, "Ptr", 0, "Ptr", 0)
    , LogPixelsY := DllCall("Gdi32.dll\GetDeviceCaps", "Ptr", hDC, "Int", 90)
	, DllCall("Gdi32.dll\DeleteDC", "Ptr", hDC), pTM := FontGetMetrics(hFont, Size)
	, OutPutVar[1] := "", OutPutVar[2] := Size/LogPixelsY
	, OutPutVar[3] := NumGet(pTM+0, 28, "Int"), OutPutVar[4] := NumGet(pTM+0, 52, "UChar")
	, OutPutVar[5] := NumGet(pTM+0, 53, "UChar"), OutPutVar[6] := NumGet(pTM+0, 54, "UChar")
	return OutPutVar
}

;cambiar color del texto y fondo de un control
;Sintaxis: ControlSetColor( [hWnd], [Control], [color del texto, nombre o RGB], [color de fondo, nombre o RGB] )
;NOTA: necesario CtlColors_Class
ControlSetColor(hWnd, Control, TC := "Black", BG := "White") {
	_gethwnd(hWnd, Control)
	return CtlColors.Change(Control, Hex(_getcolor(BG), 6,, ""), Hex(_getcolor(TC), 6,, ""))
}

;cambiar cursor al posicionar el cursor sobre el control espesificado
;Sintaxis: ControlSetCursor( [hWnd], [Control], [cursor] )
;Cursor: ver funcion.
;Ejemplo:
	;Gui, Add, Edit, hwndhEdit Limit11 x2 w247, Activado
	;Gui, Add, Button, hWndhButton1 x2 gButton1 w247, Desactivar
	;Gui, Add, Button, hWndhButton2 x2 gButton2 w247, Activar
	;Gui, Show, w250
	;ControlSetCursor(0, hEdit, "Hand"), ControlSetCursor(0, hButton1, "CrossHair"), ControlSetCursor(0, hButton2, "CrossHair")
	;return
	;GuiClose:
	;GuiEscape:
	;ExitApp
	;return
	;Button2:
	;Button1:
	;ControlSetCursor(0, hEdit, (A_ThisLabel="Button1")?-1:"Hand")
	;ControlSetText(0, hEdit, (A_ThisLabel="Button1")?"Desactivado":"Activado")
	;return
ControlSetCursor(hWnd, Control, CursorType := -1) {
	static List := []
	static CursorTypes := {-1: -1, "Hand": 32649 ;mano
		, "Arrow": 32512 ;flecha normal
		, "AppStarting": 32650 ;flecha cargando
		, "CrossHair": 32515 ;cruz
		, "Help": 32651 ;ayuda (signo de interrogación)
		, "Edit": 32513 ;barra vertical (de edición)
		, "No": 32648, "Slashed": 32648 ;circulo (bloqueado)
		, "SizeAll": 32646 ;redimencionar (norte, sur, este, oeste)
		, "SizeNESW": 32643 ;redimencionar (noreste, sodoeste)
		, "SizeNS": 32645 ;redimencionar (norte, sur)
		, "SizeNWSE": 32642 ;redimencionar (sodoeste, noreste) <---
		, "SizeEWE": 32644 ;redimencionar (este, oeste)
		, "UpArrow": 32516 ;flecha hacia arriba.
		, "Wait": 32514} ;cargando
	_gethwnd(hWnd, Control)
	if !(IsWindow(Control)) || !(CursorTypes[CursorType])
		return false, ErrorLevel := true
	if (CursorType=-1)
		return List.Delete(Control), !(List.MaxIndex())?(OnMessage(0x200, "") OnMessage(0x2A1, "")):, Set(A_ThisFunc, List)
	Set(A_ThisFunc, List), List[Control] := DllCall("User32.dll\LoadCursorW", "Ptr", 0, "Int", CursorTypes[CursorType])
	return OnMessage(0x200, "ControlSetCursor_OnMouseMove"), OnMessage(0x2A1, "ControlSetCursor_OnMouseHover")
} ControlSetCursor_OnMouseMove(wParam, lParam, Msg, hWnd) {
    static TrackWnd, TrackPos
    if (TrackWnd=hWnd) && (TrackPos=lParam)
        return
    VarSetCapacity(ET, 16), NumPut(16   , ET,  0), NumPut(0x3  , ET,  4), NumPut(hwnd , ET,  8), NumPut(50 , ET, 12)
    , TrackWnd := hwnd, TrackPos := lParam, DllCall("User32.dll\TrackMouseEvent", "Ptr", &ET)
} ControlSetCursor_OnMouseHover() {
	static State := []
	MouseGetPos(x, y, w, c, 2)
	if (hWnd:=Get("ControlSetCursor")[c]) {
		DllCall("User32.dll\SetCursor", "Ptr", hWnd)
	} else CursorReload()
}

;permitir/bloquear el redibujado de un control
;Sintaxis: ControlSetRedraw( [hWnd], [control], [0|1] )
ControlSetRedraw(hWnd, Control, Redraw := true) {
	_gethWnd(hWnd, Control)
	return WinSetRedraw(Control, Redraw)
}

;cambiar color de fondo y texto
;Sintaxis: ControlColor( [hWnd control], [color de fondo], [color del texto] )
;Color: RGB o Nombre
;Controles soportados (clases): Static, ListBox, Edit
ControlColor(hWnd, BackgroundColor := "White", TextColor := "") {
	static Controls := {}, Init := false
	If (Controls.HasKey(BackgroundColor)) {
		if !(Controls[BackgroundColor].T="")
			DllCall("Gdi32.dll\SetTextColor", "Ptr", hWnd, "UInt", Controls[BackgroundColor].T)
		DllCall("Gdi32.dll\SetBkColor", "Ptr", hWnd, "UInt", Controls[BackgroundColor].B)
		, DllCall("Gdi32.dll\SetDCBrushColor", "Ptr", hWNd, "UInt", Controls[BackgroundColor].B)
		return DllCall("Gdi32.dll\GetStockObject", "UInt", 18, "UPtr") 
	} if (DllCall("User32.dll\IsWindow", "Ptr", hWnd)) {
		Loop, Parse, % "0x0133|0x0134|0x0138", |
			if !(OnMessage(A_LoopField)=A_ThisFunc)
				OnMessage(A_LoopField, A_ThisFunc)
		Controls.RemoveAt(hWNd, ""), BackgroundColor := _getcolor(BackgroundColor), TextColor := _getcolor(TextColor)
		If !(BackgroundColor="") && !((B:=((BackgroundColor&0xFF0000)>>16)|(BackgroundColor&0x00FF00)|((BackgroundColor&0x0000FF)<<16))="")
			Controls[hWnd] := {B: B, T: TextColor=""?"":((TextColor&0xFF0000)>>16)|(TextColor&0x00FF00)|((TextColor&0x0000FF)<<16)}
		return r:=DllCall("User32.dll\RedrawWindow", "Ptr", hWnd, "Ptr", 0, "Ptr", 0, "UInt", 0x0405, "UInt"), ErrorLevel := !(r)
	} return false, ErrorLevel := true
}




















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: MOUSE/CURSOR Y TECLADO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;desplazamiento acelerado, más rápido gire la rueda, más líneas se desplazará por tic
;Sintaxis: MouseAutoWheelSpeed( [TimeOut (ms)], [Boost], [Limit], [ToolTip] )
;DESCRIPCION - PARÁMETROS:
	;TimeOut: tiempo fuera en el que se resetea el desplazamiento, en milisegundos
	;Boost: si se desplaza una distancia larga en una sola sesión, aplicar factor de impulso adicional (0=desactivado)
	;Limit: velcidad máxima (espesificar 0 para desactivar)
	;ToolTip: espesificar 1 (o el tiempo fuera, en milisegundos) para mostrar la velocidad de dezplazamiento como ToolTip
;NOTA: devuelve la velocidad actual (la misma que se muestra con ToolTip activado)
;EJEMPLO: WheelUp::MouseAutoWheelSpeed(,,, 1)
MouseAutoWheelSpeed(TimeOut := 500, Boost := 30, Limit := 60, ToolTip := 0) {
	static d := 0, i := 0
	t := A_TimeSincePriorHotkey, ToolTip := !(ToolTip>-1)?0:((ToolTip=1)?TimeOut:ToolTip)
	, TimeOut := (TimeOut>0)?TimeOut:500, Boost := (Boost>-1)?Boost:30
	if (A_PriorHotkey=A_ThisHotkey) && (t<TimeOut) && (Limit>0) {
		d := (d+1), v := ((t<80)&&(t>1))?((250.0/t)-1):1
		if (Boost>1&&d>Boost) {
			z := (v>i)?(i:=v):(v:=i)
			v *= (d/Boost)
		} v := (v>1)?((v>Limit)?Limit:Floor(v)):1
		if (ToolTip)
			ToolTip("×" v,,, -ToolTip)
		return MouseClick( A_ThisHotkey,,, v )
	} else {
		d := (i:=0)
		if (ToolTip)
			ToolTip("×" 1,,, -ToolTip)
		return MouseClick(A_ThisHotkey)
}} ;http://www.autohotkey.com/board/topic/48426-accelerated-scrolling-script/

;clics o mantiene pulsado un botón del ratón, o girar la rueda del ratón
;Sintaxis: MouseClick( [boton/rueda], [xpos], [ypos], [repeticiones], [velocidad de movimiento (x,y)] )
MouseClick(WhichButton := "Left", x := "", y := "", ClickCount := 1, Speed := 0, DU := "", R := "") {
	Loop, %ClickCount%
		MouseClick, %WhichButton%, %x%, %y%,, %Speed%, %DU%, %R%
	return ClickCount
}

;Envia pulsaciones de teclado clics del ratón a la ventana activa.
;Sintaxis: Send( [Texto], [¿Repetir?], [Retraso en cada repeticion (ms)] )
Send(Keys, Count := 1, Delay := -2) {
	if !(ok:=0)&&!(Count>1) {
		SendInput, %Keys%
		return !ErrorLevel, Sleep(Delay)
	} Loop, %Count%
		ok += Send(Keys,, A_Index=Count?-2:Delay)
	return ok, ErrorLevel := ok=Count?0:1
} SendInput(Keys, Count := 1, Delay := -2) {
	return Send(Keys, Count, Delay)
} SendRaw(Keys, Count := 1, Delay := -2) {
	return Send("{raw}" Keys, Count, Delay)
} SendPlay(Keys, Count := 1, Delay := -2) {
	if !(ok:=0)&&!(Count>1) {
		SendPlay, %Keys%
		return !ErrorLevel, Sleep(Delay)
	} Loop, %Count%
		ok += SendPlay(Keys,, A_Index=Count?-2:Delay)
	return ok, ErrorLevel := ok=Count?0:1
}

;envía una o más combinaciones de teclas a la ventana activa
;Ejemplo: SendKeys("Hola{+}"), SendKeys("`r"), SendKeys("Hola{+}"), SendKeys("`r"), SendKeys("Hola{+}")
SendKeys(Keys) {
	static WshShell
	if !(IsObject(WshShell))
		WshShell := ComObjCreate("WScript.Shell")
	return WshShell.SendKeys(Keys)
} ;https://msdn.microsoft.com/en-us/library/8c6yea83%28v=vs.84%29.aspx

;espera por una tecla a ser precionada o liberada
;Sintaxis: KeyWait( [tecla], [opciones], [tiempo fuera, en segundos] )
;OPCIONES:
	;D = espera a que la tecla sea precionada
	;[Vacío] (defecto) = espera a que la tecla sea liberada por el usuario
KeyWait(KeyName, Options := "", TimeOut := 0) {
	KeyWait, %KeyName%, % Options (TimeOut?" T" TimeOut:"")
	return !ErrorLevel
}

;Activa o desactiva la función de rastros del mouse
;Sintáxis: MouseTrails( [Número o dejar vacio para recuperar el estado actual.] )
;Nota: especifique un número mayor a 1 para activar. para desactivar especifique 0 o 1
;Ejemplos: MouseTrails( 10 ) | MouseTrails( 0 ) | MouseTrails(  )
MouseTrails(N := "", Save := false) {
	if (N != "")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005D, "UInt", N, "Str", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005E, "UInt", 0, "UIntP", N, "UInt", 0)
	return N
}

;cambia o recupera la velocidad actual del mouse
;Sintáxis: MouseSpeed( [establecer velocidad / dejar vacio], [¿guardar cambios?] )
MouseSpeed(Value := "", Save := false) {
	if (Value!="")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x71, "UInt", 0, "UInt", (Value>20)?20:(Value<1)?1:Value, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x70, "UInt", 0, "UIntP", Value, "UInt", 0)
	return Value
}

;recupera/cambia el número de líneas para desplazarse cuando se mueve la rueda ratón verticalmente
;Sintaxis: MouseScrollLines( [valor], [¿guardar cambios?] )
MouseScrollLines(Lines := -1, Save := false) {
	if (Lines >= 0)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0069, "UInt", Lines, "UInt", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0068, "UInt", 0, "UIntP", Lines, "UInt", 0)
	return Lines
}

;establece/recupera el tiempo (ms) de doble clic para el ratón
;Sintaxis: MouseDoubleClick( [milisegundos (1~5000)] )
MouseDoubleClick(ms := -1) {
	if (ms >= 0)
		return DllCall("User32.dll\SetDoubleClickTime", "UInt", ms)
	return DllCall("User32.dll\GetDoubleClickTime")
}

;Invierte o restaura los botones izquierdo y derecho del ratón
;Sintaxis: MouseSwap( 0|1 )
MouseSwap(fSwap) {
	return DllCall("User32.dll\SwapMouseButton", "Int", !!fSwap)
}

;recupera/establece el número de caracteres para desplazarse cuando se mueve la rueda horizontal ratón
;Sintaxis: MouseWheelScrollChars( [valor, defecto = 3] )
MouseWheelScrollChars(Value := "", Save := false) {
	if (Value!="")
		return DllCall("User32.dll\SystemParametersInfo", "UInt", 0x006D, "UInt", Value, "UIntP", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfo", "UInt", 0x006C, "UInt", 0, "UIntP", Value, "UInt", 0)
	return  Value
}

;Mueve el cursor a las coordenadas de pantalla especificadas
;Sintaxis: MouseSetPos( [x], [y], [velocidad] )
MouseSetPos(x := "", y := "", Speed := "", R := 0) {
	if (Speed!="")
		return MouseMove(x, y, Speed, R)
	if (x="") || (y="")
		CursorGetPos(x_, y_)
	return DllCall("User32.dll\SetCursorPos", "Int", x=""?x_:x, "Int", y=""?y_:y)
} CursorSetPos(x := "", y := "", Speed := 0, R := 0) {
	return MouseSetPos(x, y, Speed, R)
} MouseMove(x, y, Speed := -1, R := "") {
	MouseMove, %x%, %y%, % Speed>-1?Speed:A_DefaultMouseSpeed, % R?"R":""
	return !ErrorLevel
}

;recupera la posicion del cursor, ventana y control bajo el cursor.
;Sintaxis: MouseGetPos( [x], [y], [ventana], [control], [modo] )
;Nota: si solo necesita las coordenadas xy, usar CursorGetPos(x,y)
MouseGetPos(ByRef x := "", ByRef y := "", ByRef  Win := "", ByRef Control := "", Mode := 0) {
	MouseGetPos, x, y, Win, Control, %Mode%
	i := {}, i.x := x, i.y := y, i.Win := i.hWnd := Win, i.Control := i.ctrl := Control
	return i
} 

;recupera la posicion xy del cursor.
;Sintaxis: CursorGetPos( [x], [y], [ventana hWnd (salida)], [ID] )
;ID: espesificar ID para convertir a coordenadas de la ventana espesificada
CursorGetPos(ByRef x := "", ByRef y := "", ByRef Win := "", ScreenToClient := 0) {
	VarSetCapacity(lpPoint, 8 * 2, 0), i := {}
	, r := DllCall("User32.dll\GetCursorPos", "Ptr", &lpPoint)
	if (ScreenToClient)
		DllCall("User32.dll\ScreenToClient", "Ptr", ScreenToClient, "Ptr", &lpPoint)
	x := i.x := NumGet(lpPoint, 0, "Int"), y := i.y := NumGet(lpPoint, 4, "Int")
	if (IsByRef(Win))
		VarSetCapacity(POINT, 8 * 2, 0)
		, NumPut(x, POINT, 0, "Int"), NumPut(y, POINT, 4, "Int")
		, Win := DllCall("User32.dll\WindowFromPoint", "Int64", NumGet(POINT, 0, "Int64"))
	return i, ErrorLevel := !r
}

;obtener el texto en las coordenadas espesificadas
;Sintaxis: MouseGetText( [x], [y] )
;Ejemplo:
	;for k, v in MouseGetText()
	;	MsgBox % k ": " v
	;ExitApp
MouseGetText(x := "", y := "") {
	static uia
	if (x="") || (y="")
		CursorGetPos(_x, _y)
	x := x=""?_x:x, y := y=""?_y:y
	if !(uia) ;https://msdn.microsoft.com/en-us/library/windows/desktop/ff384838%28v=vs.85%29.aspx
		uia := ComObjCreate("{ff48dba4-60ef-4201-aa87-54103eef594e}", "{30cbe57d-d9d0-452a-ab13-7ac5ac4825ee}")
	Item := {}, DllCall(_vt(uia,7),"Ptr",uia,"int64",x|y<<32,"Ptr*",element)
	if !(element)
		return "", ErrorLevel := true
	DllCall(_vt(element,23),"Ptr",element,"Ptr*",name),DllCall(_vt(element,10),"Ptr",element,"UInt",30045,"Ptr",_variant(var))
	,DllCall(_vt(element,10),"Ptr",element,"uint",30092,"Ptr",_variant(lname)), DllCall(_vt(element,10),"Ptr",element,"uint",30093,"Ptr",_variant(lval))
	,a:=StrGet(name,"utf-16"),b:=StrGet(NumGet(val,8,"Ptr"),"utf-16"),c:=StrGet(NumGet(lname,8,"Ptr"),"utf-16")
	,d:=StrGet(NumGet(lval,8,"Ptr"),"utf-16"),a?Item.Push(a):0,b&&_vas(Item,b)?Item.Push(b):0,c&&_vas(Item,c)?Item.Push(c):0
	,d&&_vas(Item,d)?Item.Push(d):0,DllCall(_vt(element,21),"Ptr",element,"Uint*",type)
	if (type=50004)
		e:=MouseGetText_ElementWhole(uia,element),e&&_vas(item,e)?item.Push(e):false
	return Item, ObjRelease(element), ErrorLevel := false
} MouseGetText_ElementWhole(uia, element) {
	static init := 1, trueCondition, walker
	if (init)
		init:=DllCall(_vt(uia,21),"ptr",uia,"ptr*",trueCondition),init+=DllCall(_vt(uia,14),"ptr",uia,"ptr*",walker)
	DllCall(_vt(uia,5),"ptr",uia,"ptr*",root), DllCall(_vt(uia,3),"ptr",uia,"ptr",element,"ptr",root,"int*",same), ObjRelease(root)
	if (same)
		return
	hr:=DllCall(_vt(walker,3),"ptr",walker,"ptr",element,"ptr*",parent)
	if !(e:="") && !(parent)
		return
	DllCall(_vt(parent,6),"ptr",parent,"uint",2,"ptr",trueCondition,"ptr*",array), DllCall(_vt(array,3),"ptr",array,"int*",length)
	Loop % (length)
		DllCall(_vt(array,4),"ptr",array,"int",A_Index-1,"ptr*",newElement), DllCall(_vt(newElement,23),"ptr",newElement,"ptr*",name)
		, e.=StrGet(name,"utf-16"), ObjRelease(newElement)
	return e, ObjRelease(array), ObjRelease(parent)
} ;http://www.autohotkey.com/board/topic/94619-ahk-l-screen-reader-a-tool-to-get-text-anywhere/

;muestra/oculta el cursor
;Sintaxis: CursorShow( [Estado (0|1)], [Modo (0|1)], [Reestablecer (segundos)], [¿esperar?] )
;REESTABLECER: tiempo fuera en el que el cursor se muestra/oculta (dependiedo el estado espesificado)
;EJEMPLO: CursorShow(0,, 5, true), ExitApp()
CursorShow(State, Mode := 0, TimeOut := 0, WaitTimeOut := false) {
	;--------------------------------------------------------------------------------------------------------------
	static hCursor, hCursorImage, Cursor, LastState, LastMode
	static CursorShow := Func("CursorShow").Bind(-1)
	if (State=-1)
		return i := CursorShow( !LastState, LastMode ), ErrorLevel := !i
	;--------------------------------------------------------------------------------------------------------------
	if (TimeOut > 0) { ;alternar: State=0|1, Mode=0|1, TimeOut>0
		if !CursorShow( LastState:=State, LastMode:=Mode )
			return 0, ErrorLevel := 1
		if WaitTimeOut
			Sleep(TimeOut*1000)
		else return SetTimer(CursorShow, -(TimeOut*1000))
		return i := CursorShow( !State, Mode ), ErrorLevel := !i
	} ;--------------------------------------------------------------------------------------------------------------
	if (Mode) ;solo afecta a las ventanas creadas por el script: State=0|1, Mode=1, TimeOut=0
		Loop {
			NewDisplayCounter := DllCall("User32.dll\ShowCursor", "Int", State)
			if (State&&(NewDisplayCounter>=0))||(!State&&(NewDisplayCounter<=-1))
				return 1, ErrorLevel := 0
			if (NewDisplayCounter=OldDisplayCounter)||(State&&(NewDisplayCounter<OldDisplayCounter))
			||(!State&&(NewDisplayCounter>OldDisplayCounter))
				return 0, ErrorLevel := 1
			OldDisplayCounter := NewDisplayCounter
		}
	;--------------------------------------------------------------------------------------------------------------
	if (State) ;restaura los cursores: State=1, Mode=0, TimeOut=0
		return CursorReload()
	VarSetCapacity( AndMask, 32 * 4, 0xFF ), VarSetCapacity( XorMask, 32 * 4, 0 ), i := 0
	Loop, Parse, % "32650,32512,32515,32649,32651,32513,32641,32648,32640,32646,32643,32645,32642,32644,32516,32514", `,
	{ if !(Cursor) {
			hCursor := hCursorImage := []
			, hCursor[A_Index] := DllCall("User32.dll\CreateCursor", "Ptr", 0, "Int", 0, "Int", 0
				, "Int", DllCall("User32.dll\GetSystemMetrics", "Int", 13)
				, "Int", DllCall("User32.dll\GetSystemMetrics", "Int", 14)
				, "Ptr", &AndMask, "Ptr", &XorMask)
			, hCursorImage[A_Index] := DllCall("User32.dll\CopyImage", "Ptr", hCursor[A_Index], "UInt", 2, "Int", 0, "Int", 0, "UInt", 0)
		} i += DllCall("User32.dll\SetSystemCursor", "Ptr", hCursorImage[A_Index], "UInt", A_LoopField)
	} return Cursor := i, ErrorLevel := !i
} ;--------------------------------------------------------------------------------------------------------------

;vuelve a cargar los cursores del sistema
CursorReload() {
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0), ErrorLevel := !i
}

;cambiar cursor
;Sintaxis: SetSystemCursor( [cursor type] )
;Cursor Type: ARROW|IBEAM|WAIT|CROSS|UPARROW|SIZENWSE|SIZENESW|SIZEWE|SIZENS|SIZEALL|NO|HAND|APPSTARTING|HELP
;Nota: para restaurar dejar vacío
SetSystemCursor(Cursor := "") {
	static SystemCursors := "32512IDC_ARROW|32513IDC_IBEAM|32514IDC_WAIT|32515IDC_CROSS|32516IDC_UPARROW|32642IDC_SIZENWSE|32643IDC_SIZENESW|32644IDC_SIZEWE|32645IDC_SIZENS|32646IDC_SIZEALL|32648IDC_NO|32649IDC_HAND|32650IDC_APPSTARTING|32651IDC_HELP"
	If !(Cursor)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0)
	If (StrLen(SystemCursors) = 221)
		Loop, Parse, % SystemCursors, |
			SystemCursors := StrReplace(SystemCursors, A_LoopField, DllCall("User32.dll\LoadCursor", "UInt", 0, "Int", SubStr(A_LoopField, 1, 5)) A_LoopField)
	Cursor := SubStr(SystemCursors, InStr(SystemCursors "|", "IDC_" Cursor "|") - 5 - (p:=(StrLen(SystemCursors) - 221)) / 14, 5)
	Loop, Parse, % SystemCursors, |
		DllCall("User32.dll\SetSystemCursor", "Ptr", DllCall("User32.dll\CopyIcon", "UInt", Cursor), "UInt",  SubStr(A_LoopField, 6, p))
}



























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;modo de inicio del sistema
;Sintaxis: SystemBoot()
;Return: 0(normal) | 1(a prueba de fallos) | 2(a prueba de fallos con acceso a la red)
SystemBoot() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", 67)
}

;notifica al sistema que las asociaciones de tipo de archivo han cambiado.
SystemAssocChanged() {
	return r:=DllCall("Shell32.dll\SHChangeNotify", "UInt", 0x08000000, "UInt", 0, "Ptr", 0, "Ptr", 0), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762118%28v=vs.85%29.aspx

SysGet(Subcommand, Param3 := "") {
	SysGet, OutputVar, %Subcommand%, %Param3%
	return OutputVar ;DllCall("User32.dll\GetSystemMetrics", "Int", Subcommand)
}

;Opciones de apagado
;Sinraxis: Shutdown( [Código], [¿Forzar?] )
;CÓDIGOS
	;1 = Apagar | 2 = Reiniciar | 3 = Cerrar sesion | 4 = apaga el ardenador y alimentación
	;5 = Suspender | 6 = Hibernar
	;7 = Apagar monitor | 8 = Encender monitor | 9 = Poner el monitor en bajo consumo
	;10 = bloquear el equipo
Shutdown(Code, Force := false) {
	if Between(Code, 5, 6) {
		return DllCall("PowrProf.dll\\SetSuspendState", "int", Code=5?0:1, "int", Force, "int", 0)
	} else if Between(Code, 7, 9) {
		Code := Code=7?2:Code=8?-1:1, GetDesktop(,, hDesktop)
		return SendMessage(hDesktop, 0x112, "UInt", 0xF170,, Code)
	} else if Between(Code, 1, 4) {
		Code := Code=1?0x00000001:Code=2?0x00000002:Code=3?0:0x00000008
		return DllCall("User32.dll\ExitWindowsEx", "UInt", Force?Code|0x00000004:Code, "UInt", 0)
	} else if (Code=10) {
		return DllCall("User32.dll\LockWorkStation")
	} return false, ErrorLevel := true
} ShutdownEx(Code, Seconds := 0) { ;Code = /s: apagar, /r: reiniciar, /f: forzar, /a: cancelar.
	Seconds := (Seconds>0)?"/t" A_Space Seconds:
	Run, %ComSpec% /c Shutdown %Code% %Seconds%,, Hide
	return !ErrorLevel
} ;programar apagado. Sintaxis: ShutdownEx( [/s|/r /f], [segundos] )

;cambiar fecha y hora
;Sintaxis: SystemSetTime( [tiempo], [Local / System] )
;Nota: el tiempo debe ser un array con el formato año/mes/día/hora/min/seg/ms
;Ejemplo: SystemSetTime( [2020,12,09,,,01] )
SystemSetTime(Time, Mode := "Local") {
	VarSetCapacity(SYSTEMTIME, 8 * 2, 0)
	, NumPut(Time[1]=""?A_Year:Time[1], SYSTEMTIME, 0, "UShort")
	, NumPut(Time[2]=""?A_Mon:Time[2], SYSTEMTIME, 2, "UShort")
	, NumPut(Time[7]=""?A_WDay:Time[7], SYSTEMTIME, 4, "UShort")
	, NumPut(Time[3]=""?A_DD:Time[3], SYSTEMTIME, 6, "UShort")
	, NumPut(Time[4]=""?A_Hour:Time[4], SYSTEMTIME, 8, "UShort")
	, NumPut(Time[4]=""?A_Min:Time[5], SYSTEMTIME, 10, "UShort")
	, NumPut(Time[5]=""?A_Sec:Time[5], SYSTEMTIME, 12, "UShort")
	, NumPut(Time[6]=""?A_MSec:Time[6], SYSTEMTIME, 14, "UShort")
	return i:=DllCall("kernel32.dll\Set" Mode "Time", "Ptr", &SYSTEMTIME)
		, ErrorLevel := !i
}

;obtener fecha y hora
;Sintaxis: SystemGetTime( [Local / System] )
;Nota: devuelve un array con el formato año/mes/día/hora/min/seg/ms
SystemGetTime(Mode := "Local") {
	nSize := VarSetCapacity(SYSTEMTIME, 8 * 2, 0), NumPut(nSize, SYSTEMTIME, "UShort")
	i := DllCall("kernel32.dll\Get" Mode "Time", "Ptr", &SYSTEMTIME), Time := []
	Loop, Parse, % "0,2,6,8,10,12,14", `,
		Time[A_Index] := NumGet(SYSTEMTIME, A_LoopField, "UShort")
	return Time, ErrorLevel := !i
}

;Recupera información sobre el uso actual del sistema de memoria tanto física como virtual.
;EJEMPLO: MsgBox % Sys.GlobalMemoryStatusEx().Load " %"
SysGlobalMemoryStatusEx() { ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366589%28v=vs.85%29.aspx
	VarSetCapacity(MEMORYSTATUSEX, 64, 0), NumPut(64, MEMORYSTATUSEX, "UInt")
	ErrorLevel := !DllCall("kernel32.dll\GlobalMemoryStatusEx", "Ptr", &MEMORYSTATUSEX)
	i := {}, i.Lenght := NumGet(MEMORYSTATUSEX, 0, "UInt") ; El tamaño de la estructura, en bytes
		, i.Load := NumGet(MEMORYSTATUSEX, 4, "UInt") ;número entre 0 y 100 que especifica el porcentaje aproximado de la memoria física que está en uso
		, i.TotalPhys := NumGet(MEMORYSTATUSEX, 8, "UInt64") ;cantidad de memoria física real, en bytes
		, i.AvailPhys := NumGet(MEMORYSTATUSEX, 16, "UInt64") ;cantidad de memoria física disponible actualmente, en bytes
		, i.TotalPageFile := NumGet(MEMORYSTATUSEX, 24, "UInt64") ;límite de memoria comprometida actual para el sistema o el proceso actual, en bytes
		, i.AvailPageFile := NumGet(MEMORYSTATUSEX, 32, "UInt64") ;cantidad máxima de memoria que el proceso actual puede usar, en bytes.
		, i.TotalVirtual := NumGet(MEMORYSTATUSEX, 40, "UInt64") ;El tamaño de la parte del modo usuario del espacio de direcciones virtuales del proceso de llamada, en bytes
		, i.AvailVirtual := NumGet(MEMORYSTATUSEX, 48, "UInt64") ; La cantidad de memoria sin reservas y no comprometido actualmente en la parte del modo usuario del espacio de direcciones virtuales del proceso de llamada, en bytes
		;, i.AvailExtendedVirtual := NumGet(MEMORYSTATUSEX, 56, "UInt64") ;Reservado. Este valor es siempre 0.
		;, i.RAM := (a:=Get( A_ThisFunc ).RAM) ? a : DllCall("Kernel32.dll\GetPhysicallyInstalledSystemMemory", "UInt64*", TotalMemoryInKilobytes)  ;cantidad de RAM instalada físicamente en el equipo, en kilobytes
	return i
}

;porcentaje de uso del CPU
SystemCPULoad() {
	static PIT, PKT, PUT
	if !PIT
		DllCall("Kernel32.dll\GetSystemTimes", "Int64P", PIT, "Int64P", PKT, "Int64P", PUT)
	DllCall("Kernel32.dll\GetSystemTimes", "Int64P", CIT, "Int64P", CKT, "Int64P", CUT)
	Return (((SystemTime:=(PKT-CKT)+(PUT-CUT))-(PIT-CIT))*100)//SystemTime,PIT:=CIT,PKT:=CKT,PUT:=CUT
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3413
	
;sistema operativo: información de la versión
SysGetVersion() { ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff561910%28v=vs.85%29.aspx
	static VersionInfo
	if !(VersionInfo)
		VarSetCapacity(RTL_OSVIEX, 284, 0), NumPut(284, RTL_OSVIEX, 0, "UInt")
		, DllCall("ntdll.dll\RtlGetVersion", "Ptr", &RTL_OSVIEX), i := {}
		, i.MajorVersion := NumGet(RTL_OSVIEX, 4, "UInt")
		, i.MinorVersion := NumGet(RTL_OSVIEX, 8, "UInt")
		, i.BuildNumber := NumGet(RTL_OSVIEX, 12, "UInt")
		, i.PlatformId := NumGet(RTL_OSVIEX, 16, "UInt")
		, i.CSDVersion := StrGet(&RTL_OSVIEX + 20, 128, "UTF-16")
		, i.ServicePackMajor := NumGet(RTL_OSVIEX, 276, "UShort")
		, i.ServicePackMinor := NumGet(RTL_OSVIEX, 278, "UShort")
		, i.SuiteMask := NumGet(RTL_OSVIEX, 280, "UShort")
		, i.ProductType := NumGet(RTL_OSVIEX, 282, "UChar")
	return (VersionInfo?VersionInfo:(VersionInfo:=i))
}

SystemGetFontInfo(ByRef Name := "", ByRef Size := "", ByRef Weight := "", ByRef IsItalic := "") {
	nSize := VarSetCapacity(NCM, 500, 0), NumPut(nSize, &NCM, 0, "UInt")
	, i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0029, "UInt", nSize, "Ptr", &NCM, "UInt", 0)
	, Name := StrGet(&NCM+408+28, 32), Height := NumGet(&NCM+408, 0, "Int")
	, Size := DllCall("MulDiv", "Int", -Height, "Int", 72, "Int", A_ScreenDPI)
	, Weight := NumGet(&NCM + 408 + 16, 0, "Int"), IsItalic := NumGet(&NCM + 408 + 20, 0, "UChar")
	return i, ErrorLevel := !i
}

SystemSetFontInfo(Name := "", Size := "", Weight := "", IsItalic := "") {
	nSize := VarSetCapacity(NCM, 500, 0), NumPut(nSize, &NCM, 0, "UInt")
	, DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0029, "UInt", nSize, "Ptr", &NCM, "UInt", 0)
	, Name := Name?StrPut(Name, &NCM+408+28, 32):Name
	, Size := Size?NumPut(-DllCall("MulDiv", "Int", Size, "Int", A_ScreenDPI, "Int", 72), &NCM+408+0, "Int"):Size
	, Weight := Weight?NumPut(Weight, &NCM+408+16, "Int"):Weight
	, IsItalic := IsItalic=1||IsItalic=0?NumPut(IsItalic, &NCM+408+20, "UChar"):IsItalic
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x002A, "UInt", nSize, "Ptr", &NCM, "UInt", 0x01|0x02)
		, ErrorLevel := !i
}

;vuelve a cargar los iconos del sistema
SystemIconsReload() {
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0058, "UInt", 0, "Ptr", 0, "UInt", 0), ErrorLevel := !i
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
; ::::::::::::::::::::::::::::::::::::::::::::: VARIABLES ::::::::::::::::::::::::::::::::::
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;Recupera la ruta a la raíz del directorio del usuario actual
A_UserProfile() {
	static UserProfile
	return UserProfile?UserProfile:(UserProfile:=EnvGet("USERPROFILE"))
}

;Recupera la ruta a la raíz del directorio que contiene los datos del programa compartidos por todos los usuarios.
A_AllUsersProfile() {
	static AllUsersProfile
	if !(AllUsersProfile)
		DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(AllUsersProfile, uSize * 2, 0)
		, DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Str", AllUsersProfile, "UInt*", uSize)
	return AllUsersProfile
}

;Recupera la ruta de acceso al directorio raíz donde se almacenan los perfiles de usuario.
A_Profiles() {
	static Profiles
	if !(Profiles)
		DllCall("Userenv.dll\GetProfilesDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(Profiles, uSize * 2, 0)
		, DllCall("Userenv.dll\GetProfilesDirectoryW", "Str", Profiles, "UInt*", uSize)
	return Profiles
}

;Recupera la ruta de acceso a la raíz del perfil de usuario predeterminado.
A_DefaultUserProfile() {
	static DefaultUserProfile
	if !(DefaultUserProfile)
		DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(DefaultUserProfile, uSize * 2)
		, DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Str", DefaultUserProfile, "UInt*", uSize)
	return DefaultUserProfile
}

;recupera el nombre del usuario actual
A_UserName() {
	static UserName
	if !(UserName)
		DllCall("Advapi32.dll\GetUserNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(UserName, (uSize * 2) + 1, 0)
		, DllCall("Advapi32.dll\GetUserNameW", "Str", UserName, "UInt*", uSize + 1)
	return UserName
}

;recupera el dominio del usuario actual
A_UserDomain(ByRef UserName := "") {
	static UserDomain
	if !(UserDomain)
		DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(UserDomain, (uSize * 2) + 1, 0)
		, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", UserDomain, "UInt*", uSize + 1)
	return StrSplit(UserDomain, "\")[1], UserName := IsByRef(UserName)?StrSplit(UserDomain, "\")[2]:""
}

;Recupera/Establece el nombre NetBIOS del equipo local.
;Este nombre se estableció al inicio del sistema, cuando el sistema lo lee desde el registro.
A_ComputerName(lpComputerName*) {
	static ComputerName
	if (lpComputerName.MaxIndex())
		return DllCall("Kernel32.dll\SetComputerNameW", "Str", lpComputerName[1])
	if !(ComputerName)
		DllCall("kernel32.dll\GetComputerNameW", "Ptr", 0, "UInt*", uSize)
		, VarSetCapacity(ComputerName, uSize * 2, 0)
		, DllCall("kernel32.dll\GetComputerNameW", "Str", ComputerName, "UInt*", uSize)
	return ComputerName
}

;recupera la ruta del directorio de sistema utilizado por WOW64.
;NOTA: Este directorio no está presente en Windows de 32 bits.
A_SysDir64() {
	static SysDir64
	if !(SysDir64)
		uSize := DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(SysDir64, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWow64DirectoryW", "Str", SysDir64, "UInt", uSize)
	return SysDir64
}

;recupera la ruta del directorio de sistema.
;El directorio del sistema contiene los archivos del sistema, como las bibliotecas y los controladores de vínculos dinámicos.
A_SysDir() {
	static SysDir
	if !(SysDir)
		uSize := DllCall("kernel32.dll\GetSystemDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(SysDir, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemDirectoryW", "Str", SysDir, "UInt", uSize)
	return SysDir
}

;recupera la ruta del directorio compartido de Windows en un sistema multi-usuario.
A_SysWinDir() {
	static SysWinDir
	if !(SysWinDir)
		uSize := DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(SysWinDir, uSize * 2, 0)
		, DllCall("kernel32.dll\GetSystemWindowsDirectoryW", "Str", SysWinDir, "UInt", uSize)
	return SysWinDir
}

;recupera la ruta de acceso del directorio de Windows.
A_WinDir() {
	static WinDir
	if !(WinDir)
		uSize := DllCall("kernel32.dll\GetWindowsDirectoryW", "Ptr", 0, "UInt", 0)
		, VarSetCapacity(WinDir, uSize * 2, 0)
		, DllCall("kernel32.dll\GetWindowsDirectoryW", "Str", WinDir, "UInt", uSize)
	return WinDir
}

;Archivos Temporales
A_Temp() {
	static Temp
	if !(Temp)
		uSize := DllCall("kernel32.dll\GetTempPathW", "UInt", 0, "Ptr", 0)
		, VarSetCapacity(Temp, (uSize * 2) + 1, 0)
		, DllCall("kernel32.dll\GetTempPathW", "UInt", uSize + 1, "Str", Temp)
	return Temp
}

;recupera/establece el directorio de trabajo
A_WorkingDir(WorkingDir*) {
	if (WorkingDir.MaxIndex())
		return DllCall("kernel32.dll\SetCurrentDirectoryW", "Str", WorkingDir[1])
	VarSetCapacity(WorkingDir, (260 * 2) + 1) / 2
	, DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt*", 261, "Str", WorkingDir)
	return WorkingDir
}

;recupera la ruta a la consola de windows (cmd.exe)
A_ComSpec() {
	static _ComSpec
	return _ComSpec?_ComSpec:(_ComSpec:=EnvGet("ComSpec"))
}

;recupera el idioma por defecto del sistema
A_Language() {
	static Language
	return Language?Language:(Language:=Format("{:04X}", DllCall("Kernel32.dll\GetSystemDefaultUILanguage", "UShort")))
}

A_AppDataLocal() {
	static AppDataLocal
	return AppDataLocal?AppDataLocal:(AppDataLocal:=EnvGet("LOCALAPPDATA"))
} ;http://ahkscript.org/boards/viewtopic.php?f=13&p=52910#p52910

;ancho del monitor actual
A_ScreenWidth() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", false)
}

;tamaño de la zona de trabajo en el monitor de pantalla principal.
;el área de trabajo es la parte de la pantalla que no está oculta por la barra de tareas o las barras de herramientas de escritorio de aplicaciones.
;Sintaxis: A_MonitorWorkArea( [xpos], [ypos], [ancho], [alto] )
A_MonitorWorkArea(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 8 * 2, 0), i := {}
	, r := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0030, "UInt", 0, "Ptr", &RECT, "UInt", 0)
	, i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	, i.w := i.Width := Width := NumGet(RECT,  8, "Int") - x
	, i.h := i.Height := Height := NumGet(RECT, 12, "Int") - y
	return i, ErrorLevel := !r
}

;alto del monitor actual
A_ScreenHeight() {
	return DllCall("User32.dll\GetSystemMetrics", "Int", true)
}

;ruta completa al script
A_ScriptFullPath() {
	return A_ScriptFullPath
}

;directorio del script
A_ScriptDir() {
	return A_ScriptDir
}

;nombre del script
A_ScriptName() {
	return A_ScriptName
}

;devuelve 1 si el script se está ejecutando como administrador
A_IsAdmin() {
	return A_IsAdmin
}

A_IPAddress1() {
	return A_IPAddress1
} A_IPAddress2() {
	return A_IPAddress2
} A_IPAddress3() {
	return A_IPAddress3
} A_IPAddress4() {
	return A_IPAddress4
}

A_Cursor() {
	return A_Cursor
}

A_OSVersion() {
	return A_OSVersion
} A_OSType() {
	return A_OSType
}

A_TickCount(ByRef ElapsedTime := "") {
	static Time
	return _Time := DllCall("Kernel32.dll\GetTickCount"), ElapsedTime := _Time-Time, Time := _Time
}

A_LastError(SetLastError*) {
	return SetLastError.MaxIndex()?SetLastError(SetLastError[1]):GetLastError()
}

A_DetectHiddenWindows() {
	return A_DetectHiddenWindows="On"
}

A_Year(Year := "") {
	return Year=""?A_Year:SystemSetTime([Year])
} A_Mon(Mon := "") {
	return Mon=""?A_Mon:SystemSetTime([, Mon])
} A_DD(Day := "") {
	return Day=""?A_DD:SystemSetTime([,, Day])
} A_Hour(Hour := "") {
	return Hour=""?A_Hour:SystemSetTime([,,, Hour])
} A_Min(Min := "") {
	return Min=""?A_Min:SystemSetTime([,,,, Min])
} A_Sec(Sec := "") {
	return Sec=""?A_Sec:SystemSetTime([,,,,, Sec])
} A_MSec(MSec := "") {
	return MSec=""?A_MSec:SystemSetTime([,,,,,, MSec])
} A_WDay(WDay := "") {
	return WDay=""?A_WDay:SystemSetTime([,,,,,,, WDay])
}

A_Time(Delimiter := "") {
	CurrentTime := SplitTime()
	return CurrentTime[1] Delimiter CurrentTime[2] Delimiter CurrentTime[3] Delimiter
		. CurrentTime[4] Delimiter CurrentTime[5] Delimiter CurrentTime[6]
}

;------------------------------------------------------------------------------------------------------------------------------------------------

;recupera el directorio de Archivos De Programa
A_ProgramFiles() {
	static _ProgramFiles
	if !(_ProgramFiles)
		_ProgramFiles := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{905e63b6-c1bf-494e-b29c-65b732d3d21a}":0x0026)
	return _ProgramFiles
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio del usuario actual 
A_Programs() {
	static Programs
	if !(Programs)
		Programs := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}":0x0002)
	return Programs
}

;ruta completa y el nombre de la carpeta de programas en el menú Inicio para todos los usuarios
A_ProgramsCommon() {
	static ProgramsCommon
	if !(ProgramsCommon)
		ProgramsCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}":0X0017)
	return ProgramsCommon
}

;directorio de sistema de archivos que contiene los datos de aplicación para el usuario actual
A_AppData() {
	static AppData
	if !(AppData)
		AppData := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}":0x001a)
	return AppData
}

;directorio de sistema de archivos que contiene los datos de aplicación para todos los usuarios
A_AppDataCommon() {
	static AppDataCommon
	if !(AppDataCommon)
		AppDataCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}":0x0023)
	return AppDataCommon
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio del usuario actual
A_Desktop() {
	static Desktop
	if !(Desktop)
		Desktop := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}":0x0010)
	return Desktop
}

;ruta completa y el nombre de la carpeta que contiene los archivos de escritorio para todos los usuarios
A_DesktopCommon() {
	static DesktopCommon
	if !(DesktopCommon)
		DesktopCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}":0x0019)
	return DesktopCommon
}

;ruta completa y el nombre de la carpeta del menú Inicio del usuario actua
A_StartMenu() {
	static StartMenu
	if !(StartMenu)
		StartMenu := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}":0x000b)
	return StartMenu
}

;ruta completa y el nombre de la carpeta del menú Inicio para todos los usuarios
A_StartMenuCommon() {
	static StartMenuCommon
	if !(StartMenuCommon)
		StartMenuCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{A4115719-D62E-491D-AA7C-E74B8BE3B067}":0x0016)
	return StartMenuCommon
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio del usuario actual
A_Startup() {
	static Startup
	if !(Startup)
		Startup := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{B97D20BB-F46A-4C97-BA10-5E3608430854}":0x0007)
	return Startup
}

;ruta completa y el nombre de la carpeta Inicio en el menú Inicio para todos los usuarios
A_StartupCommon() {
	static StartupCommon
	if !(StartupCommon)
		StartupCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}":0x0018)
	return StartupCommon
}

A_MyDocuments() {
	static MyDocuments
	if !(MyDocuments)
		MyDocuments := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{FDD39AD0-238F-46AF-ADB4-6C85480369C7}":0x0005)
	return MyDocuments
}

A_DocumentsCommon() {
	static DocumentsCommon
	if !(DocumentsCommon)
		DocumentsCommon := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{ED4824AF-DCE4-45A8-81E2-FC7965083634}":0x002e)
	return DocumentsCommon
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de música
A_MyMusic() {
	static MyMusic
	if !(MyMusic)
		MyMusic := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{4BD8D571-6D19-48D3-BE97-422220080E43}":0x000d)
	return MyMusic
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de imagen
A_MyPictures() {
	static MyPictures
	if !(MyPictures)
		MyPictures := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{33E28130-4E1E-4676-835A-98395C3BC3BB}":0x0027)
	return MyPictures
}

;directorio del sistema de archivos que sirve de repositorio común para los archivos de vídeo
A_MyVideo() {
	static MyVideo
	if !(MyVideo)
		MyVideo := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{18989B1D-99B5-455B-841C-AB7C74E4DDFC}":0x000e)
	return MyVideo
}

;directorio de sistema de archivos que contiene accesos directos a los documentos usados recientemente del usuario
A_Recent() {
	static Recent
	if !(Recent)
		Recent := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{AE50C081-EBD2-438A-8655-8A092E34987A}":0x0008)
	return Recent
}

;directorio de sistema de archivos que contiene Enviar a elementos de menú
A_SendTo() {
	static SendTo
	if !(SendTo)
		SendTo := GetKnownFolderPath(IsWindowsVistaOrGreater()?"{8983036C-27C0-404B-8F08-102D10DCFD74}":0x0009)
	return SendTo
}

;------------------------------------------------------------------------------------------------------------------------------------------------

;espacio
A_Space(Count := 1) {
	Loop, %Count%
		_ .= Chr(32)
	return _
}

;tabulación
A_Tab(Count := 1) {
	Loop, %Count%
		_ .= Chr(9)
	return _
}

;comilla
A_Quote(Count := 1) {
	Loop, %Count%
		_ .= Chr(34)
	return _
}

;obtiene un array con los parámetros usados para ejecutar el script
;EJEMPLO: MsgBox( A_Args()[1] "`n" A_Args()[2] "`n" A_Args()[3] "`n" A_Args()[4] "`n" A_Args()[5] "`n`nTotal: " A_Args()[0] )
A_Args() { ;http://ahkscript.org/boards/viewtopic.php?t=4357 || By SKAN
	static Args
	if (Args)
		return Args
	CommandLineString := DllCall("Kernel32.dll\GetCommandLineW", "Str"), Args := [], Skip := A_IsCompiled ? 1 : 2
	, pArgs := DllCall("Shell32.dll\CommandLineToArgvW", "WStr", CommandLineString, "PtrP", nArgs) 
	Loop, %nArgs% {
		if (A_Index > Skip)
			hArgs := NumGet( (A_Index - 1) * A_PtrSize + pArgs )
			, Args[A_Index - Skip] := StrGet( hArgs, "UTF-16" )
	} return Args, Args[0] := nArgs-Skip, DllCall("Kernel32.dll\LocalFree", "Ptr", pArgs)
}

;------------------------------------------------------------------------------------------------------------------------------------------------

/* -------------------------------------------------------------------------------------------------------------------------------------------------------------
 ::::::::::::::::::::::::::::::::::::::::::::: VERSION HELPER FUNCTIONS ::::::::::::::::::::::::::::::::::
• Ejemplo:
	MsgBox %  "IsWindowsXPOrGreater: " IsWindowsXPOrGreater()
		. "`nIsWindowsXPSP1OrGreater: " IsWindowsXPSP1OrGreater()
		. "`nIsWindowsXPSP2OrGreater: " IsWindowsXPSP2OrGreater()
		. "`nIsWindowsXPSP3OrGreater: " IsWindowsXPSP3OrGreater()
		. "`nIsWindowsVistaOrGreater: " IsWindowsVistaOrGreater()
		. "`nIsWindowsVistaSP1OrGreater: " IsWindowsVistaSP1OrGreater()
		. "`nIsWindowsVistaSP2OrGreater: " IsWindowsVistaSP2OrGreater()
		. "`nIsWindows7OrGreater: " IsWindows7OrGreater()
		. "`nIsWindows7SP1OrGreater: " IsWindows7SP1OrGreater()
		. "`nIsWindows8OrGreater: " IsWindows8OrGreater()
		. "`nIsWindows8Point1OrGreater: " IsWindows8Point1OrGreater()
		. "`nIsWindows10OrGreater: " IsWindows10OrGreater()
		. "`nIsWindowsServer: " IsWindowsServer()
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
IsWindowsVersionOrGreater(MajorVersion, MinorVersion, ServicePackMajor) {
	VersionInfo := SysGetVersion()
	return (VersionInfo.MajorVersion > MajorVersion)?true
	: (VersionInfo.MajorVersion < MajorVersion)?false
	: (VersionInfo.MinorVersion > MinorVersion)?true
	: (VersionInfo.MinorVersion < MinorVersion)?false
	: (VersionInfo.ServicePackMajor >= ServicePackMajor)?true:false
}

IsWindowsXPOrGreater() { ; >= WIN_XP
	return isWindowsVersionOrGreater(5, 1, 0)
} IsWindowsXPSP1OrGreater() { ; >= WIN_XP SP1
	return isWindowsVersionOrGreater(5, 1, 1)
} IsWindowsXPSP2OrGreater() { ; >= WIN_XP SP2
	return isWindowsVersionOrGreater(5, 1, 2)
} IsWindowsXPSP3OrGreater() { ; >= WIN_XP SP3
	return isWindowsVersionOrGreater(5, 1, 3)
}

IsWindowsVistaOrGreater() { ; >= WIN_V
	return isWindowsVersionOrGreater(6, 0, 0)
} IsWindowsVistaSP1OrGreater() { ; >= WIN_V SP1
	return isWindowsVersionOrGreater(6, 0, 1)
} IsWindowsVistaSP2OrGreater() { ; >= WIN_V SP2
	return isWindowsVersionOrGreater(6, 0, 2)
}

IsWindows7OrGreater() { ; >= WIN_7
	return isWindowsVersionOrGreater(6, 1, 0)
} IsWindows7SP1OrGreater() { ; >= WIN_7 SP1
	return isWindowsVersionOrGreater(6, 1, 1)
}

IsWindows8OrGreater() { ; >= WIN_8
	return isWindowsVersionOrGreater(6, 2, 0)
} IsWindows8Point1OrGreater() { ; >= WIN_8.1
	return isWindowsVersionOrGreater(6, 3, 0)
}

IsWindows10OrGreater() { ; >= WIN_10
	return isWindowsVersionOrGreater(10, 0, 0)
}

IsWindowsServer() { ; = WIN_SERVER
	static isWindowsServer
	if (isWindowsServer!="")
		return isWindowsServer
	VersionInfo := SysGetVersion()
	return isWindowsServer:=(((VersionInfo.CSDVersion="")&&(VersionInfo.ProductType!=0x0000001))||((DllCall("User32.dll\GetSystemMetrics", "Int", 89))&&!(ErrorLevel)))
}

;devuelve una cadena que identifica al sistema operativo actual.
;Sintaxis 1: WindowsVersion( [Service Pack (salida)] )
;Sintaxis 2: WindowsVersionEx( [¿mostrar Service Pack y Arquitectura?] )
;Sintaxis 3: WinVersion()
;Service Pack: número del último Service Pack instalado en el sistema (0, 1, 2, 3 ...).
;Devuelve: WIN_SERVER2003R2, WIN_HOMESERVER, WIN_SERVER2008, WIN_SERVER2008R2, WIN_SERVER2012, WIN_SERVER2012R2, WIN_SERVER2016
	;WIN_XP, WIN_V, WIN_7, WIN_8, WIN_8.1, WIN_10
;Nota: si hay una nueva version de windows (aún no incluida en la funcion), devuelve lo mismo que WinVersion().
;Ejemplo: 
	;MsgBox % "WindowsVersion: " WindowsVersion(SP) " Service Pack " SP
	;	. "`nWindowsVersionEx: " WindowsVersionEx(true)
	;	. "`nWinVersion: " WinVersion()
WindowsVersion(ByRef ServicePackMajor := "") {
	static WindowsVersion, ServicePackMajor2
	if (WindowsVersion!="")
		return WindowsVersion, ServicePackMajor := ServicePackMajor2
	VersionInfo := SysGetVersion()
	return (WindowsVersion:=(((VersionInfo.MajorVersion=5)&&(VersionInfo.MinorVersion=2)&&(VersionInfo.SuiteMask&0x00008000))?"WIN_HOMESERVER"
	: ((DllCall("User32.dll\GetSystemMetrics", "Int", 89))&&!(ErrorLevel))?"WIN_SERVER2003R2" ;SM_SERVERR2
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=0)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2008"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=1)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2008R2"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=2)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2012"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=3)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2012R2"
	: ((VersionInfo.MajorVersion=10)&&(VersionInfo.MinorVersion=0)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2016"
	: (VersionInfo.MajorVersion=5)?"WIN_XP"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=0))?"WIN_V"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=1))?"WIN_7"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=2))?"WIN_8"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=3))?"WIN_8.1"
	: ((VersionInfo.MajorVersion=10)&&(VersionInfo.MinorVersion=0))?"WIN_10":WinVersion())), ServicePackMajor := (ServicePackMajor2:=VersionInfo.ServicePackMajor)
} WindowsVersionEx(Ex := false) {
	static WindowsVersionEx, WindowsVersion
	if (Ex=2)
		return ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_OperatingSystem")
	if (WindowsVersionEx)||(WindowsVersion)
		return Ex?WindowsVersion A_Space WindowsVersionEx:WindowsVersion
    for OS in ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_OperatingSystem") {
		WindowsVersion := Trim(OS.Caption), WindowsVersionEx := Trim((OS.CSDVersion?OS.CSDVersion A_Space:) (A_Is64bitOS?"x64":"x86"))
		return Ex?WindowsVersion A_Space WindowsVersionEx:WindowsVersion
}} WinVersion() { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724833(v=vs.85).aspx
	VersionInfo := SysGetVersion()
	return VersionInfo.MajorVersion "." VersionInfo.MinorVersion "." VersionInfo.BuildNumber
}



















































/*#############################################################################################################################################
  ::::::::::::::::::::::::::::::::::::::::::::: VENTANAS ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
NOTAS:
	• las funciones solo aceptan el ID de la ventana, excepto algunas como IsWindow(), IsWinActive(), WinWait(), etc.
	• para el titulo o ahk_xxx usar WinExist( .. ) o IsWindow(, [clase], [proceso/pid], [titulo]).
	• para referirse a la ventana activa, espesificar -1.
	• para referirse a la ventana bajo el cursor, espesificar -2.
	• para referirse a la última ventana espesificada, espesificar -3.
*/
;comprueba si la ventana no responde
WinHugh(hWnd) {
	_gethwnd(hWnd)
	return r:=DllCall("User32.dll\IsHungAppWindow", "Ptr", hWnd), ErrorLevel := !r
}

;comprueba si la ventana está habilitada
;Sintaxis: WinEnabled( [ID] )
WinEnabled(hWnd) {
	_gethwnd(hWnd)
	return r:=DllCall("User32.dll\IsWindowEnabled", "UInt", hWnd), ErrorLevel := !r
}

;comprueba si la ventana existe / obtiene la ventana activa.
;Sintaxis: IsWindow( [ID], [clase], [proceso/pid], [título] )
;NOTA: dejar vacio para obtener el ID de la ventana activa
;EJEMPLO: MsgBox % IsWindow(,, "notepad.exe" )
IsWindow(hWnd*) { 
	if !hWnd.MaxIndex()
		return i := Set("LastWindowId", DllCall("User32.dll\GetForegroundWindow")), ErrorLevel := !i
	if !hWnd[1]&&(hWnd[2]||hWnd[3]||hWnd[4]) {
		Loop, Parse, % WinEnum(), `n
		{ if hWnd[2]&&(WinGetClass(A_LoopField)!=hWnd[2])
				continue
			if (hWnd[4]!="")&&(WinGetTitle(A_LoopField)!=hWnd[4])
				continue
			if hWnd[3]&&(_getpid(A_LoopField,hWnd[3])!=hWnd[3])
				continue
			return Set("LastWindowId", A_LoopField), ErrorLevel := 0
	}} if !hWnd[1]||!DllCall("User32.dll\IsWindow", "Ptr", hWnd[1])
	||(hWnd[2]&&(WinGetClass(hWnd[1])!=hWnd[2]))
	||(hWnd[4]&&(WinGetTitle(hWnd[1])!=hWnd[4]))
	||(hWnd[3]&&(_getpid(hWnd[1],hWnd[3])!=hWnd[3]))
		return 0, ErrorLevel := 1
	return Set("LastWindowId", hWnd[1]), ErrorLevel := 0
}

;comprueba si la ventana es visible
WinVisible(hWnd) {
	_gethwnd(hWnd)
	return r:=DllCall("User32.dll\IsWindowVisible", "Ptr", hWnd), ErrorLevel := !r
}

;comprueba si la ventana está minimizada
WinMin(hWnd) {
	_gethwnd(hWnd)
	return r:=DllCall("User32.dll\IsIconic", "Ptr", hWnd), ErrorLevel := !r
}

;comprueba si la ventana está maximizada
WinMax(hWnd) {
	_gethwnd(hWnd)
	return r:=DllCall("User32.dll\IsZoomed", "Ptr", hWnd), ErrorLevel := !r
}

;devuelve 1 si la ventana: existe, no esta maximizada/minimizada, es visible
WinNormal(hWnd) {
	_gethwnd(hWnd)
	if !IsWindow(hWnd)||WinMin(hWnd)||WinMax(hWnd)||!WinVisible(hWnd)
		return 0, ErrorLevel := 1
	return 1, ErrorLevel := 0
}

;comprueba si es una ventana hija
;Sintaxis: WinChild( [ID ventana padre], [ID ventana hija] )
WinChild(hWnd, ChWnd*) {
	if !ChWnd.MaxIndex()
		return WinGetStyle(hWnd)&0x40000000?hWnd:WinGet(hWnd, "TopChild")
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsChild", "Ptr", hWnd, "Ptr", ChWnd[1])
}

;comprueba si la ventana está activa
;Sintaxis: IsWinActive( [ID], [clase], [proceso/pid], [titulo] )
IsWinActive(hWnd := "", Class := "", ProcessName := "", Title := "") {
	ActiveWindowId := IsWindow()
	if (!Class&&!ProcessName&&!ActiveWindowId&&!Title)
	||(!hWnd&&!Class&&!ProcessName&&!Title)
	||(hWnd&&(ActiveWindowId!=hWnd))
	||(Class&&(WinGetClass(hWnd?hWnd:ActiveWindowId)!=Class))
	||(Title&&(WinGetTitle(hWnd?hWnd:ActiveWindowId)!=Title))
	||(ProcessName&&(_getpid(hWnd,ProcessName,ActiveWindowId) != ProcessName))
		return false, ErrorLevel := true
	return true, ErrorLevel := false
}

;comprueba si la ventana tiene el estilo extendido AlwaysOnTop
;Sintaxis: WinAlwaysOnTop( [ID], [-1(alternar)|0|1] )
WinAlwaysOnTop(hWnd, AlwaysOnTop := "") {
	_gethwnd(hWnd)
	if (AlwaysOnTop!="")
		return WinSet(hWnd, "AlwaysOnTop", AlwaysOnTop=-1?!WinAlwaysOnTop(hWnd):AlwaysOnTop)
	return (WinGetExStyle(hWnd)&0x00000008)?true:false
}

;comprueba si la ventana tiene el estilo WS_SIZEBOX (+Resize)
;Sintaxis: WinResized( [ID], [-1(alternar)|0|1], [¿redibujar?] )
WinResized(hWnd, Resize := "", Redraw := false) {
	_gethwnd(hWnd)
	if (Resize!="") {
		r:=WinSetStyle(hWnd, (Resize=-1?(WinResized(hWnd)?"-":"+"):(Resize?"":"-")) 0x00040000)
		if (Redraw)
			WinRedraw(hWnd)
		return r
	} return (WinGetStyle(hWnd)&0x00040000)?true:false	
}

;comprueba si la ventana tiene el estilo extendido WS_EX_ACCEPTFILES
;Sintaxis: WinDragDrop( [ID], [-1(alternar)|0|1] )
WinDragDrop(hWnd, ACCEPTFILES := "") {
	_gethwnd(hWnd)
	if (ACCEPTFILES!="")
		return WinSetExStyle(hWnd, (ACCEPTFILES=-1?(WinDragDrop(hWnd)?"-":""):(ACCEPTFILES?"":"-")) 0x00000010)
	return (WinGetExStyle(hWnd)&0x00000010)?true:false
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;obtiene una lista con todas las ventanas de nivel superior en la pantalla o controles en la ventana
;W8+: sólo ventanas de nivel superior de las aplicaciones de escritorio
;Sintaxis: WinEnum( [hWnd], [¿incluir ventanas ocultas?], [delimitador], [cantidad (salida)] )
;hWnd: espesificar el hWnd de una ventana para obtener una lista con todos los controles
WinEnum(hWnd := "", DetectHiddenWindows := true, Delimiter := "`n", ByRef Count := "") {
	static EnumAddress := RegisterCallback("EnumWindowsProc", "Fast", 2) ;lpEnumFunc
	_gethwnd(hWnd), Param := {List: "", dhw: DetectHiddenWindows, Delimiter: Delimiter, Count: 0} ;lParam
	if (hWnd)
		r:=DllCall("User32.dll\EnumChildWindows", "Ptr", hWnd, "Ptr", EnumAddress, "Ptr", &Param)
	else r:=DllCall("User32.dll\EnumWindows", "Ptr", EnumAddress, "Ptr", &Param)
	return Param.List, Count := Param.Count, ErrorLevel := !r
} EnumWindowsProc(hWnd, lParam) {
	Param := Object(lParam)
	if (Param.dhw) || (WinVisible(hWnd))
		Param.List .= (Param.List?Param.Delimiter:"") hWnd, Param.Count++
    return true
}

;minimiza todas las ventanas
;Sintaxis: WinMinimizeAll( [¿forzar?] )
;NOTA: si se usa forzar, usar WinMinimizeAllUndo(1) para restaurarlas
	;para dar foco al escritorio usar ShowDesktop()
WinMinimizeAll(Force := false) {
	static Array, ActiveWindow
	if (Force="?"||Force="*")
		return Force="?"?Array:ActiveWindow
	ActiveWindow := IsWindow()
	if Force {
		Array := [], ok := Count := 0
		Loop, Parse, % WinEnum(, false), `n
		{	if !WinMin(A_LoopField) {
				Count++
				if WinMinimize(A_LoopField)
					ok++, Array[ok] := A_LoopField
		}} return ok, ErrorLevel := !(ok=Count)
	} if !(hWindow := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0))
		return ComObjCreate("shell.application").MinimizeAll()
	return PostMessage(hWindow, 0x0111, "UInt", 419)
}

;restaura todas las ventanas
;Sintaxis: WinMinimizeAllUndo( [¿forzar?] )
;NOTA: si se usa forzar, restaura solo las ventanas minimizadas por WinMinimizeAll(1)
WinMinimizeAllUndo(Force := false) {
	if Force {
		ok := Count := 0
		for Index, hWnd in WinMinimizeAll("?") {
			if WinMin(hWnd)&&WinVisible(hWnd)
				ok += WinRestore(hWnd)?true:false, Count++
		} return ok, WinActivate(WinMinimizeAll("*")), ErrorLevel := !(ok=Count)
	} if !(hWindow := DllCall("User32.dll\FindWindowW", "Str", "Shell_TrayWnd", "Ptr", 0))
		return ComObjCreate("shell.application").UndoMinimizeALL()
	return PostMessage(hWindow, 0x0111, "UInt", 416)
}

;Invoca un elemento de menú de la barra de menú de la ventana especificada
;Sintaxis: WinMenuSelectItem( [ID], [Menu Principal], [Submenus*] )
;EJEMPLO: WinMenuSelectItem( IsWindow(), "Archivo", "Abrir..." )
WinMenuSelectItem(hWnd, Menu, Submenu*) { ;AHKv1 --> WinMenuSelectItem()
	return MenuSelect(hWnd, Menu, Submenu*) ;AHKv2 --> MenuSelect()
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;centrar ventana, opcional posicionarla arriba/abajo/izquierda/derecha.
;Sintaxis: WinCenter( [ID], [Posición] )
;Posición: se pueden combinar.
	;Center = centrar ventana.
	;Top | Bottom = posicionar arriba. posicionar abajo.
	;Left | Right = posicionar a la izquierda. posicionar a la derecha.
;Notas:
	;• al alto de la pantalla se le resta el alto de la barra de tareas.
	;• si la ventana está maximizada, se modifica el ancho o el alto dependiendo la posicion.
		;--> si se posiciona arriba o abajo, se modifica el alto (A_ScreenHeight/2-10%).
		;--> si se posiciona a la izquierda o a la derecha, se modifica el ancho (A_ScreenWidth/2-10%).
;Ejemplo: abra Notepad para el ejemplo.
 	;MsgBox % "Centrar ventana: " ((!!WinActivate(WinExist("ahk_class Notepad"), 3)+WinMove(-3,,, 543, 403)+!!WinCenter(-3))-2)
	;MsgBox % "Posicionar arriba a la izquierda: " WinCenter(-3, "Top Left")
	;MsgBox % "Posicionar arriba a la derecha: " WinCenter(-3, "Top Right")
	;MsgBox % "Posicionar abajo a la izquierda: " WinCenter(-3, "Bottom Left")
	;MsgBox % "Posicionar abajo a la derecha: " WinCenter(-3, "Bottom Right")
	;MsgBox % "Posicionar arriba y centrarla: " WinCenter(-3, "Top Center")
	;MsgBox % "Posicionar abajo y centrarla: " WinCenter(-3, "Bottom Center")
	;MsgBox % "Posicionar a la izquierda y centrarla: " WinCenter(-3, "Left Center")
	;MsgBox % "Posicionar a la derecha y centrarla: " WinCenter(-3, "Right Center")
WinCenter(hWnd, Pos := "") {
	_gethwnd(hWnd)
	WinGetPos(hWnd, x, y, w, h), w2 := A_ScreenWidth, h2 := (A_ScreenHeight - TaskbarGetPos().h)
	, T := InStr(Pos, "Top"), B := InStr(Pos, "Bottom"), L := InStr(Pos, "Left"), R := InStr(Pos, "Right"), C := InStr(Pos, "Center")
	if (WinMax(hWnd))
		w := (L||R)?Percent(w2/2, 10):w2, h := (T||B)?Percent(h2/2, 10):h2
	if (T) || (B) || (L) || (R)
		return WinMove(hWnd, L?0:R?(w2-w):C?((w2/2)-(w/2)):x, T?0:B?(h2-h):C?((h2/2)-(h/2)):y, w, h)
	return WinMove(hWnd, (w2/2) - (w/2), (h2/2) - (h/2), w, h)
}

;parpadea la ventana especificada. no cambia el estado activo de la ventana.
;Sintaxis: WinFlash( [ID], [opciones], [veces que parpadea la ventana], [velocidad de parpadeo en milisegundos] )
;Opciones (se pueden sumar para combinar):
	;0 = parar (defecto).
	;1 = afecta al titulo de la ventana
	;2 = afecta al boton de la barra de tareas
	;12 = hasta que la ventana esté activa
WinFlash(hWnd, dwFlags := 0, uCount := 0, dwTimeout := 0) {
	_gethwnd(hWnd)
	, cbSize := VarSetCapacity(FLASHWINFO, A_PtrSize = 4 ? 20 : 32, 0) 
	, NumPut(cbSize, FLASHWINFO, 0, "UInt")
	, NumPut(hWnd, FLASHWINFO, 4, "Ptr")
	, NumPut(dwFlags+(uCount=0?4:0), FLASHWINFO, 8, "UInt")
	, NumPut(uCount>0?uCount:0, FLASHWINFO, A_PtrSize = 4 ? 12 : 16, "UInt")
	, NumPut(dwTimeout>0?dwTimeout:0, FLASHWINFO, A_PtrSize = 4 ? 16 : 24, "UInt")
	return DllCall("User32.dll\FlashWindowEx", "Ptr", &FLASHWINFO)
}

;redibujar la ventana
;Sintaxis: WinRedraw( [ID] )
WinRedraw(hWnd) {
	_gethwnd(hWnd)
	return i := DllCall("User32.dll\InvalidateRect", "Ptr", hWnd, "Ptr", 0, "Int", true)
		, DllCall("User32.dll\UpdateWindow", "Ptr", hWnd), ErrorLevel := !i ;forzar
}

;Permite producir efectos especiales al mostrar u ocultar ventanas
;Sintaxis: WinAnimate( [ID], [duracion de la animación , en milisegundos], [tipo de animación], [transparencia], [region] )
;TIPOS DE ANIMACIÓN (se pueden combinar):
	;S = Mostrar | H = Ocultar | C = Centrar | R = redibujar al terminar la animacion | T = quitar transparencia antes de producir el efecto
	;1 = Desvanecer | 2 = Diapositiva (combinar con 3/4 y/o 5/6)
	;3 = Izquierda A Derecha | 4 = Derecha A Izquierda
	;5 = Arriba Abajo | 6 = Abajo Arriba
;Nota: cuando se usa la opcion 'S' (mostrar), a veces los controles no se muestran correctamente, por ello, es necesario
	;redibujar la ventana, usar WinRedraw(), o agregar la opcion R.
WinAnimate(hWnd, Time := 200, Mode := "RS1", Transparent := "", Region := "") { 
	static List := {S: 0x00020000, 1: 0x00080000, C: 0x00000010, H: 0x00010000, 3: 0x00000001, 4: 0x00000002, 2: 0x00040000, 5: 0x00000004, 6: 0x00000008}
	_gethwnd(hWnd)
	if InStr(Mode, "T")
		WinSet(hWnd, "Transparent", "Off")
	i := DllCall("User32.dll\AnimateWindow", "Ptr", hWnd, "UInt", Time, "UInt", _cstr(List, Mode, "~", "+"))
	if InStr(Mode, "R")
		WinRedraw(hWnd)
	if (Transparent!="")
		WinSet(hWnd, "Transparent", Transparent)
	if (Region!="")
		WinSet(hWnd, "Region", Region)
	return i, ErrorLevel := !i
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632669%28v=vs.85%29.aspx

;mover ventana
;Sintaxis: WinMove( [ID], [x], [y], [ancho], [alto], [¿redibujar?] )
WinMove(hWnd, x := "", y := "", Width := "", Height := "", Redraw := true) {
	_gethwnd(hWnd)
	if (x="") || (y="") || (Width="") || (Height="")
		WinGetPos(hWnd, x_, y_, w_, h_)
	x := (x="")?x_:x, y := (y="")?y_:y, Width := (Width="")?w_:Width, Height := (Height="")?h_:Height
	return r:=DllCall("User32.dll\MoveWindow", "Ptr", hWnd, "Int", x, "Int", y, "Int", Width, "Int", Height, "Int", !!Redraw), ErrorLevel:=!r
}

;cerrar ventana
;Sintaxis: WinClose( [ID], [Segundos a esperar], [¿Forzar?] )
;NOTA: espesificar 0 segundos para esperar indefinidamente
WinClose(hWnd, Seconds := -1, Force := false) {
	_gethwnd(hWnd)
	if Force {
		WinGetPID(hWnd, WinThreadId)
		, hThread := DllCall("Kernel32.dll\OpenThread", "UInt", 0x0001, "UInt", 0, "UInt", WinThreadId)
		return i := DllCall("Kernel32.dll\TerminateThread", "Ptr", hThread, "UInt", 0)
			, DllCall("Kernel32.dll\CloseHandle", "Ptr", hThread), ErrorLevel := !i, WinWaitClose(hWnd, Seconds)
	} return i := PostMessage(hWnd, 0x0002), WinWaitClose(hWnd, Seconds)
} WinKill(hWnd, Seconds := -1) {
	_gethwnd(hWnd)
	return WinClose(hWnd, Seconds, true)?true:DllCall("User32.dll\EndTask", "Ptr", hWnd, "Int", 0, "Int", true)
}

;destruir ventanas creadas por el script
;Sintaxis: WinDestroy( [hWnd], [¿solo eliminar los controles?], [¿detectar controles ocultos?] )
;Return: si elimina los controles, devuelve la cantidad de controles eliminados
WinDestroy(hWnd, DeleteCtrls := false, DetectHiddenWindows := true) {
	_gethwnd(hWnd)
	if (DeleteCtrls) && !(c:=0) { ;eliminar todos los controles de la ventana -->
		Loop, Parse, % WinEnum(hWnd, DetectHiddenWindows), `n
			c += DllCall("User32.dll\DestroyWindow", "Ptr", A_LoopField)
		return c, ErrorLevel := !(c) ;<--
	} return r:=DllCall("User32.dll\DestroyWindow", "Ptr", hWnd), ErrorLevel := !(r)
}

;cierra todas las ventanas que coincidan con los datos espesificados
;Sintaxis: WinCloseEx( [ID], [Clase], [Proceso/PID], [¿forzar?], [¿afectar a las ventanas ocultas?], [titulo] )
WinCloseEx(hWnd := "", Class := "", ProcessName := "", Force := false, DetectHiddenWindows := true, Title*) {
	Win := Total := 0
	Loop, Parse, % WinEnum(, DetectHiddenWindows), `n
	{ if hWnd&&(hWnd!=A_LoopField)
			continue
		if Class&&!(WinGetClass(A_LoopField)==Class)
			continue
		if ProcessName&&(_getpid(A_LoopField,ProcessName)!=ProcessName)
			continue
		if Title.MaxIndex()&&(WinGetTitle(A_LoopField)!=Title[1])
			continue
		Win += WinClose(A_LoopField,, Force), Total++
	} return Win=Total, ErrorLevel := !(Win=Total)
}

;minimiza la ventana
;Sintaxis: WinMinimize( [ID], [¿Forzar?] )
WinMinimize(hWnd, Force := false) {
	_gethwnd(hWnd)
	if (Force) {
		r := PostMessage(hWnd,  0x112, "UInt", 0xF020)
		if !(IsWindowsVistaOrGreater())
			return r, ErrorLevel := !r
		return r:=DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 11), ErrorLevel := !r
	} return r:=DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 6), ErrorLevel := !r
}

;maximiza la ventana
;Sintaxis: WinMaximize( [ID], [¿Forzar?] )
WinMaximize(hWnd, Force := false) {
	_gethwnd(hWnd)
	if (Force) ;SW_MAXIMIZE = 3
		PostMessage(hWnd, 0x112, "UInt", 0xF030) 
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 3), ErrorLevel := !i 
}

;restaura la ventana a su tamaño y posicion original
;Sintaxis: WinRestore( [ID], [¿Forzar?] )
WinRestore(hWnd, Force := 0) {
	_gethwnd(hWnd)
	if Force ;SW_RESTORE = 9
		PostMessage(hWnd, 0x112, "UInt", 0xF120)
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 9), ErrorLevel := !i 
}

;oculta la ventana
;NOTA: para ocultar la ventana solo en la barra de tareas usar TaskBarRemove()
WinHide(hWnd) {
	_gethwnd(hWnd) ;SW_HIDE = 0
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", false), ErrorLevel := !i 
}

;habilita la ventana
;Sintaxis: WinEnable( [ID], [¿Activar?], [¿Esperar? (seg)] )
WinEnable(hWnd, Activate := false, WaitActive := -1) {
	_gethwnd(hWnd)
	return i := DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", true)
		, a := Activate?WinActivate(hWnd):"", ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
}

;deshabilita la ventana
WinDisable(hWnd) {
	_gethwnd(hWnd)
	return i:=!DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", false), ErrorLevel := !i
}

;muestra la ventana
;Sintaxis: WinShow( [ID], [¿Activar?], [¿Esperar? (segundos)] )
WinShow(hWnd, Activate := false, WaitActive := -1) {
	_gethwnd(hWnd)
	return i := DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", 5)
		, a := Activate?WinActivate(hWnd):"", ErrorLevel := !i 
		, WinWaitActive(hWnd, WaitActive) ;SW_SHOW = 5
}

;activa la ventana
;NOTA: si la ventana está minimizada, las restaura a su tamaño y posicion original
;Sintaxis: WinActivate( [ID], [¿Esperar? (segundos)], [¿Forzar?] )
WinActivate(hWnd, WaitActive := -1, Force := false) {
	_gethwnd(hWnd)
	if WinMin( hWnd )
		WinRestore(hWnd)
	if (Force) {
		CurrentThreadId := ProcessExist(-2), WinGetPID(hWnd, WinThreadId)
		, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", true)
		return i := DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
			, DllCall("User32.dll\BringWindowToTop", "Ptr", hWnd)
			, DllCall("User32.dll\SetFocus", "Ptr", hWnd)
			, DllCall("User32.dll\AttachThreadInput", "UInt", CurrentThreadId, "UInt", WinThreadId, "Int", false)
			, ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
	} return i := DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd)
		, ErrorLevel := !i, WinWaitActive(hWnd, WaitActive)
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;obtener posicion de la ventana
;Sintaxis: WinGetPos( [ID], [x], [y], [ancho], [alto], [modo] )
;MODOS:
	;0 (defecto) = obtiene el ancho y alto de la ventana entera
	;1 = excluir los bordes de la ventana
	;+2 = convierte en coordenadas de pantalla (0+2 o 1+2)
WinGetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "", Mode := 0) {
	_gethwnd(hWnd), VarSetCapacity(WRECT, 8 * 2, 0)
	, h := DllCall("User32.dll\GetWindowRect", "Ptr", hWnd, "Ptr", &WRECT)
	if (Mode=1) || (Mode=3)
		VarSetCapacity(CRECT, 8 * 2, 0)
		, h := DllCall("User32.dll\GetClientRect", "Ptr", hWnd, "Ptr", &CRECT)
	if (Mode=2) || (Mode=3)
		DllCall("User32.dll\ClientToScreen", "Ptr", hWnd, "Ptr", &WRECT)
		, DllCall("User32.dll\ClientToScreen", "Ptr", hWnd, "Ptr", &CRECT)
	i := {}, i.x := x := NumGet(WRECT, 0, "Int"), i.y := y := NumGet(WRECT, 4, "Int")
	, i.h := i.Height := Height := NumGet(Mode=1||Mode=3?CRECT:WRECT, 12, "Int") - (Mode=1||Mode=3?0:y)
	, i.w := i.Width := Width := NumGet(Mode=1||Mode=3?CRECT:WRECT,  8, "Int") - (Mode=1||Mode=3?0:x)
	return i, ErrorLevel := !h
}

;convierte en coordenadas de pantalla o relativo a la ventana, suma/quita bordes.
;Sintaxis: WinClient( [ID], [x], [y], [ancho], [alto], [ScreenToClient|ClientToScreen|+/-Borders] )
WinClient(hWnd, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "", Mode := "ClientToScreen") {
	if (Mode="+Borders") || (Mode="-Borders") {
        WinGetPos(hWnd, _x, _y, _w, _h)
        , w := Mode="+Borders"?(w=_w?w:w<_w?w+(_w-w):w)
			: (w=_w?w:w>_w?w-(w-_w):w)
        , h := Mode="+Borders"?(h=_h?h:h<_h?h+(_h-h):h>_h?(_h+(h-_h)):h)
			: (h=_h?h:h>_h?h-(h-_h):h)
		, x := x=""?_x:x, y := y=""?_y:y
	} else {
		_gethwnd(hWnd), VarSetCapacity(RECT, 16, 0)
		, NumPut(x, RECT, 0, "Int"), NumPut(y, RECT, 4, "Int")
		, NumPut(x+w, RECT, 8, "Int"), NumPut(y+h, RECT, 12, "Int")
		, DllCall("User32.dll\" Mode, "Ptr", hWnd, "Ptr", &RECT)
		, x := NumGet(RECT, 0, "Int"), y := NumGet(RECT, 4, "Int")
		, w := NumGet(RECT, 8, "Int")-x, h := NumGet(RECT, 12, "Int")-y
	} return [x, y, w, h]
}

;obtiene el ancho y alto de los bordes de la ventana
;Sintaxis: WinGetBorder( [ID], [ancho], [alto], [modo] )
;Modos: 0 = normal | 1 = convierte en coordenadas de pantalla
WinGetBorder(hWnd, ByRef Width := "", ByRef Height := "", Mode := 0) {
	WinGetPos(hWnd,,, Width, Height, Mode?2:0), WinGetPos(hWnd,,, Width2, Height2, Mode?3:1)
	, i := {}, i.w := i.Width := Width := Width - Width2, i.h := i.Height := Height := Height - Height2
	return i, ErrorLevel := !h
}

;obtiene el estilo de la ventana
;Ejemplo: MsgBox % Hex(WinGetStyle(-1), 8, 1)
WinGetStyle(hWnd) { ;0x40000 = resize
	_gethwnd(hWnd)
	, Style := DllCall("User32.dll\" (A_PtrSize=4?"GetWindowLongW":"GetWindowLongPtrW"), "Ptr", hWnd, "Int", -16)
	return Style, ErrorLevel := !Style
}

;obtiene el estilo extendido de la ventana
;Ejemplo: MsgBox % Hex(WinGetExStyle(-1), 8, 1)
WinGetExStyle(hWnd) {
	_gethwnd(hWnd)
	, ExStyle := DllCall("User32.dll\" (A_PtrSize=4?"GetWindowLongW":"GetWindowLongPtrW"), "Ptr", hWnd, "Int", -20)
	return ExStyle, ErrorLevel := !ExStyle
}

;obtiene el titulo de la ventana especificada.
;Sintaxis: WinGetTitle( [hWnd] )
WinGetTitle(hWnd) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633520%28v=vs.85%29.aspx
	_gethwnd(hWnd)
	, Size := DllCall("User32.dll\GetWindowTextLengthW", "Ptr", hWnd)
	, VarSetCapacity(OutputVar, (Size + 1) * 2, 0) / 2
	, r := DllCall("User32.dll\GetWindowTextW", "Ptr", hWnd, "Str", OutputVar, "Int", (Size + 1) * 2)
	return OutputVar, ErrorLevel := !r
}

;obtiene el nombre de la clase a la que pertenece la ventana especificada.
WinGetClass(hWnd) {
	_gethwnd(hWnd)
	, VarSetCapacity(OutputVar, (256 + 1) * 2, 0)
	, r := DllCall("User32.dll\GetClassNameW", "Ptr", hWnd, "Str", OutputVar, "Int", 256 + 1)
	return OutputVar, ErrorLevel := !r
}

;recupera el PID, opcional ThreadId/ProcessName/ProcessPath
;Sintaxis: WinGetPID( [ID], [ThreadId (salida)], [Proceso (salida)], [Proceso Ruta (salida)] )
;EJEMPLO: MsgBox % "Pid: " WinGetPid(IsWindow(),,,i) "`nCompanyName: " FileGetInfo(i,"CompanyName") "`nRuta: " i
WinGetPID(hWnd, ByRef ThreadId := "", ByRef ProcessName := "", ByRef ProcessPath := "") {
	VarSetCapacity(lpdwProcessId, 8 + A_PtrSize, 0), _gethwnd(hWnd)
	, ThreadId := DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "Ptr", &lpdwProcessId)
	return ProcessId := NumGet(lpdwProcessId, 0, "Ptr")
		, ProcessName := IsByRef(ProcessName)?ProcessName(ProcessId):""
		, ProcessPath := IsByRef(ProcessPath)?ProcessPath(ProcessId):""
		, ErrorLevel := !ThreadId
}

;obtener el texto de la ventana
;Sintaxis: WinGetText( [ID] )
WinGetText(hWnd) {
	_gethwnd(hWnd)
	WinGetText, OutputVar, ahk_id %hWnd%
	return OutputVar
}

;obtener informacion de la ventana
;Sintaxis: WinGet( [ID], [CMD] )
;CMD: TopChild|Top|Parent
WinGet(hWnd, Cmd) {
	_gethwnd(hWnd)
	if (Cmd="TopChild") {
		top_hwnd := hWnd
		Loop {
			if !(top_hwnd:=DllCall("User32.dll\GetTopWindow", "Ptr", top_hwnd))
				return last_hwnd?last_hwnd:hWnd
			last_hwnd := top_hwnd
	}} else if (Cmd="Top")
		return DllCall("User32.dll\GetTopWindow", "Ptr", hWnd)
	else if (Cmd="Parent")
		return DllCall("User32.dll\GetParent", "Ptr", hWnd)
	dhw := A_DetectHiddenWindows
	DetectHiddenWindows, On
	WinGet, OutputVar, %Cmd%, ahk_id %hWnd%
	DetectHiddenWindows, %dhw%
	return OutputVar
}

;obtiene el icono de la ventana
;Sintaxis: WinGetIcon( [ID], [tipo] )
;Tipos: 0 = icono pequeño | 1 = icono grande
	;2 = Recupera el icono pequeño que proporciona la aplicación.
		;si la aplicación no proporciona uno, el sistema utiliza el icono generado por el sistema para esa ventana.
WinGetIcon(hWnd, Type := 0) {
	_gethwnd(hWnd)
	return SendMessage(hWnd, 0x007F,, Type)
}

;obtener hWnd del menu de la ventana espesificada
;Sintaxis: WinGetMenu( [hWnd] )
WinGetMenu(hWnd) {
	return DllCall("User32.dll\GetMenu", "Ptr", hWnd)
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;establecer el titulo de la ventana espesificada
;Sintaxis: WinSetTitle( [ID], [Titulo], [Modo] )
;Modos: 1 = ocultar el titulo | 2 = ocultar el icono | 3 = ambos.
WinSetTitle(hWnd, NewTitle := "", Mode := 0) {
	_gethwnd(hWnd)
	if !(Mode)
		return r:=DllCall("User32.dll\SetWindowTextW", "Ptr", hWnd, "Str", NewTitle), ErrorLevel := !r
	Flags := Mode=1?1:Mode=2?4:Mode=3?5:0
	if (Flags)
		return !(r:=DllCall("UxTheme.dll\SetWindowThemeAttribute", "Ptr", hWnd, "Int", 1, "Int64*", ((Flags+2)<<32)|(Flags+2), "Int", 8)), ErrorLevel := !!r
	return false, ErrorLevel := true
}

;cambia el icono de la ventana
;Sintaxis: WinSetIcon( [ID], [Icono/DLL/Ejecutable], [Índice] )
WinSetIcon(hWnd, Icon, Index := 1) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632643%28v=vs.85%29.aspx
	if !(hIcon := ExtractIcon(Icon, Index))
		return false, ErrorLevel := 2
	_gethwnd(hWnd)
	, SendMessage(hWnd, 0x0080,,,, hIcon), SendMessage(hWnd, 0x0080,, 1,, hIcon)
	if ErrorLevel
		return false, ExtractIcon(hIcon, -1), ErrorLevel := true
	return true, ErrorLevel := false ;WM_SETICON := 0x0080, ICON_SMALL := 0, ICON_BIG := 1
}

;permitir/bloquear el redibujado de la ventana
;Sintaxis: WinSetRedraw( [hWnd], [0|1] )
WinSetRedraw(hWnd, Redraw := true) {
	_gethWnd(hWnd), r := SendMessage(hWnd, 0x000B, "Int", !!Redraw)
	return (r=0), ErrorLevel := (r!=0)
}

;registrar eventos para una ventana
;Sintaxis: WinSetEventHook( [ID], [Funcion], [Evento menor], [Evento mayor] )
;Sintaxis (eliminar): WinSetEventHook( [hEvent] )
;EVENTOS: https://msdn.microsoft.com/en-us/library/windows/desktop/dd318066%28v=vs.85%29.aspx
;EJEMPLO:
	;WinSetEventHook( WinExist("ahk_exe notepad.exe"), "WinEventProc", EVENT_OBJECT_LOCATIONCHANGE := 0x800B )
	;WinEventProc(hWinEventHook, Event, hWnd, idObject, idChild, dwEventThread, dwmsEventTime) {
	;	if hWnd
		;	MsgBox % "Título: " WinGetTitle( hWnd )
		;		. "`nClase: " WinGetClass( hWnd )
		;		. "`nEvento: " Event
	;	return
	;}
WinSetEventHook(hWnd, Func := "", EventMin := "", EventMax := "") {
	_gethwnd(hWnd)
	if !Func ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd373640%28v=vs.85%29.aspx
		return i := DllCall("User32.dll\UnhookWinEvent", "Ptr", hWnd), ErrorLevel := !i
	if !IsWindow( hWnd ) OR !IsFunc( Func )
		return 0, ErrorLevel := 2
	static WINEVENT_OUTOFCONTEXT := 0x0, WINEVENT_SKIPOWNPROCESS := 0x2
	EventMax := EventMax ? EventMax : EventMin, WinGetPID( hWnd, WinThreadId )
	return i := DllCall("User32.dll\SetWinEventHook", "UInt", EventMin, "UInt", EventMax, "Ptr", 0, "Ptr", RegisterCallback( Func )
		, "UInt", 0, "UInt", WinThreadId, "UInt", WINEVENT_OUTOFCONTEXT|WINEVENT_SKIPOWNPROCESS)
		, ErrorLevel := !i
}

;establecer estilo
;Sintaxis: WinSetStyle( [ID], [+-^Estilo], [SWP_FRAMECHANGED] )
;Estilo: +(añadir) -(quitar) ^(alternar) || por defecto reemplaza el estilo
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600%28v=vs.85%29.aspx
;Nota: algunos cambios necesitan SWP_FRAMECHANGED para que surtan efecto.
WinSetStyle(hWnd, Style, FRAMECHANGED := false) {
	static Func := "User32.dll\" ((A_PtrSize=4)?"SetWindowLongW":"SetWindowLongPtrW")
	_gethwnd(hWnd), Style := _mnum(WinGetStyle(hWnd), Style)
	if (ErrorLevel) || !(DllCall(Func, "Ptr", hWnd, "Int", -16, "Int", Style))
		return false, ErrorLevel := true
	if (FRAMECHANGED) ;http://ahkscript.org/boards/viewtopic.php?f=5&t=9591
		DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x27)
	return true, ErrorLevel := false
}

;establecer estilo extendido
;Sintaxis: WinSetExStyle( [ID], [+-^Estilo], [SWP_FRAMECHANGED] )
;Estilo: +(añadir, defecto) -(quitar) ^(alternar)
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543%28v=vs.85%29.aspx
;Nota: algunos cambios necesitan SWP_FRAMECHANGED para que surtan efecto.
WinSetExStyle(hWnd, ExStyle, FRAMECHANGED := false) {
	static Func := "User32.dll\" ((A_PtrSize=4)?"SetWindowLongW":"SetWindowLongPtrW")
	_gethwnd(hWnd), ExStyle := _mnum(WinGetExStyle(hWnd), ExStyle)
	if (ErrorLevel) || !(DllCall(Func, "Ptr", hWnd, "Int", -20, "Int", ExStyle))
		return false, ErrorLevel := true
	if (FRAMECHANGED) ;http://ahkscript.org/boards/viewtopic.php?f=5&t=9591
		DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x27)
	return true, ErrorLevel := false
}

;hace una variedad de cambios en la ventana.
;Sintaxis: WinSet( [ID], [Atributo], [Valor] )
;Atributos: Bottom|Top|+/-AlwaysOnTop|Parent
WinSet(hWnd, Attribute, Value := "") {
	_gethwnd(hWnd)
	if (Attribute="Bottom")
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="Top")
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="TOPMOST"||Attribute="+AlwaysOnTop"||(Attribute="AlwaysOnTop"&&Value!=0&&Value!="Off"))
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", -1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="NOTOPMOST"||Attribute="-AlwaysOnTop"||(Attribute="AlwaysOnTop"&&(Value=0||Value="Off")))
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", -2, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (Attribute="Parent")
		return DllCall("User32.dll\SetParent", "Ptr", hWnd, "Ptr", Value)
	dhw := A_DetectHiddenWindows
	DetectHiddenWindows, On
	WinSet, %Attribute%, %Value%, ahk_id %hWnd%
	DetectHiddenWindows, %dhw%
	return !ErrorLevel
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;espera a que la ventana no exista
;Sintaxis: WinWaitClose( [ID], [segundos], [clase], [proceso/pid], [titulo] )
WinWaitClose(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title*) {
	_gethwnd(hWnd)
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWindow(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep(100)
}}

;esperar a que la ventana se active
;Sintaxis: WinWaitActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title*) {
	_gethwnd(hWnd)
	if (Seconds=-1)||(!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if IsWinActive(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep(100)
}}

;esperar a que la ventana pierda el foco
;Sintaxis: WinWaitNotActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitNotActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	_gethwnd(hWnd)
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWinActive(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep(100)
}}

;esperar a que la ventana exista
;Sintaxis: WinWait( [ID], [Segundos], [clase], [proceso/pid], [Título] )
;Nota: devuelve el ID 
WinWait(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	_gethwnd(hWnd)
	if (Seconds = -1)||(!hWnd&&!Class&&!ProcessName)
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (i:=IsWindow(hWnd, Class, ProcessName, Title))
			return i, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep(100)
}}






































































/*#############################################################################################################################################
 ::::::::::::::::::::::::::::::::::::::::::::: MENU ::::::::::::::::::::::::::::::::::
PARÁMETROS:
	• hWnd = ID de la ventana
	• hMenu = ID del menu (para obtener el ID del menu por nombre, usar GetMenuByName)
	• Menu = nombre del menu
EJEMPLO:
	Menu, MyMenu, Add, Item 1: Hola, close
	Menu, MyMenu, Add, % "ID: " GetMenuByName("MyMenu"), close
	MenuCheckRadioItem(GetMenuByName("MyMenu"), 2)
	Menu, MyMenu, Show
	return
	close:
	ExitApp
#############################################################################################################################################
*/
;ejecuta un comando del menu de la ventana
;Sintaxis: MenuSelectItem( [hWnd], [ID del Menú], [Nombre del Menú] )
;NOTA: espesificar ' > ' para submenús
;Ejemplo: MenuSelectItem( IsWindow(),, "Archivo > Abrir..." )
;VER: MenuGetItemList()
MenuSelectItem(hWnd, MenuItemId := "", MenuItemName := "") {
	if (MenuItemName != "") {
		Loop, Parse, % List:=MenuGetItemList(hWnd), `n, `r
		{ RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
			if (MenuItemName = MenuItem2) {
				MenuItemId := MenuItem1
				break
		}} if (MenuItemId="")
			Loop, Parse, % List, `n, `r
			{ RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
				if InStr(MenuItem2, MenuItemName) {
					MenuItemId := MenuItem1
					break
	}}} return DllCall("User32.dll\SendNotifyMessageW", "Ptr", hWnd, "UInt", 0x111, "Ptr", MenuItemId, "Ptr", 0)
}

;Invoca un elemento de menú de la barra de menú de la ventana especificada
;Sintaxis: MenuSelect( [hWnd], [Menu Principal], [Submenus*] )
;EJEMPLO: MenuSelect( IsWindow(), "Archivo", "Abrir..." )
;VER: MenuSelectItem()
MenuSelect(hWnd, Menu, Submenu*) {
	if !Submenu.MaxIndex()
		return MenuSelectItem(hWnd,, Menu)
	Loop, % Submenu.MaxIndex()
		_Submenu .= " > " Submenu[A_Index]
	return MenuSelectItem(hWnd,, Menu _Submenu)
}

;redibujar el menú de la ventana.
;Sintaxis: MenuRedraw( [hWnd] )
MenuRedraw(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd)
}

;marcar el menu espesificado. al mismo tiempo desmarca todos los demás en el grupo espesificado
;Sintaxis: MenuCheckRadioItem( [hMenu], [item], [inicio], [fin] )
MenuCheckRadioItem(hMenu, ItemPos, First := 1, Last := 0) {
	if !(Last>0)
		Last := MenuGetItemCount(hMenu)
	return DllCall("User32.dll\CheckMenuRadioItem", "Ptr", hMenu, "UInt", First - 1, "UInt", Last - 1, "UInt", ItemPos - 1, "UInt", 0x0400)
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;comprueba si es un menú válido
;Sintaxis: IsMenu( [hMenu] )
IsMenu(hMenu) {
	return DllCall("User32.dll\IsMenu", "Ptr", hMenu)
}

MenuIsChecked(hMenu, ItemPos) {
	return (DllCall("User32.dll\GetMenuState", "Ptr", hMenu, "UInt", ItemPos - 1, "UInt", 0x0400, "UInt") & 0x08)
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;obtener una lista con todos los elementos de los menús de la ventana
;Sintaxis: MenuGetItemList( [hWnd] )
;NOTA: sólo funciona con aplicaciones que utilizan menús estándar de Windows
;EJEMPLO: ver uso de LoopParse con RegExMatch() en: MenuSelectItem()
MenuGetItemList(hWnd, hMenu := 0, Prefix := "") { ;http://ahkscript.org/boards/viewtopic.php?p=48401#p48401
	_gethwnd(hWnd)
	, hMenu := hMenu ? hMenu : DllCall("User32.dll\GetMenu", "Ptr", hWnd)
	, Count := DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
	Loop, %Count% {
		sSize := DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Ptr", 0, "Int", 0, "UInt", 0x00000400)
		, sSize := VarSetCapacity( lpString, (sSize + 1) * 2 ) / 2
		if !DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Str", lpString, "Int", sSize, "UInt", 0x00000400)
			continue
		lpString := StrReplace(lpString, "&")
		, ItemId := DllCall("User32.dll\GetMenuItemID", "Ptr", hMenu, "Int", A_Index-1)
		if (itemID = -1) AND (hSubMenu := DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", A_Index-1)) {
			List .= MenuGetItemList( "", hSubMenu, Prefix lpString " > " ) "`n"
			continue
		} List .= ItemId "`t" Prefix RegExReplace( lpString, "`t.*" ) "`n"
	} return RTrim( List, "`n" )
}

;obtener el ID del menu por nombre
;Sintaxis: GetMenuByName( [menu] )
GetMenuByName(Menu) {
	static hMenu
	If !(hMenu) {
		Menu, %A_ThisFunc%Menu, Add
		Menu, %A_ThisFunc%Menu, DeleteAll
		Gui, %A_ThisFunc%GUI:+HWNDhWnd
		Gui, %A_ThisFunc%GUI:Menu, %A_ThisFunc%Menu
		hMenu := WinGetMenu(hWnd)
		Gui, %A_ThisFunc%GUI:Menu
		Gui, %A_ThisFunc%GUI:Destroy
	} Menu, %A_ThisFunc%Menu, Add, :%Menu%
	hSubMenu := MenuGetSubMenu(hMenu)
	Menu, %A_ThisFunc%Menu, Delete, :%Menu%
	return hSubMenu
}

;obtener el ID del submenu del menu espesificado
;Sintaxis: MenuGetSubMenu( [hMenu], [item] )
MenuGetSubMenu(hMenu, ItemPos := 1) {
	return DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", ItemPos - 1)
}

;determina la cantidad de items en el menu
;Sintaxis: MenuGetItemCount( [hMenu] )
MenuGetItemCount(hMenu) {
	return DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
}









































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: TAREAS PROGRAMADAS ::::::::::::::::::::::::::::::::::
;Nota: requiere WIN_V+
;#############################################################################################################################################
;recupera todas las tareas programadas
;Sintaxis: SchTasksEnum( [¿buscar tareas en subcarpetas?] )
;Return: for [Index], [v.Name, v.Path] in SchTasksEnum()
;Ejemplo:
	;for k, v in SchTasksEnum(true)
	;	List .= v.path "`n"
	;MsgBox % List
SchTasksEnum(All := false) {
	if !(schservice:=SchTasksInit())
		return false
	RootFolder := schservice.GetFolder("\"), List := []
	, TaskCollection := RootFolder.GetTasks(0)
	for RegisteredTask in TaskCollection
			Task := {}, Task.Path := RegisteredTask.Path, Task.Name := RegisteredTask.Name, List.Push(Task)
	if (All)
		Loop, Parse, % SchTasksFoldersEnum(), `n
		{ 	TaskFolder := schservice.GetFolder(A_LoopField)
			, TaskCollection := TaskFolder.GetTasks(0)
			for RegisteredTask in TaskCollection
					Task := {}, Task.Path := RegisteredTask.Path, Task.Name := RegisteredTask.Name, List.Push(Task)
		} return List
} SchTasksInit(ByRef TaskPath := "", ByRef TaskName := "") {
	static schservice
	if !(IsObject(schservice)) {
		try schservice := ComObjCreate("Schedule.Service")
		catch, OutputVar
			return false, ErrorLevel := OutputVar
		schservice.Connect()
	} if (IsByRef(TaskName)) {
		SplitPath, TaskPath, TaskName, TaskPath
		TaskPath := "\" LTrim(TaskPath, "\")
	} return schservice
}

;enumera todas las subcarpetas en el directorio espesificado
;Sintaxis: SchTasksFoldersEnum( [ruta], [¿enumerar todas las carpetas y subcarpetas del directorio espesificado?] )
;Nota: si no espesifica un ruta (defecto), recupera todas las carpetas y subcarpetas en el directorio raiz.
;Ejemplos:
	;MsgBox % SchTasksFoldersEnum("\") ;recupera todas las carpetas en el directorio raiz.
	;MsgBox % SchTasksFoldersEnum() ;recupera todas las carpetas y subcarpetas en el directorio raiz.
SchTasksFoldersEnum(TaskPath := "", All := false, Prefix := "") {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\" LTrim(TaskPath, "\"))
	, FolderCollection := TaskFolder.GetFolders(0)
	catch, OutputVar
		return "", ErrorLevel := OutputVar
	for RegisteredFolder in FolderCollection {
		if (TaskPath="") || (All) {
			TaskFolder2 := schservice.GetFolder(RegisteredFolder.Path)
			if (TaskFolder2.GetFolders(0).Count>0) {
				List .= SchTasksFoldersEnum(RegisteredFolder.Path, true, RegisteredFolder.Path "`n") "`n"
			} else List .= Prefix RegisteredFolder.Path "`n"
		} else List .= (A_Index=1?"":"`n") RegisteredFolder.Name
	} Sort, List, U D`n
	return List
}

;habilitar tarea
;Sintaxis: SchTasksEnable( [ruta\nombre] )
SchTasksEnable(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Enabled := true
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;deshabilitar tarea
;Sintaxis: SchTasksDisable( [ruta\nombre] )
SchTasksDisable(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Enabled := false
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;crear carpeta\subcarpeta(s...)
;Sintaxis: SchTasksCreateFolder( [carpeta\sub1\sub2\etc...] )
SchTasksCreateFolder(TaskPath) {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\"), TaskFolder.CreateFolder(TaskPath)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;detener tarea
;Sintaxis: SchTasksStop( [ruta\nombre] )
SchTasksStop(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Stop(0)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;ejecutar tarea
;Sintaxis: SchTasksRun( [ruta\nombre], [parámetros] )
SchTasksRun(TaskPath, Params := "") {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Run(Params, RunningTask)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;obtener información de la tarea.
;Sintaxis: SchTasksGetInfo( [ruta\nombre], [estado], [info] )
;Estado: Unknown | Disabled | Queued | Ready | Running
;Info: devuelve la informacion en formato .XML. usar SchTasksSplitInfo() para leer los valores.
;Ejemplo:
	;SchTasksGetInfo("CCleanerSkipUAC", State, RegistrationInfo)
	;MsgBox % State
	;MsgBox % RegistrationInfo
	;Info := SchTasksSplitInfo(RegistrationInfo)
	;MsgBox % "Autor: " Info.Author "`nDominio\Usuario: " Info.UserId "`nLogonType: " Info.LogonType "`nPrioridad: " Info.Priority
	;	. "`nHabilitado: " Info.Enabled "`nOculto: " Info.Hidden "`nComando: " Info.Command "`nArgumentos: " Info.Arguments
SchTasksGetInfo(TaskPath, ByRef State := "", ByRef RegistrationInfo := "") {
	static States := {0: "Unknown", 1: "Disabled", 2: "Queued", 3: "Ready", 4: "Running"}
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	if (IsByRef(State))
		State := States[RegisteredTask.State]
	if (IsByRef(RegistrationInfo))
		RegistrationInfo := RegisteredTask.XML
	return true, ErrorLevel := false
} SchTasksSplitInfo(RegistrationInfo) {
	RegInfo := {}
	Loop, Parse, % "Author,UserId,LogonType,Priority,Enabled,Hidden,Command,Arguments", `,
		RegExMatch(RegistrationInfo, "<" A_LoopField ">(.+)</" A_LoopField ">", TypeID)
		, RegInfo[A_LoopField] := (A_LoopField="Enabled"||A_LoopField="Hidden")?(TypeID1="true"):TypeID1
	return RegInfo
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;establecer prioridad
;Sintaxis: SchTasksSetPriority( [ruta\nombre], [prioridad 0~10 (defecto=7)] )
SchTasksSetPriority(TaskPath, Priority := 7) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, TaskDefinition := RegisteredTask.Definition
	, TaskSettings := TaskDefinition.Settings
	, TaskSettings.Priority := ((Priority>-1)&&(Priority<11))?Priority:7
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;eliminar tarea
;Sintaxis: SchTasksDelete( [ruta\nombre] )
SchTasksDelete(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, TaskFolder.DeleteTask(TaskName, 0)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;eliminar carpeta junto con todas sus subcarpetas
;Sintaxis: SchTasksDeleteFolder( [ruta], [¿eliminar si la carpeta tiene subcarpetas?] )
SchTasksDeleteFolder(TaskPath, Recurse := true) {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\")
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	if (Recurse) && (TaskFolder.GetFolders(0).Count>0) {
		Loop, Parse, % SchTasksFoldersEnum("\" LTrim(TaskPath, "\"), true), `n
		{ SplitPath, A_LoopField, TaskName2, TaskPath2
			try TaskFolder2 := schservice.GetFolder("\" LTrim(TaskPath2, "\"))
			, TaskFolder2.DeleteFolder(TaskName2, 0)
	}} try TaskFolder.DeleteFolder(TaskPath, 0)
	return true, ErrorLevel := false
}












































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SONIDO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;Silenciar
;Sintáxis: SoundMute( [Opcion] )
;OPCIONES:
	;0 = restaurar | 1 = silenciar | 2 = alternar
	;-1 (defecto) = devuelve 1 si esta silenciado
SoundMute(Mode := -1) {
	if (Mode = -1)
		return SoundGet(, "MUTE")="On"?true:false
	return SoundSet(Mode=2?"+1":Mode,, "MUTE")
}

;obtener volumen 
SoundGet(ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundGet, OutputVar, %ComponentType%, %ControlType%, %DeviceNumber%
	return OutputVar
}

;establecer volumen
SoundSet(Percent, ComponentType := "MASTER", ControlType := "VOLUME", DeviceNumber := 1) {
	SoundSet, %Percent%, %ComponentType%, %ControlType%, %DeviceNumber%
	return !ErrorLevel
}

;emite un tono desde el altavoz del PC.
;Sintaxis: SoundBeep( [frequencia 37~32767], [duración] )
SoundBeep(Frequency := 523, Duration := 150) {
	return DllCall("Kernel32.dll\Beep", "UInt", Frequency, "UInt", Duration)
}

;reproduce un sonido, video u otro tipo de archivo compatible
;Sintaxis: SoundPlay( [archivo], [¿esperar?] )
SoundPlay(Filename, Wait := false) {
	if (Wait) {
		SoundPlay, %Filename%, 1
		SoundPlay, ________.wav
	} else SoundPlay, %Filename%
	return !ErrorLevel
}













































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SERVICIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;cambiar modo de inicio del servicio.
;Sintaxis: ServiceSet( [servicio], [boot | system | auto | manual | disabled] )
ServiceSet(IpName, StartMode := "") {
	static StartupModes := {"boot": 0x00000000, "system": 0x00000001, "auto": 0x00000002, "manual": 0x00000003, "disabled": 0x00000004, "disable": 0x00000004}
	hService := ServiceOpen( IpName,, 0x0002 ) ;SERVICE_NO_CHANGE := 0xffffffff | SERVICE_CHANGE_CONFIG := 0x0002
	if StartupModes[StartMode]
		return i := DllCall("Advapi32.dll\ChangeServiceConfigW", "Ptr", hService, "UInt", 0xffffffff, "UInt", StartupModes[StartMode]
		, "UInt", 0xffffffff, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	return 0, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := 1
}

;recupera la informacion del servicio
;Sintaxis: ServiceGetDescription( [servicio], [Fast|Slow] )
ServiceGetDescription(IpName, Mode := "Fast") {
	if (Mode="F"||Mode="Fast") { ;Fast: lee desde el registro (recomendado)
		return RegRead("HKLM\SYSTEM\CurrentControlSet\Services\" IpName, "Description")
	} else if (Mode="S"||Mode="Slow") { ;Slow: abre el servicio para leer la descripcion (mas lento)
		hService := ServiceOpen(IpName,, 0x0001)
		, DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", 0, "UInt", 0, "UIntP", pcbBytesNeeded)
		, cbBufSize := VarSetCapacity(SERVICE_DESCRIPTION, pcbBytesNeeded * 2, 0) / 2
		, i := DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", &SERVICE_DESCRIPTION, "UInt", cbBufSize, "UIntP", 0)
		return StrGet(NumGet(SERVICE_DESCRIPTION, 0, "Ptr"), cbBufSize, "UTF-16")
			, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	} return 0, ErrorLevel := 1
}

;establece la informacion del servicio
;Sintaxis: ServiceSetDescription( [servicio], [descripcion], [Fast|Slow] )
ServiceSetDescription(IpName, Description := "", Mode := "Slow") {
	Description := Trim(StrReplace(Description, A_Tab, A_Space))
	if (Mode="F"||Mode="Fast") { ;Fast: establece desde el registro (puede dar problemas con permisos)
		return RegWrite(, "HKLM\SYSTEM\CurrentControlSet\Services\" IpName, "Description", Description)
	} else if (Mode="S"||Mode="Slow") { ;Slow: abre el servicio para establecer la descripcion (recomendado)
		hService := ServiceOpen(IpName,, 0x0002)
		, VarSetCapacity(SERVICE_DESCRIPTION, StrLen(Description), 0)
		, NumPut(&Description, SERVICE_DESCRIPTION, 0, "Ptr")
		return i := DllCall("Advapi32.dll\ChangeServiceConfig2W", "Ptr", hService, "UInt", 1, "Ptr", &SERVICE_DESCRIPTION)
			, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
	} return 0, ErrorLevel := 1
}

;pausar
ServicePause(IpName) {
	hService := ServiceOpen( IpName,, 0x0040 )
	, VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000002, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;reanudar servicio
ServiceContinue(IpName) {
	hService := ServiceOpen( IpName,, 0x0040 )
	, VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000003, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;eliminar
ServiceDelete(IpName) {
	hService := ServiceOpen( IpName,, 0x00010000 )
	return i := DllCall("Advapi32.lib\DeleteService", "Ptr", hService)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !i
}

;iniciar
ServiceStart(IpName) {
	if (ServiceInfo(IpName).StartMode = "disable")
		ServiceSet( IpName, "manual" )
	hService := ServiceOpen( IpName,, 0x0010 )
	return i := DllCall("Advapi32.dll\StartServiceW", "Ptr", hService, "UInt", 0, "Ptr", 0)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !i
}

;detener
ServiceStop(IpName) {
	hService := ServiceOpen( IpName,, 0x0020 )
	, VarSetCapacity(SERVICE_STATUS, A_PtrSize = 4 ? 28 : 36, 0)
	return i := DllCall("Advapi32.dll\ControlService", "Ptr", hService, "UInt", 0x00000001, "Ptr", &SERVICE_STATUS)
		, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := !i
}

;obtiene el estado
;Sintaxis: ServiceStatus( [servicio] )
;EJEMPLO: MsgBox % ServiceStatus("spooler").State
ServiceStatus(IpName) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms685996%28v=vs.85%29.aspx
	static s1 := "STOPPED", s2 := "START_PENDING", s3 := "STOP_PENDING", s4 := "RUNNING", s5 := "CONTINUE_PENDING", s6 := "PAUSE_PENDING", s7 := "PAUSED"
	static t1 := "KERNEL_DRIVER", t2 := "FILE_SYSTEM_DRIVER", t16 := "OWN_PROCESS", t32 := "SHARE_PROCESS", t100 := "INTERACTIVE_PROCESS"
	hService := ServiceOpen( IpName,, 0x0004 ), i := {}
	, cbBufSize := VarSetCapacity(SERVICE_STATUS_PROCESS, A_PtrSize=4?36:44, 0), VarSetCapacity(pcbBytesNeeded, 4)
	, r := DllCall("Advapi32.dll\QueryServiceStatusEx", "Ptr", hService, "UInt", 0, "Ptr", &SERVICE_STATUS_PROCESS, "UInt", cbBufSize, "UIntP", &pcbBytesNeeded)
	, i.Type := (x:=NumGet(&SERVICE_STATUS_PROCESS, 0, "UInt"))?t%x%:t%x%
	, i.State := (x:=NumGet(&SERVICE_STATUS_PROCESS, 4, "UInt"))?s%x%:s%x%
	, i.ControlsAccepted := NumGet(&SERVICE_STATUS_PROCESS, 8, "UInt")
	, i.ExitCode := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 12 : 16, "UInt")
	, i.SpecificExitCode := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 16 : 24, "UInt")
	, i.CheckPoint := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 20 : 28, "UInt")
	, i.WaitHint := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 24 : 32, "UInt")
	, i.ProcessId := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 28 : 36, "UInt")
	, i.Flags := NumGet(&SERVICE_STATUS_PROCESS, A_PtrSize = 4 ? 32 : 40, "UInt") ;1=system process (always be running)
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService)
		, ErrorLevel := !r
}

;obtener informacion
;Sintaxis: ServiceInfo( [servicio] )
;EJEMPLO:
	;for k, v in ServiceInfo( "spooler" )
	;	MsgBox % k ": " v
ServiceInfo(IpName) {
	static StartType := {0: "BOOT", 1: "SYSTEM", 2: "AUTO", 3: "MANUAL", 4: "DISABLE"}
	hService := ServiceOpen( IpName,, 0x0001 )
	, DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", 0, "UInt", 0, "UIntP", pcbBytesNeeded)
	, cbBufSize := VarSetCapacity(QUERY_SERVICE_CONFIG, pcbBytesNeeded>0?pcbBytesNeeded:8000, 0) 
	, DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", &QUERY_SERVICE_CONFIG, "UInt", cbBufSize, "UIntP", 0)
	, i := {}, i.Type := NumGet(&QUERY_SERVICE_CONFIG, 0, "UInt") 
		, i.StartType := NumGet(&QUERY_SERVICE_CONFIG, 4, "UInt"), i.StartMode := StartType[i.StartType]
		, i.ErrorControl := NumGet(&QUERY_SERVICE_CONFIG, 8, "UInt")
		, i.PathName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 12 : 16, "UInt") )
		, i.OrderGroup := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 16 : 24, "UInt") ) 
		, i.TagId := NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 20 : 28, "UInt")
		, i.Dependencies := NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 24 : 32, "Ptr")
		, i.StartName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 28 : 36, "UInt") ) 
		, i.DisplayName := StrGet( NumGet(&QUERY_SERVICE_CONFIG, A_PtrSize = 4 ? 32 : 40, "UInt") ) 
	return i, DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hService), ErrorLevel := i.StartType=""?1:0
}

;comprueba si existe el servicio
;Sintaxis: ServiceExist( [servicio], [Fast|Slow] )
;Test (Fast vs Slow): MsgBox % "Fast: " _fspdtestex(999, "ServiceExist", "Spooler") "`nSlow: " _fspdtestex(999, "ServiceExist", "Spooler", "S")
ServiceExist(lpDisplayName, Mode := "Fast") {
	if (Mode="F"||Mode="Fast") ;Fast: comprueba si existe desde el registro. (recomendado)
		return RegExistKey("HKLM\SYSTEM\CurrentControlSet\Services\" lpDisplayName)
	if (Mode="S"||Mode="Slow") ;Slow: abre y cierra el servicio para comprobar si existe. (mas lento)
		return i:=DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", ServiceOpen(lpDisplayName)), ErrorLevel:=!i
	return 0, ErrorLevel := 1
}

;abre un servicio para modificar/leer datos/configuracion
;Sintaxis: ServiceOpen( [servicio], [acceso para SCManager], [acceso para el servicio], [SCManager (salida)] )
ServiceOpen(lpDisplayName, SCManagerAccess := 0xF003F, ServiceAccess := 0xF01FF, ByRef hSCManager := "") {
	hSCManager := DllCall("AdvApi32.dll\OpenSCManagerW", "Ptr", 0, "Ptr", 0, "UInt", SCManagerAccess) 
	, DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Str", lpDisplayName, "Ptr", 0, "UIntP", lpcchBuffer)
	, VarSetCapacity(lpServiceName, lpcchBuffer * 2)
	, lpServiceName := DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Str", lpDisplayName, "Str", lpServiceName, "UIntP", lpcchBuffer) ? lpServiceName : lpDisplayName
	return i := DllCall("Advapi32.dll\OpenServiceW", "Ptr", hSCManager, "Str", lpServiceName, "UInt", ServiceAccess)
		, x:=IsByRef(hSCManager)?"":DllCall("AdvApi32.dll\CloseServiceHandle", "Ptr", hSCManager)
		, ErrorLevel := !i
}


























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: UNIDADES ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;cambiar nombre de la unidad
;Sintaxis: DriveSetLabel( [unidad], [nombre] )
DriveSetLabel(Drive, VolumeLabel := "") {
	return r:=DllCall("Kernel32.dll\SetVolumeLabelW", "Str", SubStr(Drive, 1, 1) ":", "Str", VolumeLabel), ErrorLevel := !r
}

 ;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 ;obtener tipo de unidad: Unknown, Removable, Fixed, Network, CDROM, RAMDisk
;Sintaxis: DriveGetType( [Unidad] )
;Tipos: Unknown | Removable | Fixed | Network | CDROM | RAMDisk
;Ejemplo: MsgBox % DriveGetType(A_WinDir)
DriveGetType(Drive) {
	static Types := {0: "Unknown", 1: "", 2: "Removable", 3: "Fixed", 4: "Network", 5: "CDROM", 6: "RAMDisk"}
	Type := DllCall("Kernel32.dll\GetDriveTypeW", "Str", SubStr(Drive, 1, 1) ":")
	return Types[Type], ErrorLevel := !Types[Type]
}

;obtener informacion de la unidad
;Sintaxis: DriveGetInfo( [unidad], [nombre], [sistema de archivos], [serial], [MaximumComponentLength], [FileSystemFlags] )
;Ejemplo:
	;DriveGetInfo(A_WinDir, VolumeName, FileSystem, SerialNumber, MCLength, FileSystemFlags)
	;MsgBox % "VolumeName: " VolumeName "`nFileSystem: " FileSystem "`nSerialNumber: " SerialNumber "`nMCLength: " MCLength "`nFileSystemFlags: " FileSystemFlags
DriveGetInfo(Drive, ByRef VolumeName := "", ByRef FileSystem := "", ByRef SerialNumber := "", ByRef MCLength := "", ByRef FileSystemFlags := "") {
	VarSetCapacity(VolumeName, (260 + 1) * 2), VarSetCapacity(FileSystem, (260 + 1) * 2), Drive := SubStr(Drive, 1, 1)
	r := DllCall("Kernel32.dll\GetVolumeInformationW", "Str", Drive ":", "Str", VolumeName, "UInt", 261, "UIntP"
	, SerialNumber, "UIntP", MCLength, "UIntP", FileSystemFlags, "Str", FileSystem, "UInt", 261)
	if (r) && (VolumeName="")
		RegRead, VolumeName, % "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" Drive "\DefaultLabel"
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364993%28v=vs.85%29.aspx

;obtener informacion de la unidad
;Sintaxis: DriveGetInfoEx( [unidad], [nombre], [sistema de archivos], [tipo], [serial], [espacio], [nombre compartido en red] )
;Sistema de archivos: FAT | FAT32 | NTFS | CDFS.
;Tipos: Unknown | Removable | Fixed | Network | CDROM | RAMDisk.
;Espacio (array): [total, disponible, en uso]. en bytes.
;Ejemplo:
	;DriveGetInfoEx(A_WinDir, VolumeName, FileSystem, Type, SerialNumber, Size, ShareName)
	;MsgBox % "VolumeName: " VolumeName "`nFileSystem: " FileSystem "`nType: " Type "`nSerialNumber: " SerialNumber
	;	. "`nTotal: " Round(Size[1]/(1024**3), 2) " GB | Disponible: " Round(Size[2]/(1024**3), 2) " GB | En Uso: " Round(Size[3]/(1024**3), 2) " GB`nShareName: " ShareName
DriveGetInfoEx(Drive, ByRef VolumeName := "", ByRef FileSystem := "", ByRef Type := "", ByRef SerialNumber := "", ByRef Size := "", ByRef ShareName := "") {
	static Types := {0: "Unknown", 1: "Removable", 2: "Fixed", 3: "Network", 4: "CDROM", 5: "RAMDisk"}
	try fso := ComObjCreate("Scripting.FileSystemObject"), d := fso.GetDrive(fso.GetDriveName(Drive))
	catch
		return false, ErrorLevel := true
	if (IsByRef(VolumeName))
		VolumeName := d.VolumeName
	if (IsByRef(FileSystem))
		FileSystem := d.FileSystem
	if (IsByRef(Type))
		Type := Types[d.DriveType]
	if (IsByRef(SerialNumber))
		SerialNumber := d.SerialNumber
	if (IsByRef(Size))
		Size := [t:=d.TotalSize, f:=(d.FreeSpace?d.FreeSpace:d.AvailableSpace), t-f]
	if (IsByRef(ShareName))
		ShareName := d.ShareName
	return true, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/ts2t8ybh(v=vs.84).aspx

 ;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
;recupera la cantidad de espacio libre en Bytes
;Sintaxis: DriveSpaceFree( [unidad], [KB|MB|GB] )
DriveSpaceFree(Drive, Units := 0) {
	static Size := {KB: 1024, MB: 1024**2, GB: 1024**3}
	VarSetCapacity(FreeSpace, 8 * 2, 0), Drive := SubStr(Drive, 1, 1) ":"
	, r := DllCall("Kernel32.dll\GetDiskFreeSpaceExW", "Str", Drive, "UInt64", &FreeSpace, "UInt64", 0, "UInt64", 0)
	return Size[Units]?NumGet(FreeSpace, 0, "UInt64")/Size[Units]:NumGet(FreeSpace, 0, "UInt64"), ErrorLevel := !r
}

;listar unidades
;Sintaxis: DriveEnum( [CDROM|REMOVABLE|FIXED|NETWORK|RAMDISK|UNKNOWN separados por coma] )
DriveEnum(Type := "") {
	DriveGet, OutputVar, List
	if (Type)
		Loop, Parse, % OutputVar
			if (InVar(DriveGetType(A_LoopField), Type))
				List .= A_LoopField
	return Type?List:OutputVar
}

;expulsar/retraer unidad de CD/DVD. expulsar USB.
;Sintaxis: DriveEject( [unidad], [0|1] )
;NOTA: el script no avanza hasta que la unidad se cierre/expulse.
DriveEject(Drive, Close := false) {
	Drive := SubStr(Drive, 1, 1)
	if ((IpType:=DriveGetType(Drive))="CDROM") || !(IpType) {
		if !(IpType)
			return false, ErrorLevel := true
		Drive, Eject, %Drive%:, % !!Close
		return !ErrorLevel
	} hDrive := DllCall("Kernel32.dll\CreateFileW", "Str", "\\.\" Drive ":", "UInt", 0, "UInt", 0, "UInt", 0, "UInt", 3, "UInt", 0, "Ptr", 0)
	, Size := VarSetcapacity(STORAGE_DEVICE_NUMBER, 8 + A_PtrSize, 0), nVT := true
	, IpR := DllCall("Kernel32.dll\DeviceIoControl", "Ptr", hDrive, "UInt", 0x2D1080, "Ptr", 0, "UInt", 0, "Ptr", &STORAGE_DEVICE_NUMBER, "UInt", Size, "UIntP", 0, "Ptr", 0)
	, CloseHandle(hDrive), IpType := NumGet(STORAGE_DEVICE_NUMBER, "UInt")
	, sPHDRV := (IpType=0x00000007)?"\\\\.\\PHYSICALDRIVE" NumGet(STORAGE_DEVICE_NUMBER, 4, "UInt"):""
	, queryEnum := ComObjGet("winmgmts:").ExecQuery("Select * from Win32_DiskDrive WHERE DeviceID='" sPHDRV "' AND InterfaceType='USB'")._NewEnum()
	If !(queryEnum[Drive])
		return false, ErrorLevel := true
	if !(GetModuleHandle("SetupAPI.dll"))
		hModule := LoadLibrary("SetupAPI.dll")
	DllCall("SetupAPI.dll\CM_Locate_DevNode", "PtrP", nDID, "Str", Drive.PNPDeviceID, "UInt", 0), DllCall("SetupAPI.dll\CM_Get_Parent", "PtrP", nDID, "UInt", nDID, "UInt", 0)
	while % (nDID && nVT && (A_Index<4)) 
		DllCall("SetupAPI.dll\CM_Request_Device_Eject", "UInt", nDID, "PtrP", nVT,  "Ptr", 0, "UInt", 0, "UInt", 0)
	if (hModule)
		FreeLibrary(hModule) 
	return !nVT, ErrorLevel := nVT
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=4491























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: MONITOR ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
PixelGetColor(x := "", y := "", AltSlowRGB := 0) {
	if (x="")||(y="")
		MouseGetPos(x_, y_)
	PixelGetColor, OutputVar, % (x="")?x_:x, % (y="")?y_:y, %AltSlowRGB%
	return OutputVar
}

;obtiene informacion de un monitor
;Sintaxis: MonitorInfo( [monitor], [número], [nombre] ]
;Ejemplo: MsgBox % "Monitor Primario: " MonitorInfo().Name
MonitorInfo(hWnd := "", Number := "", Name := "") {
	if !(hWnd) && !(Number) && !(Name)
		hWnd := MonitorPrimary()
	if !(hWnd) {
		for k, v in MonitorEnum() {
			if (Number) && (v.Num!=Number)
				continue
			if (Name) && (v.Name!=Name)
				continue
			v["hWnd"] := k
			return v, ErrorLevel := !v
		} return false, ErrorLevel := true
	} cbSize := VarSetCapacity(MONITORINFOEX, 52 * 2, 0)
	, NumPut( cbSize, MONITORINFOEX, 0, "UInt"), DllCall("User32.dll\GetMonitorInfoW", "Ptr", hWnd, "Ptr", &MONITORINFOEX)
	, MonName := StrGet(&MONITORINFOEX + 40, 32), MonNum := RegExReplace(MonName, ".*(\d+)$", "$1")
	return {Name: (Name := StrGet(&MONITORINFOEX + 40, 32)), Num: RegExReplace(Name, ".*(\d+)$", "$1")
		, Left: NumGet(MONITORINFOEX, 4, "Int"), Top: NumGet(MONITORINFOEX, 8, "Int") , Right: NumGet(MONITORINFOEX, 12, "Int") 
		, Bottom: NumGet(MONITORINFOEX, 16, "Int") , WALeft: NumGet(MONITORINFOEX, 20, "Int") , WATop: NumGet(MONITORINFOEX, 24, "Int") 
		, WARight: NumGet(MONITORINFOEX, 28, "Int") , WABottom: NumGet(MONITORINFOEX, 32, "Int") , Primary: NumGet(MONITORINFOEX, 36, "UInt")}
}

;obtiene una lista de monitores e informacion
;Sintaxis: MonitorEnum( [monitor|opcion] )
;Opcion: -1 = recupera la cantidad de monitores | -2 = solo devuelve el hWnd
;EJEMPLO:
	;Gui, Add, ListView, w660 r10 Grid, HMON|Num|Name|Primary|Left|Top|Right|Bottom|WALeft|WATop|WARight|WABottom
	;for HMON, M In MonitorEnum()
	;   LV_Add(, HMON, M.Num, M.Name, M.Primary, M.Left, M.Top, M.Right, M.Bottom, M.WALeft, M.WATop, M.WARight, M.WABottom)
	;Loop, % LV_GetCount("Column")
	;   LV_ModifyCol(A_Index, "AutoHdr")
	;Gui, Show
MonitorEnum(hMonitor := "") {
	static MonitorEnumProc := RegisterCallback("MonitorEnumProc", "Fast", 4)
	static Monitors := {}
	if !(hMonitor) || (hMonitor=-1) || (hMonitor=-2) {
		Monitors:={"Mode": hMonitor, "Count": 0, "List": []}
		, i := DllCall("User32.dll\EnumDisplayMonitors", "Ptr", 0, "Ptr", 0, "Ptr", MonitorEnumProc, "Ptr", &Monitors)
		return hMonitor=-1?Monitors.Count:Monitors.List, ErrorLevel := !i
	} return Monitors.List[hMonitor], ErrorLevel := !Monitors.List.HasKey(hMonitor)
} MonitorEnumProc(HMON, HDC, PRECT, ObjectAddr) {
	Monitors := Object(ObjectAddr)
	if (Monitors.Mode="")
		Monitors.List[HMON] := MonitorInfo(HMON),
	else if (Monitors.Mode=-1)
		Monitors.Count++
	else if (Monitors.Mode=-2)
		Monitors.List.Push(HMON)
	return true
}

;obtiene el número de monitores
;Sintaxis: MonitorCount( [¿incluir todos los monitores?] )
MonitorCount(All := false) {
	if !(All)
		return DllCall("User32.dll\GetSystemMetrics", "Int", 80)
	return MonitorEnum(-1)
}

;recupera hWnd del monitor principal
;Sintaxis: MonitorPrimary( [info (salida)] )
;Ejemplo: MsgBox % "hWnd: " MonitorPrimary(h) "`nNúmero: " h.Num "`nNombre: " h.Name
MonitorPrimary(ByRef Info := "", dwFlags := 0x1) {
	hMonitor := DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", dwFlags)
	if (IsByRef(Info))
		Info := MonitorInfo(v)
	return hMonitor, ErrorLevel := !hMonitor
} 

;modificar brillo y gama
;Sintaxis: SetDeviceGammaRamp( [brillo 1~256 N125], [gama] )
SetDeviceGammaRamp(Brightness := 125, Gamma := 1.0) {
	Brightness := (Brightness>256)?256:(Brightness<0)?1:Brightness
	, VarSetCapacity(gr, 512*3), x := 1/gamma
	Loop, 256 {
		(nValue:=(Brightness+128)*(A_Index-1))>65535?(nValue:=65535)
		nValue := (nValue**x/65535**x)*65535
		, NumPut(nValue, gr, 2*(A_Index-1), "Ushort")
		, NumPut(nValue, gr, 512+2*(A_Index-1), "Ushort")
		, NumPut(nValue, gr, 1024+2*(A_Index-1), "Ushort")
	} hDC := DllCall("User32.dll\GetDC", "Ptr", 0)
	return DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC, "Ptr", &gr)
	, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC)
}

;obtener brillo
;Sintaxis: MonitorBrightness( [rojo], [verde], [azul] )
MonitorGetBrightness(ByRef R := "", ByRef G := "", ByRef B := "") {
	hDC:=DllCall("User32.dll\GetDC", "Ptr", 0), VarSetCapacity(gr, 1536, 0)
	, i:=DllCall("Gdi32.dll\GetDeviceGammaRamp", "Ptr", hDC, "Ptr", &gr), R := NumGet(gr, 2, "UShort") - 128
	, G := NumGet(gr, 512 + 2, "UShort") - 128, B := NumGet(gr, 1024 + 2, "UShort") - 128
	return R, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), ErrorLevel := !i
}

;modificar brillo
;Sintaxis: MonitorBrightness( [rojo], [verde], [azul] )
MonitorSetBrightness(R := "", G := "", B := "") {
	if (R="")||(G="")||(B="")
		MonitorGetBrightness(_R, _G, _B), R := (R="")?_R:R, G := (G="")?_G:G, B := (B="")?_B:B
	Loop % (VarSetCapacity(gr, 1536, 0) / 6)
		NumPut((r:=(R+128)*(A_Index-1))>65535?65535:r, gr, 2*(A_Index-1), "UShort")
		, NumPut((g:=(G+128)*(A_Index-1))>65535?65535:g, gr, 512+2*(A_Index-1), "UShort")
		, NumPut((b:=(B+128)*(A_Index-1))>65535?65535:b, gr, 1024+2*(A_Index-1), "UShort")
	i:=DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC:=DllCall("user32.dll\GetDC", "Ptr", 0), "Ptr", &gr)
	return i, DllCall("User32.dll\ReleaseDC", "Ptr", 0, "Ptr", hDC), ErrorLevel := !i
}

;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: INCLUDE :::::::::::::::::::::::::::::::::: *i
;Notas:
	;• poner las clases y funciones en la carpeta Lib.
		;--> %A_MyDocuments%\AutoHotkey\Lib
		;--> %A_ScriptDir%\Lib
		;--> %AHK_INSTALL_PATH%\Lib
	;• las funciones y clases con *i son opcionales (omite si no existe).
return
;#############################################################################################################################################
;--------------------------------------
;CLASES
;--------------------------------------
;estilo para los botones (redondeado, color de fondo/texto/borde ...)
#Include <Class_ImageButton> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=1103
;color para los controles
#Include <Class_CtlColors> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=4026
;color para ListView controles
#Include *i <Class_LV_Colors> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=1081
;otra opcion para las funciones con archivos INI
#Include *i <Class_INIFile> ;https://github.com/flipeador/AutoHotKey/blob/master/Class_INIFile
;clase para archivos
#Include *i <Class_OpenFile> ;https://github.com/flipeador/AutoHotKey/blob/master/Class_OpenFile
;editar filas individuales en ListView
#Include *i <Class_LV_InCellEdit> ;http://ahkscript.org/boards/viewtopic.php?p=15056#p15056

;--------------------------------------
;FUNCIONES
;--------------------------------------
#Include <Gdip> ;http://ahkscript.org/boards/viewtopic.php?t=6517
;otra opcion al InputBox
#Include *i <InputBoxEx> ;http://ahkscript.org/boards/viewtopic.php?f=42&t=5827
#Include *i <TrayTipEx> ;http://ahkscript.org/boards/viewtopic.php?f=42&t=5827
;otra opcion al TrayTip
#Include *i <ToolTipEx> ;https://github.com/flipeador/AutoHotKey/blob/master/ToolTipEx
;color de fondo para Picture controles
#Include *i <LinearGradient> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3593
;dialogo para seleccionar un icono
#Include *i <ChooseIcon> ;https://autohotkey.com/boards/viewtopic.php?f=42&t=10802

;--------------------------------------
;CONSTANTES
;--------------------------------------
;Link: http://ahkscript.org/boards/viewtopic.php?f=6&t=4557

;--------------------------------------
;OTROS
;--------------------------------------
#NoEnv ;evita comprobar las variables vacías para ver si son variables de entorno (recomendado para todos los nuevos scripts).
#MaxMem 4095 ;establece la capacidad máxima de cada variable, en megabytes.
