/*
FUNCIONES  AUTOHOTKEY UNICODE 32 & 64 BITS.
-------------------------------------------------------------------------
SO: WIN_XP, WIN_V, WIN_7, WIN_8, WIN_8.1,  WIN_10
AHK/SO Arquitectura: 32-Bits / 64-Bits
SO BASE: MS Windows 10 Pro 32 bits (10.0, compilación 10586)
Funciones:
	• Archivos
	• Carpetas
	• Cadena
	• Criptografía
	• Procesos
	• Internet
	• Gui & Dialogos
	• Gui controles
	• Registro
	• Control
	• Mouse & Teclado
	• Sistema & Configuración & Información de Versión
	• Ventanas
	• Servicios
	• Unidades
	• Sonido
	• Monitor
	• Números & Operaciones Matemáticas
	• Menús
	• Ejecutar
	• Barra de tareas
	• Device Context
	• Escritorio & Explorador & Menu Inicio & Papelera De Reciclaje
	• Estructuras
	• Notificaciones
	• Fuentes & Colores & Pincel
	• Recursos & DLL
	• Nombres y Rutas de Archivos
	• Tareas programadas
	• Administración de memoria
	• Gdiplus (GDI+)
	• Portapapeles
	• Administración de Energía
	• Pipe
	• Usuarios
	• Autorización y Seguridad
	• Dispositivos y Aplicaciones Predeterminadas
	• Administración De Configuración Plug and Play (PnP)
	• Array y Objetos
	• Lista de Imágenes, Imágenes, Bitmap, Iconos, Pixel
	• Servicios de Escritorio Remoto
	• Programas de Inicio Automático
	• Shell Interface (IShellItems & ShellItemArray)
	• Variables.
	• Sincronización
	• Otros (funciones variadas)
Clases (evitar sobreescribirlas, como por ejemplo, usandolas como simples variables, IVirtualDesktopManager:=1):
	• IVirtualDesktopManager
	• __gsvalue
	• __RichEditClass
Link (reporta problemas o sugerencias para nuevas funciones): http://ahkscript.org/boards/viewtopic.php?f=42&t=5535
AutoHotKey: 1.1.23.00+
Actualizado: AHK1.1.23.01 U32 & U64 || miércoles, 17 de febrero de 2016
Historial De Cambios: https://github.com/flipeador/AutoHotKey/blob/master/AutoHotKey%20Functions%20Library%20~%20Change%20Log
Notas:
	• si utiliza MUCHO las funciones que utilizan Gdip, iniciarlo antes usando GdiplusStartup().
	• ver INCLUDE al final para links a funciones y clases necesarias.
	• algunas funciones no soportan todos los SO espesificados arriba, esto es indicado en la funcion, Ej: WIN_V+
	• para obtener la descripción de A_LastError, usar GetLastError(description_out).
	• algunas funciones posiblemente no funcionen correctamente en la version de 64-Bits de AHK, reportar problemas.
	• algunas funciones requieren privilegios elevados en WIN_V+ (ejecutar como administrador), Ej. DriveFormat().
Codificación: UTF-8 BOM
Windows System Error Codes (exit codes) Description: http://www.symantec.com/connect/articles/windows-system-error-codes-exit-codes-description
Windows Data Types For AHK: https://github.com/flipeador/AutoHotKey/blob/master/Windows%20Data%20Types%20for%20AHK
*/ ;flipeador@gmail.com ################################################################################################
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
; ::::::::::::::::::::::::::::::::::::::::::::: FUNCIONES APARTE (para uso interno) ::::::::::::::::::::::::::::::::::																							   #
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
_getpid(h,z*){
	if z.MaxIndex() {
		p:=z[1],x:=z[2],i:=z[3]
		if (p) && (InStr(p,"."))
			WinGetPID(h?h:x,, i)
		else if (p)
			i := WinGetPID(h?h:x)
		return i
	} return __gsvalue.LastProcessId := ((InStr(h,".")||h=-1||h=-2)?ProcessExist(h):h=-3?__gsvalue.LastProcessId:h)
}

_gethwnd(ByRef hWnd, ByRef Control := "") {
	if (hWnd = -1)
		__gsvalue.LastWindowId := hWnd := WinExist("A")
	else if (hWnd = -2) {
		MouseGetPos,,, hWnd
		__gsvalue.LastWindowId := hWnd
	} else if (hWnd = -3)
		hWnd := __gsvalue.LastWindowId
	if IsByRef(Control) {
		if (Control = -1)
			__gsvalue.LastControlId := Control := ControlFocus(hWnd)
		else if (Control = -2) {
			MouseGetPos,,,, Control, 2
			__gsvalue.LastControlId := Control
		} else if (Control = -3)
			Control := __gsvalue.LastControlId
		else Control := (Control+0)=""?ControlExist(hWnd, Control):Control
}	}
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
;####################################################################################################################

















































































;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------  ------------   FUNCIONES	-------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->
;<--------------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	---------------	------->

;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ARCHIVOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;--------------------------------------------------------------------------------------------------------------------------------------------------
;General
;--------------------------------------------------------------------------------------------------------------------------------------------------
;eliminar o reciclar archivo(s) y/o directorio(s)
;Sintaxis: DeleteFile( [Filename], [Mode], [Force] )
;Parámetros:
	;Mode: espesificar una o mas de las siguientes letras.
		;R = operar en sub-directorios
		;F = operar en archivos (defecto)
		;D = operar en directorios
		;P = no eliminar el archivo de forma permanente, enviarlo a la papelera de reciclaje.
	;Force: espesificar true para forzar la operación. cuando se eliminar un archivo, se le quita el atributo de solo lectura, cuando se elimina un directorio, también elimina los subdirectorios.
;ErrorLevel:
	;-1 = ERROR. archivo inválido.
	;0 = OK. se han eliminado todos los archivos y/o directorios
	;[Array] = ERROR. no se han eliminado los siguientes archivos y/o directorios.
;Return:
	;0 = ERROR. no se ha eliminado ningun archivo y/o directorio
	;[Array] = OK. se han eliminado los siguientes archivos y/o directorios
DeleteFile(Filename, Mode := "F", Force := true) {
	R := InStr(Mode, "R"), F := InStr(Mode, "F"), D := InStr(Mode, "D"), P := InStr(Mode, "P")
	if !(P) && (R || InStr(Filename, "*") || InStr(Filename, "?")) && (Ok := []) && (Error := []) {
		Loop, Files, % Filename, % Mode
			if DeleteFile(A_LoopFileFullPath, Mode)
				Ok.Push(A_LoopFileFullPath)
			else Error.Push(A_LoopFileFullPath)
		return Ok.MaxIndex()?Ok:false, ErrorLevel := Error.MaxIndex()?Error:false
	} if IsFile(Filename, Filename, Attrib) {
		if (F) {
			if (P) {
				FileRecycle, % Filename
				return ErrorLevel?false:[Filename], ErrorLevel := ErrorLevel?[Filename]:false
			} if !DllCall("Kernel32.dll\DeleteFileW", "Str", (StrLen(Filename) > 260 ? "\\?\" : "") Filename)
				if !(Force && SetFileAttributes("-R", Filename) && DllCall("Kernel32.dll\DeleteFileW", "Str", (StrLen(Filename) > 260 ? "\\?\" : "") Filename))
					return false, ErrorLevel := [Filename]
			return [Filename], ErrorLevel := false
	}} else if (Attrib) || (P) {
		if (D) {
			if (P)
				FileRecycle, % Filename
			else FileRemoveDir, % Filename, % Force
			return ErrorLevel?false:[Filename], ErrorLevel := ErrorLevel?[Filename]:false
	}} return false, ErrorLevel := -1
}

;sobreescribir los datos del archivo por datos inválidos.
;Sintaxis: ShredFile( [Filename], [Passes], [MaxSize], [FillBytes] )
;Parámetros:
	;Filename: archivo a sobreescribir.
	;Passes: pasadas. por defecto usa 1.
	;MaxSize: tamaño máximo de memoria (RAM) a usar, en Bytes. por defecto usa 100MB.
	;FillBytes: Array con los bytes a rellenar entre cada pasada (entre 0 y 255). por defecto usa el N° de pasadas actual.
;Nota: para archivos de 500MB o más puede ser muy lento.
ShredFile(Filename, Passes := 1, MaxSize := 104857600, FillBytes := "") {
	if !SetFileAttributes("N", Filename) || !(f := FileOpen(Filename, "rw-rwd"))
		return false
	TotalSize := CurrentSize := f.Length, Bytes := []
	Loop, % Floor(TotalSize / MaxSize)
		CurrentSize -= Bytes.Push(MaxSize) * 0 + MaxSize
	if (CurrentSize > 0)
		Bytes.Push(CurrentSize)
	Loop, % (Passes) {
		FillByte := (FillBytes[A_Index] + 0) = "" ? A_Index : FillBytes[A_Index]
		for k, v in Bytes {
			VarSetCapacity(Data, v, FillByte)
			, f.RawWrite(Data, v)
			, VarSetCapacity(Data, 0)
		} f.Seek(0), VarSetCapacity(Data, 0)
	} return true, f.Close(), SetFileTime(1602, Filename, "MCA")
}

;renombrar archivo
;Sintaxis: FileRename( [Filename], [NewName], [Overwrite] )
FileRename(Filename, NewName, Overwrite := false) {
	SplitPath, Filename,, Dir
	return MoveFile(Filename, Dir "\" NewName, OverWrite)
}

;copiar archivo
;Sintaxis: CopyFile( [Filename], [NewFilename], [Overwrite] )
;Parámetros:
	;Filename: archivo a copiar.
	;NewFilename: nuevo archivo, directorio, o dejar vacío para usar el directorio actual.
	;Overwrite: espesificar true para sobreescribir el archivo si ya existe.
CopyFile(Filename, NewFilename := "", Overwrite := false) {
	Filename := GetFullPathName(Filename)
	SplitPath, Filename, File
	if (NewFilename = "")
		NewFilename := A_WorkingDir "\" File
	else NewFilename := GetFullPathName(NewFilename), NewFilename := DirExist(NewFilename) ? NewFilename "\" File : NewFilename
	return DllCall("Kernel32.dll\CopyFileExW", "Str", (StrLen(Filename) > 260 ? "\\?\" : "") Filename
		, "Str", (StrLen(NewFilename) > 260 ? "\\?\" : "") NewFilename, "Ptr", 0, "Ptr", 0, "Ptr", 0
		, "UInt", (IsWindowsVistaOrGreater()?0x00001808:0) | (Overwrite?0:0x00000001))
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363852(v=vs.85).aspx

;mover archivo
;Sintaxis: MoveFile( [Filename], [NewFilename], [Overwrite] )
;Parámetros:
	;Filename: archivo a mover.
	;NewFilename: archivo destino, directorio, o dejar vacío para usar el directorio actual.
	;Overwrite: espesificar true para sobreescribir el archivo si ya existe.
MoveFile(Filename, NewFilename := "", Overwrite := false) {
	Filename := GetFullPathName(Filename)
	SplitPath, Filename, File
	if (NewFilename = "")
		NewFilename := A_WorkingDir "\" File
	else NewFilename := GetFullPathName(NewFilename), NewFilename := DirExist(NewFilename) ? NewFilename "\" File : NewFilename
	return DllCall("Kernel32.dll\MoveFileExW", "Str", (StrLen(Filename) > 260 ? "\\?\" : "") Filename
		, "Str", (StrLen(NewFilename) > 260 ? "\\?\" : "") NewFilename, "UInt", 0x00000008 | (Overwrite?0:0x00000001))
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365240(v=vs.85).aspx

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Diálogos
;--------------------------------------------------------------------------------------------------------------------------------------------------
;dialogo para seleccionar archivos
;Sintaxis: SelectFile( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
;Opciones:
	;M = permitir seleccionar varios archivos
		;Return: File1`nFile2`nFile3`nEtc
	;3 = el archivo debe existir
SelectFile(RootDirFilename := "", Filter := "", Options := 3, Prompt := "") {
	try FileSelectFile, OutputVar, %Options%, %RootDirFilename%, %Prompt%, %Filter%
	catch
		FileSelectFile, OutputVar, %Options%,, %Prompt%, %Filter%
	if (InStr(Options, "M")) {
		Loop, Parse, % OutputVar, `n, `r
			if (A_Index=1)
				Path := A_LoopField
			else Files .= Path "\" A_LoopField "`n"
		OutputVar := RTrim(StrReplace(Files, "\\", "\"), "`n")
	} return OutputVar
}

;dialogo para guardar archivo
;Sintaxis: SaveFile( [Archivo/Directorio], [Filtro], [Opciones], [Título de la ventana] )
SaveFile(RootDirFilename := "", Filter := "", Options := 24, Prompt := "") {
	try FileSelectFile, OutputVar, S%Options%, %RootDirFilename%, %Prompt%, %Filter%
	catch
		FileSelectFile, OutputVar, S%Options%,, %Prompt%, %Filter%
	return OutputVar
}

;diálogo para guardar archivo
;Sintaxis: FileSaveDialog( [opciones] )
;Parámetros:
	;Opciones:espesificar un Objeto con la información.
		;Title: título para la ventana.
		;RooDir: ruta completa a un directorio que sera seleccionado por defecto al abrir el diálogo.
		;Filename: nombre de larchivo por defecto.
		;Flags: https://msdn.microsoft.com/en-us/library/windows/desktop/dn457282(v=vs.85).aspx
			;Guardar Archivo:
				;0x00000002 = preguntar para sobreescribir si el archivo ya existe.
				;0x00000004 = solo permite elegir un archivo que tenga la extensiones espesificadas en el filtro.
				;0x00010000 = no comprobar si la creacion del elemento, como se espesifica en el diálogo, tendrá exito. 
				;0x00002000 = preguntar por la creación si el elemento no existe.
			;General:
				;0x00040000 = ocultar los elementos del panel izquierdo como: Equipo, Bibliotecas, Favoritos, Red, etc.)
				;0x02000000 = no añadir el elemento seleccionado o guardado a la lista de elementos recientes.
				;0x10000000 = incluir archivos ocultos y del sistema.
				;0x40000000 = indica que el panel de vista previe siempre debe mostrarse.
		;ButtonLabel: espesificar el nombre de los botones "Abrir" y "Guardar".
		;Filter: espesificar un Array en un Array con el nombre descriptivo del filtro, el filtro y opcional establecerlo por defecto
			;Sintaxis: [ ["Descripción 1", "Filtro 1"], ["Descripción 2", "Filtro 2", "Defecto"] , ["Descripción 3", "Filtro 3"] ]
		;FilterIndex: espesificar el indice del filtro por defecto a mostrar. esto se puede espesificar en "Filter".
;Return: ruta
;ErrorLevel:
	;-1 = error al crear el objeto.
	;0 = OK
	;1 = ERROR
	;2 = no se ha podido obtener la ruta
FileSaveDialog(Options := "") { ;WIN_V+
	;IModalWindow: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761688(v=vs.85).aspx
		;IFileDialog: https://msdn.microsoft.com/en-us/library/windows/desktop/bb775966(v=vs.85).aspx
			;IFileSaveDialog: https://msdn.microsoft.com/en-us/library/windows/desktop/bb775688(v=vs.85).aspx
 
	;create IFileSaveDialog Interface
	;Example: https://searchcode.com/codesearch/view/10150167/
	;Source Code: http://board.flatassembler.net/topic.php?t=14106
	if !(IFileSaveDialog := ComObjCreate("{C0B4E2F3-BA21-4773-8DBA-335EC946EB8B}", "{84BCCD23-5FDE-4CDB-AEA4-AF64B83D78AB}"))
		return false, ErrorLevel := -1
	
	;IFileSaveDialog::SetOptions method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775708(v=vs.85).aspx)
	if Options.HasKey("Flags")
		DllCall(NumGet(NumGet(IFileSaveDialog+0), 9*A_PtrSize), "Ptr", IFileSaveDialog, "UInt", Options.Flags)
	else DllCall(NumGet(NumGet(IFileSaveDialog+0), 9*A_PtrSize), "Ptr", IFileSaveDialog, "UInt", 0x12002002)
	
	;IFileDialog::SetTitle method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761834(v=vs.85).aspx)
	if Options.HasKey("Title")
		DllCall(NumGet(NumGet(IFileSaveDialog+0), 17*A_PtrSize), "Ptr", IFileSaveDialog, "WStr", Options.Title)
 
	;IFileDialog::SetFolder method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761828(v=vs.85).aspx)
	if Options.HasKey("RootDir") && DirExist(Options.RootDir)
		DllCall(NumGet(NumGet(IFileSaveDialog+0), 12*A_PtrSize), "Ptr", IFileSaveDialog, "Ptr", CreateShellItem(Options.RootDir))
	
	;IFileDialog::SetFileName method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775974(v=vs.85).aspx)
	if Options.HasKey("Filename")
		DllCall(NumGet(NumGet(IFileSaveDialog+0), 15*A_PtrSize), "Ptr", IFileSaveDialog, "WStr", Options.Filename)
	
	;IFileDialog::SetOkButtonLabel method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761830(v=vs.85).aspx)
	if Options.HasKey("ButtonLabel")
		DllCall(NumGet(NumGet(IFileSaveDialog+0), 18*A_PtrSize), "Ptr", IFileSaveDialog, "WStr", Options.ButtonLabel)
 
	;IFileDialog::SetFileTypes method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775980(v=vs.85).aspx)
	if Options.HasKey("Filter") && Options.Filter.MaxIndex() {
		VarSetCapacity(COMDLG_FILTERSPEC, Array_Length(Options.Filter) * 2, 0), Offset := 0
		for k, v in Options.Filter {
			d%A_Index% := v.2=""?"":v.1, NumPut(&d%A_Index%, COMDLG_FILTERSPEC, Offset, "Ptr") ;friendly name of the filter
			, f%A_Index% := v.2=""?v.1:v.2, NumPut(&f%A_Index%, COMDLG_FILTERSPEC, Offset+A_PtrSize, "Ptr"), Offset += 2*A_PtrSize ;filter pattern
			if (v.3) && !Options.HasKey("FilterIndex") ;establecer filtro por defecto si no se ha espesificado FilterIndex.
				Options.FilterIndex := A_Index
		} DllCall(NumGet(NumGet(IFileSaveDialog+0), 4*A_PtrSize), "Ptr", IFileSaveDialog, "UInt", Options.Filter.MaxIndex(), "Ptr", &COMDLG_FILTERSPEC)
		for k, v in Options.Filter ;free Descriptions and Filters variables
			VarSetCapacity(d%A_Index%, 0), VarSetCapacity(f%A_Index%, 0)
	}
 
	;IFileDialog::SetFileTypeIndex method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775978(v=vs.85).aspx)
	if Options.HasKey("FilterIndex")
		DllCall(NumGet(NumGet(IFileSaveDialog+0), 5*A_PtrSize), "Ptr", IFileSaveDialog, "UInt", Options.FilterIndex)

	;IModalWindow::Show method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761688(v=vs.85).aspx)
	if !(DllCall(NumGet(NumGet(IFileSaveDialog+0), 3*A_PtrSize), "Ptr", IFileSaveDialog, "Ptr", 0) = 0)
		return false, ObjRelease(IFileSaveDialog), ErrorLevel := true

	;IFileDialog::GetResult method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775964(v=vs.85).aspx)
	if !(DllCall(NumGet(NumGet(IFileSaveDialog+0), 20*A_PtrSize), "Ptr", IFileSaveDialog, "PtrP", IShellItem) = 0)
		return false, ObjRelease(IFileSaveDialog), ErrorLevel := 2
	OutputVar := GetPathFromIDList(GetIDListFromObject(IShellItem)), ObjRelease(IShellItem), ObjRelease(IFileSaveDialog)

	;return and free IFileSaveDialog object
	return OutputVar, ErrorLevel := OutputVar=""?2:false
} ;https://autohotkey.com/boards/viewtopic.php?f=42&t=13302&p=68253#p68253

;diálogo para seleccionar archivo/carpeta
;Sintaxis: FileOpenDialog( [opciones]] )
;Parámetros:
	;Opciones: espesificar un Objeto con la información.
		;hWnd: identificador de la ventana propietaria.
		;RootDir: ruta completa a un directorio que sera seleccionado por defecto al abrir el diálogo. si la ruta no existe, se omite.
		;Filename: nombre del archivo por defecto en el diálogo.
		;Filter: espesificar un Array en un Array con el nombre descriptivo del filtro, el filtro y opcional establecerlo por defecto
			;Sintaxis: [ ["Descripción 1", "Filtro 1"], ["Descripción 2", "Filtro 2", "Defecto"] , ["Descripción 3", "Filtro 3"] ]
		;Prompt: comentario.
		;Title: título de la ventana.
		;Flags: https://msdn.microsoft.com/en-us/library/windows/desktop/dn457282(v=vs.85).aspx
			;Seleccionar Directorio:
				;0x00000020 = seleccionar directorio.
				;0x00000800 = el directorio debe existir.
			;Seleccionar Archivo:
				;0x00000200 = permite seleccionar mas de un archivo.
				;0x00001000 = el archivo debe existir.
				;0x00100000 = los accesos directos no deben ser tratados como su destino (no deve devolver la ruta destino del acceso directo sino la ruta al acceso directo).
				;0x00000080 = permite al usuario elegir cualquier artículo en el espacio de nombre Shell.
			;General:
				;0x00040000 = ocultar los elementos del panel izquierdo como: Equipo, Bibliotecas, Favoritos, Red, etc.)
				;0x02000000 = no añadir el elemento seleccionado o guardado a la lista de elementos recientes.
				;0x10000000 = incluir archivos ocultos y del sistema.
				;0x40000000 = indica que el panel de vista previe siempre debe mostrarse.
		;ButtonLabel: espesificar el nombre de los botones "Abrir" y "Guardar".
		;FilterIndex: espesificar el indice del filtro por defecto a mostrar. esto se puede espesificar en "Filter".
		;DefaultExtension: establecer la extension por defecto a añadir a los nombres de archivos.
		;DefaultFolder: establecer directorio por defecto si no se espesifica
		;CustomPlaces: establecer directorios personalizados en el panel izquierdo. puede ser un Array o directamente el directorio.
			;Sintaxis 1: "Directorio"
			;Sintaxis 2: ["Directorio 1", "Directorio 2"]
;Return: archivos separador por `n
;ErrorLevel:
	;-1 = error al crear el objeto
	;0 = OK
	;1 = el usuario canceló el diálogo.
	;2 = la variable de salida esta vacía. esto ocurre, por ej. cuando el usuario acepta el diálogo no habiando seleccionado una carpeta (ejemplo, estando en Equipo).
FileOpenDialog(Options := "") { ;WIN_V+
	;IModalWindow: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761688(v=vs.85).aspx
		;IFileDialog: https://msdn.microsoft.com/en-us/library/windows/desktop/bb775966(v=vs.85).aspx
			;IFileOpenDialog: https://msdn.microsoft.com/en-us/library/windows/desktop/bb775834(v=vs.85).aspx#methods
	;ShellItemArray: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761106(v=vs.85).aspx
 
	;create IFileOpenDialog Interface
	;Example: http://codexpert.ro/blog/2013/05/21/file-open-dialog-with-multiple-selection-part-3-cutting-the-dog-tail/
	;Source Code: http://dotnetframework.org/default.aspx/DotNET/DotNET/8@0/untmp/whidbey/REDBITS/ndp/fx/src/WinForms/Managed/System/WinForms/FileDialog_Vista_Interop@cs/1/FileDialog_Vista_Interop@cs
	if !(IFileOpenDialog := ComObjCreate("{DC1C5A9C-E88A-4DDE-A5A1-60F82A20AEF7}", "{D57C7288-D4AD-4768-BE02-9D969532D960}"))
		return false, ErrorLevel := -1
 
	;IFileDialog::SetDefaultFolder method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775972(v=vs.85).aspx)
	if Options.HasKey("DefaultFolder") && DirExist(Options.DefaultFolder)
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 11*A_PtrSize), "Ptr", IFileOpenDialog, "Ptr", CreateShellItem(Options.DefaultFolder))
	;else DllCall(NumGet(NumGet(IFileOpenDialog+0), 11*A_PtrSize), "Ptr", IFileOpenDialog, "Ptr", CreateShellItem(A_MyDocuments))
 
	;IFileDialog::AddPlace method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775946(v=vs.85).aspx)
	if Options.HasKey("CustomPlaces") {
		if !IsObject(Options.CustomPlaces) && DirExist(Options.CustomPlaces)
			DllCall(NumGet(NumGet(IFileOpenDialog+0), 21*A_PtrSize), "Ptr", IFileOpenDialog, "Ptr", CreateShellItem(Options.CustomPlaces), "UInt", 0)
		else if IsObject(Options.CustomPlaces) {
			for k, v in Options.CustomPlaces {
				if DirExist(v) {
					DllCall(NumGet(NumGet(IFileOpenDialog+0), 21*A_PtrSize), "Ptr", IFileOpenDialog, "Ptr", CreateShellItem(v), "UInt", 0)
	}	}	}	}
 
	;IFileDialog::SetDefaultExtension method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775970(v=vs.85).aspx)
	if Options.HasKey("DefaultExtension") && (Options.DefaultExtension:=StrReplace(Options.DefaultExtension, "."))
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 22*A_PtrSize), "Ptr", IFileOpenDialog, "WStr", Options.DefaultExtension)
 
	;IFileDialog::SetTitle method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761834(v=vs.85).aspx)
	if Options.HasKey("Title")
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 17*A_PtrSize), "Ptr", IFileOpenDialog, "WStr", Options.Title)
 
	;IFileDialog::SetFolder method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761828(v=vs.85).aspx)
	if Options.HasKey("RootDir") && DirExist(Options.RootDir)
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 12*A_PtrSize), "Ptr", IFileOpenDialog, "Ptr", CreateShellItem(Options.RootDir))
 
	;IFileDialog::SetFileName method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775974(v=vs.85).aspx)
	if Options.HasKey("Filename")
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 15*A_PtrSize), "Ptr", IFileOpenDialog, "WStr", Options.Filename)
 
	;IFileDialog::SetOptions method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761832(v=vs.85).aspx)
	if Options.HasKey("Flags")
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 9*A_PtrSize), "Ptr", IFileOpenDialog, "UInt", Options.Flags)
	else DllCall(NumGet(NumGet(IFileOpenDialog+0), 9*A_PtrSize), "Ptr", IFileOpenDialog, "UInt", 0x12101000)
 
	;IFileDialog::SetOkButtonLabel method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761830(v=vs.85).aspx)
	if Options.HasKey("ButtonLabel")
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 18*A_PtrSize), "Ptr", IFileOpenDialog, "WStr", Options.ButtonLabel)
 
	;IFileDialog::SetFileTypes method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775980(v=vs.85).aspx)
	if Options.HasKey("Filter") && Options.Filter.MaxIndex() {
		VarSetCapacity(COMDLG_FILTERSPEC, Array_Length(Options.Filter) * 2, 0), Offset := 0
		for k, v in Options.Filter {
			d%A_Index% := v.2=""?"":v.1, NumPut(&d%A_Index%, COMDLG_FILTERSPEC, Offset, "Ptr") ;friendly name of the filter
			, f%A_Index% := v.2=""?v.1:v.2, NumPut(&f%A_Index%, COMDLG_FILTERSPEC, Offset+A_PtrSize, "Ptr"), Offset += 2*A_PtrSize ;filter pattern
			if (v.3) && !Options.HasKey("FilterIndex") ;establecer filtro por defecto
				Options.FilterIndex := A_Index
		} DllCall(NumGet(NumGet(IFileOpenDialog+0), 4*A_PtrSize), "Ptr", IFileOpenDialog, "UInt", Options.Filter.MaxIndex(), "Ptr", &COMDLG_FILTERSPEC)
		for k, v in Options.Filter ;free Descriptions and Filters variables
			VarSetCapacity(d%A_Index%, 0), VarSetCapacity(f%A_Index%, 0)
	}
 
	;IFileDialog::SetFileTypeIndex method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775978(v=vs.85).aspx)
	if Options.HasKey("FilterIndex")
		DllCall(NumGet(NumGet(IFileOpenDialog+0), 5*A_PtrSize), "Ptr", IFileOpenDialog, "UInt", Options.FilterIndex)
 
	;IModalWindow::Show method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761688(v=vs.85).aspx)
	if !(DllCall(NumGet(NumGet(IFileOpenDialog+0), 3*A_PtrSize), "Ptr", IFileOpenDialog, "Ptr", 0) = 0)
		return false, ObjRelease(IFileOpenDialog), ErrorLevel := true
 
	;IFileOpenDialog::GetResults method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb775831(v=vs.85).aspx)
	DllCall(NumGet(NumGet(IFileOpenDialog+0), 27*A_PtrSize), "Ptr", IFileOpenDialog, "PtrP", IShellItemArray)
	for Index, Path in GetIDListsFromShellItemArray(IShellItemArray, true)
		OutputVar .= Path "`n"
	ObjRelease(IShellItemArray), ObjRelease(IFileOpenDialog) 
	
	;return
	return RTrim(OutputVar, "`n"), ErrorLevel := OutputVar=""?2:false
} ;https://autohotkey.com/boards/viewtopic.php?f=42&t=13302&p=68253#p68253

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Obtener
;--------------------------------------------------------------------------------------------------------------------------------------------------
;obtener fecha de creacion, modificacion y/o último acceso
GetFileTime(Filename, WhichTime := "M") {
	OutputVar := []
	Loop, Parse, % WhichTime
	{	FileGetTime, Time, %Filename%, %WhichTime%
		if !(Time="")
			OutputVar.Push(Time)
	} return OutputVar.MaxIndex()=1?OutputVar[1]:OutputVar
}

;obtener atributos de un archivo o carpeta
;Sintaxis: GetFileAttributes( [Archivo/Carpeta], [out Attrib], [out Path], [out Type] )
;Parámetros:
	;Attrib: devuelve un valor que reprecenta los atributos.
	;Path: devuelve la ruta completa.
	;Type: si es archivo devuelve "F", si es directorio devuelve "D".
;Return:
	;0 = ERROR
	;[atributos] = OK
		;R = solo lectura
		;A = archivo | modificado
		;S = sistema
		;H = oculto
		;N = normal
		;O = fuera de linea
		;T = temporal
		;C = comprimido
		;D = directorio | carpeta
		;E = encriptado
		;V = virtual
GetFileAttributes(Filename, ByRef Attrib := "", ByRef Path := "", ByRef Type := "") {
	Path := GetFullPathName(Filename), Path := (StrLen(Path) > 260 ? "\\?\" : "") Path (StrLen(Path) > 2 ? "" : "\")
	if ((Attrib := DllCall("Kernel32.dll\GetFileAttributesW", "Ptr", &Path)) = -1)
		return false
	for k, v in {"R": 0x1, "A": 0x20, "S": 0x4, "H": 0x2, "N": 0x80, "D": 0x10, "O": 0x1000, "C": 0x800, "T": 0x100, "E": 0x4000, "V": 0x10000}
		if (Attrib & v)
			OutputVar .= k
	if IsByRef(Type)
		Type := Attrib&0x10?"D":"F"
	return OutputVar
}

;obtiene información del archivo
;Nota: usar GetFileVersionInfo() para obtener información mas rápido
FileGetInfo2(Filename, ValidatePath := 0) {
	Filename := ValidatePath ? GetValidPathName(Filename) : Filename
	if !IsFile( Filename )
		return "", ErrorLevel := 1
	Filename := RegExReplace(Filename, "\\+", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Datafile WHERE Name = '" Filename "'")
		i.AccessMask := a.AccessMask, i.Archive := a.Archive, i.Caption := a.Caption, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod, i.CreationClassName := a.CreationClassName, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName, i.CSName := a.CSName, i.Description := a.Description, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName, i.Encrypted := a.Encrypted, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension, i.FileName := a.FileName, i.FileSize := a.FileSize, i.FileType := a.FileType, i.Writeable := a.Writeable
		, i.FSCreationClassName := a.FSCreationClassName, i.FSName := a.FSName, i.Hidden := a.Hidden, i.InstallDate := a.InstallDate
		, i.InUseCount := a.InUseCount, i.LastAccessed := a.LastAccessed, i.LastModified := a.LastModified, i.ManuFacturer := a.Manufacturer
		, i.Name := a.Name, i.Path := a.Path, i.Readable := a.Readable, i.Status := a.Status, i.System := a.System, i.Version := a.Version
	return i, ErrorLevel := !i.Name
}

;obtener informacion de un acceso directo
;Sintaxis: GetShortcutFile( [acceso directo], [comando], [directorio de trabajo], [parámetros], [descripcion], [icono], [índice], [modo de inicio] )
;Modo de inicio: 1 = normal | 2 = maximizado | 3 = minimizado
;Nota: si el archivo espesificado no es un acceso directo válido, devuelve el archivo espesificado.
GetShortcutFile(ShortcutFile, ByRef OutTarget := "", ByRef OutDir := "", ByRef OutArgs := "", ByRef OutDescription := "", ByRef OutIcon := "", ByRef OutIconNum := "", ByRef OutRunState := "") {
	FileGetShortcut, %ShortcutFile%, OutTarget, OutDir, OutArgs, OutDescription, OutIcon, OutIconNum, OutRunState
	return ErrorLevel?ShortcutFile:(OutTarget?OutTarget:ShortcutFile)
}

GetFileVersion(Filename) {
	FileGetVersion, OutputVar, %Filename%
	return OutputVar
}

GetFileSize(FileName, Units := "", Places := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	FileGetSize, FileSize, %FileName%
	FileSize := _[Units]?FileSize/_[Units]:FileSize
	return Places=""?FileSize:Round(FileSize, Places)
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Establecer
;--------------------------------------------------------------------------------------------------------------------------------------------------
SetFileTime(Time := "", FilePattern := "", WhichTimeMCA := "M", OperateOnFolders := false, Recurse := false) {
	if IsObject(Time)
		for k, v in Time
			FileSetTime, %v%, %FilePattern%, % k=1?"M":k=2?"C":k=3?"A":k, %OperateOnFolders%, %Recurse%
	else Loop, Parse, % WhichTimeMCA
		FileSetTime, %Time%, %FilePattern%, %A_LoopField%, %OperateOnFolders%, %Recurse%
	return !ErrorLevel
}

;cambiar atributo(s) a carpeta(s) y/o archivo(s).
;Sintaxis: SetFileAttributes( [+/-/^ Attrib], [Filename], [Mode] )
;Parámetros:
	;Mode: F = incluir archivos | D = incluir directorios | R = incluir subdirectorios.
	;Attrib: espesificar una o mas de las siguientes letras. para quitar usar "-", para añadir usar "+", para alternar usar "^".
		;R = solo lectura
		;A = archivo | modificado
		;S = sistema
		;H = oculto
		;N = normal
		;O = fuera de linea
		;T = temporal
		;[valor] = espesificar un valor que representa los atributos para reemplazar.
;Ejemplo: MsgBox % SetFileAttributes("+HS-R^A", A_Desktop "\test.txt")
SetFileAttributes(Attributes, Filename, Mode := "FD") {
	static A := {R: 0x1, A: 0x20, S: 0x4, H: 0x2, N: 0x80, O: 0x1000, T: 0x100}
	if InStr(Mode, "R") || InStr(Filename, "*") || InStr(Filename, "?") {
		Loop, Files, % Filename, % Mode
			Ok += !!SetFileAttributes(Attributes, A_LoopFileFullPath)
		return Ok
	} if ((Attributes + 0) = "") {
		if (GetFileAttributes(Filename, Attrib, Filename) = 0)
			return false
		Loop, Parse, % Attributes,, % A_Space A_Tab
			if A[A_LoopField]
				Attrib := _cvtvalue(Attrib, P A[A_LoopField])
			else P := A_LoopField
	} else Attrib := Attributes, Filename := (StrLen(Filename) > 260 ? "\\?\" : "") Filename
	return DllCall("Kernel32.dll\SetFileAttributesW", "Ptr",  &Filename, "UInt", Attrib)
}

;establecer seguridad para el archivo/carpeta
;Sintaxis: FileSetSecurity( [archivo], [Usuario], [permisos], [opciones], [acceso] )
;Parámetros:
	;Archivo: espesificar el archivo o carpeta a modificar
	;Usuario: espesificar el SID del usuario que hereda los permisos o Dominio\Usuario. si no se espesifica usa el usuario actual
		;Nota: para obtener una lista de usuarios con información, usar UserAccountsEnum()
	;Permisos: espesificar el acceso deseado
		;0x1F01FF = CONTROL TOTAL (F)
		;0x120089 = LECTURA (R)
		;0x120116 = ESCRITURA (W)
		;0x1200a0 = EJECUCIÓN (X)
		;0x00010000 = ELIMINACIÓN (D)
		;0x1301BF = MODIFICACIÓN (M)
	;Opciones:
		;0 = directorios
		;1 = directorios y archivos
		;2 = directorios y sub-directorios
		;3 = directorios, sub-directorios y archivos
	;Acceso: https://msdn.microsoft.com/en-us/library/windows/desktop/aa772244(v=vs.85).aspx
		;0 = permitir
		;1 = denegar
;Notas:
	;los permisos se pueden ver haciendo clic en propiedades del archivo, pestaña seguridad.
	;los permisos pueden ser cambiados con ICACLS en CMD: icacls [archivo] /grant *[usuario]:([permisos, letra],WDAC)
	;la función establece el propietario, ya que se requiere para cambiar los permisos
	;el proceso invocador debe tener permisos de administrador para modificar los permisos
;Ejemplo:
	;MsgBox % "Tomar Posesión: " FileSetOwner(A_SysDir() "\calc.exe") ;primero tomar posesión
	;MsgBox % "Control Total: " FileSetSecurity(A_SysDir() "\calc.exe") ;segundo modificar los permisos
;Return: 0|1
FileSetSecurity(Path, Trustee := "", AccessMask := 0x1F01FF, Flags := 1, AccesFlag := 0) { ;WIN_V+
	Trustee := Trustee=""?A_UserNameEx():Trustee, Path := GetFullPathName(Path)
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Path, 1, 1)
	, Owner := oADsSecurityDescriptor.Owner
	if !(Trustee=Owner) && !(Owner="") && !(Trustee="")
		FileSetOwner(Path, Trustee)
	oDiscretionaryAcl := oADsSecurityDescriptor.DiscretionaryAcl
	, oAccessControlEntry := ComObjCreate("AccessControlEntry")
	, oAccessControlEntry.Trustee := Trustee
	, oAccessControlEntry.AccessMask := AccessMask
	, oAccessControlEntry.AceFlags := Flags
	, oAccessControlEntry.AceType := AccesFlag
	, oDiscretionaryAcl.AddAce(oAccessControlEntry)
	, oADsSecurityUtility.SetSecurityDescriptor(Path, 1, oADsSecurityDescriptor, 1)
}

;establecer el propietario a archivo/directorio
;Sintaxis: FileSetOwner( [archivo], [usuario] )
;Parámetros:
	;Usuario: espesificar el dominio\usuario o el SID del usuario. por defecto usa el usuario actual.
FileSetOwner(Path, Owner := "") {
	Owner := Owner=""?A_UserNameEx():Owner
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Path:=GetFullPathName(Path), 1, 1)
	, oADsSecurityDescriptor.Owner := Owner
	, oADsSecurityUtility.SetSecurityDescriptor(Path, 1, oADsSecurityDescriptor, 1)
}

;obtiene el dominio y nombre de usuario propietario
;Sintaxis: FileGetOwner( [archivo] )
;Return: dominio\usuario
FileGetOwner(Path) { ;WIN_V+
	oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(GetFullPathName(Path), 1, 1)
	return oADsSecurityDescriptor.Owner
}

;permite que un administrador recupere el acceso a un archivo que anteriormente le era denegado, convirtiendo al administrador en el propietario del archivo.
;Sintaxis: FileTakeOwn( [archivo], [¿Recurse?], [AdminGroup] )
;Parámetros:
	;Archivo: espesificar el archivo o carpeta a la cual tomar posesión. puede usar el comodín «*»
	;Recurse: 0|1. indica si se debe operar en sub-directorios.
	;AdminGroup: concede la posesión al grupo de administradores en vez del usuario actual
;Notas:
	;esta función establece el propietario del archivo espesificado al usuario actual o al grupo de administradores
	;esta información se puede ver y cambiar en las propiedades del archivo, seguridad, opciones avanzadas.
	;el proceso invocador debe tener permisos de administrador para modificar el propietario
;Return: 0|1
;ErrorLevel: 0|1
FileTakeOwn(File, Recurse := false, AdminGroup := false) { ;WIN_V+
	CMD("takeown.exe /F " Chr(34) GetFullPathName(File) Chr(34) (AdminGroup?" /A":"") (Recurse?" /R":""))
	return !ErrorLevel
} ;https://technet.microsoft.com/es-es/library/cc753024(v=ws.10).aspx

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Escribir
;Nota: cuando se escribe, se remplaza `n por `ř`n
;--------------------------------------------------------------------------------------------------------------------------------------------------
;escribir en un archivo. (añadir al final)
;Sintáxis: AppendFile( [Text], [Filename], [Encoding] )
AppendFile(Text, Filename, Encoding := "CP0") {
	if !(f := FileOpen(Filename, "a`n", Encoding)) 
		if !SetFileAttributes("-R", Filename) || !(f := FileOpen(Filename, "a`n", Encoding))
			return false, ErrorLevel := true
	f.Length := f.Length + (BytesWritten := f.Write(Text))
	return BytesWritten, f.Close(), ErrorLevel := false
}

;añadir texto a una linea espesífica.
;escribir en una linea espesifica
;Sintáxis: AppendFileLine( [Text], [Filename], [LineNum], [Encoding], [Right] )
AppendFileLine(Text, Filename, LineNum := 1, Encoding := "CP0", Right := false) {
	if !(f := FileOpen(Filename, "rw", Encoding)) 
		if !SetFileAttributes("-R", Filename) || !(f := FileOpen(Filename, "rw", Encoding))
			return false, ErrorLevel := true
	Content := StrSplit(f.Read(), "`n", "`r"), Lines := Content.MaxIndex() ? Content.MaxIndex() : 0
	Loop, % (Lines < LineNum ? LineNum-Lines : 0)
		Content.Push("")
	for CurrentLine, CurrentLineText in Content
		NewText .= ((A_Index = 1 ? "" : "`r`n") (A_Index = LineNum ? (Right?Text CurrentLineText:CurrentLineText Text) : CurrentLineText))
	f.Length := StrLen(NewText), f.Seek(0)
	return f.Write(NewText), f.Close(), ErrorLevel := false
}

;escribir en un archivo. (reemplazar todo el contenido)
;Sintáxis: FileWrite( [Text], [Filename], [Encoding] )
WriteFile(Text, Filename, Encoding := "CP0") {
	if !(f := FileOpen(Filename, "w`n", Encoding)) 
		if !SetFileAttributes("-R", Filename) || !(f := FileOpen(Filename, "w`n", Encoding))
			return false, ErrorLevel := true
	f.Length := StrLen(Text), f.Seek(0)
	return f.Write(Text), f.Close(), ErrorLevel := false
}

;escribir en una linea espesifica (reemplazar linea entera).
;Sintáxis: FileWriteLine( [Text], [Filename], [LineNum], [Encoding], [RemoveLine] )
WriteFileLine(Text, Filename, LineNum := 1, Encoding := "CP0", RemoveLine := false) {
	if !(f := FileOpen(Filename, "rw", Encoding)) 
		if !SetFileAttributes("-R", Filename) || !(f := FileOpen(Filename, "rw", Encoding))
			return false, ErrorLevel := true
	Content := StrSplit(f.Read(), "`n", "`r"), Lines := Content.MaxIndex() ? Content.MaxIndex() : 0
	Loop, % (Lines < LineNum ? LineNum-Lines : 0)
		Content.Push("")
	for CurrentLine, CurrentLineText in Content
		NewText .= RemoveLine ? (A_Index = LineNum ? "" : ((A_Index = 1 ? "" : "`r`n") CurrentLineText))
		: ((A_Index = 1 ? "" : "`r`n") (A_Index = LineNum ? Text : CurrentLineText))
	f.Length := StrLen(NewText), f.Seek(0)
	return f.Write(NewText), f.Close(), ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Leer
;Nota: cuando se lee, se remplaza `ř`n por `n
;--------------------------------------------------------------------------------------------------------------------------------------------------
;leer archivo
;Sintáxis: ReadFile( [Filename], [Encoding], [Characters] )
;Parámetros:
	;Filename: arhivo a leer.
	;Encoding: codificación.
	;Characters: espesificar el número de caracteres máximos a leer.
;Return: String
ReadFile(Filename, Encoding := "CP0", Characters := 0) {
	if !(f := FileOpen(Filename, "r`n", Encoding))
		return "", ErrorLevel := true
	return Characters>0?f.Read(Characters):f.Read(), f.Close(), ErrorLevel := false
}

;leer texto en la línea espesificada.
;Sintaxis: ReadFileLine( [Archivo], [Linea] )
ReadFileLine(Filename, LineNum := 1, Encoding := "CP0") {
	if !(f := FileOpen(Filename, "r", Encoding))
		return false, ErrorLevel := true
	Loop, % (LineNum - 1)
		f.ReadLine()
	return f.ReadLine(), f.Close(), ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------------
;Otros
;--------------------------------------------------------------------------------------------------------------------------------------------------
;comprueba si es archivo
;Sintaxis: IsFile( [Filename], [out FullPathName], [out Attrib] )
IsFile(Filename, ByRef FullPathName := "", ByRef Attrib := "") {
	Attrib := GetFileAttributes(Filename,, FullPathName, Type)
	return Type="F"?(Attrib?Attrib:true):false, FullPathName := SubStr(FullPathName, 5)
}

;Comparar 2 archivos
;Sintaxis: FileCompare( [archivo 1], [archivo 2] )
;Return:
	;1 = archivo1 > archivo2
	;0 = archivo1 = archivo2
	;-1 = archivo1 < archivo2
;ErrorLevel: 0|1(return "")
;Nota: si los archivos tienen el mismo tamaño, ejecuta una comparación binaria
FileCompare(File1, File2) {
	if !IsObject(oF1:=FileOpen(File1, "r")) || !IsObject(oF2:=FileOpen(File2, "r"))
		return "", oF1.Close(), ErrorLevel := true
	if !(oF1.Length=oF2.Length)
		return oF1.Length>oF2.Length?1:-1, oF1.Close(), oF2.Close(), ErrorLevel := false
	oF1.RawRead(Source1, oF1.Length), oF2.RawRead(Source2, oF2.Length)
	return CompareMemory(Source1, Source2), oF1.Close(), oF2.Close()
}

;separa un nombre de archivo o URL en su nombre, directorio, la extensión y la unidad.
;Sintaxis: SplitPath( [Nombre / URL], [nombre.ext], [directorio], [extension], [nombre], [unidad] )
SplitPath(InputVar, ByRef OutFileName := "", ByRef OutDir := "", ByRef OutExtension := "", ByRef OutNameNoExt := "", ByRef OutDrive := "") {
	SplitPath, InputVar, OutFileName, OutDir, OutExtension, OutNameNoExt, OutDrive
	i := {}, i.FileName := (i.FN:=OutFileName), i.Dir := OutDir, i.Ext := (i.Extension:=OutExtension), i.Name := OutNameNoExt, i.Drive := OutDrive
	return i
}

FileFNPath(Filename, Start := "(", End := ")") {
	Filename := GetFullPathName(Filename), SplitPath(Filename, FullName, Dir, Ext, Name)
	, Filename := Dir "\" Name, Ext := Ext=""?"":"." Ext
	Loop {
		if FileExist((tmppath?tmppath:Filename) Ext)
			tmppath := tmppath?StrReplace(tmppath, Start (A_Index-1) End, Start A_Index End):Filename Start true End
		else return (tmppath?tmppath:Filename) Ext
}}

;esperar a que un archivo exista o no
;Sintaxis: FileWait( [archivo], [segundos], [¿esperar a que no exista?] )
FileWait(FileName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	FileName := GetFullPathName(FileName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsFile(FileName))||(!NotExist&&IsFile(FileName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
}}

;crear acceso directo
;Sintaxis: CreateShortcut( [archivo al que hace referencia], [acceso directo], [directorio de trabajo], [argumentos], [descripcion], [icono], [tecla], [inicio] )
;Parámetros:
	;Icono: espesificar el icono o un Array con el icono y el indice [Icono, Indice].
	;Tecla: tecla de método abreviado.
	;Inicio: modo de inicio. 1 = Normal (defecto). 3 = Maximizado. 7 = Minimizado.
;Nota: si el acceso directo ya existe, lo sobreescribe.
;Return: devuelve la ruta al nuevo acceso directo o cero si falló
CreateShortcut(Target, ShortcutFile, WorkingDir := "", Args := "", Description := "", IconFile := -1, ShortcutKey := "", RunState := 1) {
	SplitPath, ShortcutFile,,, Ext
	ShortcutFile .= Ext="lnk"?"":".lnk"
	FileCreateShortcut, % Target, % ShortcutFile, % WorkingDir, % Args, % Description, % IsObject(IconFile)?IconFile.1:IconFile, % ShortcutKey, % IsObject(IconFile)?IconFile.2:1, % RunState
	return ErrorLevel?false:ShortcutFile
	try WshShell := ComObjCreate("WScript.Shell")
	, oShellLink := WshShell.CreateShortcut(GetFullPathName(ShortcutFile))
	, oShellLink.TargetPath := Target, oShellLink.Arguments := Args
	, oShellLink.WorkingDirectory := WorkingDir, oShellLink.Description := Description
	, oShellLink.IconLocation := (IsObject(IconFile)?(IconFile[1] ", " (IconFile[2]>0?IconFile[2]-1:0)):(((IconFile=-1)?Target:IconFile) ", 0"))
	, oShellLink.Hotkey := ShortcutKey, oShellLink.WindowStyle := RunState=3?3:RunState=7?7:1, oShellLink.Save
	catch
		return false, ErrorLevel := true
	return ShortcutFile, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/xk6kst2k%28v=vs.84%29.aspx

;abrir un directorio en el explorador de windows y seleccionar archivo(s)
;Sintaxis: OpenFolderAndSelectItems( [directorio], [archivos, espesificar un array para varios archivos], [opciones] )
;Opciones:
	;0x0001 = selecciona un archivo y poner su nombre en el modo de edición. solo válido para un archivo.
	;0x0002 = selecciona el archivo(s) en el escritorio en lugar de en una ventana del Explorador de Windows. si el escritorio se oculta detrás de las ventanas abiertas, no se hará visible
;Ejemplo: MsgBox % OpenFolderAndSelectItems(A_WinDir, ["explorer.exe", "hh.exe", "nonexistsfile.ext"]) "`n" ErrorLevel
;Nota: archivos inválidos se omiten (no existen)
OpenFolderAndSelectItems(DirName, Files, Flags := 0x0) {
	if !(DirExist(DirName)) || !(Files:=GetValidArrayFiles(Files,, DirName "\"))
		return false, ErrorLevel := 2
	VarSetCapacity(ITEMLIST, Files.MaxIndex() * A_PtrSize, 0), FolderPidl := ParseDisplayName(DirName)
	for k, v in Files
		NumPut(ParseDisplayName(v), ITEMLIST, (A_Index - 1) * A_PtrSize, "Ptr")
	r := DllCall("Shell32.dll\SHOpenFolderAndSelectItems", "Ptr", FolderPidl, "UInt", Files.MaxIndex(), "Ptr", &ITEMLIST, "UInt", Flags)
	for k, v in Files
		CoTaskMemFree(NumGet(ITEMLIST, (A_Index - 1) * A_PtrSize, "Ptr"))
	return !r, CoTaskMemFree(FolderPidl), ErrorLevel := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762232(v=vs.85).aspx

IniRead(Filename := "", Section := "", Key := "", OutputVar := " ") {
	static _
	if (Key!=""&&Section!="")
		IniRead, OutputVar, % (_:=((Filename="")?_:Filename)), %Section%, %Key%, %OutputVar%
	else if (Key=""&&Section!="")
		IniRead, OutputVar, % (_:=((Filename="")?_:Filename)), %Section%
	else IniRead, OutputVar, % (_:=((Filename="")?_:Filename))
	return OutputVar
} IniWrite(Value := "", Filename := "", Section := "", Key := "") {
	static _
	if (Key="")
		IniWrite, %Value%, % (_:=((Filename="")?_:Filename)), %Section%
	else IniWrite, %Value%, % (_:=((Filename="")?_:Filename)), %Section%, %Key%
	return !ErrorLevel
} IniDelete(Filename := "", Section := "", Key := "") {
	static _
	if (Key="")
		IniDelete, % (_:=((Filename="")?_:Filename)), %Section%
	else IniDelete, % (_:=((Filename="")?_:Filename)), %Section%, %Key%
	return !ErrorLeveL
}

;Sintaxis: CreateFile( [archivo], [acceso], [acceso compartido], [SECURITY_ATTRIBUTES], [accion], [opciones y atributos], [TEMPLATEFILE])
;Accesos: Read=0x80000000 | Write=0x40000000 | EXECUTE=0x20000000 | ALL=0x10000000
;Accesos compartido: Read=1 | Write=2 | DELETE=4 | ALL=7 | 0
;SECURITY_ATTRIBUTES: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
;Accion: CREATE_ALWAYS=2 | CREATE_NEW=1 | OPEN_ALWAYS=4 | OPEN_EXISTING=3 | TRUNCATE_EXISTING=5
CreateFile(Filename, DesiredAccess := 0x10000000, ShareMode := 7, SecurityAttributes := 0, CreationDisposition := 2, FlagsAndAttributes := 0, TemplateFile := 0) {
	hFile := DllCall("Kernel32.dll\CreateFileW", "Ptr", &Filename, "UInt", DesiredAccess, "UInt", ShareMode
	, "Ptr", SecurityAttributes, "UInt", CreationDisposition, "UInt", FlagsAndAttributes, "Ptr", TemplateFile, "Ptr")
	return hFile, ErrorLevel := !hFile
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx

FindFirstFile(Filename, ByRef WIN32_FIND_DATA) {
	VarSetCapacity(WIN32_FIND_DATA, 0), VarSetCapacity(WIN32_FIND_DATA, 4 + 3*A_PtrSize + 4*4 + 260*2 + 14, 0)
	return DllCall("Kernel32.dll\FindFirstFileW", "Ptr", &Filename, "Ptr", &WIN32_FIND_DATA, "Ptr")
}
















































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: USUARIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PRINCIPALES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;enumera todos los usuarios con información
;Sintaxis: UserAccountsEnum( [opciones] )
;Parámetros:
	;Opciones: espesificar las condiciones de busqueda
		;Sintaxis:  [espacio]WHERE [que] = '[igual a]' [ AND|OR...]
;Ejemplo:
	;for k, v in UserAccountsEnum()
	;	MsgBox % k "#`n" v.Domain "\" v.Name
UserAccountsEnum(Options := "") {
	List := []
	for this in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM Win32_UserAccount" Options) {
		Info := {}
		Loop, Parse, % "AccountType|Caption|Description|Disabled|Domain|FullName|InstallDate|LocalAccount"
		. "|Lockout|Name|PasswordChangeable|PasswordExpires|PasswordRequired|SID|SIDType|Status", |
			Info[A_LoopField] := this[A_LoopField]
		List.Push(Info)
	} return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa394507(v=vs.85).aspx

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES SECUNDARIAS
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtiene información del usuario actual y la mantiene en la memoria para acelerar el resultado
;Ejemplo: MsgBox % "Dominio\Usuario: " GetCurrentUserInfo().Domain "\" GetCurrentUserInfo().Name "`nSID: " GetCurrentUserInfo().SID
;Notas:
	;otra forma de obtener el SID, es usando cmd.
		;Link: http://www.windows-commandline.com/get-sid-of-user/
		;Ejemplo: wmic useraccount where (name='%username%' and domain='%userdomain%') get sid
GetCurrentUserInfo() {
	static CurrentUserInfo
	if !(CurrentUserInfo)
		if !(CurrentUserInfo:=UserAccountsEnum(" WHERE Name = '" A_UserName "' AND Domain = '" A_UserDomain() "'")[1])
			CurrentUserInfo := UserAccountsEnum(" WHERE Name = '" A_UserName "'")[1]
	return CurrentUserInfo
} 





































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: EJECUTAR & HANDLES ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;EJECUTAR
;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;ejecutar en un proceso aparte
;Sintaxis: RunProcess( [parámetros], [opciones], [WorkingDir], [codificación], [ExitCode (out)], [¿esperar?] )
;Parámetros:
	;Parámetros: espesificar la ruta a un archivo y los parámetros.
		;Sintaxis: [archivo] [param 1] [param 2] [param 3] [etc...]
	;Opciones: espesificar opciones para la creacion del proceso y prioridad
		;Opciones de creación: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx
			;0x08000000 = el proceso es una aplicación de consola, que se ejecuta sin una ventana.
			;0x00000004 = el proceso se crea en un estado de suspención
		;Prioridades: https://msdn.microsoft.com/en-us/library/windows/desktop/ms683211(v=vs.85).aspx
			;0x00000100 = tiempo real
			;0x00000080 = alta
			;0x00008000 = por encima de lo normal
			;0x00000020 = normal
			;0x00004000 = por debajo de lo normal
			;0x00000040 = baja
		;Nota: sumar valores para combinar. ver link para mas opciones de creación
	;WorkingDir: espesificar el directorio de trabajo. si no se espesifica, usa el del proceso invocador
	;Codificación: espesificar la codificación para el texto salida, por defecto usa CP437
	;ExitCode: devuelve el código de salida
	;Esperar: 0|1. determina si se debe esperar que el proceso finalize. por defecto = 1
;Return: resultado en la codifiación espesificada
;ErrorLevel: 0|1
RunProcess(Param, CreationFlags := 0, WorkingDir := 0, Encoding := "CP437", ByRef ExitCode := "", WaitClose := true) {
	CreatePipe(hReadPipe, hWritePipe), SetHandleInformation(hWritePipe, 0x00000001)
	, Size := VarSetCapacity(STARTUPINFO, A_PtrSize=4?68:104, 0), NumPut(Size, STARTUPINFO, 0, "UInt")
    , NumPut(0x100, STARTUPINFO, A_PtrSize=4?44:60, "UInt"), NumPut(hStdInRd, STARTUPINFO, A_PtrSize=4?56:80, "Ptr")
    , NumPut(hWritePipe, STARTUPINFO, A_PtrSize=4?60:88, "Ptr"), NumPut(hWritePipe, STARTUPINFO, A_PtrSize=4?64:96, "Ptr")
	, this := CreateProcess(, Param,,,, CreationFlags,, WorkingDir, &STARTUPINFO), CloseHandle(hWritePipe), Size := VarSetCapacity(Buff, 4095)
	if (WaitClose)
		while  DllCall("Kernel32.dll\ReadFile", "Ptr", hReadPipe, "Ptr", &Buff, "UInt", Size, "PtrP", Bytes, "Ptr", 0)
			OutputVar .= StrGet(&Buff, Bytes, Encoding)
	return OutputVar, ExitCode := GetExitCodeProcess(this.handle), CloseHandle(this.handle, hReadPipe), ErrorLevel := !this.handle
}

;ejecutar archivo, abrir carpeta/URL
;Sintáxis: Run( [Archivo], [directorio de trabajo], [opciones], [PID] )
Run(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	Run, % Target, % WorkingDir, % "UseErrorLevel " Options, OutputVarPID
	return ErrorLevel?0:(OutputVarPID?OutputVarPID:true)
}

;ejecutar archivo (esperar)
;Sintáxis: RunWait( [Archivo], [directorio de trabajo], [opciones], [PID] )
RunWait(Target, WorkingDir := "", Options := "", ByRef OutputVarPID := "") {
	RunWait, % Target, % WorkingDir, % "UseErrorLevel " Options, OutputVarPID
	return ErrorLevel?0:(OutputVarPID?OutputVarPID:true)
}

;abrir propiedades de un archivo/carpeta
;Sintaxis: Properties( [archivo/carpeta], [esperar (segundos)], [¿AlwaysOnTop?] )
;Notas: 
	;• para esperar indefinidamente, espesificar 0 (segundo parametro)
	;• cuando se espesifica tiempo fuera, primero busca y cierra todas las demás ventanas
		;de propiedades abiertas por el proceso actual; ya que sino, esperaría a que todas las
		;ventanas se cierren, y solo queremos esperar la que espesificamos para el archivo.
;Ejemplo: Properties(comspec, false, true)
Properties(Target, WaitClose := -1, AlwaysOnTop := false) {
	if !FileExist(Target)
		return 0, ErrorLevel := 2
	if (WaitClose>-1) {
		WinCloseEx(, "#32770", ProcessExist(), true)
		, Run("Properties " Chr(34) Target Chr(34))
		, hWnd := WinWait(, 5, "#32770", ProcessExist(),, IsWindows8OrGreater())
		, WinAlwaysOnTop(hWnd, AlwaysOnTop)
		return WinWaitClose(hWnd, WaitClose)
	} r := Run("Properties " Chr(34) Target Chr(34))
	if (AlwaysOnTop) && (hWnd:=WinWait(, 5, "#32770", ProcessExist(),, IsWindows8OrGreater()))
		WinAlwaysOnTop(hWnd, true)
	return hWnd?hWnd:r, ErrorLevel := !r
}

;ejecuta un comando en la consola y devuelve el resultado
;Sintaxis: CMD( [cmd], [codificación], [código de salida (out)] )
;Ejemplo: MsgBox % CMD("dir " A_WinDir, "CP437")
;Nota: el directorio de trabajo por defecto es C:\Windows\System32
CMD(Script, Encoding := "CP437", ByRef ExitCode := "") {
	return RunProcess(A_ComSpec() A_Space "/c" A_Space Script, 0x08000000+0x00000080, A_SysDir(), Encoding, ExitCode)
}

;ejecutar script .vbs
;Sintaxis: VBS( [script], [código de salida (out)], [wscript.exe / cscript.exe] )
;Ejemplo: VBS("WScript.Echo " Chr(34) "AHK" A_AhkVersion Chr(34))
;Nota: cambiar Wscript.exe por Cscript.exe para el modo consola
VBS(Script, ByRef ExitCode := "", Filename := "wscript.exe") {
	WriteFile(Script, A_Temp "\~wscript.vbs")
	return ExitCode, CMD(Filename A_Space Chr(34) A_Temp "\~wscript.vbs" Chr(34),, ExitCode)
}

;ejecutar script
;Sintaxis: ExecScript( [script], [parámetros], [aplicación] )
;Ejemplo: ExecScript("MsgBox E.X.A.M.P.L.E")
ExecScript(Script, Params := "", Filename := "") {
	SplitPath, Filename, Name
	Name .= A_Year A_Mon A_DD A_Hour A_Min A_Sec
	Filename := (Filename=""?A_AhkPath " /CP65001":Trim(Filename)) A_Space Chr(34) "\\.\pipe\" Name Chr(34)
	, Pipe1 := CreateNamedPipe(Name, 2), Pipe2 := CreateNamedPipe(Name, 2)
	, ComObjCreate("WScript.Shell").Exec(Trim(Filename) A_Space Trim(Params))
	, ConnectNamedPipe(Pipe1), CloseHandle(Pipe1), r := ConnectNamedPipe(Pipe2)
	, FileOpen(Pipe2, "h", "UTF-8").Write(Script), CloseHandle(Pipe2)
	return r, ErrorLevel := !r
}

;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;HANDLE
;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CloseHandle(HANDLE*) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx
	Error := ErrorLevel, Ok := 0
	for k, v in HANDLE
		Ok += !!DllCall("Kernel32.dll\CloseHandle", "Ptr", v, "UInt")
	return Ok=HANDLE.MaxIndex(), ErrorLevel := Error
}

;obtener ciertas propiedades de un HANDLE
;Sintaxis: GetHandleInformation( [HANDLE], [flags] )
;Parámetros:
	;Flags: puede ser uno de los siguientes valores.
	;0x00000000
	;0x00000001 = HANDLE_FLAG_INHERIT
	;0x00000002 = HANDLE_FLAG_PROTECT_FROM_CLOSE
;Return: 0|1
;ErrorLevel:
	;1 = OK
	;6 = el HANDLE es inválido
	;[otro] = ver https://msdn.microsoft.com/en-us/library/ms681382(v=vs.85).aspx
GetHandleInformation(Handle, ByRef Flags := "") {
	Ok := DllCall("Kernel32.dll\GetHandleInformation", "Ptr", Handle, "UIntP", Flags)
	return !!Ok, ErrorLevel := Ok?false:A_LastError
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724329(v=vs.85).aspx

;establece siertas propiedades de un HANDLE
;Sintaxis: SetHandleInformation( [HANDLE], [flags] )
;Return / ErrorLevel / Parámetros: ver GetHandleInformation()
SetHandleInformation(Handle, Flags := 0x00000000) {
	Ok := DllCall("Kernel32.dll\SetHandleInformation", "Ptr", Handle, "UInt", Flags, "UInt", Flags)
	return !!Ok, ErrorLevel := Ok?false:A_LastError
}













































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: PIPE FUNCTIONS ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365152(v=vs.85).aspx
;#############################################################################################################################################
;crear pipe anónimo
;Sintaxis: CreatePipe( [read handle (out)], [write handle (out)], [atributos], [tamaño] )
;Parámetros:
	;Atributos: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
	;Tamaño: tamaño en bytes para el pipe. dejar en cero para usar el tamaño predeterminado del sistema
;Return: !=0 => OK
CreatePipe(ByRef hReadPipe, ByRef hWritePipe, PipeAttributes := 0, Size := 0) {
	return DllCall("Kernel32.dll\CreatePipe", "PtrP", hReadPipe, "PtrP", hWritePipe, "Ptr", PipeAttributes, "UInt", Size, "UInt")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365152(v=vs.85).aspx

;crear pipe con nombre
;Sintaxis: CreateNamedPipe( [name], [OpenMode], [PipeMode], [MaxInstances], [OutBufferSize], [DefaultTimeOut], [SecurityAttributes] )
;Parámetros:
	;Name: nombre único de no mas de 256 carácteres. puede contener cualquier carácter que no sea una barra invertida
	;OpenMode: modo de apertura
		;:::: modos de acceso ::::
		;0x00000003 = PIPE_ACCESS_DUPLEX
		;0x00000001 = PIPE_ACCESS_INBOUND
		;0x00000002 = PIPE_ACCESS_OUTBOUND
		;:::: opciones ::::
		;0x00080000 = FILE_FLAG_FIRST_PIPE_INSTANCE
		;0x80000000 = FILE_FLAG_WRITE_THROUGH
		;0x40000000 = FILE_FLAG_OVERLAPPED
		;:::: seguridad del modo de acceso ::::
		;0x00040000 = WRITE_DAC
		;0x00080000 = WRITE_OWNER
		;0x01000000 = ACCESS_SYSTEM_SECURITY
	;PipeMode: modo del pipe
		;:::: tipos ::::
		;0x00000000 = PIPE_TYPE_BYTE
		;0x00000004 = PIPE_TYPE_MESSAGE
		;:::: modos de lectura ::::
		;0x00000000 = PIPE_READMODE_BYTE
		;0x00000002 = PIPE_READMODE_MESSAGE
		;:::: modos de espera ::::
		;0x00000000 = PIPE_WAIT
		;0x00000001 = PIPE_NOWAIT
		;:::: modos de control remoto en el cliente ::::
		;0x00000000 = PIPE_ACCEPT_REMOTE_CLIENTS
		;0x00000008 = PIPE_REJECT_REMOTE_CLIENTS
	;MaxInstances: instancias máximas para este pipe 1~100
	;OutBufferSize: número de bytes que se reservan para el búfer de salida.
	;InBufferSize: número de bytes que se reservan para el búfer de entrada.
	;DefaultTimeOut: tiempo fuera, en ms.
	;SecurityAttributes: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
;Return: 0xFFFFFFFF(INVALID_HANDLE_VALUE) | hNamedPipe(HANDLE)
CreateNamedPipe(Name, OpenMode := 0, PipeMode := 0, MaxInstances := 255, OutBufferSize := 0, InBufferSize := 0, DefaultTimeOut := 0, SecurityAttributes := 0) {
	Name := "\\.\pipe\" SubStr(StrReplace(Trim(Name), "`n"), 1, 256)
	return DllCall("Kernel32.dll\CreateNamedPipeW", "Ptr", &Name, "UInt", OpenMode, "UInt", PipeMode
	, "UInt", MaxInstances, "UInt", OutBufferSize, "UInt", InBufferSize, "UInt", DefaultTimeOut, "UPtr", SecurityAttributes, "UPtr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365150(v=vs.85).aspx

;esperar a un pipe con nombre para conectarce con una instancia de un pipe con nombre
;Sintaxis: ConnectNamedPipe( [hNamedPipe], [Overlapped] )
ConnectNamedPipe(hNamedPipe, Overlapped := 0) {
	return DllCall("Kernel32.dll\ConnectNamedPipe", "UPtr", hNamedPipe, "UPtr", Overlapped, "UInt")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365146(v=vs.85).aspx





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CARPETAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;eliminar directorio
;Sintaxis: DirDelete( [carpeta], [¿eliminar archivos y subcarpetas?] )
DirDelete(DirName, Recurse := false) {
	FileRemoveDir, %DirName%, %Recurse%
	return !ErrorLevel
} DirRemove(DirName, Recurse := false) {
	FileRemoveDir, %DirName%, %Recurse%
	return !ErrorLevel
}

;vaciar directorio sin eliminarlo
;Sintaxis: DirEmpty( [directorio], [¿incluir subdirectorios?] )
;Return: array que contiene los archivos y carpetas eliminados (0 si no se eliminó nada).
;ErrorLevel: array que contiene los archivos y carpetas que no se puedieron eliminar (0 si se eliminó todo).
DirEmpty(DirName, Recurse := false) {
	Error := [], OutputVar := []
	Loop, Files, %DirName%\*.*, FD
	{	if IsFile(A_LoopFileFullPath) {
			if !(DeleteFile(A_LoopFileFullPath))
				Error.Push(A_LoopFileFullPath)
			else OutputVar.Push(A_LoopFileFullPath)
		} else {
			if !(DirDelete(A_LoopFileFullPath, Recurse))
				Error.Push(A_LoopFileFullPath)
			else OutputVar.Push(A_LoopFileFullPath)
	}} return OutputVar.MaxIndex()?OutputVar:false, ErrorLevel := Error.MaxIndex()?Error:false
}

;renombrar directorio
;Sintaxis: Rename( [directorio], [nuevo nombre], [¿eliminar si ya existe una carpeta con el mismo nombre?], [¿eliminar si la carpeta no está vacía?] )
DirRename(Dirname, NewName, OverWrite := false, Recurse := false) {
	SplitPath, Dirname,, Dir
	if (FileExist(Dir "\" NewName)) {
		if !(OverWrite)
			return false, ErrorLevel := 2
		if !(DirDelete(Dir "\" NewName, Recurse))
			return false, ErrorLevel := 3
	} FileMoveDir, %Dirname%, %Dir%\%NewName%, R
	return !ErrorLevel
}

;mover directorio
;Sintaxis: DirMove( [directorio], [destino], [opciones], [¿eliminar si el directorio no está vacio?] )
;Opciones: 1 = sobreescribir archivos | 2 = eliminar destino antes de copiar.
DirMove(DirName, Dest, OverWrite := false, Recurse := true) {
	if (OverWrite=2)
		DirDelete(Dest, Recurse)
	FileMoveDir, %DirName%, %Dest%, % ((OverWrite="R")?"R":!!(OverWrite))
	return !ErrorLevel
}

;copiar directorio
;Sintaxis: DirCopy( [directorio], [destino], [opciones] )
;Opciones: 1 = sobreescribir archivos | 2 = eliminar destino antes de copiar.
DirCopy(Source, Dest, OverWrite := false) {
	if (OverWrite=2)
		DirDelete(Dest, true)
	FileCopyDir, % RTrim(Source, "\"), % RTrim(Dest, "\"), % OverWrite?true:false
	return !ErrorLevel
}

;crear carpeta
;Sintaxis: DirCreate( [directorio], [¿crear subdirectorios?], [eliminar antes si existe 0|1], [atributos] )
DirCreate(DirName, Recurse := true, Remove := "", Attrib := "") {
	if (Remove=0) || (Remove=1)
		DirRemove(DirName, Remove)
	if (Recurse) {
		FileCreateDir, %DirName%
		if (Attrib)
			FileSetAttrib, %Attrib%, %DirName%
		return !ErrorLevel
	} return r:=DllCall("Kernel32.dll\CreateDirectoryW", "Str", "\\?\" DirName, "Ptr", 0), ErrorLevel := !r
}

;dialogo: seleccionar carpeta
;Sintaxis: DirSelect( [Directorio], [Opciones/VentanaID], [Título] )
DirSelect(StartingFolder := "", Options := 1,  Prompt := "") {
	try FileSelectFolder, OutputVar, %StartingFolder%, %Options%, %Prompt%
	catch
		FileSelectFolder, OutputVar,, %Options%, %Prompt%
	if (Options=1) && !(OutputVar)
		ErrorLevel := true
	return RTrim(OutputVar, "\")
}

;comprueba si es carpeta
;Sintaxis: IsDir( [carpeta] )
IsDir(DirName, ByRef FullPathName := "") {
	if IsByRef(FullPathName)
		FullPathName := GetFullPathName(DirName)
	return InStr(FileExist(DirName),"D")
} IsFolder(DirName, ByRef FullPathName := "") {
	return IsByRef(FullPathName)?IsDir(DirName, FullPathName):IsDir(DirName)
}

;comprueba si el directorio existe, quita \ al final, si lo tiene.
DirExist(ByRef Path) {
	Path := Trim(RegExReplace(Trim(Path), "\\+$"))
	return InStr(FileExist(Path), "D")?Path:""
}

;abrir carpeta con explorer.exe
;Sintaxis: DirOpen( [carpeta], [abrir en una nueva ventana] ) 
DirOpen(Dir, NewWindow := false) {
	if !DirExist(Dir)
		return false, ErrorLevel := true
	return Run(A_WinDir "\explorer.exe " (NewWindow?"/n,":"") Chr(34) Dir Chr(34))
}

;obtiene informacion sobre un directorio
;EJEMPLO: MsgBox % DirGetInfo( A_WinDir ).CSName
DirGetInfo(Dirname, ValidatePath := 0) {
	if !DirExist( Dirname )
		return "", ErrorLevel := 1
	Dirname := StrReplace(Dirname, "\", "\\"), i := {}
	for a in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM CIM_Directory WHERE Name = '" Dirname "'")
		i.AccessMask := a.AccessMask, i.Archive := a.Archive, i.Caption := a.Caption, i.Compressed := a.Compressed
		, i.CompressionMethod := a.CompressionMethod, i.CreationClassName := a.CreationClassName, i.CreationDate := a.CreationDate
		, i.CSCreationClassName := a.CSCreationClassName, i.CSName := a.CSName, i.Description := a.Description, i.Drive := a.Drive
		, i.EightDotThreeFileName := a.EightDotThreeFileName, i.Encrypted := a.Encrypted, i.EncryptionMethod := a.EncryptionMethod
		, i.Extension := a.Extension, i.FileName := a.FileName, i.FileType := a.FileType, i.LastAccessed := a.LastAccessed
		, i.FSName := a.FSName, i.InstallDate := a.InstallDate, i.InUseCount := a.InUseCount, i.FileSize := a.FileSize, i.Hidden := a.Hidden
		, i.LastModified := a.LastModified, i.Name := a.Name, i.Path := a.Path, i.Readable := a.Readable, i.Status := a.Status
		, i.System := a.System, i.Version := a.Version, i.Writeable := a.Writeable, i.FSCreationClassName := a.FSCreationClassName
	return i, ErrorLevel := !i.Name
}

;esperar a que un directorio exista o no
;Sintaxis: DirWait( [directorio], [segundos], [¿esperar a que no exista?] )
DirWait(DirName, Seconds := 0, NotExist := false) {
	if (Seconds=-1)
		return 0
	DirName := GetFullPathName(DirName)
	, ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (NotExist&&!IsDir(DirName))||(!NotExist&&IsDir(DirName))
			return 1, ErrorLevel := 0
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return 0, ErrorLevel := 1
		Sleep(500)
}}

;obtener tamaño de un directorio
;Sintaxis: DirGetSize( [directorio], [KB|MB|GB], [¿incluir subcarpetas?] )
DirGetSize(DirName, Units := "", Recurse := true) {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	Size := 0
	Loop, Files, %DirName%\*.*, % Recurse?"FR":"F"
		Size += A_LoopFileSize
	return _[Units]?Size/_[Units]:Size, ErrorLevel := !IsFolder(DirName)
}





















































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: NÚMEROS & OPERACIONES MATEMÁTICAS ::::::::::::::::::::::::::::::::::
Links:
	• http://ahkscript.org/boards/viewtopic.php?t=3925
	• https://dl.dropboxusercontent.com/u/186419968/html/BaseConversion/index.html
	• https://raw.githubusercontent.com/aviaryan/autohotkey-scripts/master/Functions/Maths.ahk
Funciones que aceptan números infinitos (nota: debe expresar el número como string si tiene mas de 18 cifras):
	• Divide()
	• MulDivEx()
	• Power()
	• Prefect()
	• Greater()
	• Add()
	• Multiply()
	• BitShiftLeft()
	• BitShiftRight()
	• RoundEx()
#############################################################################################################################################
*/
;multiplica dos valores y luego divide el resultado por un tercer valor. el resultado final se redondea al entero más cercano
;Sintaxis: MulDiv( [multiplicando], [multiplicador], [deniminador], [decimales=0] )
MulDiv(Number, Numerator, Denominator := 1, Places := 0) {
	return Round((Number*Numerator)/Denominator, Places)
} MulDivEx(Number, Numerator, Denominator := 1, Places := 0) {
	return RoundEx(Divide(Multiply(Number, Numerator), Denominator, Places), Places)
}

;elevar un numero (potenciación)
;Sintaxis: Power( [base], [exponente] )
;Ejemplo: MsgBox % Power(99, 999) ;99^999
Power(Base, Exponent) {
	SLB := StrLen(Base), VarSetCapacity(B, SLB, 0)
	Loop, Parse, % Base
		NumPut(A_LoopField, B, SLB - A_Index, "UChar")
	VarSetCapacity(P, SLB, 0), MoveMemory(&P, &B, PL:=SLB)
	Loop, % (Exponent - 1) {
		V := 0, VarSetCapacity(R, RL := PL + SLB + 1, 0)
		Loop, %SLB% { ; multiply
			If (I := NumGet(B, A_Index - 1, "UChar")) {
				Loop, %PL%
					N := NumGet(R, J := A_Index + V - 1, "UChar") + (NumGet(P, A_Index - 1, "UChar") * I)
					, NumPut(SubStr(N, 0), R, J++, "UChar")
					, NumPut(NumGet(R, J, "UChar") + SubStr("0" . N, -1, 1), R, J, "UChar")
			} V++
		} VarSetCapacity(P, RL, 0), MoveMemory(&P, &R, PL:=RL)
		while !NumGet(P, PL - 1, "UChar") ; remove trailing zeroes
			PL--
	} VarSetCapacity(V, RL, 0)
	Loop, %RL%
		V .= NumGet(R, --RL, "UChar")
	return LTrim(V, "0")
} ;http://ahkscript.org/boards/viewtopic.php?p=49693#p49693

;convierte cualquier número a la forma perfecta, es decir, elimina ceros adicionales y agrega requeridos.
Prefect(n) {
	if InStr((n:=(InStr(n:=RTrim(n, "+-"), "-")&&(l:=true))?SubStr(n, 2):n), ".") {
		if !((n:=Trim(n, "0"))="*") && (Substr(n,1,1) == ".")
			n := "0" n
		if (SubStr(n, 0)==".")
			n := Substr(n, 1, -1)
		return (l?"-":"") n
	} else return Trim(n, "0")?((l?"-":"") LTrim(n, "0")):0
}

;redondear un número
;Sintaxis: RoundEx( [num], [decimales] )
RoundEx(n, d := 0) {
	if InStr(n, ".") {
		if ((f:=StrLen(n)-(InStr(n, ".")=0?StrLen(n):InStr(n, ".")))>d) {
			if ((s:=SubStr(n, InStr(n, ".")+d+1, 1))>=5)
				Loop, % (d-1)
					z .= "0"
			n := Add(SubStr(n, 1, InStr(n, ".")+d), (s >= 5) ? "0." z "1" : "0")
		} else {
			Loop, % (d - f)
				z .= "0"
			n .= z
		} return RTrim(n, ".")
	} return n
}

;multiplicar
;Sintaxis: Multiply( [num 1], [num 2] )
Multiply(num1, num2) {
	ps := (mnum2:=InStr(num2, "-"))?0:1, ps := (mnum1:=InStr(num1, "-"))?!ps:ps, num1 := SubStr(num1, mnum1?2:1), num2 := Substr(num2, mnum2?2:1)
	, dec := (dot1:=InStr(num1, "."))?StrLen(num1)-dot1:0, dec := (dot2:=InStr(num2, "."))?dec+StrLen(num2)-dot2:dec, num1 := StrReplace(num1, ".")
	Loop, % StrLen(num2:=StrReplace(num2, "."))
		tnum2 .= SubStr(num2, 1-A_Index, 1)
	num2 := tnum2, pr := "0"
	Loop, Parse, % num2
	{ rw := "0", zr := ""
		if (A_LoopField) {
			Loop, %A_LoopField%
				rw := Add(rw, num1)
		} else Loop, % (StrLen(num1)-1)
			rw .= "0"
		Loop, % (A_Index-1)
			zr .= "0"
		rw .= zr, pr := Add(pr, rw)
	} return (ps?"":"-") (dec?Prefect(SubStr(pr, 1, StrLen(pr)-dec) "." SubStr(pr, 1-dec)):pr)
}

;comprueba si num1>num2
;Sintaxis: IsGreater( [num 1], [num 2], [valor a devolver si los números son iguales = 0] )
Greater(n1, n2, teq := false) {
	if !((l2:=InStr(n2, "-"))="*") && ((!(l1:=InStr(n1, "-")) && l2) || (l1 && !l2))
		return (!l1&&l2)?true:false
	if ((e1:=(d1:=InStr(n1:=Prefect(n1), "."))?StrLen(n1)-d1:0)>(e2:=(d2:=InStr(n2:=Prefect(n2), "."))?StrLen(n2)-d2:0))
		Loop, % (e1-e2)
			n2 .= "0"
	else if (e2 > e1)
		Loop, % (e2-e1) 
			n1 .= "0"
	if ((z1:=StrLen(n1:=StrReplace(n1, ".")))>(z2:=StrLen(n2:=StrReplace(n2, "."))))
		return l1?0:1
	else if (z2>z1)
		return l1?1:0
	else Loop {
			if ((h1:=SubStr(n1, A_Index, 1))>(h2:=Substr(n2, A_index, 1)))
				return l1?0:1
			else if (h2>h1)
				return l1?1:0
			else if (A_Index=z1)
				return teq
}}

;sumar
Add(number1, number2) {
	count := (InStr(n2:=number2, "--")?2:InStr(number2, "-")?1:0) + (InStr(n1:=number1, "-")?1:0)
	, number1 := StrReplace(number1, "-"), number2 := StrReplace(number2, "-")
	if ((dec1:=(p1:=InStr(number1, "."))?StrLen(number1)-p1:0)>(dec2:=(p2:=InStr(number2, "."))?StrLen(number2)-p2:0)) && !((dec:=dec1)="*")
		Loop, % (dec1 - dec2)
			number2 .= "0"
	else if (dec2 > dec1) && !((dec:=dec2)="*")
		Loop, % (dec2 - dec1) 
			number1 .= "0"
	else dec := dec1
	if ((l1:=StrLen(number1:=StrReplace(number1, ".")))>=(l2:=StrLen(number2:=StrReplace(number2, "."))))
		Loop, % (l1 - l2)
			number2 := "0" number2
	else Loop, % (l2 - l1)
		number1 := "0" number1
	if !((n:=StrLen(number1))="*") && !(count=1) && !(count=3) {
		Loop {
			digit := SubStr(number1,1 - A_Index, 1) + SubStr(number2, 1 - A_index, 1) + (carry ? 1 : 0)
			if (A_index==n) && !((sum:=digit sum)="*")
				break
			carry := digit>9?true:false, digit := carry?SubStr(digit, 0, 1):digit, sum := digit sum
		} sum := ((InStr(n2, "-")&&InStr(n1, "-"))?"-":"") sum
	} else {
		if !(numbercompare:=Greater(number1, number2, true))
			mid := number2, number2 := number1, number1 := mid
		Loop {
			digit := SubStr(number1,1 - A_Index, 1) - SubStr(number2, 1 - A_index, 1) + (borrow ? -1 : 0)
			if (A_index==n) && !((digit:=StrReplace(digit, "-"))="*") && !((sum:=digit sum)="*")
				break
			borrow := InStr(digit, "-")?true:false, digit := borrow?(digit+10):digit, sum := digit sum
		} sum := (InStr(n2, "--")?(numbercompare?"-":""):InStr(n2, "-")?(numbercompare?"":"-"):InStr(n1, "-")?(numbercompare?"-":""):"") sum
	} sum := sum=="-"?0:sum, sum := (dec&&sum)?SubStr(sum, 1,StrLen(sum) - dec) "." SubStr(sum, 1 - dec):sum
		return Prefect(sum)
}

;dividir
;Sintaxis: Divide( [num 1], [num 2], [decimales] )
Divide(n1, n2, l := 6) {
	p := InStr(n1, "-")?(InStr(n2, "-")?true:false):(InStr(n2, "-")?false:true)
	if !((n1:=Prefect(n1:=StrReplace(n1, "-")))="*") && !(n2:=Prefect(n2:=StrReplace(n2, "-")))
		return
	d := z := InStr(n2, ".")?(StrLen(n2)-InStr(n2, ".")+(InStr(n1, ".")?-(StrLen(n1)-InStr(n1, ".")):0)+0):(InStr(n1, ".")?-(StrLen(n1)-InStr(n1, ".")):0), x1 := StrLen(k1:=(n1:=LTrim(n1:=StrReplace(n1, "."), "0")))
	Loop, % (x2:=StrLen(k2:=(n2:=LTrim(n2:=StrReplace(n2, "."), "0")))) + l
		n1 .= "0"
	cl := 0, z := z - x2 - l, t := false, n1f := x1 + x2 + l
	while !(n1="") {
		if !(_t:=n:=0) && !(bl:="") && !((w:=t?SubStr(n1, 1, x2+1):SubStr(n1, 1, x2))="*") && Greater(w, n2, true) && !((j:=w)="*") {
			Loop, 10 {
				t_%A_index% := Multiply(n2, A_index)
				if !(Greater(j, t_%A_index%, true)) && !((n:=t?x2+1:x2)="*") {
					_t := A_index - 1, bl := t_%_t%
					break
			}	} r .= _
		} else if !((j:=SubStr(n1, 1, x2+1))="*") {
			Loop, 10 {
				t_%A_index% := Multiply(n2, A_index)
				if !(Greater(j, t_%A_index%, true)) && !((n:=x2+1)="*") {
					_t := A_index - 1 , bl := t_%_t%
					break
			}	} r .= cl=0?"":_ "0"
		} r .= _t, cl += (n - StrLen(m)), m := Add(j, "-" bl), n1 := (m:=m=0?"":m) SubStr(n1, n + 1)
		if Greater("0", m, true) && !(_k:="") {
			Loop, % StrLen(n1)
				_k .= "0"
			if (n1==_k) && !((n1:=SubStr(n1, 1, -1))="*") && !((n1:="1" n1)="*") && !((r:=Multiply(r, n1))="*")
				break
		} if (_t=0)
			break
		if !(_:="") && !(t:=false) && (m=="") {
			Loop
				if (InStr(n1, "0") == 1)
					_ .= "0" , n1 := Substr(n1, 2) , cl+=1
				else break
		} if (StrLen(m)==x2)
		t := true
		else Loop, % (x2 - StrLen(m) - 1)
			_ .= "0"
	} if (z<0) {
		e := Format("{:0.16e}", SubStr(k1,1,15) / SubStr(k2,1,15)), d := Format("{:0.16e}", d + StrLen(SubStr(k1,16)) - StrLen(SubStr(k2,16))), d := InStr(e, "-")?d - SubStr(e,-1) + 1:d + SubStr(e,-1) + 1
		if (d > 0)
			r := SubStr(r, 1, d) "." SubStr(r, d + 1)
		else if (d < 0){
			Loop, % Abs(d)
				_e .= "0"
			r := "0." _e r
		} else r := "0." r
	} else if (n:="1") {
		Loop, % z
			n .= "0"
		r := Multiply(Prefect(r), n)
	} return (p?"":"-") RoundEx(Prefect(r), d<0?Abs(d)+l:l)
}

BitShiftLeft(Value, Bit, BitwiseAnd := "") { ;MsgBox % (54992<<0xC) "`n" BitShiftLeft(54992, 0xC) 
	return (BitwiseAnd=""?RoundEx(Multiply(Value, Power(2, Bit))):RoundEx(Multiply(Value, Power(2, Bit)))&BitwiseAnd)
} BitShiftRight(Value, Bit, BitwiseAnd := "") { ;MsgBox % (54992>>0xC) "`n" BitShiftRight(54992, 0xC)
	return (BitwiseAnd=""?RoundEx(Divide(Value, Power(2, Bit))):RoundEx(Divide(Value, Power(2, Bit)))&BitwiseAnd)
}

;evalúa una expresión
;Sintaxis: Eval( [expresión] )
;Ejemplos: 
	;MsgBox % Eval("99999999999999999284888*2")
	;MsgBox % Eval("99^9")
	;MsgBox % Eval("2>1 AND 3>2 AND -2<99")
	;MsgBox % Eval("19 mod 7") 
	;MsgBox % Eval("Cos(2) + Sin(34.55) - Tan(33.077) * Exp(2) - Abs(1) - Sgn(Sqr(0.1))")
;Funciones Soportadas (Hex, Int): http://www.tutorialspoint.com/vbscript/vbscript_number_mathematical_functions.htm
;Operadores Soportados (+, -): http://www.tutorialspoint.com/vbscript/vbscript_operators.htm
;Return: resultado o vacío si hubo un error
;ErrorLevel: 0|1
Eval(Expression) {
	if (A_Is64bitOS) {
		Script := "Set l=CreateObject(" Chr(34) "Scripting.FileSystemObject" Chr(34) ")`n"
			. "Set f=l.CreateTextFile(" Chr(34) (f:=A_Temp "\~evalcscript.exe.dat") Chr(34) ", True)"
			. "`nf.Write Eval(" Expression ")" . "`nf.Close"
		, VBS(Script,, "cscript.exe"), Result := ReadFile(f), Result := Result = "true" ? 1 : Result = "false" ? 0 : Result
		return InStr(Result, "e") ? Format("{:f}", Result) : Result
	} try wscript := ComObjCreate("ScriptControl"), wscript.Language := "VBScript"
	return wscript.Eval(Expression)
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;obtiene el mayor numero
;Sintaxis: Max( [números separados por coma] )
;Ejemplo: MsgBox % Max( 7, 9, 0, -11, 6, 3, 5, 8 ) "`n" Max("5,2,8,-44,7")
Max(n*) {
	n := ((n.MaxIndex()=1)?StrSplit(n[1], ",", A_Space A_Tab):n), _ := n[1]
	Loop, % (n.MaxIndex())
		_ := ((_<n[A_Index+1])?n[A_Index+1]:_)
	return _
}

;obtiene el menor numero
;Sintaxis: Min( [números separados por coma] )
;Ejemplo: MsgBox % Min( 7, 9, 0, 222, -0.2 ) "`n" Min("5,2,8,-44,7")
Min(n*) {
	n := ((n.MaxIndex()=1)?StrSplit(n[1], ",", A_Space A_Tab):n), _ := n[1]
	Loop, % (n.MaxIndex())
		_ := ((_>n[A_Index+1])?((n[A_Index+1]="")?_:n[A_Index+1]):_)
	return _
}

LOWORD(l) {
    return (l & 0xffff)
} HIWORD(l, Extract := true) {
    return (Extract?((l >> 16) & 0xffff):(l << 16))
} LOBYTE(w) {
    return (w & 0xff)
} HIBYTE(w, Extract := true) {
    return (Extract?((w >> 8) & 0xff):((w << 8) & 0xff))
}

;MsgBox % RNum(0) "," RNum(10) "," RNum(5) ;0-5
;MsgBox % RNum(1) "," RNum(4) ;1~4
;MsgBox % RNum(6) "," RNum(9) ;6~9
;MsgBox % RNumEx(0) "," RNumEx(10) "," RNumEx(5) ;0-5
;MsgBox % RNumEx(1) "," RNumEx(3) ;1~3
;MsgBox % RNumEx(4) "," RNumEx(6) ;4~6
;MsgBox % RNumEx(7) "," RNumEx(9) ;7~9
RNum(Num, Min := 1, Max := 9, ms := 5) {
	return between(ln:=StrRight(Num), Min, Max)?(ms=""||ln!=ms?(StrLen(Num)=1?(ln<ms?0:Num+(10-ln)):(ms=""?StrTrimRight(Num) 0:(ln<ms?StrTrimRight(Num) 0:Num+(10-ln)))):Num):Num
} RNumEx(n) {
	if (StrLen(n)=1) && (n!=0) && (n!=5) {
		n := n=1||n=2||n=3?0:n=4||n=5||n=6?5:n+(10-n)
	} else {
		if ((l:=StrRight(n))!=0) && (l!=5) {
			n := (l=1||l=2||l=3?StrTrimRight(n) 0:l=4||l=5||l=6?StrTrimRight(n) 5:n+(10-l))
	}} return n
}

_cvtvalue(Base, Value, Mod := "*") {
	if !(Mod="*")
		Value := (Mod=-1?"^":Mod?"+":Mod=0?"-":"") Trim(Value)
	else Value := Trim(Value)
	Mod := SubStr(Value, 1, 1), Value := (Mod="+"||Mod="-"||Mod="^")?SubStr(Value, 2):Value, Base := (Base+0)=""?0:Base
	return l := (Mod="-"?(Base&Value?Base-Value:Base)
		: Mod="+"?(Base&Value?Base:Base+Value)
		: Mod="^"?(Base&Value?Base-Value:Base+Value) : (Value)), ErrorLevel := l=Base
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;if [value] between [low] [high]
;comprueba si un número esta contenido entre otros dos valores (inclusive)
;Sintaxis: Between( [número], [valor menor], [valor mayor], [valores a excluir*] ) 
;Valores a excluir: valores separados por coma (si es alguno de estos valores devuelve 0)
Between(value, low, high, nval*) {
	nval := ((nval.MaxIndex()=1)?StrSplit(nval[1], ",", A_Space A_Tab):nval)
	Loop, % (nval.MaxIndex())
		if (value=nval[A_Index])
			return false
	return ((value>=low)&&(value<=high))
}

;determina si es Número
;Sintaxis: IsNumber( [número], [carácteres no permitidos separados por coma] )
;EJEMPLO: MsgBox % IsNumber(-23.02) "`n" IsNumber("*1") "`n" IsNumber(-1) "`n" IsNumber(0xF,"*") "`n" IsNumber(+1)
IsNumber(num, IfChars := "*,x") {
	return ((Contains(num,IfChars)||((num+0)=""))?false:true)
}

;determina si es un número primo
;Nota: un número primo es un entero positivo o negativo que solamente es divisible por él mismo y por uno.
IsPrime(Number) {
  Loop, % Floor(Sqrt(Number))
    If (A_Index > 1) && !Mod(Number, A_Index)
      return false
  return true
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------
;convertir a hexadecimal
;Sintaxis: Hex( [num], [max], [may], [prefix] )
;Parámetros:
	;Num: espesificar el número a convertir, puede ser de la siguiente forma: FF000000.
	;Max: espesificar la longitúd que debe tener, se rellena con ceros.
	;May: espesificar 1 para usar mayúsculas.
	;Prefix: prefijo a añadir antes del número, por defecto usa "0x".
Hex(Number, Length := 0, May := false, Prefix := "0x") {
	return Format(Prefix "{:" ((Length>0)?0 LTrim(Length,0):"") (May?"X":"x") "}", (Number+0)=""?"0x" Number:Number)
}

Int(Number, Signed := false) {
	return Format("{:" (Signed?"d":"u") "}", (Number+0)=""?"0x" Number:Number)
} IsInt(Number) {
	RegExMatch(Number, "^-?\d+$", Number)
	return Number
}

;convertir a Float
;Sintaxis: Float( [valor], [max.decimales] )
Float(Number, Type := "0.2") {
	return Format("{:" Type (RegExReplace(Type, "[^fegaEGA]")?"":"f") "}", (Number+0)=""?"0x" Number:Number)
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir twips a píxeles
TwipToPixel(Twip, Round := false, Places := 0) {
	Twips := (Twip * (1.0 / 1440.0) * A_ScreenDPI)
	return (Round?Round(Twips, Places):Twips)
} ;https://es.wikipedia.org/wiki/Twip

;convertir pixeles a twips
PixelToTwip(Pixel, Round := false, Places := 0) {
	Pixels := (Pixel / (1.0 / 1440.0) / A_ScreenDPI)
	return (Round?Round(Pixels, Places):Pixels)
} ;https://es.wikipedia.org/wiki/Píxel

;convertir entero a hexadecimal
IntToHex(Int, Prefix := "0x") {
	h := 8.000000
	while (h--)
		n := ((Int >> (h * 4)) & 0xf), v .= n>9?Chr(0x37+n):n
		, v .= h=0&&(h//(8/4))=0?A_Space:""
	return Prefix v
}

;convertir binario a hexadecimal
BinToHex(Bin, Prefix := "0x") {
	static h := "0123456789ABCDEF"
	d := 0, l := StrLen(Bin)
   Loop, Parse, % Bin,, %A_Space%%A_Tab%`n
	{ d += (d + A_LoopField)
		If ((A_Index&3)=(l&3))
			x := x SubStr(h, d+1, 1), d := 0
   } return Prefix x
}

;convertir binario a octal
BinToOct(Bin) {
    i := Oct := Dec := 0
    while (Bin != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		} Dec += Mod(Bin, 10) * z
        i++
        Bin /= 10
    } i := 1
    while (Dec != 0) {
        Oct += Mod(Dec, 8) * i
        Dec /= 8
        i *= 10
    } return Oct
}

;convertir binario a decimal
BinToDec(Bin) {
    i := Dec := 0
    while (Bin != 0) {
        rem := Mod(Bin, 10)
		Bin /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 2
			Loop, % (i - 1)
				x *= 2
			z := x
		} Dec += rem * z
		i++
    } return Dec
}

;convertir binario a string
;Ejemplo: MsgBox % BinToStr("01000010 01101001 01101110 01010100 01101111 01010011 01110100 01110010")
BinToStr(Bin) {
	Bin := RegExReplace(Bin, "[^0-1]") ;extraer 0 y 1
	Loop {
		if (v:=128) && !(a:=0) && !(StrLen(b:=SubStr(Bin, -7))=8)
			break
		Loop, Parse, % b
			a := A_LoopField?(a+v):a, v /= 2
		OutputVar := Chr(a) OutputVar, Bin := SubStr(Bin, 1, -8)
	} return OutputVar
}

;convertir string a binario
;Ejemplo: MsgBox % StrToBin("StrToBin") "`n" StrToBin("StrToBin", "")
StrToBin(String, Prefix := " ") {
	Loop, Parse, % String
	{ v := 128, b := Ord(A_LoopField)
		Loop, 8
			b := (l:=(Log(b-v)=""))?b:(b-v), OutputVar .= !l, v /= 2
		OutputVar .= Prefix
	} return Trim(OutputVar)
}

;convertir decimal a binario
DecToBin(Dec) {
    Bin := !(i:=1)
    while (Dec != 0) {
        rem := Mod(Dec, 2)
        Dec /= 2
        Bin += rem * i
        i *= 10
	} return Bin
}

;convertir decimal a octal
DecToOct(Dec) {
    Oct := !(i:=1)
    while (Dec > 0) {
        rem := Mod(Dec, 8)
        Dec /= 8
        Oct += rem * i
        i *= 10
    } return Oct
}

;convertir octal a decimal
OctToDec(Oct) {
    i := Dec := 0
    while (Oct != 0) {
        rem := Mod(Oct, 10)
        Oct /= 10
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		} Dec += rem * z
        i++
    } return Dec
}

;convertir octal a binario
OctToBin(Oct) {
    i := Dec := Bin := 0
    while (Oct != 0) {
		if (i = 0) {
			z := 1
		} else {
			x := 8
			Loop, % (i - 1)
				x *= 8
			z := x
		} Dec += Mod(Oct, 10) * z
        i++
        Oct /= 10
    } i := 1
    while (Dec != 0) {
        Bin += Mod(Dec, 2) * i
        Dec /= 2
        i *= 10
    } return Bin
}

;convertir hexadecimal a string
;Ejemplo: MsgBox % HexToStr("0x53 0x74 0x72 0x54 0x6f 0x48 0x65 0x78") "`n" HexToStr("537472546f486578") "`n" HexToStr("0x530x740x720x540x6f0x480x650x78")
HexToStr(Hex) {
	Loop, Parse, % RegExReplace(StrReplace(Hex, "0x"), "[^0-9a-zA-Z]") 
	{ 	Char .= A_LoopField
		if (StrLen(Char) = 2)
			OutputVar .= Chr(DllCall("msvcrt.dll\_wcstoui64", "WStr", Char, "Ptr", 0, "Int", 16, "CDECL Int64")), Char := ""
	} return OutputVar
}

;convertir hexadecimal a RGB
;Sintaxis: HexToRGB( [hex], [R (salida)], [G (salida)], [B (salida)] )
HexToRGB(Hex, ByRef R := "", ByRef G := "", ByRef B := "") {
    H := InStr(Hex, "0x")?Hex:(InStr(Hex, "#")?"0x" SubStr(Hex, 2):"0x" Hex)
	return (R := (H & 0xFF0000) >> 16) "," (G := (H & 0xFF00) >> 8) "," (B := (H & 0xFF))
}

;convertir cadena de carácteres a hexadecimal
;MsgBox % StrToHex("StrToHex") "`n" StrToHex("StrToHex", "")
StrToHex(String, Prefix := " 0x") {
	Loop, Parse, % String
	{	if DllCall("msvcrt.dll\_ui64tow_s", "Int64", Ord(A_LoopField), "WStr", Char, "UPtr", VarSetCapacity(Char, 32 * 2 + 1, 0), "Int", 16)
		&& DllCall("msvcrt.dll\_i64tow", "Int64", Ord(A_LoopField), "WStr", Char, "UPtr", VarSetCapacity(Char, 32 * 2 + 1, 0), "Int", 16)
			continue
		OutputVar .= Prefix Char
	} return Trim(OutputVar)
} ;https://msdn.microsoft.com/en-us/library/0we9x30h.aspx

;convertir Float a Integer.
FloatToInt(Float) {
	return MulDiv(Float, 1, 1)
}

;----------------------------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------------------

;convertir tiempo. hora, minuto, segundo, milisegundo, dias, mes, año.
;Sintaxis: ConvertTime( [tiempo], [de], [a], [decimales 0~14] )
;Uso: ConvertTime( [h:m:s|hora|min|sec|ms|dia|mes|año], [time|hour|min|sec|ms|day|mon|year], [hour|min|sec|ms|day|mon|year] )
;EJEMPLOS (ver funcion): MsgBox % ConvertTime( 0xFFF, "ms", "sec", 0 )
ConvertTime(time, from, to, Places := 2) {
	;--------------------------------------------------------------------------------------------------------------------------------
	;tiempo: ConvertTime( "01:60:3600", "time", "hour" ) ;1hora 60min 3600seg = 3horas
	if (from = "time")
		RegExMatch(time, "(?<h>\d+):(?<m>\d+):(?<s>\d+)", _)
		, time_hour := _h+(_m/60)+(_s/3600), time_min := (_h*60)+_m+(_s/60)
		, time_sec := (_h/3600)+(_m*60)+_s, time_ms := (_h*3600000)+(_m*60000)+(_s*1000)
		, time_day := (_h/24)+(_m/1440)+(_s/86400), time_mon := (_h/730.484398)+(_m/43829.0639)+(_s/2629743.83)
		, time_year := (_h/8765.81277)+(_m/525948.766)+(_s/31556926)
	;--------------------------------------------------------------------------------------------------------------------------------
	;milisegundos: ConvertTime( 60000, "ms", "min" ) ;60000ms = 1min
	else if (from = "ms")
		ms_hour := time/3600000, ms_min := time/60000, ms_sec := time*0.001
		, ms_day := time/86400000, ms_mon := time/2629743830, ms_year := time/31556926000
	;--------------------------------------------------------------------------------------------------------------------------------
	;segundos: ConvertTime( 3600, "sec", "min" ) ;3600seg = 60minutos
	else if (from = "sec")
		sec_hour := time/3600, sec_min := time/60, sec_ms := time*1000
		, sec_day := time/86400, sec_mon := time/2629743.83, sec_year := time/31556926
	;--------------------------------------------------------------------------------------------------------------------------------
	;minutos: ConvertTime( 1, "min", "sec" ) ;1min = 60seg
	else if (from = "min")
		min_hour := time/60, min_sec := time*60, min_ms := time*60000
		, min_day := time/1440, min_mon := time/43829.0639, min_year := time/525948.766
	;--------------------------------------------------------------------------------------------------------------------------------
	;horas: ConvertTime( 2, "hour", "min" ) ;2horas = 120min
	else if (from = "hour")
		hour_min := time*60, hour_sec := time*3600, hour_ms := time*3600000
		, hour_day := time/24, hour_mon := time/730.484398, hour_year := time/8765.81277
	;--------------------------------------------------------------------------------------------------------------------------------
	;días: ConvertTime( 1, "day", "hour" ) ;1dia = 24horas
	else if (from = "day")
		day_hour := time*24, day_min := time*1440, day_sec := time*86400, day_ms := time*86400000
		, day_mon := time/30, day_year := time/365.242199
	;--------------------------------------------------------------------------------------------------------------------------------
	;mes: ConvertTime( 1, "mon", "hour" ) ;1mes = 730,48horas
	else if (from = "mon")
		mon_hour := time*730.484398, mon_min := time*43829.0639, mon_sec := time*2629743.83, mon_ms := time*2629743830
		, mon_day := time*30, mon_year := time/12
	;--------------------------------------------------------------------------------------------------------------------------------
	;año: ConvertTime( 1, "year", "mon" ) ;1año = 12meses
	else if (from = "year")
		year_hour := time*8765.81277, year_min := time*525948.766, year_sec := time*31556926, year_ms := time*31556926000
		year_day := time*365.242199, year_mon := time*12
	;--------------------------------------------------------------------------------------------------------------------------------
	return Round(%from%_%to%, Places)
}

;añadir marca decimal a un numero (coma o punto, por defecto: automatico dependiendo del idioma del sistema)
;Sintaxis 1: GetNumberFormat( [número], [codigo de idioma, punto o coma] )
;Sintaxis 2 (WIN_V+): GetNumberFormatEx( [número], [cadena de idioma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;Cadenas de idioma: https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
;EJEMPLO: MsgBox % GetNumberFormat(1000000.99, ".") "`n" GetNumberFormatEx(1024.75, "en-US")
GetNumberFormat(Number, Locale := 0x0400) {
	Locale := Locale="."?0x0456:Locale=","?0x0409:!Locale?0x0400:Locale
	, Size := DllCall("Kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Ptr", 0, "Int", 0)
    , VarSetCapacity(OutputVar, Size * 2)
	, r := DllCall("Kernel32.dll\GetNumberFormatW", "UInt", Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Str", OutputVar, "Int", Size)
    return OutputVar
} GetNumberFormatEx(Number, Locale := "!x-sys-default-locale") { ;WIN_V+ (recomendado)
	Size := DllCall("Kernel32.dll\GetNumberFormatEx", "Ptr", &Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Ptr", 0, "Int", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, r := DllCall("Kernel32.dll\GetNumberFormatEx", "Ptr", &Locale, "UInt", 0, "Str", Number, "Ptr", 0, "Str", OutputVar, "Int", Size)
	return OutputVar
} ;http://ahkscript.org/boards/viewtopic.php?p=56005#p56005

;Formatea una serie de números como una cadena de moneda para un entorno local especificado
;Sintaxis 1: GetCurrencyFormat( [cadena], [código de idioma] )
;Sintaxis 2 (WIN_V+): GetCurrencyFormatEx( [cadena], [cadena de idioma] )
;Códigos de idioma: https://msdn.microsoft.com/en-us/library/dd318693.aspx
;Cadenas de idioma: https://msdn.microsoft.com/en-us/goglobal/bb896001.aspx
;EJEMPLO: MsgBox % GetCurrencyFormat(0.99) "`n" GetCurrencyFormatEx(2.75, "en-US")
GetCurrencyFormat(String, Locale := 0x0400) {
	Size := DllCall("Kernel32.dll\GetCurrencyFormatW" , "UInt", Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Ptr", 0, "Int", 0) 
	, VarSetCapacity(OutputVar, Size * 2,  0)
	, r := DllCall("Kernel32.dll\GetCurrencyFormatW" , "UInt", Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Str", OutputVar, "Int", Size)
    return OutputVar, ErrorLevel := !r
} GetCurrencyFormatEx(String, Locale := "!x-sys-default-locale") { ;WIN_V+ (recomendado)
	Size := DllCall("Kernel32.dll\GetCurrencyFormatEx" , "Ptr", &Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Ptr", 0, "Int", 0) 
	, VarSetCapacity(OutputVar, Size * 2,  0)
	, r := DllCall("Kernel32.dll\GetCurrencyFormatEx" , "Ptr", &Locale, "UInt" , 0, "Ptr", &String, "Ptr" , 0, "Str", OutputVar, "Int", Size)
    return OutputVar, ErrorLevel := !r
} ;http://ahkscript.org/boards/viewtopic.php?p=56005#p56005

;saca el promedio
NumAverage(num*) {
	Sum := 0, num := num.MaxIndex()=1?StrSplit(num[1], ",", A_Space A_Tab):num
	Loop, % num.MaxIndex()
		Sum += num[A_Index]
	return Sum/(num.MaxIndex()+0.0)
}

;genera un número pseudo-aleatorio
;Sintaxis 1: Random( [min (-2147483648)], [max (2147483647)], [1~4294967295] )
;Sintaxis 2: RandomEx( [min], [max], [decimales] )
;Nota: para generar un carácter usar Chr(Random(97, 122))
Random(Min := -2147483648, Max := 2147483647, NewSeed := 0) {
	if (NewSeed) {
		Random,, %NewSeed%
		return NewSeed
	} Random, RandNum, %Min%, %Max%
	return RandNum
} RandomEx(Min, Max, Round := 0, Bits := 52) {
    DllCall("Advapi32.dll\CryptAcquireContextW", "Ptr*", hProv:=0, "Ptr", 0, "Ptr", 0, "UInt", 1, "UInt", 0xF0000000|0x40)
    , Bytes := Ceil(Bits/8), VarSetCapacity(Data, Bytes)
    , DllCall("Advapi32.dll\CryptGenRandom", "Ptr", hProv, "UInt", Bytes, "Ptr", &Data)
    , NumPut(((0xff >> (7-Mod(Bits-1, 8))) & NumGet(Data, Bytes-1, "UChar")), Data, Bytes-1, "UChar")
    , DllCall("Advapi32.dll\CryptReleaseContext", "Ptr", hProv, "UInt", 0)
	, r := ((NumGet(Data, 0, "UInt64") / 0xfffffffffffff) * (Max - Min)) + Min
    return (Round>-1)?Round(r, Round):r
} ;http://www.autohotkey.com/board/topic/70530-random-number-crypt-secure-rand-numberbuffer/

;determinar el porcentaje
;Sintaxis: Percent( [numero], [procentaje], [porcentaje (salida)], [decimales] )
;Ejemplo: MsgBox % "100 menos su 10%: " Percent(100, 10, Percent) "`n10% de 100: " Percent
;Return: devuelve la resta resultante del numero espesificado y el porncentaje espesificado de ese valor.
;3er Parámetro: devuelve el porcentaje espesificado para el valor espesificado.
Percent(num, Percent, ByRef OutputPercent := "", Places := 2) {
	return Float(num-(i:=(num/100)*Percent), "0." Places), OutputPercent := IsByRef(OutputPercent)?Round(i, Places):""
}

;descomposición prima
Factor(n, Delimiter := "`n") {
    if (n=1)
        return
    f := 2
	while (f<=n) {
        if (Mod(n, f)=0)
            return f Delimiter Factor(n/f)
        f++
}} ;http://rosettacode.org/wiki/Prime_decomposition#AutoHotkey

;convertir radian a grado sexagesimal/centesimal
;Sintaxis: RadianToDegree( [radianes], [¿centesimal?] )
;Ejemplo: MsgBox % RadianToDegree(120) "`n" RadianToDegree(120, true) ;6875.493542 | 7639.437268
RadianToDegree(Radians, Centesimal := false) {
	if (Centesimal)
		return Radians*63.6619772368 ;200/pi | 200/3.14159265359 = 63.6619772368
	return Radians*57.2957795131 ;180/pi | 180/3.14159265359 = 57.2957795131
}

;convertir grado sexagesimal/centesimal a radian
;Sintaxis: RadianToDegree( [grados], [¿centesimal?] )
;MsgBox % DegreeToRadian(6875.493542) "`n" DegreeToRadian(7639.437268, true) ;120 | 120
DegreeToRadian(Degrees, Centesimal := false) {
	if (Centesimal)
		return Degrees*0.01570796326 ;pi/200 | 3.14159265359/200 = 0.01570796326
	return Degrees*0.01745329251 ;pi/180 | 3.14159265359/180 = 0.01745329251
}























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: GDIPLUS ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/ms533971(v=vs.85).aspx
;Funciones extraidas de «Gdip standard library v1.45 by tic»: http://ahkscript.org/boards/viewtopic.php?t=6517
;Notas: 
	;• antes de usar cualquier funcion de abajo: usar GdiplusStartup()
	;• cuando ya no necesite usarlas: usar GdiplusShutdown()
;THIS IS A REWRITTEN VERSION OF GDIP STANDART LIBRARY BY TIC (credits for him)
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES NECESARIAS ~ INICIO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;inicializar Windows GDI+
;Sintaxis: GdiplusStartup( [hModule (out)] )
;hModule: distinto de cero si es la primera vez que se inicia o despues de ejecutar GdiplusShutdown()
GdiplusStartup(ByRef hModule := "") {
	static hToken
	if (hModule="*") || (hModule="?") || (hToken)
		return hToken := hModule="*"?0:hToken, hModule := 0
	Error := ErrorLevel, hModule := GetModuleHandle("gdiplus.dll")?0:LoadLibrary("gdiplus.dll")
	, VarSetCapacity(l, A_PtrSize=8?24:16, 0), l := Chr(1)
	, DllCall("gdiplus.dll\GdiplusStartup", "PtrP", hToken, "Ptr", &l, "Ptr", 0)
	return hToken, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/ms534077(v=vs.85).aspx

;limpia los recursos utilizados por Windows GDI+
;Sintaxis: GdiplusShutdown( [hToken], [0|1] )
;hToken: HANDLE que devuelve GdiplusStartup, opcional si se inicio con GdiplusStartup.
GdiplusShutdown(hToken := 0, hModule := true) {
	if (hModule) {
		Error := ErrorLevel, DllCall("gdiplus.dll\GdiplusShutdown", "Ptr", hToken?hToken:GdiplusStartup("?"))
		if (hModule:=GetModuleHandle("gdiplus.dll"))
			FreeLibrary(hModule)
		ErrorLevel := Error, GdiplusStartup("*")
}} ;https://msdn.microsoft.com/en-us/library/ms534076(v=vs.85).aspx

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GdipCreateBitmapFromStream(pStream) {
	DllCall("gdiplus.dll\GdipCreateBitmapFromStream", "Ptr", pStream, "PtrP", pBitmap)
	return pBitmap
} ;GdipCreateBitmapFromStream

GdipCreateHBitmapFromBitmap(pBitmap, Background := 0xFFFFFFFF) {
	DllCall("gdiplus.dll\GdipCreateHBITMAPFromBitmap", "Ptr", pBitmap, "PtrP", hBitmap, "UInt", _getcolor(Background))
	return hBitmap
} ;https://msdn.microsoft.com/en-us/library/ms536295(v=vs.85).aspx

GdipCreateBitmapFromHBitmap(hBitmap, Palette := 0) {
	DllCall("gdiplus.dll\GdipCreateBitmapFromHBITMAP", "Ptr", hBitmap, "Ptr", Palette, "PtrP", pBitmap)
	return pBitmap
} ;https://msdn.microsoft.com/en-us/library/ms536314(v=vs.85).aspx

;obtener Bitmap desde el Portapapeles
;Return:
	;0 = ERROR
	;pBitmap = OK
;ErrorLevel:
	;-2 = no se ha encontrado ningun Bitmap
	;-1 = no se ha podido abrir el portapapeles
	;0 = OK
	;1 = error al obtener el hBitmap desde el portapapeles
	;2 = error al obtener pBitmap desde hBitmap.
GdipCreateBitmapFromClipboard() {
	if !OpenClipboard()
		return false, ErrorLevel := -1
	if !IsClipboardFormatAvailable(8)
		return false, ErrorLevel := -2, CloseClipboard()
	if !(hBitmap:=GetClipboardData(2))
		return false, ErrorLevel := true, CloseClipboard()
	CloseClipboard()
	if !(pBitmap:=GdipCreateBitmapFromHBitmap(hBitmap))
		return false, ErrorLevel := 2
	return pBitmap, ErrorLevel := false, DeleteObject(hBitmap)
}

GdipDisposeImage(pBitmap) {
	DllCall("gdiplus.dll\GdipDisposeImage", "Ptr", pBitmap)
}

GdipCreateBitmap(Width, Height, PixelFormat := 0x26200A) {
	DllCall("gdiplus.dll\GdipCreateBitmapFromScan0", "Int", Width, "Int", Height, "Int", 0, "Int", PixelFormat, "Ptr", 0, "PtrP", pBitmap)
	return pBitmap
} ;https://msdn.microsoft.com/en-us/library/ms536315(v=vs.85).aspx

GdipGraphicsFromImage(pBitmap) {
	DllCall("gdiplus.dll\GdipGetImageGraphicsContext", "Ptr", pBitmap, "PtrP", pGraphics)
	return pGraphics
}

GdipSetImageAttributesColorMatrix(Matrix) {
	VarSetCapacity(ColourMatrix, 100, 0), Matrix := RegExReplace(RegExReplace(Matrix
	, "^[^\d-\.]+([\d\.])", "$1", "", 1), "[^\d-\.]+", "|"), Matrix := StrSplit(Matrix, "|")
	Loop, 25
		Matrix := (Matrix[A_Index]!="")?Matrix[A_Index]:!Mod(A_Index-1, 6)
		, NumPut(Matrix, ColourMatrix, (A_Index-1)*4, "Float")
	DllCall("gdiplus.dll\GdipCreateImageAttributes", "PtrP", ImageAttr)
	, DllCall("gdiplus.dll\GdipSetImageAttributesColorMatrix", "Ptr", ImageAttr, "Int", 1, "Int", 1, "Ptr", &ColourMatrix, "Ptr", 0, "Int", 0)
	return ImageAttr
}

GdipGetImageWidth(pBitmap) {
   DllCall("gdiplus.dll\GdipGetImageWidth", "Ptr", pBitmap, "UIntP", Width)
   return Width
}

GdipGetImageHeight(pBitmap) {
   DllCall("gdiplus.dll\GdipGetImageHeight", "Ptr", pBitmap, "UIntP", Height)
   return Height
}

GdipDisposeImageAttributes(ImageAttr) {
	return DllCall("gdiplus.dll\GdipDisposeImageAttributes", "Ptr", ImageAttr)
}

GdipDrawImage(pGraphics, pBitmap, dx := "", dy := "", dw := "", dh := "", sx := "", sy := "", sw := "", sh := "", Matrix := 1) {
	if ((Matrix&1)="")
		ImageAttr := GdipSetImageAttributesColorMatrix(Matrix)
	else if !(Matrix=1)
		ImageAttr := GdipSetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")
	if (sx sy sw sh="") {
		if (dx dy dw dh="") {
			sx := dx := sy := dy := 0
			, sw := dw := GdipGetImageWidth(pBitmap)
			, sh := dh := GdipGetImageHeight(pBitmap)
		} else {
			sx := sy := 0
			, sw := GdipGetImageWidth(pBitmap)
			, sh := GdipGetImageHeight(pBitmap)
	}} himgr := DllCall("gdiplus.dll\GdipDrawImageRectRect", "Ptr", pGraphics, "Ptr", pBitmap, "Float", dx, "Float", dy
	, "Float", dw, "Float", dh, "Float", sx, "Float", sy, "Float", sw, "Float", sh, "Int", 2, "Ptr", ImageAttr, "Ptr", 0, "Ptr", 0)
	if (ImageAttr)
		GdipDisposeImageAttributes(ImageAttr)
	return himgr
}

GdipDeleteGraphics(pGraphics) {
	return DllCall("gdiplus.dll\GdipDeleteGraphics", "Ptr", pGraphics)
}

GdipCreateBitmapFromFile(File, Index := 1, IconSizes := "256|128|64|48|32|16") {
	SplitPath, File,,, Ext
	if (Ext="exe") || (Ext="dll") {
		Size := VarSetCapacity(ICONINFO, 16 + (2*A_PtrSize), 0)
		Loop, Parse, % IconSizes, |
		{ 	if !(hIcon:=LoadImage(File, Index, A_LoopField, A_LoopField))
				continue
			if !(DllCall("User32.dll\GetIconInfo", "Ptr", hIcon, "Ptr", &ICONINFO, "Int")) || !(GetObject(c:=NumGet(ICONINFO, 12 + (A_PtrSize-4) + 4), Size, ICONINFO) && c) {
				DestroyIcon(hIcon), hIcon := ""
				continue
			} break
		} if !(hIcon)
			return false
		hbm := CreateDIBSection(Width:=NumGet(ICONINFO, 4, "Int"), -(Height:=NumGet(ICONINFO, 8, "Int"))), hDC := CreateCompatibleDC(), hSelectObj := SelectObject(hDC, hbm)
		if !DrawIcon(hDC,,, hIcon, Width, Height)
			return false, DestroyIcon(hIcon)
		GetObject(hbm, A_PtrSize=8?104:84, dib, 104), Stride := NumGet(dib, 12, "Int"), Bits := NumGet(dib, 20 + (A_PtrSize-4))
		, DllCall("gdiplus.dll\GdipCreateBitmapFromScan0", "Int", Width, "Int", Height, "Int", Stride, "Int", 0x26200A, "Int", Bits, "PtrP", pBitmapOld)
		, pBitmap := GdipCreateBitmap(Width, Height), pGraphics := GdipGraphicsFromImage(pBitmap), GdipDrawImage(pGraphics, pBitmapOld, 0, 0, Width, Height, 0, 0, Width, Height)
		, SelectObject(hDC, obm), DeleteObject(obm), DeleteDC(hDC), GdipDeleteGraphics(pGraphics), GdipDisposeImage(pBitmapOld), DestroyIcon(hIcon)
	} else DllCall("gdiplus.dll\GdipCreateBitmapFromFile", "Ptr", &File, "PtrP", pBitmap)
	return pBitmap
}

;pBitmap To File
;Sintaxis: GdipSaveBitmapToFile( [pBitmap], [archivo], [jpg calidad 0~100], [¿sobreescribir archivo?] )
;Extensiones soportadas: BMP|DIB|RLE|JPG|JPEG|JPE|JFIF|GIF|TIF|TIFF|PNG
;Return: 0|1
GdipSaveBitmapToFile(pBitmap, File, Quality := 100, OverWrite := true) {
	if !(OverWrite) && (FileExist(File))
		return false, ErrorLevel := 5 ;5=el archivo ya existe
	File := GetFullPathName(File), SplitPath(File,, Dir, Ext)
	if !(InVar(Ext, "bmp,dib,rle,jpg,jpeg,jpe,jfif,gif,tif,tiff,png")) 
		return false, ErrorLevel := 4 ;4=extension no soportada
	DllCall("gdiplus.dll\GdipGetImageEncodersSize", "UIntP", Count, "UIntP", Size)
	, VarSetCapacity(ci, Size, 0), DllCall("gdiplus.dll\GdipGetImageEncoders", "UInt", Count, "UInt", Size, "Ptr", &ci)
	if !(Count) && !(Size)
		return false, ErrorLevel := 2 ;2=no se pudo obtener una lista de los codificadores en el sistema
	Loop, %Count% {
		if !(InStr(Str:=StrGet(NumGet(ci, (idx:=(48+7*A_PtrSize)*(A_Index-1))+32+3*A_PtrSize), "UTF-16"), "*." Ext))
			continue
		Codec := &ci+idx
		break
	} if !(DirCreate(Dir)="*") && !(Codec)
		return false, ErrorLevel := 3 ;3=no se pudo encontrar codificador para el formato de archivo especificado
	if !(Quality=75) {
		if !((Quality:=Quality<0?0:Quality>100?100:Quality)="*") && (InVar(Ext, "jpg,jpeg,jpe,jfif")) {
			DllCall("gdiplus.dll\GdipGetEncoderParameterListSize", "Ptr", pBitmap, "Ptr", Codec, "UIntP", Size), VarSetCapacity(EncoderParameters
			, Size, 0), DllCall("gdiplus.dll\GdipGetEncoderParameterList", "Ptr", pBitmap, "Ptr", Codec, "UInt", Size, "Ptr", &EncoderParameters)
			Loop, % NumGet(EncoderParameters, 0, "UInt") {
				elem := (24+A_PtrSize)*(A_Index-1) + 4 + (pad:=A_PtrSize-4)
				if (NumGet(EncoderParameters, elem+16, "UInt")=1) && (NumGet(EncoderParameters, elem+20, "UInt")=6) {
					p := elem+&EncoderParameters-pad-4, NumPut(Quality, NumGet(NumPut(4, NumPut(1, p+0)+20, "UInt")), "UInt")
					break
	}	}	}	} return Error:=!DllCall("gdiplus.dll\GdipSaveImageToFile", "Ptr", pBitmap, "Ptr", &File, "Ptr", Codec, "UInt", p?p:0), ErrorLevel := !Error ;1=error al guardar el archivo
}

GdipGetImageDimensions(pBitmap, ByRef Width := "", ByRef Height := "") {
	if (w:=true) && IsByRef(Width)
		w := !DllCall("gdiplus.dll\GdipGetImageWidth", "Ptr", pBitmap, "UIntP", Width)
	if (h:=true) && IsByRef(Height)
		h := !DllCall("gdiplus.dll\GdipGetImageHeight", "Ptr", pBitmap, "UIntP", Height)
	return h&&w, ErrorLevel := !(h&&w)
}

;Bitmap From Screen
;Sintaxis: GdipBitmapFromScreen( [pantalla], [raster], [hWnd] )
;Pantalla:
	;0 = todas
	;x|y|w|h = coordenadas
GdipBitmapFromScreen(Screen := 0, Raster := 0x00CC0020, hWnd := 0) {
	if (Screen=0) && (Pos:=[])
		Pos := GetSystemMetrics(76, 77, 78, 79)
	else Pos := StrSplit(Screen, "|", A_Space A_Tab)
	hDC := CreateCompatibleDC(), hbm := CreateDIBSection(Pos[3], Pos[4], hDC), hSelObject := SelectObject(hDC, hbm)
	, hDC2 := GetDC(hWnd, 0, hWnd?3:0), BitBlt(hDC,,, Pos[3], Pos[4], hDC2, Pos[1], Pos[2], Raster)
	, ReleaseDC(0, hDC2), pBitmap := GdipCreateBitmapFromHBITMAP(hbm), SelectObject(hDC, hSelObject)
	return pBitmap, DeleteObject(hbm), DeleteDC(hDC2, hDC)
}

GdipAddPathBeziers(pPath, Points) {
	Points := StrSplit(Points, "|", A_Space A_Tab)
	, VarSetCapacity(Point, Points.MaxIndex() * 8, 0)
	for k, v in Points
		Coord := StrSplit(Points[A_Index], ",", A_Space A_Tab)
		, NumPut(Coord[1], Point, (A_Index-1) * 8, "Float")
		, NumPut(Coord[2], Point, ((A_Index-1) * 8) + 4, "Float")
	return DllCall("gdiplus.dll\GdipAddPathBeziers", "Ptr", pPath, "Ptr", &Point, "Int", Points.MaxIndex())
} ;https://msdn.microsoft.com/en-us/library/ms535620(v=vs.85).aspx

GdipAddPathBezier(pPath, spx := 0, spy := 0, fcpx := 0, fcpy := 0, scpx := 0, scpy := 0, epx := 0, epy := 0) {
	return DllCall("gdiplus.dll\GdipAddPathBezier", "Ptr", pPath, "Float", spx, "Float", spy, "Float", fcpx
	, "Float", fcpy, "Float", scpx, "Float", scpy, "Float", epx, "Float", epy)
} ;https://msdn.microsoft.com/en-us/library/ms535622(v=vs.85).aspx

GdipAddPathLines(pPath, Points) {
	Points := StrSplit(Points, "|", A_Space A_Tab)
	, VarSetCapacity(Point, Points.MaxIndex() * 8, 0)
	for k, v in Points
		Coord := StrSplit(Points[A_Index], ",", A_Space A_Tab)
		, NumPut(Coord[1], Point, (A_Index-1) * 8, "Float")
		, NumPut(Coord[2], Point, ((A_Index-1) * 8) + 4, "Float")
	return DllCall("gdiplus.dll\GdipAddPathLine2", "Ptr", pPath, "Ptr", &Point, "Int", Points.MaxIndex())
} ;https://msdn.microsoft.com/en-us/library/ms535600(v=vs.85).aspx

GdipAddPathLine(pPath, spx, spy, epx, epy) {
	return DllCall("gdiplus.dll\GdipAddPathLine", "Ptr", pPath, "Float", spx, "Float", spy, "Float", epx, "Float", epy)
} ;https://msdn.microsoft.com/en-us/library/ms535603(v=vs.85).aspx

;Sintaxis: GdipCreateSolidBrush( [ARGB Color] )
GdipCreateSolidBrush(ARGB := "0xFF000000") {
	DllCall("gdiplus\GdipCreateSolidFill", "UInt", RGBToARGB(ARGB), "UPtrP", pBrush)
	return pBrush
} ;https://msdn.microsoft.com/en-us/library/ms534735(v=vs.85).aspx

GdipFillRectangle(pGraphics, pBrush, x, y, w, h) {
	return DllCall("gdiplus\GdipFillRectangle", "UPtr", pGraphics, "UPtr", pBrush, "Float", x, "Float", y, "Float", w, "Float", h)
}

GdipCreateHICONFromBitmap(pBitmap) {
	DllCall("gdiplus\GdipCreateHICONFromBitmap", "UPtr", pBitmap, "UPtrP", hIcon)
	return hIcon
}

GdipTextToGraphics(pGraphics, Text, Options, Font := 0, Width := "", Height := "", Measure := 0) {
	Font := Font?Trim(Font):FontQuery()[1], IWidth := Width, IHeight:= Height, Style := Align := 0
	, RegExMatch(Options, "i)X([\-\d\.]+)(p*)", xpos), RegExMatch(Options, "i)Y([\-\d\.]+)(p*)", ypos)
	, RegExMatch(Options, "i)W([\-\d\.]+)(p*)", Width), RegExMatch(Options, "i)H([\-\d\.]+)(p*)", Height)
	, RegExMatch(Options, "i)C(?!(entre|enter))([a-f\d]+)", Colour), RegExMatch(Options, "i)Top|Up|Bottom|Down|vCentre|vCenter", vPos)
	, RegExMatch(Options, "i)NoWrap", NoWrap), RegExMatch(Options, "i)R(\d)", Rendering), RegExMatch(Options, "i)S(\d+)(p*)", Size)
	if !GdipDeleteBrush(GdipCloneBrush(Colour2))
		PassBrush := 1, pBrush := Colour2
	if !(IWidth && IHeight) && (xpos2 || ypos2 || Width2 || Height2 || Size2)
		return false
	Loop, Parse, % "Regular|Bold|Italic|BoldItalic|Underline|Strikeout", |
		if RegExMatch(Options, "\b" A_loopField)
			Style |= (A_LoopField != "StrikeOut") ? (A_Index-1) : 8
	Loop, Parse, % "Near|Left|Centre|Center|Far|Right", |
		if RegExMatch(Options, "\b" A_loopField)
			Align |= A_Index//2.1      ; 0|0|1|1|2|2
	xpos := (xpos1!="")?xpos2?IWidth*(xpos1/100):xpos1:0, ypos := (ypos1!="")?ypos2?IHeight*(ypos1/100):ypos1:0
	, Width := Width1?Width2?IWidth*(Width1/100):Width1:IWidth, Height := Height1?Height2?IHeight*(Height1/100):Height1:IHeight
	, Colour := !PassBrush?("0x" (Colour2?Colour2:"ff000000")):Colour, Rendering := ((Rendering1>=0)&&(Rendering1<=5))?Rendering1:4
	, Size := (Size1>0)?Size2?IHeight*(Size1/100):Size1:12, hFamily := GdipCreateFontFamily(Font), hFont := GdipCreateFont(hFamily, Size, Style)
	, FormatStyle := NoWrap?0x4000|0x1000:0x4000, hFormat := GdipCreateStringFormat(FormatStyle), pBrush := PassBrush?pBrush:GdipCreateSolidBrush(Colour)
	if !(hFamily && hFont && hFormat && pBrush && pGraphics)
		return false
	VarSetCapacity(RC, 16), NumPut(xpos, RC, 0, "Float"), NumPut(ypos, RC, 4, "Float"), NumPut(Width, RC, 8, "Float"), NumPut(Height, RC, 12, "Float")
   , GdipSetStringFormatAlign(hFormat, Align), GdipSetTextRenderingHint(pGraphics, Rendering), ReturnRC := GdipMeasureString(pGraphics, Text, hFont, hFormat, RC)
	if (vPos)
		ReturnRC := StrSplit(vPos, "|"), ypos := (vPos="vCentre"||vPos="vCenter")?((Height-ReturnRC.4)//2):(vPos="Top"||vPos="Up")?0:(vPos="Bottom"||vPos = "Down")?(Height-ReturnRC.4):ypos
		, VarSetCapacity(RC2, 16), NumPut(xpos, RC2, 0, "Float"), NumPut(ypos, RC2, 4, "Float"), NumPut(Width, RC2, 8, "Float"), NumPut(ReturnRC.4, RC2, 12, "Float")
		, ReturnRC := GdipMeasureString(pGraphics, Text, hFont, hFormat, RC2)
	E := !Measure?GdipDrawString(pGraphics, Text, hFont, hFormat, pBrush, RC):E, PassBrush := !PassBrush?GdipDeleteBrush(pBrush):PassBrush
	return E?E:ReturnRC, GdipDeleteStringFormat(hFormat), GdipDeleteFont(hFont), GdipDeleteFontFamily(hFamily)
}

GdipDeleteFont(hFont) {
   return DllCall("gdiplus\GdipDeleteFont", "UPtr", hFont)
}

GdipDeleteFontFamily(hFamily) {
   return DllCall("gdiplus\GdipDeleteFontFamily", "UPtr", hFamily)
}

GdipDeleteStringFormat(hFormat) {
   return DllCall("gdiplus\GdipDeleteStringFormat", "UPtr", hFormat)
}

GdipDrawString(pGraphics, Str, hFont, hFormat, pBrush, ByRef RectF) {
	return DllCall("gdiplus\GdipDrawString", "UPtr", pGraphics, "UPtr", &Str, "Int", -1, "UPtr", hFont, "UPtr", &RectF, "UPtr", hFormat, "UPtr", pBrush)
}

GdipMeasureString(pGraphics, Str, hFont, hFormat, ByRef RectF) {
	VarSetCapacity(RC, 16)
	, DllCall("gdiplus\GdipMeasureString", "UPtr", pGraphics, "UPtr", &Str, "Int", -1, "UPtr", hFont, "UPtr", &RectF, "UPtr", hFormat, "UPtr", &RC, "UIntP", Chars, "UIntP", Lines)
	return &RC?(NumGet(RC, 0, "Float") "|" NumGet(RC, 4, "Float") "|" NumGet(RC, 8, "Float") "|" NumGet(RC, 12, "Float") "|" Chars "|" Lines):false
}

;Near = 0 | Center = 1 | Far = 2
GdipSetStringFormatAlign(hFormat, Align := 0) {
   return DllCall("gdiplus\GdipSetStringFormatAlign", "UPtr", hFormat, "Int", Align)
}

;StringFormatFlagsDirectionRightToLeft = 0x00000001 | StringFormatFlagsDirectionVertical = 0x00000002
;StringFormatFlagsNoFitBlackBox = 0x00000004 | StringFormatFlagsDisplayFormatControl = 0x00000020
;StringFormatFlagsNoFontFallback = 0x00000400 | StringFormatFlagsMeasureTrailingSpaces = 0x00000800
;StringFormatFlagsNoWrap = 0x00001000 | StringFormatFlagsLineLimit = 0x00002000 | StringFormatFlagsNoClip = 0x00004000 
GdipCreateStringFormat(Format := 0, Lang := 0) {
   DllCall("gdiplus\GdipCreateStringFormat", "Int", Format, "Int", Lang, "UPtrP", hFormat)
   return hFormat
}

GdipCreateFontFamily(Font) {
	DllCall("gdiplus\GdipCreateFontFamilyFromName", "UPtr", &Font, "UInt", 0, "UPtrP", hFamily)
	return hFamily
}

;Regular = 0 | Bold = 1 | Italic = 2 | BoldItalic = 3 | Underline = 4 | Strikeout = 8
GdipCreateFont(hFamily, Size := 0, Style := 0) {
	Size := Size?Size:FontQuery()[2]
   , DllCall("gdiplus\GdipCreateFont", "UPtr", hFamily, "Float", Size, "Int", Style, "Int", 0, "UPtrP", hFont)
   return hFont
}

GdipCloneBrush(pBrush) {
	DllCall("gdiplus\GdipCloneBrush", "UPtr", pBrush, "UPtrP", pBrushClone)
	return pBrushClone
}

GdipDeleteBrush(pBrush) {
   return DllCall("gdiplus\GdipDeleteBrush", "UPtr", pBrush)
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;funciones de calidad
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GdipSetInterpolationMode(pGraphics, Mode := 7) {
	return DllCall("gdiplus.dll\GdipSetInterpolationMode", "Ptr", pGraphics, "Int", Mode)
}

GdipSetSmoothingMode(pGraphics, Mode := 4) {
   return DllCall("gdiplus.dll\GdipSetSmoothingMode", "Ptr", pGraphics, "Int", Mode)
}

GdipSetTextRenderingHint(pGraphics, Hint := 4) {
	return DllCall("gdiplus.dll\GdipSetTextRenderingHint", "Ptr", pGraphics, "Int", Hint)
}

GdipSetCompositingMode(pGraphics, Mode := 0) {
   return DllCall("gdiplus.dll\GdipSetCompositingMode", "Ptr", pGraphics, "Int", !!Mode)
}
































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ADMINISTRACIÓN DE MEMORIA ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa366781(v=vs.85).aspx#general_memory_functions
;#############################################################################################################################################
;copia un bloque de memoria de un lugar a otro
;Sintaxis: CopyMemory[ [destino], [origen], [bytes] )
CopyMemory(ByRef Destination, Source, Bytes) {
	DllCall("msvcrt.dll\memcpy_s", "Ptr", Destination, "UInt", Bytes, "Ptr", Source, "UInt", Bytes)
}

;mover un bloque de memoria de un lugar a otro
;Sintaxis: MoveMemory[ [destino], [origen], [bytes] )
MoveMemory(ByRef Destination, Source, Bytes) {
	DllCall("msvcrt.dll\memmove_s", "Ptr", Destination, "UInt", Bytes, "Ptr", Source, "UInt", Bytes)
} 

;llena un bloque de memoria con el valor especificado
;Sintaxis: FillMemory( [destino], [bytes], [valor] )
FillMemory(ByRef Destination, Bytes, Fill) {
	DllCall("ntdll.dll\RtlFillMemory", "Ptr", Destination, "UInt", Bytes, "UChar", Fill) 
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff561870(v=vs.85).aspx

;llena un bloque de memoria con ceros
;Sintaxis: ZeroMemory( [destino], [bytes] )
ZeroMemory(ByRef Destination, Bytes) {
	DllCall("ntdll.dll\RtlZeroMemory", "Ptr", Destination, "UInt", Bytes)
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff563610(v=vs.85).aspx

;compara dos bloques de memoria
;Sintaxis: CompareMemory( [mem1], [mem2], [tamaño total, en bytes] )
;Return:
	;1 = mem1 > mem2
	;0 = mem1 = mem2
	;-1 = mem1 < mem2
CompareMemory(Source1, Source2, Size := 0) {
	if !(Size)
		Size1 := VarSetCapacity(Source1), Size2 := VarSetCapacity(Source2), Size := Size1<Size2?Size1:Size2
		, Result := DllCall("msvcrt.dll\memcmp", "UPtr", &Source1, "UPtr", &Source2, "UInt", Size, "CDecl Int")
	else Result := DllCall("msvcrt.dll\memcmp", "UPtr", Source1, "UPtr", Source2, "UInt", Size, "CDecl Int")
	return Result>0?1:Result<0?-1:0, ErrorLevel := ((Result+0)="")
}

;recupera la cantidad de memoria RAM en KB instalada físicamente de tablas de firmware SMBIOS (System Management BIOS) del equipo
;Ejemplo: MsgBox % Round(GetPhysicallyInstalledSystemMemory()/1024, 1) " MB"
;Nota: para recuperar solo la RAM, usar GlobalMemoryStatus().TotalPhys
GetPhysicallyInstalledSystemMemory() { ;WIN_V SP1+
	DllCall("Kernel32.dll\GetPhysicallyInstalledSystemMemory", "Int64P", TotalMemoryInKilobytes)
	return TotalMemoryInKilobytes
}

;recupera información sobre el uso actual de memoria física y virtual del sistema
;Ejemplo: MsgBox % (l:=GlobalMemoryStatus()) "Load: " l.Load " %`nRAM: " Round(l.TotalPhys/(1024**2), 1) " MB"
GlobalMemoryStatus() {
	VarSetCapacity(MEMORYSTATUSEX, 64, 0), NumPut(64, MEMORYSTATUSEX, "UInt")
	r := DllCall("Kernel32.dll\GlobalMemoryStatusEx", "Ptr", &MEMORYSTATUSEX)
	return !r?false:{Load: NumGet(MEMORYSTATUSEX, 4, "UInt") ;número entre 0 y 100 que especifica el porcentaje aproximado de la memoria física que está en uso
	, TotalPhys: NumGet(MEMORYSTATUSEX, 8, "UInt64") ;cantidad de memoria física real, en bytes
	, AvailPhys: NumGet(MEMORYSTATUSEX, 16, "UInt64") ;cantidad de memoria física disponible actualmente, en bytes
	, TotalPageFile: NumGet(MEMORYSTATUSEX, 24, "UInt64") ;límite de memoria comprometida actual para el sistema o el proceso actual, en bytes
	, AvailPageFile: NumGet(MEMORYSTATUSEX, 32, "UInt64") ;cantidad máxima de memoria que el proceso actual puede usar, en bytes.
	, TotalVirtual: NumGet(MEMORYSTATUSEX, 40, "UInt64") ;espacio de direcciones virtuales del proceso de llamada, en bytes
	, AvailVirtual: NumGet(MEMORYSTATUSEX, 48, "UInt64")} ;espacio disponible de direcciones virtuales del proceso de llamada, en bytes
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366589(v=vs.85).aspx

;recupera los límites de tamaño actuales para el conjunto de trabajo de la memoria caché del sistema
;Sintaxis: GetSystemFileCacheSize( [min, en bytes], [max, en bytes], [FILE_CACHE_MAX_HARD_ENABLE=1 | FILE_CACHE_MIN_HARD_ENABLE=4] )
;Ejemplo: MsgBox % GetSystemFileCacheSize(Min, Max, Flags) "`nMin: " Round(Min/(1024**2), 1) " MB" "`nMax: " Round(Max/(1024**2), 1) " MB" "`nFlags: " Flags
GetSystemFileCacheSize(ByRef MinimumFileCacheSize := "", ByRef MaximumFileCacheSize := "", ByRef Flags := "") {
	return DllCall("Kernel32.dll\GetSystemFileCacheSize", "Int64P", MinimumFileCacheSize, "Int64P", MaximumFileCacheSize, "UIntP", Flags)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa965224(v=vs.85).aspx

GlobalLock(hMem) {
	return DllCall("Kernel32.dll\GlobalLock", "Ptr", hMem, "Ptr")
} GlobalAlloc(Bytes, Flags := 0x0002) {
	return DllCall("Kernel32.dll\GlobalAlloc", "UInt", Flags, "UInt", Bytes, "Ptr")
} GlobalReAlloc(hMem, Bytes, Flags := 0x0002) {
	return DllCall("Kernel32.dll\GlobalReAlloc", "Ptr", hMem, "UInt", Bytes, "UInt", Flags, "Ptr")
} GlobalUnlock(hMem) {
	return DllCall("Kernel32.dll\GlobalUnlock", "Ptr", hMem, "UInt")
} GlobalFree(hMem) {
	return DllCall("Kernel32.dll\GlobalFree", "Ptr", hMem, "Ptr")
} GlobalSize(hMem) {
	return DllCall("Kernel32.dll\GlobalSize", "Ptr", hMem, "UInt")
} GlobalDiscard(hMem) {
	return DllCall("Kernel32.dll\GlobalDiscard", "Ptr", hMem, "Ptr")
} GlobalFlags(hMem) {
	return DllCall("Kernel32.dll\GlobalFlags", "Ptr", hMem, "UInt")
}

LocalFree(hMem*) {
	Error := ErrorLevel, Ok := 0
	for k, v in hMem
		Ok += !DllCall("Kernel32.dll\LocalFree", "Ptr", v, "Ptr")
	return Ok=hMem.MaxIndex(), ErrorLevel := Error
}

CreateStreamOnHGlobal(hGlobal, DeleteOnRelease := true) {
	DllCall("ole32.dll\CreateStreamOnHGlobal", "Ptr", hGlobal, "Int", !!DeleteOnRelease, "PtrP", IStream)
	return IStream
}

;cambia el estado de una región de la memoria dentro del espacio de direcciones virtuales de un proceso especificado. la memoria se asigna a cero. 
;Sintaxis: VirtualAlloc( [hProcess], [direccion], [tamaño], [tipo], [protección], [NUMA] )
;hProcess (opcional): HANDLE a un proceso, si no se utiliza, usa el proceso actual.
;Dirección (opcional): dirección de inicio de la región de asignar
;Tamaño: tamaño de la region, en bytes
;Tipo: tipo de asignación de memoria
	;MEM_COMMIT (defecto) = 0x00001000
	;MEM_RESERVE = 0x00002000
	;MEM_RESET = 0x00080000
	;MEM_RESET_UNDO = 0x1000000
	;---------------------------------------------------------
	;MEM_LARGE_PAGES = 0x20000000
	;MEM_PHYSICAL = 0x00400000
	;MEM_TOP_DOWN = 0x00100000
;Protección: la protección de la memoria para la región de páginas que se asignará
	;PAGE_EXECUTE = 0x10
	;PAGE_EXECUTE_READ = 0x20
	;PAGE_EXECUTE_READWRITE = 0x40
	;PAGE_EXECUTE_WRITECOPY = 0x80
	;PAGE_NOACCESS = 0x01
	;PAGE_READONLY = 0x02
	;PAGE_READWRITE (defecto) = 0x04
	;PAGE_WRITECOPY = 0x08
	;PAGE_TARGETS_INVALID = 0x40000000
	;PAGE_TARGETS_NO_UPDATE = 0x40000000
	;---------------------------------------------------------
	;PAGE_GUARD = 0x100
	;PAGE_NOCACHE = 0x200
	;PAGE_WRITECOMBINE = 0x400
;NUMA (opcional): nodo NUMA, donde la memoria física debe residir.
VirtualAlloc(ByRef hProcess := 0, ByRef Address := 0, ByRef Bytes := 0, AllocationType := 0x00001000, Protect := 0x04, Preferred := 0) {
	if !(hProcess) ;VirtualAlloc
		return DllCall("Kernel32.dll\VirtualAlloc", "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt", Protect, "UInt")
	if !(Preferred) ;VirtualAllocEx + hProcess | else VirtualAllocExNuma + NUMA
		return DllCall("Kernel32.dll\VirtualAllocEx", "Ptr", hProcess, "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt", Protect, "UInt")
	return DllCall("Kernel32.dll\VirtualAllocExNuma", "Ptr", hProcess, "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt", Protect, "UInt", Preferred, "UInt")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366891(v=vs.85).aspx

;liberar una región de páginas dentro del espacio de direcciones virtuales del proceso espesificado
;Sintaxis: VirtualFree( [hProcess], [direccion], [tamaño, en bytes], [tipo] )
;Tipos:
	;MEM_DECOMMIT = 0x4000
	;MEM_RELEASE (defecto) = 0x8000
VirtualFree(hProcess := 0, Address := 0, Bytes := 0, AllocationType := 0x8000) {
	Error := ErrorLevel
	if !(hProcess) ;VirtualFree | else VirtualFreeEx + hProcess
		return DllCall("Kernel32.dll\VirtualFree", "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt"), ErrorLevel := Error
	return DllCall("Kernel32.dll\VirtualFreeEx", "Ptr", hProcess, "UInt", Address, "UPtr", Bytes, "UInt", AllocationType, "UInt"), ErrorLevel := Error
}

;libera un bloque de memoria de una tarea asignada previamente a través de una llamada a la función CoTaskMemAlloc() o CoTaskMemAlloc().
;Sintaxis: CoTaskMemFree( [hMem] )
CoTaskMemFree(ByRef hMem) {
	Error := ErrorLevel
	, Ok := DllCall("Ole32.dll\CoTaskMemFree", "UPtr", hMem)
	return !!Ok, VarSetCapacity(hMem, 0), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680722(v=vs.85).aspx

;asigna un bloque de memoria de trabajo
;Sintaxis: CoTaskMemAlloc( [tamaño del bloque de memoria, en bytes] )
;Return: hMem
CoTaskMemAlloc(Bytes) {
	return DllCall("Ole32.dll\CoTaskMemAlloc", "UPtr", Bytes, "UPtr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms692727(v=vs.85).aspx

;cambia el tamaño de un bloque previamente asignado de memoria de trabajo.
;Sintaxis: CoTaskMemRealloc( [hMem], [nuevo tamaño para el bloque de memoria, en bytes] )
CoTaskMemRealloc(hMem, Bytes) {
	return DllCall("Ole32.dll\CoTaskMemRealloc", "Ptr", hMem, "UPtr", Bytes, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687280(v=vs.85).aspx

;ajusta la capacidad de una variable a su contenido.
;Ejemplo:
	;VarSetCapacity(OutputVar, 104857600, 0) ;asiga 100 MB a OutputVar
	;OutputVar := "123456789" ;asigna una cadena de carácteres a OutputVar
	;MsgBox % "Contenido: " OutputVar "`nCapacidad: " VarSetCapacity(OutputVar) ;muestra el contenido y la capacidad actual de OutputVar, en bytes.
	;VarAdjustCapacity(OutputVar) ;aplicando el ajuste.
	;MsgBox % "Contenido: " OutputVar "`nCapacidad: " VarSetCapacity(OutputVar) ;vuelve a mostrar el contenido y la capacidad actual de OutputVar, en bytes.
VarAdjustCapacity(ByRef Var) {
	return Capacity := VarSetCapacity(Var, -1)
	, OutputVar := Var, VarSetCapacity(Var, 0)
	, VarSetCapacity(Var, Capacity), Var := OutputVar
}














































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: DEVICE CONTEXT FUNCTIONS ::::::::::::::::::::::::::::::::::
;Notas:
	;usar DeleteDC para: CreateDC, CreateIC, CreateCompatibleDC
	;usar ReleaseDC para: GetDC
;#############################################################################################################################################
;crea un contexto de dispositivo (DC, device context) para un dispositivo utilizando el nombre especificado
;Sintaxis: CreateDC( [nombre], [nombre del dispositivo de salida], [data] )
;Return: hDC
CreateDC(Driver := "DISPLAY", Device := "", InitData := 0) {
	if (Driver="DISPLAY") && !(Device="") && !(Device=Driver) ;si Driver="DISPLAY" -> Device="" o Device="DISPLAY"
		Device := ""
	return DllCall("Gdi32.dll\CreateDC", "Ptr", Driver=""?0:&Driver, "Ptr", Device=""?0:&Device, "Ptr", 0, "Ptr", InitData, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/dd183490(v=vs.85).aspx

CreateCompatibleDC(hWnd := 0) {
	return DllCall("Gdi32.dll\CreateCompatibleDC", "Ptr", hWnd, "Ptr")
}

;recupera la información para el dispositivo especificado
;Sintaxis: GetDeviceCaps( [hDC], [Index], [return type] )
GetDeviceCaps(ByRef hDC := 0, Index := 1, ReturnType := "Int") {
	r := DllCall("Gdi32.dll\GetDeviceCaps", "Ptr", hDC?hDC:(DC:=CreateDC()), "Int", Index, ReturnType)
	if (DC)
		hDC := IsByRef(hDC)?DC:DllCall("Gdi32.dll\DeleteDC", "Ptr", DC, "Int")
	return r
} ;https://msdn.microsoft.com/en-us/library/dd144877(v=vs.85).aspx

GetStockObject(Object, ByRef hDC := 0) {
	if IsByRef(hDC)
		hDC := DllCall("User32.dll\GetDC", "Ptr", hDC?hDC:0, "Ptr")
	return DllCall("Gdi32.dll\GetStockObject", "Int", Object, "Ptr")
}

;Sintaxis: GetDC( [hWnd], [region], [modo] )
;hWnd: ventana_hwnd o 0 para toda la pantalla
;Return: hDC
GetDC(hWnd := 0, RegionClip := 0, Flags := 0) {
	if (RegionClip) || (Flags)
		return DllCall("User32.dll\GetDCEx", "Ptr", hWnd, "Ptr", RegionClip, "UInt", Flags)
	return DllCall("User32.dll\GetDC", "Ptr", hWnd, "Ptr")
}

;Sintaxis: ReleaseDC( [hWnd], [hDC] )
ReleaseDC(hWnd, hDC) {
	return DllCall("User32.dll\ReleaseDC", "Ptr", hWnd, "Ptr", hDC, "Int")
}

;Sintaxis: DeleteDC( [hDC] )
DeleteDC(hDC*) {
	Ok := 0
	Loop, % hDC.MaxIndex()
		Ok += !!DllCall("Gdi32.dll\DeleteDC", "Ptr", hDC[A_Index], "UInt")
	return Ok=hDC.MaxIndex()
}

;Sintaxis: BitBlt( [destino], [x], [y], [ancho], [alto], [source], [sx], [sy], [raster] )
;Raster: BLACKNESS = 0x00000042 | NOTSRCERASE = 0x001100A6 | NOTSRCCOPY = 0x00330008
	;SRCERASE = 0x00440328 | DSTINVERT = 0x00550009 | PATINVERT = 0x005A0049 | SRCINVERT = 0x00660046
	;SRCAND = 0x008800C6 | MERGEPAINT = 0x00BB0226 | MERGECOPY = 0x00C000CA | SRCCOPY = 0x00CC0020
	;SRCPAINT = 0x00EE0086 | PATCOPY = 0x00F00021 | PATPAINT = 0x00FB0A09 | WHITENESS = 0x00FF0062
	;CAPTUREBLT = 0x40000000 | NOMIRRORBITMAP = 0x80000000
BitBlt(dhdc, dx := 0, dy := 0, dw := 32, dh := 32, shdc := 0, sx := 0, sy := 0, Raster := 0x00CC0020) {
	return DllCall("gdi32.dll\BitBlt", "Ptr", dhdc, "Int", dx, "Int", dy, "Int", dw, "Int", dh, "Ptr", shdc, "Int", sx, "Int", sy, "UInt", Raster, "UInt")
} ;https://msdn.microsoft.com/en-us/library/dd183370(v=vs.85).aspx

StretchBlt(dhdc, dx := 0, dy := 0, dw := 32, dh := 32, shdc := 0, sx := 0, sy := 0, sw := 0, sh := 0, Raster := 0x00CC0020) {
	return DllCall("gdi32.dll\StretchBlt", "Ptr", dhdc, "Int", dx, "Int", dy, "Int", dw, "Int", dh
		, "Ptr", Source, "Int", sx, "Int", sy, "Int", sw, "Int", shdc, "UInt", Raster, "UInt")
}

;Sintaxis: SetStretchBltMode( [hDC], [modo] )
;Modos: STRETCH_ANDSCANS = 0x01 | |STRETCH_ORSCANS = 0x02 | STRETCH_DELETESCANS = 0x03 | STRETCH_HALFTONE = 0x04
;Return: 0 | modo_anterior
SetStretchBltMode(hDC, Mode := 0x04) {
	Ok := DllCall("gdi32.dll\SetStretchBltMode", "Ptr", hDC, "Int", Mode, "UInt")
	return Ok=87?false:Ok ;ERROR_INVALID_PARAMETER = 87
} ;https://msdn.microsoft.com/en-us/library/dd145089(v=vs.85).aspx

;actualiza la posición, el tamaño, la forma, el contenido y la translucidez de una ventana de capas.
;Sintaxis: UpdateLayeredWindow( [hWnd], [hDC], [x], [y], [ancho], [alto], [color] )
UpdateLayeredWindow(hWnd, hDC, x := "", y := "", Width := "", Height := "", Alpha := 255) {
	if !((x+0)="") && !((y+0)="")
		VarSetCapacity(POINT, 8), NumPut(x, POINT, 0, "Int"), NumPut(y, POINT, 4, "Int"), l := true
	if (Width="") || (Height="")
		GetWindowPos(hWnd,,, _w, _h), Width := (Width+0)=""?_w:Width, Height := (Height+0)=""?_h:Height
	VarSetCapacity(SIZE, 8), NumPut(Width, SIZE, 0, "Int"), NumPut(Height, SIZE, 4, "Int")
	return DllCall("User32.dll\UpdateLayeredWindow", "Ptr", hWnd, "Ptr", 0, "Ptr", l?&POINT:0
		, "Ptr", &SIZE, "Ptr", hDC, "Ptr", 0, "Ptr", 0, "UIntP", Alpha<<16|1<<24, "UInt", 0x00000002)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633556(v=vs.85).aspx






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: RECURSOS & DLL ::::::::::::::::::::::::::::::::::
;Recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff468901(v=vs.85).aspx
	;Parámetros:
		;hModule = LoadLibrary("C:\File.exe", 0x2)
		;HANDLE = BeginUpdateResource()
		;hResData = FindResource()
		;hResLoad = LoadResource()
		;Info/data/lpResLock = LockResource() / Binary DATA
	;Ejemplo de uso: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648008(v=vs.85).aspx#_win32_Updating_Resources
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------
;RECURSOS
;-------------------------------------------------------------------------------------------------------------------------------------------------
;recupera un HANDLE que puede ser utilizado por la función UpdateResource para agregar, eliminar o reemplazar los recursos en un módulo binario.
;Sintaxis: BeginUpdateResource( [archivo], [¿eliminar recursos existentes?] )
;Return: HANDLE
BeginUpdateResource(FileName, DeleteExistingResources := false) {
	return r:=DllCall("Kernel32.dll\BeginUpdateResourceW", "Ptr", &FileName, "Int", !!DeleteExistingResources, "Ptr"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648030(v=vs.85).aspx

;aplica o descarta los cambios hechos antes de una llamada a UpdateResource
;Sintaxis: EndUpdateResource( [HANDLE], [¿descartar cambios?] )
;Return: 0|1
EndUpdateResource(hModule, Discard := false) {
	return r:=DllCall("Kernel32.dll\EndUpdateResourceW", "Ptr", hModule, "Int", !!Discard, "Int"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648032(v=vs.85).aspx

;EndUpdateResource() + BeginUpdateResource()
;Sintaxis: ReUpdateResource( [HANDLE], [archivo], [¿descartar cambios?], [¿eliminar recursos existentes?] )
;Return: HANDLE
ReUpdateResource(ByRef hModule, FileName, Discard := false, DeleteExistingResources := false) {
	EndUpdateResource(hModule, Discard)
	return hModule := BeginUpdateResource(FileName, DeleteExistingResources)
}

;recupera un HANDLE que se puede utilizar para obtener un puntero al primer byte del recurso especificado en la memoria
;Sintaxis: LoadResource( [hModule], [hResInfo] )
;Return: hResLoad
LoadResource(hModule, hResInfo) {
	return DllCall("Kernel32.dll\LoadResource", "Ptr", hModule, "Ptr", hResInfo, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648046(v=vs.85).aspx

;recupera un puntero al recurso especificado en la memoria
;Sintaxis: LockResource( [hResLoad] )
;Return: Pointer / ResLock / data / info
LockResource(hResLoad) {
	return r:=DllCall("Kernel32.dll\LockResource", "Ptr", hResLoad, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648047(v=vs.85).aspx

;determina la ubicación del recurso con el tipo, nombre y lenguaje espesificado en el módulo especificado
;Sintaxis: FindResource( [hModule], [nombre del recurso], [tipo de recurso], [lenguaje ID] )
;Tipos de recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx
;Nombre del recurso: espesifica el nombre o un array [dllcall_type str/ptr, nombre].
;Return: hResInfo
FindResource(hModule, ResName, ResType, Language := "") {
	ResName := IsObject(ResName)?ResName:[(ResName+0)=""?"Str":"Ptr", ResName]
	, ResType := IsObject(ResType)?ResType:[(ResType+0)=""?"Str":"Ptr", ResType]
	if (Language="")
		r := DllCall("Kernel32.dll\FindResourceW", "Ptr", hModule, ResName[1], ResName[2], ResType[1], ResType[2], "Ptr")
	else r := DllCall("Kernel32.dll\FindResourceExW", "Ptr", hModule, ResName[1], ResName[2], ResType[1], ResType[2], "UInt", Language, "Ptr")
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648043(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx

;agrega, elimina o sustituye un recurso en un archivo ejecutable portable (PE)
;Sintaxis: UpdateResource( [HANDLE], [tipo de recurso], [nombre del recurso], [lenguaje ID], [&binarydata\file\str], [bytes|modo] )
;Tipos de recursos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspx
;Nombre del recurso: espesifica el nombre o un array [dllcall_type str/ptr, nombre]
;Modos:
	;File = añadir archivo. el 5to parámetro debe hacer referencia a un archivo existente o un array [archivo, codificación]
	;Str = añadir texto. el 5to parámetro debe contener el texto o un array [texto, codificación]
;Ejemplo 1: añadir texto en RC_DATA (10), usar un archivo válido.
	;Dll_CreateEmpty(File:=A_Desktop "\test_file.dll")
	;hFile := BeginUpdateResource(File), Text := "Texto a añadir"
	;MsgBox % UpdateResource(hFile, 10, ">My Resource Name<",, Text, "Str")
	;EndUpdateResource(hFile) ;terminar.
	;hResInfo := FindResource(hModule:=LoadLibrary(File, 0x2), ">My Resource Name<", 10) ;leer texto añadido -->
	;Data := LockResource(LoadResource(hModule, hResInfo))
	;MsgBox % StrGet(Data, SizeOfResource(hModule, hResInfo), "UTF-8")
	;FreeLibrary(hModule) ;<--
;Ejemplo 2: añadir archivo en RC_DATA (10), usar un archivo válido.
	;Dll_CreateEmpty(File:=A_Desktop "\test_file.dll")
	;hFile := BeginUpdateResource(File), File := ComSpec
	;MsgBox % UpdateResource(hFile, 10, ">CMD<",, File, "File")
	;EndUpdateResource(hFile)
;Return: 0|1
UpdateResource(hModule, ResType, ResName, Language := 0x0C00, Data := 0, Bytes := "*") {
	if !(Data=0) && (Bytes="*") && !(Bytes:=StrPut(Data)) ;calcular tamaño si se espesifico DATA pero no los bytes
		return false, ErrorLevel := true
	else if (Bytes="File") ;añadir archivo
		l := FileOpen(IsObject(Data)?Data[1]:Data, "r", Data[2]), l.RawRead(Bin, Bytes:=l.Length), l.Close(), Data := &Bin
	else if (Bytes="Str") ;añadir texto
		StrPutVar(IsObject(Data)?Data[1]:Data, Bin, Data[2]?Data[2]:"UTF-8", 1,, Bytes), Data := &Bin
	ResName := IsObject(ResName)?ResName:[(ResName+0)=""?"Str":"Ptr", ResName]
	, ResType := IsObject(ResType)?ResType:[(ResType+0)=""?"Str":"Ptr", ResType]
	, Bytes := IsObject(Bytes)?Bytes:[(Bytes+0)=""?"Ptr":"UInt", Bytes]
	, r:=DllCall("Kernel32.dll\UpdateResourceW", "Ptr", hModule, ResType[1], ResType[2], ResName[1], ResName[2], "UShort", Language, "Ptr", Data, Bytes[1], Bytes[2], "UInt")
	return r, VarSetCapacity(Data, 0), VarSetCapacity(Bin, 0), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648049(v=vs.85).aspx

;recupera el tamaño, en bytes, del recurso espesificado
;Sintaxis: SizeofResource( [hModule, hResInfo] )
;Return: Bytes
SizeofResource(hModule, hResInfo) {
	return r:=DllCall("Kernel32.dll\SizeofResource", "Ptr", hModule, "Ptr", hResInfo, "UInt"), ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648048(v=vs.85).aspx

CreateResourceIndexer(projectRoot, extensionDllPath) { ;WIN_10+
	r:=DllCall("Mrmsupport.dll\CreateResourceIndexer", "WStr", projectRoot, "WStr", extensionDllPath, "PtrP", resourceIndexer, "UInt")
	return resourceIndexer, ErrorLevel := r ;S_OK = 0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/mt219668(v=vs.85).aspx

DestroyResourceIndexer(resourceIndexer) { ;WIN_10+
	return true, DllCall("Mrmsupport.dll\DestroyResourceIndexer", "PtrP", resourceIndexer), ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/mt219670(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES QUE TRABAJAN CON LAS ANTERIORES
;-------------------------------------------------------------------------------------------------------------------------------------------------
;añadir icono, reemplaza si existe
;Sintaxis: InsertIconResource( [HANDLE], [icono], [ID], [lenguaje ID] )
InsertIconResource(hModule, Icon, ID, Language := 0x0C00) {
	if !(hFile:=FileOpen(Icon, "r"))
		return false, ErrorLevel := 2
	VarSetCapacity(Data, 8, 0), hFile.RawRead(Data, 6)
	if !(NumGet(Data, 0, "UShort")=0) || !(NumGet(Data, 2, "UShort")=1)
		return false, ErrorLevel := 3
	IGs := VarSetCapacity(IG, 6 + (Count:=NumGet(Data, 4, "UShort"))*14, 0)
	, NumPut(NumGet(Data, 0,"Int64"), IG, 0, "Int64"), IGe := &IG + 6
	Loop, % (Count) {
		thisID := (ID - 1) + A_Index, hFile.RawRead(IGe+0, 12), NumPut(thisID, IGe+12, 0, "UShort")
		, imgOffset := hFile.ReadUInt(), oldPos := hFile.Pos, hFile.Pos := imgOffset
		, ICDs := VarSetCapacity(ICD, NumGet(IGe+8, 0, "UInt")),  hFile.RawRead(ICD, ICDs)
		, hFile.Pos := oldPos, UpdateResource(hModule, 3, thisID, Language, &ICD, ICDs), IGe += 14
	} return thisID + 1, UpdateResource(hModule, 14, ID, Language, &IG, IGs)
} 

;obtener HANDLE de una imagen en el ejecutable espesificado
;Sintaxis: PictureFromResource( [archivo o hModule], [nombre], [tipo], [color de fondo, RGB o nombre] )
;Ejemplo: usar Ahk2Exe.exe, LOGO.PNG, ResType=10 (RC_DATA)
	;hBitmap := PictureFromResource(RegRead("HKLM\SOFTWARE\AutoHotKey", "InstallDir") "\Compiler\Ahk2Exe.exe", "LOGO.PNG")
	;Gui, Add, Text, x0 y0 w240 h78 +0xE hwndhPicCtrl
	;SendMessage, 0x172, 0, hBitmap,, ahk_id %hPicCtrl%
	;Gui, Show
	;return
PictureFromResource(Exe, ResName, ResType := 10, Background := 0xFFFFFFFF) {
	if (((hModule:=Exe)+0)="") && !(hModule:=LoadLibrary(Exe, 0x2))
		return false, ErrorLevel := true
	hResource := FindResource(hModule, ResName, ResType), Size := SizeofResource(hModule, hResource), hLoadRes := LoadResource(hModule, hResource)
	, hLockRes := LockResource(hLoadRes), hGlobal := GlobalAlloc(Size), hLockGlob := GlobalLock(hGlobal), CopyMemory(hLockGlob, hLockRes, Size)
	, GlobalUnlock(hGlobal), pStream := CreateStreamOnHGlobal(hGlobal), GdiplusStartup(hModule), pBitmap := GdipCreateBitmapFromStream(pStream)
	, hBitmap := GdipCreateHBITMAPFromBitmap(pBitmap, Background), GdipDisposeImage(pBitmap), ObjRelease(pStream), GlobalFree(hGlobal)
	return hBitmap, ErrorLevel := !hBitmap, GdiplusShutdown(, hModule)
}  

;-------------------------------------------------------------------------------------------------------------------------------------------------
;DLL
;-------------------------------------------------------------------------------------------------------------------------------------------------
;crear .DLL vacía
;Sintaxis: Dll_CreateEmpty( [nombre.dll] )
Dll_CreateEmpty(DllFile) {    
	SplitPath, DllFile,,, Ext
	TS := A_NowUTC, DllFile .= Ext="dll"?"":".dll"
	TS -= 1970, S
	VarSetCapacity(Trg, 1536, 0), Numput(TS, Trg, 192)
	Loop, Parse, % "0X5A4DY3CXB8YB8X4550YBCX2014CYCCX210E00E0YD0X7010BYD8X400YE4X1000YE8X1000YECX78A"
		. "E0000YF0X1000YF4X200YF8X10005YFCX10005Y100X4Y108X3000Y10CX200Y114X2Y118X40000Y11CX2000Y120X10"
		. "0000Y124X1000Y12CX10Y140X1000Y144X10Y158X2000Y15CX8Y1B0X7273722EY1B4X63Y1B8X10Y1BCX1000Y1C0X"
		. "200Y1C4X200Y1D4X40000040Y1D8X6C65722EY1DCX636FY1E0X8Y1E4X2000Y1E8X200Y1ECX400Y1FCX42000040", XY
		if Mod(A_Index, 2)
			O := "0x" A_LoopField
		else NumPut("0x" A_LoopField, Trg, O, "UInt")
	if !(hFile:=CreateFile(DllFile, 0x40000000, 2))
		return false, ErrorLevel := 2
	return DllCall("Kernel32.dll\WriteFile", "Ptr", hFile, "Ptr", &Trg, "UInt", 1536, "Ptr", 0, "Ptr", 0, "UInt"), CloseHandle(hFile)
}

;añadir «un icono o un conjunto de iconos en un directorio» a una libreria .DLL
;Sintaxis: Dll_InsertIcon( [DLL], [icono o directorio que contiene los iconos], [¿sobreescribir iconos?], [¿incluir iconos en subdirectorios?] )
Dll_InsertIcons(DllFile, Data, Overwrite := false, Recurse := false) {
	if (Overwrite)
		hModule := BeginUpdateResource(DllFile)
	if !(Count:=0) && !(Index:=0) && (IsFile(Data)) {
		Index++
		if !(Overwrite) {
			if (FindResource(hFile:=LoadLibrary(DllFile, 0x2), Index, 14)) {
				Loop
					Index++
				until !(FindResource(hFile, Index, 14))
			} FreeLibrary(hFile), hModule := BeginUpdateResource(DllFile)
		} InsertIconResource(hModule, Data, Index)
		return EndUpdateResource(hModule)
	} else if (IsDir(Data)) {
		Loop, Files, %Data%\*.ico, % Recurse?"FR":"F"
		{ if !(Overwrite) {
			Index++
			if (FindResource(hFile:=LoadLibrary(DllFile, 0x2), Index, 14)) {
				Loop
					Index++
				until !(FindResource(hFile, Index, 14))
			} FreeLibrary(hFile), ReUpdateResource(hModule, DllFile, Count:=0)
			} Count++, InsertIconResource(hModule, A_LoopFileFullPath, Overwrite?A_Index:Index)
			if (Count=40)
				ReUpdateResource(hModule, DllFile, Count:=0)
		} return EndUpdateResource(hModule)
	} return false, ErrorLevel := true
}








































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: FUENTES & COLORES & PINCEL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------
;COLORES
;Parámetros:
	;ARGB: color RGB con un valor adelante y despues de «0x» que indica el nivel de transparencia. donde 00 es transparente y FF es sólido.
;-------------------------------------------------------------------------------------------------------------------------------------------------
;dialogo para elegir color
;Sintaxis: ColorSelect( [ID ventana propietaria], [color], [¿mostrar todos los colores?] )
;Color: espesificar el color por defecto RGB o Nombre
;Notas: 
	;ErrorLevel es 1 si el usuario canceló el diálogo
	;la paleta de colores elegidos por el usuario se guarda en:  %A_AppData%\usercolorpalette.ini
;EJEMPLO: MsgBox % "Color: " ColorSelect(, "Red", true)
ColorSelect(hWnd := 0, Color := "", ShowAll := "") {
	static File := A_AppData "\usercolorpalette.ini"
	Color := _getcolor(Color, true), VarSetCapacity(CUSTOM, 16*A_PtrSize, 0)
	Loop, 16 ;obtener colores
		NumPut(IniRead(File, "Color", A_Index, false), CUSTOM, (A_Index-1)*4, "UInt")
	lStructSize := VarSetCapacity(CHOOSECOLOR, 9*A_PtrSize, 0)
	, NumPut(lStructSize, CHOOSECOLOR, 0, "UInt"), NumPut(hWnd, CHOOSECOLOR, A_PtrSize, "Ptr")
	, NumPut(Color=""?IniRead(File, "Default", "Color", false):Color, CHOOSECOLOR, 3*A_PtrSize, "Ptr")
	, NumPut(&CUSTOM, CHOOSECOLOR, 4*A_PtrSize, "PtrP")
	, NumPut(0x1|0x100|(ShowAll=0?0x4:ShowAll?0x2:0x0), CHOOSECOLOR, 5*A_PtrSize, "UInt")
	, r := DllCall("comdlg32.dll\ChooseColorW", "UPtr", &CHOOSECOLOR, "UInt")
	Loop, 16 ;guardar colores
		IniWrite(NumGet(custom, (A_Index-1)*4, "UInt"), File, "Color", A_Index)
	return RGB(Color:=NumGet(CHOOSECOLOR, 3*A_PtrSize, "UInt")), l:=r?IniWrite(Color, File, "Default", "Color"):l, ErrorLevel := !r
}

;obtiene el color RGB mediante el nombre
;Sintaxis: _getcolor( [color], [modo], [Transparent] )
;Parámetros:
	;Color: nombre o valor
	;Modo: convertir salida. BGR, ARGB.
	;Transparent: espesificar la transparencia. solo válido para ARGB. ver RGBToARGB().
;Nota: si el color no se encuentra, no lo modifica
_getcolor(RGB, Mode := false, Transparent := -1) {
	static Colors := {Aqua: "0x00FFFF", Black: "0x000000", Blue: "0x0000FF", Fuchsia: "0xFF00FF", Gray: "0x808080" ;nombres soportados
		, Green: "0x008000", Lime: "0x00FF00", Maroon: "0x800000", Navy: "0x000080", Olive: "0x808000", Purple: "0x800080"
		, Red: "0xFF0000", Silver: "0xC0C0C0", Teal: "0x008080", White: "0xFFFFFF", Yellow: "0xFFFF00"}
	Color := (Colors[RGB]="")?Hex(RGB, 6, true):Colors[RGB]
	if (Mode=true) || (Mode="BGR")
		return RGBToBGR(Color)
	if (Mode="ARGB")
		return RGBToARGB(Color, Transparent)
	return Color
}

;genera un color RGB aleatorio
;Ejemplo:
	;Gui, Add, Pic, HWNDh w50 h300 gChange
	;Gui, Show
	;SetTimer, Change, 250
	;return
	;GuiClose:
	;ExitApp
	;Change:
	;SetControlColor(h, _randcolor())
	;return
_randcolor() {
	return Hex((Random(0, 255)<<16) + (Random(0, 255)<<8) + Random(0, 255), 6, true)
}

;convertir a RGB | extraer rojo, verde, azul
;Sintaxis: RGB( [color], [rojo (salida)], [verde (salida)], [azul (salida)] )
;Ejemplos:
	;MsgBox % RGB(8454016)
	;MsgBox % "R: " RGB(0x80FF80,, G, B) ", G: " G ", B: " B
	;MsgBox % "R: " RGB("#DECAFE",, G, B) ", G: " G ", B: " B
RGB(Color := "", ByRef R := "", ByRef G := "", ByRef B := "") {
	if (Color="") {
		DllCall("msvcrt.dll\sprintf", "Str", V:="000000", "Str", "#%06X", "UInt", (R<<16)+(G<<8)+B)
		return V
	} if (IsByRef(R)) || (IsByRef(G)) || (IsByRef(B)) {
		if (InStr(Color, "#")) {
			NumPut("0x" SubStr(Color, -5), V:="000000")
			return R := NumGet(V,2,"UChar"), G := NumGet(V,1,"UChar"), B := NumGet(V,0,"UChar")
		} Color := Hex(Color, 6)
		return R := (Color & 0xFF), G := ((Color & 0xFF00) >> 8), B := ((Color & 0xFF0000) >> 16)
	} Color := (Color & 255) << 16 | (Color & 65280) | (Color >> 16), Color := SubStr(Color, 1)
	return Hex(Color, 6, true)
} ;R := ((Color & 0xFF0000) >> 16), G := ((Color & 0xFF00) >> 8), B := (Color & 0xFF)

;convertir RGB a BGR
RGBToBGR(RGB) {
 	return Hex(((RGB & 255) << 16) | (((RGB >> 8) & 255) << 8) | (RGB >> 16), 6, true)
}   

;convertir RGB a ARGB.
;Sintaxis: RGBToARGB( [RGB], [0~255] )
;Return: ARGB con el prefijo 0x
;Notas:
	;si se espesifica un color RGB, la transparencia por defecto es 0xFF (255).
	;si espesifica un color ARGB, la transparencia por defecto es la misma (no la modifica).
	;el prefijo 0x no tiene importancia, puede espesificar un entero, en el color y en la transparencia.
	;el valor de la transparencia va de 0 (0x00) a 255 (0xFF), donde 0 en transparente total y 255 un color sólido.
;Ejemplo:
	;MsgBox % RGBToARGB("0x8000FF") "," RGBToARGB("8000FF")
	;	. "`n" RGBToARGB("0xFF8000FF") "," RGBToARGB("FF8000FF")
	;	. "`n`n" RGBToARGB("0x8000FF", 0) "," RGBToARGB("8000FF", 0)
	;	. "`n" RGBToARGB("0xFF8000FF", 0) "," RGBToARGB("FF8000FF", 0)
RGBToARGB(RGB, Transparent := -1) { ;ARGB (A=alpha channel, transparency). FF=color solido. 00=Transparente.
	RGB := SubStr(RGB:=Hex(RGB, 6), 1, 2)="0x"?SubStr(RGB, 3):RGB, Transparent := Transparent=0?"00":Transparent
	return "0x" CharUpper(StrLen(RGB)=8?(Transparent=-1?RGB:Hex(Transparent, 2,, "") SubStr(RGB, 3))
	: ((Transparent=-1?"FF":Hex(Transparent, 2,, "")) Hex("0x" RGB, 6,, "")))
}

;convertir ARGB a RGB.
;Sintaxis: ARGBToRGB( [ARGB] )
;Return: RGB con el prefijo 0x
;Notas:
	;si se espesifica un color RGB, no lo modifica.
	;si espesifica un color ARGB, se quita la transparencia.
	;el prefijo 0x no tiene importancia, puede espesificar un número entero.
;Ejemplo:
	;MsgBox % ARGBToRGB("0x8000FF") "," ARGBToRGB("8000FF")
	;	. "`n" ARGBToRGB("0xFF8000FF") "," ARGBToRGB("FF8000FF")
ARGBToRGB(ARGB) {
	return Hex(SubStr(SubStr(ARGB:=Hex(ARGB, 8), 1, 2)="0x"?SubStr(ARGB, 3):ARGB, -5), 6, true)
}

;-------------------------------------------------------------------------------------------------------------------------------------------------
;FUENTES
;Parámetros:
	;hFont: espesificar un identificador a una fuente, puede usar FontCreate(). dejar en cero para usar la fuente po defecto.
	;FontName: nombre de la fuente.
	;lfCharSet: script, valor que identifica al conjunto de carácteres
;-------------------------------------------------------------------------------------------------------------------------------------------------
;enumera todas las fuentes instaladas.
;Sintaxis: FontEnum( [lfCharSet], [FontName] )
;Ejemplo:
	;for k, v in FontEnum()
	;	MsgBox % v
;Nota: para comprobar si una fuente existe, usar los parámetros lfCharSet y FontName, si no se encuentra, devuelve una cadena vacía.
FontEnum(lfCharSet := 1, FontName := "") {
	hDC := GetDC(), VarSetCapacity(LOGFONT, 92, 0), NumPut(lfCharSet, LOGFONT, 23, "UChar")
	if !(FontName="")
		StrPut(FontName, &LOGFONT + 28)
	Address := RegisterCallback("EnumFontFamExProc", "Fast", 4), Data := {List: []}
	, DllCall("Gdi32.dll\EnumFontFamiliesExW", "Ptr", hDC, "Ptr", &LOGFONT, "Ptr", Address, "Ptr", &Data, "UInt", 0)
	return Data.List, ReleaseDC(0, hDC), GlobalFree(Address)
} EnumFontFamExProc(LOGFONT, lpntme, FontType, Data) {
	Data := Object(Data), FontName := StrGet(LOGFONT + 28)
	if !InArray(Data.List, FontName) ;remover fuentes duplicadas
		Data.List.Push(FontName)
	return true
} ;https://msdn.microsoft.com/en-us/library/dd162620(v=vs.85).aspx

;crea una fuente con las caracteristicas espesificadas.
;Sintaxis: FontCreate( [fuente], [tamaño], [negrita], [¿cursiva?], [¿subrayado?], [¿tachado?], [Calidad] )
;Fuente: dejar vacio para usar la fuente por defecto
;Tamaño: dejar en 0 para usar el tamaño por defecto
;Negrita: 0 | 100 | 200 | 300 | 400 (normal) | 500 | 600 | 700 (negrita) | 800 | 900
;Calidad: 
	;DEFAULT_QUALITY = 0 | DRAFT_QUALITY = 1 | PROOF_QUALITY = 2
	;NONANTIALIASED_QUALITY = 3 | ANTIALIASED_QUALITY = 4 | CLEARTYPE_QUALITY = 5
;NOTA: cuando ya no use la fuente, eliminarla con DeleteObject()
;Return: hFont
FontCreate(FontName := "", Size := 0, Bold := 400, Italic := false, Underline := false, StrikeOut := false, Quality := 5) {
	Error := ErrorLevel, FontName := FontName?FontName:FontQuery()[1], Size := Size>0?Size:FontQuery()[2]
	return DllCall("Gdi32.dll\CreateFontW", "Int", -MulDiv(Size, GetDeviceCaps(, 90), 72)
		, "Int", 0, "Int", 0, "Int", 0, "Int", Bold,"UInt", !!Italic, "UInt", !!Underline, "UInt", !!StrikeOut
		, "UInt", 1, "UInt", 4, "UInt", 0, "UInt", Quality, "UInt", 0, "Ptr", &FontName), ErrorLevel := Error
} FontDelete(hFont*) { ;usar DeleteObject() en vez de FontDelete().
	return DeleteObject(hFont*)
} ;https://msdn.microsoft.com/en-us/library/dd183499(v=vs.85).aspx

;obtiene información sobre una fuente (hFont)
;Sintaxis: FontQuery( [hFont], [nombre (out)], [tamaño (out)], [negrita (out)], [cursiva (out)], [subrayado (out)], [tachado (out)] )
FontQuery(hFont := 0, ByRef Name := "", ByRef Size := "", ByRef Bold := "", ByRef Italic := "", ByRef Underline := "", ByRef Strike := "") {
	hFont := hFont?hFont:GetStockObject(17), hDC := GetDC(), hSelectObj := SelectObject(hDC, hFont)
	, Size := DllCall("Gdi32.dll\GetTextFace", "Ptr", hDC, "Ptr", 0, "Ptr", 0), VarSetCapacity(Name, (Size>0?Size:(Size:=32)) * 2, 0)
	, DllCall("Gdi32.dll\GetTextFace", "Ptr", hDC, "Ptr", Size, "Str", Name), LogPixelsY := GetDeviceCaps(hDC, 90)
	, VarSetCapacity(TEXTMETRIC, 60, 0), DllCall("Gdi32.dll\GetTextMetricsW", "Ptr", hDC, "Ptr", &TEXTMETRIC)
	, Size := Round((NumGet(TEXTMETRIC, 0, "Int")-NumGet(TEXTMETRIC, 12, "Int"))*72/LogPixelsY)
	, Bold := NumGet(TEXTMETRIC, 28, "Int"), Italic := !!NumGet(TEXTMETRIC, 52, "UChar")
	, Underline := !!NumGet(TEXTMETRIC, 53, "UChar"), Strike := !!NumGet(TEXTMETRIC, 54, "UChar")
	return [Name, Size, Bold, Italic, Underline, Strike], VarSetCapacity(FontName, -1), SelectObject(hDC, hSelectObj), ReleaseDC(0, hDC)
}

;dialogo para seleccionar fuente
;Sintaxis: FontSelect( [hWnd], [fuente], [opciones], [efectos 0|1], [opciones adicionales] )
;Parámetros:
	;hWnd: ventana propietaria
	;Opciones: array que contiene las opciones por defecto a mostrar, en el siguiente orden:
		;Color del texto = RGB o nombre
		;Tamaño, Tamaño Minimo, Tamaño Máximo = separados por coma, tamaño por defecto y Minimo/Máximo permitidos.
		;Negrita = 700 es negrita, 400 es normal.
		;Cursiva = 0|1
		;Subrayado = 0|1
		;Tachado = 0|1
		;lfCharSet
	;Opciones Adicionales: sumar para combinar
		;0x00000200 = mostrar boton Aplicar
		;0x00000004 = mostrar boton Ayuda
		;0x00040000 = mostrar solo fuentes TrueType
		;0x02000000 = mostrar fuentes ocultas
		;0x00000100 (defecto) = habilita el subrayado, tachado y seleccion de color
		;0x00010000 (defecto) = la fuente debe existir
;Return: devuelve un Array con la informacion, en el mismo orden del 3er parametro (opciones). Array[0] contiene la fuente seleccionada
;ErrorLevel: 0|1. 1 si el usuario canceló el dialogo.
;EJEMPLO:
	;FontInfo := FontSelect(, "Arial", ["Lime", "12,10,20", 700, true, true, true])
	;MsgBox %  "Fuente: " FontInfo[0]
	;	. "`nColor: " FontInfo[1]
	;	. "`nTamaño: " FontInfo[2] "`nNegrita: " FontInfo[3] "`nCursiva: " FontInfo[4]
	;	. "`nSubrayado: " FontInfo[5] "`nTachado: " FontInfo[6] "`n`nErrorLevel: " ErrorLevel
FontSelect(hWnd := 0, FontName := "", Options := "", Flags := 0x10100) {
	FontName := FontName?Trim(FontName):FontQuery()[1]
	, Color := _getcolor(Options[1], true)
	, Size := StrSplit(Options[2], ",", A_Space A_Tab)
	, MinSize := Size[2], MaxSize := Size[3]
	, Size := Size[1]=""?FontQuery()[2]:Size[1]
	, Bold := Between(Options[3], 0, 900)?Options[3]:400
	, Italic := !!Options[4], Underline := !!Options[5], StrikeOut := !!Options[6]
	, hDC := CreateDC(), LogPixelsY := GetDeviceCaps(hDC, 90), DeleteDC(hDC)
	, Flags := 0x00000041|Flags|(MinSize!=""&&MaxSize!=""?0x00002000:0x00000000) ;0x00000008
    VarSetCapacity(LOGFONT, 92, 0) , NumPut(-MulDiv(Size, LogPixelsY, 72), LOGFONT, 0, "Int")
    , NumPut(Bold, LOGFONT, 16, "Int"), NumPut(Italic, LOGFONT, 20, "UChar")
    , NumPut(Underline, LOGFONT, 21, "UChar"), NumPut(StrikeOut, LOGFONT, 22, "UChar")
	, NumPut(Options.7?Options.7:0, LOGFONT, 23, "UChar")
	, StrPut(FontName, &LOGFONT + 28, StrLen(FontName)+1)
	, CFSize := VarSetCapacity(CHOOSEFONT, A_PtrSize=8?104:60, 0)
	, NumPut(CFSize, CHOOSEFONT, 0, "UInt"), NumPut(hWnd, CHOOSEFONT, A_PtrSize, "Ptr")
	, NumPut(&LOGFONT, CHOOSEFONT, A_PtrSize=8?24:12, "Ptr")
	, NumPut(Flags, CHOOSEFONT, A_PtrSize=8?36:20, "UInt")
	, NumPut(Color, CHOOSEFONT, A_PtrSize=8?40:24, "UInt")
	, NumPut(MinSize, CHOOSEFONT, A_PtrSize=8?92:52, "Int")
	, NumPut(MaxSize, CHOOSEFONT, A_PtrSize=8?96:56, "Int")
	, Ok := DllCall("comdlg32.dll\ChooseFontW", "Ptr", &CHOOSEFONT, "Int")
	, OutPutVar := [], OutPutVar[0] := StrGet(&LOGFONT + 28)
	, OutPutVar[1] := RGB(NumGet(CHOOSEFONT, A_PtrSize=8?40:24, "UInt"))
	, OutPutVar[2] := NumGet(CHOOSEFONT, A_PtrSize=8?32:16, "Int")//10
	, OutPutVar[3] := NumGet(LOGFONT, 16, "Int"), OutPutVar[4] := NumGet(LOGFONT, 20, "UChar")
	, OutPutVar[5] := NumGet(LOGFONT,21,"UChar"), OutPutVar[6] := NumGet(LOGFONT, 22, "UChar")
	, OutPutVar[7] := NumGet(LOGFONT, 23, "UChar")
	return OutPutVar, ErrorLevel := !Ok
}

;calcular el alto y ancho del texto en la fuente espesificada.
;Sintaxis: GetFontTextDimension( [hFont], [texto], [ancho (out)], [alto (out)] )
;Return: 0|1
GetFontTextDimension(hFont, Text, ByRef Width := "", ByRef Height := "", c := 1) {
	hFont := hFont?hFont:GetStockObject(17), hDC := GetDC()
	, hSelectObj := SelectObject(hDC, hFont), VarSetCapacity(SIZE, 8, 0)
	if !DllCall("Gdi32.dll\GetTextExtentPoint32W", "Ptr", hDC, "Ptr", &Text, "Int", StrLen(Text), "Ptr", &SIZE, "Int")
		return false, ReleaseDC(0, hDC), Width := Height := 0
	VarSetCapacity(TEXTMETRIC, 60, 0)
	if !DllCall("Gdi32.dll\GetTextMetricsW", "Ptr", hDC, "Ptr", &TEXTMETRIC, "Int") ;https://msdn.microsoft.com/en-us/library/dd144941(v=vs.85).aspx
		return false, ReleaseDC(0, hDC), Width := Height := 0
	SelectObject(hDC, hSelectObj), ReleaseDC(0, hDC), Width := NumGet(SIZE, 0, "Int"), Height := NumGet(SIZE, 4, "Int")
	, Width := Width + NumGet(TEXTMETRIC, 20, "Int") * 3
	, Height := Floor((NumGet(TEXTMETRIC, 0, "Int")*c)+(NumGet(TEXTMETRIC,16, "Int")*(Floor(c+0.5)-1))+0.5)+8
	return true
} ;https://msdn.microsoft.com/en-us/library/dd144938(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------
;PINCEL (BRUSH FUNCTIONS)
;Parámetros:
	;Color: espesificar un nombre o color RGB.
;Link: https://msdn.microsoft.com/en-us/library/dd183395(v=vs.85).aspx
;-------------------------------------------------------------------------------------------------------------------------------------------------
;crea un pincel lógico que tiene el color sólido especificado.
;Sintaxis: CreateSolidBrush( [color] )
CreateSolidBrush(RGB) {
	return DllCall("Gdi32.dll\CreateSolidBrush", "UInt", _getcolor(RGB, true), "UPtr")
} ;https://msdn.microsoft.com/en-us/library/dd183518(v=vs.85).aspx

;obtiene un HADLE a un pincel lógico que tiene el color asociado al indice espesificado.
;Index: https://msdn.microsoft.com/en-us/library/ms724371(v=vs.85).aspx
GetSysColorBrush(Index) {
	return DllCall("User32.dll\GetSysColorBrush", "Int", Index, "UPtr")
} ;https://msdn.microsoft.com/en-us/library/dd144927(v=vs.85).aspx






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SERVICIOS DE ESCRITORIO REMOTO ::::::::::::::::::::::::::::::::::
;Parámetros:
	;hServer: HANDLE al Servidor Host de sesión, por devecto usa el actual.
	;SessionID: identificador de la sesión de usuario, por defecto usa todas las sesiones.
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa383464(v=vs.85).aspx
;#############################################################################################################################################
;recupera información sobre los procesos activos en el servidor de escritorio remoto de sesión o servidor de escritorio virtual de sesión.
;Sintaxis: WTSEnumerateProcesses( [hServer], [SessionID] )
;Nota: la persona que llama debe ser miembro del grupo Administradores para enumerar los procesos que se ejecutan en otra sesión de usuario.
/*WTSEnumerateProcesses(hServer := 0, SessionID := 0xFFFFFFFE) {  :::::::::: COMENTADO DEVIDO A PROBLEMAS CON StrGet EN WIN_10
	if !DllCall("Wtsapi32.dll\WTSEnumerateProcessesExW", "Ptr", hServer, "UIntP", 1, "UInt", SessionID, "PtrP", WTS_PROCESS_INFO_EX, "UIntP", Count, "Int")
		return false
	Loop, % (Count) {
		n := NumGet(WTS_PROCESS_INFO_EX, 4, "UInt")
		MsgBox % StrGet(n) ;? AHK CRASH
	}
}

WTSEnumerateSessionsEx(hServer := 0, SessionID := 0xFFFFFFFE) {
	if !DllCall("Wtsapi32.dll\WTSEnumerateSessionsExW", "Ptr", hServer, "UIntP", 1, "UInt", 0, "PtrP", PWTS_SESSION_INFO_1, "UIntP", Count, "Int")
		return false
	Loop, % (Count) {
	
		MsgBox % StrGet(NumGet(PWTS_SESSION_INFO_1, 12, "UInt")) ;? AHK CRASH
		
	}
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ee621014(v=vs.85).aspx

WTSEnumerateProcesses()
ExitApp
*/


































































;#############################################################################################################################################
; :::::::::::::::::::::::::::::::::::::::::::::PROGRAMAS DE INICIO AUTOMÁTICO ::::::::::::::::::::::::::::::::::
;Parámetros:
	;Type: Reg = agregar entrada en el registro
	;User: ALL = todos los usuarios
	;Mode: 1 = ejecutar solo una vez en el próximo inicio
;#############################################################################################################################################
;enumera todos los programas de inicio automático
;Return: Array( {Command, Item, hKey, Key, Filename, Type, Backup, Disabled, Info} )
	;Command = ruta al programa y parámetros
	;Item = nombre
	;hKey = clave / [unidad:]
	;Key = subclave / [directorio]
	;Info = información adicional del archivo. ver GetFileVersionInfo.
	;Filename = archivo, sin parámetros, si existe. 
	;Backup = copia de seguridad del acceso directo 
	;----------------------------------------------------------------------------------------------------
	;Type = identifica el tipo de inicio, puede ser Startup, o Reg.
	;Disabled = 1 si el programa está deshabilitado.
	;User = Current | ALL
;Ejemplo:
	;for k, v in EnumerateStartupApps()
		;MsgBox % "Clave: " v.hKey "\" v.Key "`nNombre: " v.Item "`nParámetros: " v.Command "`nArchivo: " v.Filename
			;. "`nDeshabilitado: " v.Disabled "`nDescripción: " v.Info.FileDescription "`nTipo: " v.Type "`nUsuario: " v.User
EnumerateStartupApps() {
	List := []
	Loop, Reg, HKLM\Software\Microsoft\Shared Tools\MSConfig\StartupReg, K ;buscar programas deshabilitados del registro
	{ 	Info := {}, Info.Disabled := true, Info.Type := "Reg"
		Loop, Parse, % "Command|Item|hKey|Key", |
			Info[A_LoopField] := RegRead(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, A_LoopField)
		Info.Info := GetFileVersionInfo(Info.Filename:=GetValidPathName(Info.Command)), Info.User := Info.hKey="HKLM"?"ALL":"Current"
		List.Push(Info)
	} for k, v in ["Policies\Explorer\Run", "RunServicesOnce", "RunServices", "RunOnceEx", "RunOnce\Setup", "RunOnce", "RunEx", "Run"] { ;buscar programas de inicio automático en el registro
		Loop, Parse, % "HKCU|HKLM", |
		{	Loop, Reg, %A_LoopField%\Software\Microsoft\Windows\CurrentVersion\%v%, V
			{	Info := {}, Info.Type := "Reg", Info.Disabled := false
				, Info.Command := RegRead(A_LoopRegKey "\" A_LoopRegSubkey, A_LoopRegName)
				, Info.Info := GetFileVersionInfo(Info.Filename:=GetValidPathName(Info.Command))
				, SplitPath(Info.Filename, Filename), Info.Item := Filename, Info.hKey := A_LoopRegKey
				, Info.Key := A_LoopRegSubkey "\" A_LoopRegName, List.Push(Info)
	}	}	} Loop, Reg, HKLM\Software\Microsoft\Shared Tools\MSConfig\StartupFolder, K ;buscar programas deshabilitados de la carpeta inicio
	{ 	Info := {}, Info.Disabled := true, Info.Type := "Startup"
		, Info.Backup := RegRead(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, "Backup")
		, Info.Item := RegRead(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, "Item")
		, Info.Command := RegRead(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, "Command")
		, SplitKey(RegRead(A_LoopRegKey "\" A_LoopRegSubkey "\" A_LoopRegName, "Path"), hKey, Key)
		, Info.hKey := hKey, Info.Key := Key, Info.User := Info.hKey="HKLM"?"ALL":"Current"
		, Info.Info := GetFileVersionInfo(Info.Filename:=GetValidPathName(Info.Command))
		List.Push(Info)
	} Loop, Files, %A_Startup%\*.*, F ;buscar programas de inicio automático en la carpeta inicio
	{	SplitPath, A_LoopFileFullPath, Filename, Dir, Ext, Name, Drive
		if (Ext="lnk")
			FileGetShortcut, %A_LoopFileFullPath%, Target, Directory, Args, Desc, Icon, IconN, RunState
		else if (Ext="exe")
			Target := A_LoopFileFullPath
		else continue
		Info := {}, Info.hKey := SubStr(Drive, 1, 2), Info.Key := SubStr(Dir, 4), Info.Item := Filename, Info.Command := Target
		, Info.Info := GetFileVersionInfo(Info.Filename:=GetValidPathName(Info.Command)), Info.RunState := RunState
		, Info.Directory := Directory, Info.Args := Args, Info.Description := Desc, Info.Icon := [Icon, IconN]
		, Info.Disabled := false, Info.Type := "Startup", Info.User := "Current", List.Push(Info)
	} return List
}

;añadir programa al inicio automático
;Sintaxis: AddStartupApp( [ruta], [type], [user], [mode] )
;Nota: usar comillas para pasar argumentos. "c:\ruta\file.ext" /f
AddStartupApp(Filename, Type := "Startup", User := "Current", Mode := 0) {
	if (Mode=1) || (Type="Reg") {
		SplitPath, Filename,,,, Name
		Key := (User="ALL"?"HKLM":"HKCU") "\Software\Microsoft\Windows\CurrentVersion\" (Mode?"RunOnce":"Run"), l := Name
		Loop {
			if !RegExistValue(Key, Name)
				break
			Name := l A_Index
		} return RegWrite(, Key, Name, Filename)
	} if InStr(Filename, Chr(34))
		Filename := SubStr(Filename, InStr(Filename, Chr(34))+1)
		, Args := Trim(SubStr(Filename, InStr(Filename, Chr(34))+1))
		, Filename := SubStr(Filename, 1, InStr(Filename, Chr(34))-1)
	SplitPath, Filename,, WorkingDir,, Name
	l := Name
	Loop {
		if !FileExist(A_Startup "\" Name ".lnk")
			break
		Name := l A_Index
	} return CreateShortcut(Filename, A_Startup "\" Name ".lnk", WorkingDir, Args, GetFileVersionInfo(Filename).FileDescription)
}





































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: STRING (CADENA DE CARÁCTERES) ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;obtiene una cadena localizada (Localized String).
;Sintaxis: ReadLocalizedString( [DllName], [StrID], [Bytes] )
;Parámetros:
	;DllName: espesificar la ruta al archivo .DLL.
	;StrID: espesificar el ID de la cadena a obtener.
	;Bytes: espesificar los Bytes máximos para la cadena
;Notas:
	;una Cadena Localizada tiene el siguiente formato: "@[path\]dllname,-strID".
	;también puede espesificar "@[path\]dllname,-strID" en DllName y dejar StrID en 0.
	;las cadenas localizadas se pueden encontrar en valores en el registro.
;Ejemplo: MsgBox % ReadLocalizedString("mswsock.dll", 60100)  "`n`n`n" ReadLocalizedString("@%SystemRoot%\System32\mswsock.dll,-60100") 
;Return: STRING
;ErrorLevel: 0|1
ReadLocalizedString(DllName, StrID := 0, Bytes := 512) {
	if !(StrID) {
		DllName := LTrim(Trim(DllName), "@")
		, StrID := SubStr(DllName, InStr(DllName, ",")+1)
		, DllName := StrReplace(SubStr(DllName, 1, InStr(DllName, ",")-1), "%SystemRoot%", A_WinDir)
	} hModule := LoadLibrary(DllName, 0x00000002)
	return LoadString(hModule, StrID, Bytes), FreeLibrary(hModule)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647486.aspx

;carga un recurso de cadena desde el archivo ejecutable asociado con un módulo especificado.
;Sintaxis: LoadString( [hModule], [ID], [Bytes] )
;Parámetros:
	;hModule: usar LoadLibrary()
	;ID: espesificar el id donde está localizada la cadena a obtener.
	;Bytes: espesificar los Bytes máximos para la cadena
;Return: STRING
;ErrorLevel: 0|1
LoadString(hModule, uID, Bytes := 512) {
	VarSetCapacity(OutputVar, Bytes * 2, 0)
	, Ok := DllCall("User32.dll\LoadStringW", "Ptr", hModule, "UInt", Abs(uID), "Str", OutputVar, "Int", Bytes, "Int")
	return OutputVar, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647486.aspx

;convertir String a CLSID
;Sintaxis: CLSIDFromString( [CLSID], [oCLSID] )
;Parámetros:
	;CLSID: {x8-x4-x4-x4-x12}
	;oCLSID: CLSID salida.
;Return:
	;si espesifica una variable de salida en el 2do parámetro, devuelve 0|1.
	;si no espesificar el 2do parámetro, devuelve &CLSID.
;Ejemplo: MsgBox % StringFromCLSID(CLSIDFromString("{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"))
CLSIDFromString(Str, ByRef CLSID := "") {
	VarSetCapacity(CLSID, 0), VarSetCapacity(CLSID, 16, 0)
	, Ok := DllCall("Ole32.dll\CLSIDFromString", "WStr", Str, "Ptr", &CLSID, "UInt") = 0
	return IsByRef(CLSID)?Ok:&CLSID
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680589(v=vs.85).aspx

;convertir CLSID a String
;Sintaxis: StringFromCLSID( [&CLSID] )
StringFromCLSID(CLSID) {
	DllCall("Ole32.dll\StringFromCLSID", "Ptr", CLSID, "PtrP", OutputVar)
	return StrGet(OutputVar, "UTF-16"), CoTaskMemFree(OutputVar)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683917(v=vs.85).aspx

;copia un determinado número de caracteres de una cadena de origen en un búfer.
;Sintaxis: StrCopy( [destino (out)], [origen], [tamaño], [destino str/ptr] )
;Nota: usar StrPut() y StrGet().
	;StrPut(Source, &Dest + 0)
	;Dest := StrGet(&Source + 0)
StrCopy(ByRef Dest, Source, Length := 0, Type := "Ptr") {
	if !(Length)
		Length := (Type="Ptr"?StrLen(Source):DllCall("Kernel32.dll\lstrlenW", "UInt", Source))+1
	if (Type="Str")
		VarSetCapacity(Dest, 0), VarSetCapacity(Dest, Length * 2, 0)
	return DllCall("Kernel32.dll\lstrcpynW", Type, Dest, Type="Ptr"?"Str":"Ptr"
	, Source, "Int", Length?Length:DllCall("Kernel32.dll\lstrlenW", "Ptr", Source)+1)
}

;obtiene opciones representadas por carácter(es) y separadas por espacios.
;Sintaxis: SplitFlags( [texto], [opciones], [carácteres*] )
;Opciones: \d = incluir números | \w incluir letras | [\Q carácteres \E]
	;por defecto obtiene: números, letras, puntos, +, -, ^, ~, comas
;NOTAS: 
	;devuelve un Array con las opciones en el mismo orden en que se espesificó;
	;si se espsificó solo 1, devuelve directamente el texto recuperado
	;si no se espesifico nada en el 3er parametro, lo obtiene del 2do
;EJEMPLOS:
	;MsgBox % SplitFlags("c100 x350", "x") "`n" SplitFlags("c100 x350",, "c1")
	;MsgBox % (i:=SplitFlags("c1,00 x35.0002 f+150",, "c", "x", "f")) i[1] "`n" i[2] "`n" i[3]
SplitFlags(String, Options := "\d\Q,.+-^~\E\w", Chars*) {
	Flags := []
	if !(Chars.MaxIndex())
		Chars := [Options], Options := "\d\Q,.+-^~\E\w"
	Loop, % Chars.MaxIndex()
		RegExMatch(String, "i)\Q" Chars[A_Index] "\E\K[" Options "]+", Flag), Flags[A_Index] := Flag
	return Chars.MaxIndex()>1?Flags:Flags[1]
}

;calcula el tamaño de almacenamiento necesario para una cadena en una codificación espesífica, luego codificar y escribir la cadena en el buffer
;Sintaxis: StrPutVar( [string], [OutputVar], [codificación], [restar al tamaño], [sumar al tamaño], [carácteres (out)] )
;Return: devuelve el tamaño, en bytes
StrPutVar(Str, ByRef OutputVar := "", Encoding := "UTF-16", Min := 0, Max := 0, ByRef Length := "") {
	VarSetCapacity(OutputVar, 0), VarSetCapacity(OutputVar, Length:=((StrPut(Str, Encoding)
	* ((Encoding="UTF-16"||Encoding="CP1200")?2:1))-Min)+Max), Bytes := StrPut(Str, &OutputVar, Encoding)
	return IsByRef(OutputVar)?Bytes:OutputVar
}

StrNormalize(Char) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd319093%28v=vs.85%29.aspx
    Size := DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", Char, "Int", Len := StrLen(Char), "Ptr", 0, "Int", 0)
    Loop {
        VarSetCapacity(OutputVar, Size * 2)
		if ((Size:=DllCall("Normaliz.dll\NormalizeString", "Int", 2, "WStr", Char, "Int", Len, "Ptr", &OutputVar, "Int", Size)) >= 0)
			break
        if (A_LastError != 122)
            return
        Size *= -1
    } return RegExReplace(StrGet(&OutputVar, Size, "UTF-16"), "\pM")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd319093(v=vs.85).aspx

;quitar caracteres de izquierda a derecha
;Sintaxis : StrTrimLeft( [Var], [Limite] )
StrTrimLeft(String, Length := 1) {
	return SubStr(String, Length+1)
}

;quitar caracteres de derecha a izquierda
;Sintaxis : StrTrimRight( [Var], [Limite] )
StrTrimRight(String, Length := 1) {
	return SubStr(String, 1, -Length)
}

;obtener caracteres de izquierda a derecha
;Sintaxis : StrLeft( [Var], [Limite] )
StrLeft(String, Length := 1) {
	return SubStr(String, 1, Length)
}

;obtener caracteres de derecha a izquierda
;Sintaxis : StrRight( [Var], [Limite] )
StrRight(String, Length := 1) {
	return SubStr(String, -(Length-1))
}

;If [str_var] in [str]
;comprueba si el contenido de la variable coincide exactamente con los elementos espesificados
;Sintaxis: InVar( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
InVar(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := false) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (!(CaseSensitive) && (Haystack=A_LoopField)) || ((CaseSensitive) && (Haystack==A_LoopField))
			return true
	return false
}

;If [str_var] contains [str]
;comprueba si el contenido de la variable coincide exactamente o parcialmente con los elementos espesificados
;Sintaxis: Contains( [Var], [Que], [Delimitador], [omitir], [¿sensible a mayúsculas?] )
Contains(Haystack, Needle, Delimiter := ",", OmitChars := "", CaseSensitive := false) {
	Loop, Parse, % Needle, %Delimiter%, %OmitChars%
		if (InStr(Haystack, A_LoopField, !!CaseSensitive))
			return true
	return false
}

;comprueba si es minúscula
;Sintaxis: IsCharLower( [Char], [carácteres a omitir] )
IsCharLower(Char, OmitChars := "d") {
	Loop, Parse, % Char,, % OmitChars=="d"?A_Space A_Tab "`n`r":OmitChars
	{	Char := A_LoopField
		if !DllCall("User32.dll\IsCharLower", "UShort", NumGet(Char, 0, "UShort"), "Int")
			return false
	} return true
}

;comprueba si es mayúscula
;Sintaxis: IsCharUpper( [Char], [carácteres a omitir] )
IsCharUpper(Char, OmitChars := "d") {
	Loop, Parse, % Char,, % OmitChars=="d"?A_Space A_Tab "`n`r":OmitChars
	{	Char := A_LoopField
		if !DllCall("User32.dll\IsCharUpper", "UShort", NumGet(Char, 0, "UShort"), "Int")
			return false
	} return true
}

;Convierte carácteres a mayúsculas.
CharUpper(Char) {
	return DllCall("User32.dll\CharUpperW", "Ptr", &Char, "Str")
}

;Convierte carácteres a minúsulas.
CharLower(Char) {
	return DllCall("User32.dll\CharLowerW", "Ptr", &Char, "Str")
}

;invertir cadena
ReverseString(String) {
	Loop, Parse, % String
		OutputVar := A_LoopField OutputVar
	return OutputVar
}

ReplaceLiteralVar(String, FileName := false) {
	static _ := []
	static Env, St
	if !Env
		Env := {"HKCU": "Environment", "HKLM": "SYSTEM\ControlSet001\Control\Session Manager\Environment"}
	for k, v in Env
		Loop, Reg, %k%\%v%, V
			String := StrReplace(String, "%" A_LoopRegName "%", _[A_LoopRegName]?_[A_LoopRegName]:(_[A_LoopRegName]:=GetEnvironmentVariable(A_LoopRegName)))
	if !St
		St := {"Temp": (_0:=A_Temp), "ProgramFiles" : (_9:=A_ProgramFiles), "CommonProgramFiles": (i7:=A_ProgramsCommon), "AppData": (i0:=A_AppData), "OS": (_8:=A_OSVersion)
		, "COMPUTERNAME": (i5:=A_ComputerName), "HOMEDRIVE": SubStr(_1:=A_WinDir, 1, 2), "LOCALAPPDATA": (_2:=A_AppDataCommon), "desktop": (i2:=A_Desktop)
		, "WINDIR": _1, "USERNAME": (i4:=A_UserName), "SYSTEMROOT": _1, "PROCESSOR_ARCHITECTURE": A_Is64bitOS?"64":"32", "LOCALAPPDATA": _2
		, "CMDEXTVERSION": A_OSType, "StartMenu": (i3:=A_StartMenu), "MyDocuments": (_3:=A_MyDocuments), "Documents": _3, "Cursor": (i8:=A_Cursor), "SendTo": A_SendTo()
		, "Recent": A_Recent(), "MyVideo": A_MyVideo(), "MyPictures": A_MyPictures(), "MyMusic": A_MyMusic(), "DocumentsCommon": A_DocumentsCommon()
		, "Programs": (i6:=A_Programs), "ComSpec": A_ComSpec(), "SysWinDir": A_SysWinDir(), "SysDir": A_SysDir(), "SysDir64": A_SysDir64(), "DefaultUserProfile": A_DefaultUserProfile()
		, "Profiles": A_Profiles(), "AllUsersProfile": A_AllUsersProfile(), "UserProfile": A_UserProfile(), "UserDomain": A_UserDomain(), "A_Temp": _0, "A_AhkVersion": A_AhkVersion
		, "A_ScriptName": A_ScriptName, "A_ScriptFullPath": A_ScriptFullPath, "A_ScriptFullPath": A_ScriptFullPath, "A_ScriptDir": A_ScriptDir, "A_Space": A_Space, "A_Tab": A_Tab
		, "A_OSVersion": _8, "A_WinDir": _1, "A_ProgramFiles": _9, "A_AppData": i0, "A_Language": A_Language, "A_Desktop": i2, "A_StartMenu": i3, "A_UserName": i4
		, "A_AppDataCommon": _2, "A_ComputerName": i5, "A_StartMenuCommon": A_StartMenuCommon, "A_Programs": i6, "A_ProgramsCommon": i7, "A_Cursor": i8, "A_Startup": A_Startup
		, "A_DesktopCommon": A_DesktopCommon, "A_IsAdmin": A_IsAdmin, "A_StartupCommon": A_StartupCommon, "A_IPAddress4": A_IPAddress4, "A_IPAddress1": A_IPAddress1
		, "A_IPAddress2": A_IPAddress2, "A_IPAddress3": A_IPAddress3, "A_MyDocuments": _3}
	for k, v in St
		String := StrReplace(String, "%" k "%", v)
	Ot := {"CD": A_WorkingDir, "DATE": (_1:=A_DD) "/" (_2:=A_Mon) "/" (_3:=A_Year), "TIME": (_4:=A_Hour) ":" (_5=A_Min) ":" (_6:=A_Sec), "DateTime": _1 "_" _2 "_" _3 "_" _4 "_" _5 "_" _6
	, "A_DDD": A_DDD, "A_DDDD": A_DDDD, "A_MMM": A_MMM, "A_MMMM": A_MMMM, "A_MM": A_MM, "A_YYYY" : A_YYYY, "A_DD": _1, "A_WorkingDir": A_WorkingDir
	, "A_Year": _3, "A_Mon": _2, "A_WDay": A_WDay, "A_YDay": A_YDay, "A_Hour": _4,  "A_YWeek": A_YWeek, "A_Min": _5, "A_Sec": _6, "A_Now": A_Now, "A_MSec": A_MSec
	, "A_LastError": A_LastError, "A_ScreenHeight": A_ScreenHeight, "A_ScreenWidth": A_ScreenWidth}
	for k, v in Ot
		String := StrReplace(String, "%" k "%", v)
	if InStr(String, "%Clipboard%")
		String := StrReplace(String, "%Clipboard%", Clipboard)
	if (FileName) {
		String := StrReplace(String, "%A_FileVersion%", (_1:=GetFileVersion(FileName)))
		, String := StrReplace(String, "%FileVersion%", _1)
		if Contains(String, _2:="%Comments%,%InternalName%,%ProductName%,%CompanyName%,%LegalCopyright%,%FileDescription%,"
			. "%ProductVersion%,%LegalTrademarks%,%PrivateBuild%,%FileVersion%,%OriginalFilename%,%SpecialBuild%") {
			VerInfo := GetFileVersionInfo(FileName)
			Loop, Parse, % _2, `,
				String := StrReplace(String, A_LoopField, VerInfo[StrReplace(A_LoopField, "%")])
	}} return String
}

;obtener un nombre válido para un archivo
ValidateName(ByRef IpName) {
	return IpName := RegExReplace(IpName, "[\Q*/\:?" Chr(34) "<>|`n\E]")
}

;obtener una ruta válida para un directorio
;EJEMPLOS: 
	;MsgBox % ValidatePath( "\<`n||\ " A_WinDir "\/\ \ *Sys/t<e>m?32\c::md.:exe|`n\\" )
	;MsgBox % SetCurrentDirectory(A_WinDir) ValidatePath( "\system32\\cmd.:exe\ " )
ValidatePath(ByRef IpPath) {
	IpPath := RegExReplace(IpPath, "[\Q*/?" Chr(34) "<>|`n\E]")
	, IpPath := Trim(IpPath), IpPath := Trim(IpPath, "\"), IpPath := Trim(IpPath), IpDrive := StrLeft(IpPath, 2) 
	if FileExist( IpDrive ) AND InStr(IpDrive, ":")
		IpPath := IpDrive StrReplace( StrTrimLeft( IpPath, 2 ), ":" )
	else IpPath := A_WorkingDir "\" StrReplace( IpPath, ":" )
	IpPath := StrReplace(IpPath, "\\", "\"), IpPath := StrReplace(IpPath, " \ ", "\")
	, IpPath := Trim(IpPath), IpPath := Trim(IpPath, "\"), IpPath := Trim(IpPath)
	return IpPath := StrReplace(IpPath, "\\", "\")
}

Sort(VarName, Options := "") {
	Sort, VarName, %Options%
	return VarName
}















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CRIPTOGRAFÍA ::::::::::::::::::::::::::::::::::
;Links:
	;https://autohotkey.com/boards/viewtopic.php?f=6&t=21
	;https://msdn.microsoft.com/en-us/library/windows/desktop/aa380252(v=vs.85).aspx
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;CODIFICAR
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Base32Encode(Decoded, UseHex := 0, Len := 0) { 
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	If (Len = 0)
		Len := StrPut(Decoded, "UTF-8") - 1
		, VarSetCapacity(UTF8, Len, 0)
		, StrPut(Decoded, &UTF8, "UTF-8")
		, BinAddr := &UTF8
	else BinAddr := &Decoded
	VarSetCapacity(Endcoded, Len * 2, 0), I := 0
	while (I < Len) {
		J := N := 0
		S := 40
		Loop, 5
			N += NumGet(BinAddr + I++, "UChar") << (8 * (5 - ++J))
		Until (I >= Len)
		Loop, % Ceil((8 * J) / 5)
			Encoded .= SubStr(Chars, ((N >> (S -= 5)) & 0x1F) + 1, 1)
	} Loop, % ((40 - (J * 8)) // 5)
		Encoded .= "="
	return Encoded
}

Base64Encode(Str, Encoding := "UTF-8") {
	Size := StrPutVar(Str, Binary, Encoding)
	, DllCall("Crypt32.dll\CryptBinaryToStringW", "Ptr", &Binary, "UInt", Size, "UInt", 0x40000001, "Ptr", 0, "UIntP", Length)
	, VarSetCapacity(OutputVar, Length * 2)
	, Ok := DllCall("Crypt32.dll\CryptBinaryToStringW", "Ptr", &Binary, "UInt", Size, "UInt", 0x40000001, "Str", OutputVar, "UIntP", Length)
	return OutputVar, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379887(v=vs.85).aspx

;codificar URL
UriEncode(Uri, Encoding := "CP0") {
	StrPutVar(Uri, Var, Encoding)
	Loop {
		Code := NumGet(Var, A_Index - 1, "UChar")
		If !(Code)
			Break
		If (Code >= 0x30 && Code <= 0x39 ; 0-9
			|| Code >= 0x41 && Code <= 0x5A ; A-Z
			|| Code >= 0x61 && Code <= 0x7A) ; a-z
			Res .= Chr(Code)
		else Res .= "%" . SubStr(Hex(Code + 0x100), -1)
	} return Res
} ;https://autohotkey.com/board/topic/75390-ahk-l-unicode-uri-encode-url-encode-function/

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;DECODIFICAR
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Base32Decode(Encoded, UseHex := 0, ByRef Decoded := "") {
	static CharsA := "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	static CharsH := "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	Chars := UseHex ? CharsH : CharsA
	, Len := StrLen(Encoded)
	, VarSetCapacity(Decoded, Len * 2, 0)
	, I := J := K := 0
	Loop, Parse, % Encoded
	{ If !(N := InStr(Chars, A_LoopField))
			break
		K += --N << (5 * (8 - ++J))
		If (J = 8) {
			S := 40
			Loop, 5
				NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
			J := K := 0
	}} If (J < 8) {
		S := 40
		Loop, % Ceil((5 * J) / 8)
			NumPut((K >> (S -= 8)) & 0xFF, Decoded, I++, "Uchar")
	} return IsByRef(Decoded) ? I : StrGet(&Decoded, I, "UTF-8")
}

Base64Decode(Str, Encoding := "UTF-8") {
	DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &Str, "UInt", StrLen(Str), "UInt", 0x1, "Ptr", 0, "UIntP", Length, "Ptr", 0, "Ptr", 0)
	, VarSetCapacity(OutputVar, Length)
	, Ok := DllCall("Crypt32.dll\CryptStringToBinaryW", "Ptr", &Str, "UInt", StrLen(Str), "UInt", 0x1, "Ptr", &OutputVar, "UIntP", Length, "Ptr", 0, "Ptr", 0)
	return StrGet(&OutputVar, Length, Encoding), ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa380285(v=vs.85).aspx

;decodificar URL
UriDecode(Uri, Enc := "CP0") {
	Pos := 1
	Loop {
		if ((Pos:=RegExMatch(Uri, "i)(?:%[\da-f]{2})+", Code, Pos++))=0)
			break
		VarSetCapacity(Var, StrLen(Code) // 3, 0), Code := SubStr(Code, 2)
		Loop, Parse, % Code, `%
			NumPut("0x" . A_LoopField, Var, A_Index - 1, "UChar")
		Uri := StrReplace(Uri, "%" Code, StrGet(&Var, Enc))
	} return, Uri
} ;https://autohotkey.com/board/topic/75390-ahk-l-unicode-uri-encode-url-encode-function/























































;#############################################################################################################################################
;  ::::::::::::::::::::::::::::::::::::::::::::: SINCRONIZACIÓN ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx
;#############################################################################################################################################
;espera hasta que el objeto especificado esté en el estado indicado.
;Sintaxis: WaitForSingleObject( [hHandle], [dwMilliseconds], [bAlertable] )
;Acceso Requerido: SYNCHRONIZE
;Return:
	;-1 = ERROR.
	;0 = OK.
	;258 = TIMEOUT
WaitForSingleObject(hHandle, dwMilliseconds := 0xFFFFFFFF, bAlertable := false) {
	return DllCall("Kernel32.dll\WaitForSingleObjectEx", "Ptr", hHandle, "UInt", dwMilliseconds, "Int", !!bAlertable)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687036(v=vs.85).aspx



















































































/*#############################################################################################################################################
  ::::::::::::::::::::::::::::::::::::::::::::: PROCESOS ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
Notas:
	• espesificar -1 para referirse al proceso actual.
	• espesificar -2 para referirse al Thread actual. http://www.rastersoft.com/OS2/CURSO/THREAD.HTM
	• espesificar -3 para referirse al último proceso espesificado.
;Parámetros:
	ID / ProcessName = ID o Nombre del proceso
*/
;comprueba si el proceso existe
;Sintaxis: ProcessExist( [ProcessName] )
;Return: ProcessId
;Notas:
	;epsesificar -1 para obtener el PID del proceso actual.
	;espesificar -2 para obtener el ThreadId del proceso actual.
	;espesificar -3 para obtener el PID del último proceso espesificado/encontrado.
ProcessExist(ProcessName := -1) {
	if (ProcessName = -1)
		return DllCall("Kernel32.dll\GetCurrentProcessId")
	if (ProcessName = -2)
		return DllCall("Kernel32.dll\GetCurrentThreadId")
	if (ProcessName = -3)
		return __gsvalue.LastProcessId
	Size := VarSetCapacity(PROCESSENTRY32, A_PtrSize=4?296:304, 0), NumPut(Size, PROCESSENTRY32, 0, "UInt")
	, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0, "Ptr")
	, DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &PROCESSENTRY32, "Int")
	Loop {
		if ((ProcessId := NumGet(PROCESSENTRY32, 8, "UInt")) = ProcessName)
		|| (StrGet(&PROCESSENTRY32 + (A_PtrSize=4?36:44), 260, "CP0") = ProcessName)
			return __gsvalue.LastProcessId := ProcessId, CloseHandle(hSnapshot)
		if !DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &PROCESSENTRY32)
			return false, CloseHandle(hSnapshot)
}}

;devuelve una lista de todos los procesos (PID+Nombre)
;Sintaxis: ProcessEnum( [¿recuperar mas información? ]
;Ejemplo:
	;for k, v in p:=ProcessEnum()
		;MsgBox % "#" p.MaxIndex() "`n`n" k "`nNombre: " v.ProcessName "`nPID: " v.ProcessId "`nThreads: " v.Threads "`nParent: " v.ParentProcessId
ProcessEnum() {
	Size := VarSetCapacity(PROCESSENTRY32, A_PtrSize=4?296:304, 0), NumPut(Size, PROCESSENTRY32, 0, "UInt")
	, hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000002, "UInt", 0, "Ptr")
	, Ok := DllCall("Kernel32.dll\Process32First", "Ptr", hSnapshot, "Ptr", &PROCESSENTRY32, "Int"), List := []
	Loop {
		Info := {}, Info.ProcessId := NumGet(PROCESSENTRY32, 8, "UInt")
		, Info.ProcessName := StrGet(&PROCESSENTRY32+(A_PtrSize=4?36:44), 260, "CP0")
		, Info.Threads := NumGet(PROCESSENTRY32, A_PtrSize=4?20:28, "UInt")
		, Info.ParentProcessId := NumGet(PROCESSENTRY32, A_PtrSize=4?24:32, "UInt"), List.Push(Info)
	} until !DllCall("Kernel32.dll\Process32Next", "Ptr", hSnapshot, "UInt", &PROCESSENTRY32, "Int")
	return Ok?List:false, CloseHandle(hSnapshot), ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx

;Recupera información sobre el uso de memoria del proceso especificado en bytes
ProcessMemoryInfo(ProcessName) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x00000410)
	, Size := VarSetCapacity(memCounters, A_PtrSize=8?72:40), NumPut(Size, memCounters)
	if !(DllCall("Psapi.dll\GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", Size)) {
		memCounters := "", Size := VarSetCapacity(memCounters, A_PtrSize=8?80:44), NumPut(Size, memCounters)
		if !(DllCall("Kernel32.dll\K32GetProcessMemoryInfo", "Ptr", hProcess, "UInt", &memCounters, "UInt", Size))
			return false, ErrorLevel := true
	} i := {}, i.PageFaultCount := NumGet(memCounters, 4, "UInt")
		, i.PeakWorkingSetSize := NumGet(memCounters, 8, "Ptr")
		, i.WorkingSetSize := NumGet(memCounters, A_PtrSize = 8 ? 16 : 12, "Ptr") 
		, i.QuotaPeakPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 24 : 16, "Ptr")
		, i.QuotaPagedPoolUsage := NumGet(memCounters, A_PtrSize = 8 ? 32 : 20, "Ptr")
		, i.QuotaPeakNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 40 : 24, "Ptr")
		, i.QuotaNonPagedPoolUsage := NumGet( memCounters, A_PtrSize = 8 ? 48 : 28, "Ptr")
		, i.PagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 56 : 32, "Ptr")
		, i.PeakPagefileUsage := NumGet( memCounters, A_PtrSize = 8 ? 64 : 36, "Ptr")
		, i.PrivateUsage := NumGet(memCounters, A_PtrSize = 8 ? 72 : 40, "Ptr")
	return i, ErrorLevel := false, CloseHandle(hProcess)
}

;uso de CPU del proceso
ProcessCPULoad(ProcessName) {
		Static oldKrnlTime, oldUserTime, newKrnlTime, newUserTime
		ProcessId := _getpid(ProcessName)
		, oldKrnlTime := newKrnlTime, oldUserTime := newUserTime
		, hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x0400, "UInt", 0, "UInt", ProcessId)
		, DllCall("Kernel32.dll\GetProcessTimes", "Uint", hProcess, "int64P", CreationTime, "int64P", ExitTime, "int64P", newKrnlTime, "int64P", newUserTime) 
		return (((newKrnlTime-oldKrnlTime)+(newUserTime-oldUserTime))/10000000)*100, DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
}

;obtener/establecer prioridad 
;Sintaxis: ProcessPriority( [Nombre o PID], [Prioridad] )
;Prioridades: Low|BelowNormal|Normal|AboveNormal|High|RealTime
;Nota: dejar vacio el segundo parametro para recuperar la prioridad
ProcessPriority(ProcessName, Priority := "") {
	static p := {"Normal": 32, "Low": 64, "High": 128, "RealTime": 256, "BelowNormal": 16384, "AboveNormal": 32768}
	static rs := {32: "Normal", 64: "Low", 128: "High", 256: "RealTime", 16384: "BelowNormal", 32768: "AboveNormal"}
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, p[Priority]=""?0x0400:0x0200)
	if (p[Priority]="")
		return r:=rs[DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess)], CloseHandle(hProcess), ErrorLevel := !r
	return r := DllCall("kernel32.dll\SetPriorityClass", "Ptr", hProcess, "UInt", p[Priority]), CloseHandle(hProcess), ErrorLevel := !r
}

ProcessPath(ProcessName, ByRef ProcessEName := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x1000)
	Path := GetModuleFileName(hProcess)
	SplitPath, Path, ProcessEName
	return Path, CloseHandle(hProcess)
} ProcessName(ProcessName) {
	ProcessPath(ProcessName, ProcessName)
	return ProcessName
}

;establece el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessSetWorkingSetSize( [Proceso], [Min], [Max] )
ProcessSetWorkingSetSize(ProcessName, Min := -1, Max := -1) {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0100)
	, r := DllCall("Kernel32.dll\SetProcessWorkingSetSize", "Ptr", hProcess, "Ptr", Min, "Ptr", Max)
	return r, ErrorLevel := !r, CloseHandle(hProcess)
}

;obtiene el tamaño de conjunto de trabajo máximo y mínimo para el proceso especificado
;Sintaxis: ProcessGetWorkingSetSize( [Proceso], [Min (salida)], [Max (salida)] )
ProcessGetWorkingSetSize(ProcessName, ByRef Min := "", ByRef Max := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), i := {}
	, r := DllCall("Kernel32.dll\GetProcessWorkingSetSize", "Ptr", hProcess, "PtrP", Min, "PtrP", Max)
	return r?{Min: Min, Max: Max}:0, ErrorLevel := !r, CloseHandle(hProcess)
}

;habilitar/deshabilitar/eliminar privilegios para el proceso espesificado
;Sintaxis: ProcessAdjustPrivileges( [proceso], [Array o Privilegios separados por coma], [estado], [¿deshabilitar todos los privilegios?] )
;Array: espesificar los privilegios y el estado para cada uno.
	;Sintaxis: [	["privilegio 1", "estado"], ["privilegio 2", "estado"], ["privilegio 3", "estado"], ...	 ]
;Privilegios separados por coma: espesificar los privilegios separados por coma. el estado en el 3er parámetro que se aplica a todos
;Estados: Enable | Disable | Delete. Nota: el 3er parámetro solo es válido cuando se espesifican los privilegios separados por coma
;Deshabilitar todos los privilegios: establecer en verdadero para deshabilitar todos los privilegios. el 2do y 3er parámetro no tienen efecto
;Privilegios: https://msdn.microsoft.com/en-us/library/windows/desktop/bb530716(v=vs.85).aspx
	;Ver LookupPrivilegeName() para una lista con todos los privilegios
;Ejemplo:
	;MsgBox % ProcessAdjustPrivileges("notepad.exe", [["SeDebugPrivilege", "Enable"], ["SeRestorePrivilege", "Enable"]]) ;Array
	;MsgBox % ProcessAdjustPrivileges("notepad.exe", "SeDebugPrivilege,SeRestorePrivilege", "Disable") ;Privilegios separados por coma, uso del 3er parámetro
	;MsgBox % ProcessAdjustPrivileges("notepad.exe",,, true) ;deshabilitar todos los privilegios. NOTA: los privilegios habilitados por defecto no se deshabilitan
;Nota: para comprobar los cambios, puede usar ProcessHacker, doble clic en el proceso, en la pestaña «Token». items en verde oscuro no se pueden deshabilitar.
ProcessAdjustPrivileges(ProcessName, Privileges := "", State := "Enable", DisableAllPrivileges := false) {
	static States := {Enable: 0x00000002, Disable: 0x00000000, Delete: 0x00000004}
	ProcessId := _getpid(ProcessName), Privileges := IsObject(Privileges)?Privileges:StrSplit(Privileges, ",", A_Space A_Tab)
	, hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x00000028), Offset := 0
	, VarSetCapacity(TOKEN_PRIVILEGES, 4 + (12*Privileges.MaxIndex()), 0), NumPut(Privileges.MaxIndex(), TOKEN_PRIVILEGES, 0, "UInt")
	for Index, Info in Privileges {
		NumPut(LookupPrivilegeValue(IsObject(Info)?Info[1]:Info), TOKEN_PRIVILEGES, Offset+4, "Int64")
		, NumPut(States[IsObject(Info)?Info[2]:State], TOKEN_PRIVILEGES, Offset+12, "UInt")
		Offset += 12
	} DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", hToken, "Int", !!DisableAllPrivileges, "Ptr", &TOKEN_PRIVILEGES, "UInt", 0, "Ptr", 0, "Ptr", 0)
	return !(r:=A_LastError), ErrorLevel := r, CloseHandle(hToken, hProcess) ;AdjustTokenPrivileges --> A_LastError --> ERROR_SUCCESS = 0
} ;https://msdn.microsoft.com/en-us/library/aa375202(VS.85).aspx | https://msdn.microsoft.com/en-us/library/aa379306(v=vs.85).aspx

;obtener privilegios del proceso
;Sintaxis: ProcessQueryPrivileges( [ID] )
;Return: [{Nombre, Estado}]
	;Nombre: nombre del privilegio
	;Estados: estado del provilegio
		;Enabled = habilitado
		;Disabled = deshabilitado
		;Default = habilitado por defecto
		;Access = el privilegio se utilizó para obtener acceso a un objeto o servicio
;Ejemplo:
	;for k, v in p:=ProcessQueryPrivileges("chrome.exe")
	;	MsgBox % "#" k " ~ " p.MaxIndex() " ------------`nPrivilegio: " v.Name "`nEstado: " v.State
ProcessQueryPrivileges(ProcessName) {
	static States := {0x00000002: "Enabled", 0x00000000: "Disabled", 0x00000001: "Default", 0x80000000: "Access", 0x00000003: "Default"}
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x0008)
	, Ok := GetTokenInformation(hToken, 3, TOKEN_PRIVILEGES), List := [], Offset := 0
	Loop, % NumGet(TOKEN_PRIVILEGES, 0, "UInt") {
		PrivilegeInfo := {}
		, PrivilegeInfo.Name := LookupPrivilegeName(NumGet(TOKEN_PRIVILEGES, Offset+4, "Int64"))
		, PrivilegeInfo.State := States[NumGet(TOKEN_PRIVILEGES, Offset+12, "UInt")]
		, List.Push(PrivilegeInfo), Offset += 12
	} return List, CloseHandle(hToken, hProcess), ErrorLevel := !Ok
}

;determina si el proceso tiene privilegios elevados
;Sintaxis: ProcessElevation( [ID] )
;Return: 0|1
ProcessElevation(ProcessName, ByRef Owner := "") {
	ProcessId := _getpid(ProcessName), hProcess := OpenProcess(ProcessId, 0x0400), hToken := OpenProcessToken(hProcess, 0x0008)
	, GetTokenInformation(hToken, 20, TOKEN_ELEVATION)
	return NumGet(TOKEN_ELEVATION, 0, "UInt"), CloseHandle(hToken, hProcess)
}

;obtener una lista de los Threads del proceso espesificado
;Sintaxis: ProcessThreadList( [ID], [Delimitador] )
;EJEMPLO:
	;for k, v in ProcessThreadList()
		;if (i:=ProcessName(v.ProcessId))
			;MsgBox % "ThreadId: " v.ThreadId ", OwnerProcessId: " v.ProcessId " (" i ")"
ProcessThreadList(ProcessName := "", Delimiter := "`n") {
	ProcessName := _getpid(ProcessName), dwSize := VarSetCapacity(THREADENTRY32, 28, 0)
	, NumPut(dwSize, THREADENTRY32, 0, "UInt"), hSnapshot := DLLCall("Kernel32.dll\CreateToolhelp32Snapshot", "UInt", 0x00000004, "UInt", 0)
	, DllCall("Kernel32.dll\Thread32First", "Ptr", hSnapshot, "Ptr", &THREADENTRY32)
	Loop {
		th32OwnerProcessID := NumGet(THREADENTRY32, 12, "UInt")
		, th32ThreadID := NumGet(THREADENTRY32, 8, "UInt")
		if (ProcessName) {
			if (ProcessName=th32OwnerProcessID)
				ThreadList .= (A_Index=1?"":Delimiter) th32ThreadID
		} else {
			if !IsObject(ThreadList)
				ThreadList := []
			ThreadInfo := [], ThreadInfo.ThreadId := th32ThreadID
			, ThreadInfo.ProcessId := th32OwnerProcessID, ThreadList.InsertAt( A_Index, ThreadInfo )
		} if !(DllCall("Kernel32.dll\Thread32Next", "Ptr", hSnapshot, "UInt", &THREADENTRY32))
			return ThreadList, ErrorLevel := hSnapshot=-1, CloseHandle(hSnapshot)
}}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES CON HANDLE
;Parámetros:
	;Process = PID o Nombre del proceso. -1 para el proceso actual.
	;ProcessName = nombre del proceso.
	;ProcessId = espesificar el PID. Nota: para usar el PID espesificar / al principio. Ejemplo: /1004
	;ProcessPath = espesificar la ruta completa del ejecutable
	;hProces = OpenProcess()
	;hThread = OpenThread()
	;hToken = OpenProcessToken()
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Obtener HANDLE a un proceso.
;Sintaxis: OpenProcess( [Process], [acceso] )
;Parámetros:
	;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx
		;PROCESS_QUERY_INFORMATION = 0x0400
		;PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
		;PROCESS_TERMINATE = 0x0001
		;PROCESS_SET_INFORMATION  = 0x0200
		;PROCESS_VM_READ = 0x0010
;Return: hProcess
;Notas:
	;si se espesifica el acceso PROCESS_QUERY_LIMITED_INFORMATION y el SO es WIN_XP, usa PROCESS_QUERY_INFORMATION
OpenProcess(ProcessId := -1, DesiredAccess := 0x001F0FFF, InheritHandle := false) { ;0x001F0FFF=ALL
	ProcessId := StrReplace(ProcessId, "/")
	if ((ProcessId+0) = "") || (ProcessId = -1) || (ProcessId = -2) || (ProcessId = -3)
		ProcessId := ProcessExist(ProcessId)
	if (DesiredAcces & 0x1000) && !IsWindowsVistaOrGreater()
		DesiredAccess := (DesiredAccess - 0x1000) + 0x0400
	return DllCall("Kernel32.dll\OpenProcess", "UInt", DesiredAccess, "Int", !!InheritHandle, "UInt", ProcessId, "Ptr")
} 

;Sintaxis: OpenProcessToken( [hProces], [acceso] )
;Accesos:
	;STANDARD_RIGHTS_REQUIRED = 0x000F0000
	;TOKEN_ASSIGN_PRIMARY = 0x0001
	;TOKEN_DUPLICATE = 0x0002
	;TOKEN_IMPERSONATE = 0x0004
	;TOKEN_QUERY = 0x0008
	;TOKEN_QUERY_SOURCE = 0x0010
	;TOKEN_ADJUST_PRIVILEGES = 0x0020
	;TOKEN_ADJUST_GROUPS = 0x0040
	;TOKEN_ADJUST_DEFAULT = 0x0080
	;TOKEN_ADJUST_SESSIONID = 0x0100
;Return: hToken
OpenProcessToken(hProcess, DesiredAccess := 0xF01FF) { ;0xF01FF=ALL
	DllCall("Advapi32.dll\OpenProcessToken", "Ptr", hProcess, "UInt", DesiredAccess, "UIntP", hToken)
	return hToken
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379295(v=vs.85).aspx

;Sintaxis: OpenThread( [ThreadId], [acceso], [¿InheritHandle?] )
;Accesos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms686769(v=vs.85).aspx
	;Constantes: https://www.omniref.com/ruby/gems/windows-pr/0.8.6/symbols/Windows::Thread::THREAD_ALL_ACCESS
;Return: hThread
OpenThread(ThreadId, DesiredAccess := 0x1F03FF, InheritHandle := false) {
	return DllCall("Kernel32.dll\OpenThread", "UInt", DesiredAccess, "Int", !!InheritHandle, "UInt", ThreadId, "Ptr")
}

CreateProcess(ApplicationName := "", ByRef CommandLine := "", ProcessAttributes := 0, ThreadAttributes := 0, InheritHandles := true, CreationFlags := 0x08000000, Environment := 0, CurrentDirectory := "", StartupInfo := 0) {
	VarSetCapacity(PROCESS_INFORMATION, A_PtrSize=4?16:24, 0)
	, r := DllCall("Kernel32.dll\CreateProcessW", "Ptr", ApplicationName=""?0:&ApplicationName, "Ptr", CommandLine=""?0:&CommandLine
	, "Ptr", ProcessAttributes, "Ptr", ThreadAttributes, "Int", !!InheritHandles, "UInt", CreationFlags, "Ptr", Environment, "Ptr", CurrentDirectory=""?0:&CurrentDirectory
	, "Ptr", StartupInfo, "Ptr", &PROCESS_INFORMATION)
	return r?{HANDLE: NumGet(PROCESS_INFORMATION, 0, "Ptr"), hThread: NumGet(PROCESS_INFORMATION, A_PtrSize, "Ptr")
	, ID: NumGet(PROCESS_INFORMATION, A_PtrSize=4?8:16, "Ptr"), ThreadID: NumGet(PROCESS_INFORMATION, A_PtrSize=4?12:24, "Ptr")}:0, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;esperar a que el proceso exista
;Sintaxis: WaitProcess( [ProcessName / ProcessId], [Segundos] )
;Return:
	;0 = tiempo fuera.
	;[ProcessId] = se encontró el proceso.
;Ejemplo:
	;MsgBox % WaitProcess("notepad.exe", 5)
	;MsgBox % WaitProcessClose("notepad.exe", 5)
WaitProcess(ProcessName, Seconds := 0xFFFFFFFF) {
	Seconds := A_TickCount+(Seconds*1000)
	Loop {
		if (hProcess := OpenProcess(ProcessName, 0x1000)) {
			if (GetExitCodeProcess(hProcess) = 259)
				return DllCall("Kernel32.dll\GetProcessId", "Ptr", hProcess), CloseHandle(hProcess) 
			CloseHandle(hProcess)
		} Sleep, 100
	} until (A_TickCount >= Seconds)
	return false, CloseHandle(hProcess)
}

;esperar a que el proceso finalize
;Sintaxis: WaitProcessClose( [hProcess | ProcessName | /ProcessId], [Segundos] )
;Acceso Requerido: PROCESS_QUERY_LIMITED_INFORMATION
;Return:
	;0 = tiempo fuera.
	;1 = el proceso finalizó.
WaitProcessClose(hProcess, Seconds := 0xFFFFFFFF) {
	if ((hProcess+0) = "") || (SubStr(hProcess, 1, 1) = "/")
		hProcess := OpenProcess(hProcess, 0x1000), CloseHandle := true
	Seconds := A_TickCount+(Seconds*1000)
	Loop {
		if (GetExitCodeProcess(hProcess) != 259) {
			return true, CloseHandle(hProcess)
		} Sleep, 100
	} until (A_TickCount >= Seconds)
	if (CloseHandle)
		CloseHandle(hProcess)
	return false
}

;obtiene el propietario actual del proceso
;Sintaxis: GetProcessOwner( [hToken], [out UserName], [out Domain] )
;Return: SID
;Accesos Requeridos:
	;hProcess: 0x0400
	;hToken: 0x0008
;Ejemplo:ver SetProcessOwner()
GetProcessOwner(hToken, ByRef UserName := "", ByRef Domain := "") {
	GetTokenInformation(hToken, 4, TOKEN_OWNER), pSID := NumGet(TOKEN_OWNER, 0)
	if IsByRef(UserName) || IsByRef(Domain)
		LookupAccountSid(pSID, UserName, Domain)
	return ConvertSidToStringSid(pSID)
}	

;establecer propietario para el proceso
;Sintaxis: SetProcessOwner( [hToken], [SID] )
;Accesos Requeridos:
	;hProcess: 0x0200
	;hToken: 0x0080
;Parámetros:
	;SID: puede espesificar un SID, un pSID o dejar en -1 para usar el usuario actual
;Ejemplo:
	;hProcess := OpenProcess(, 0x0400|0x0200)
	;hToken := OpenProcessToken(hProcess, 0x0008	|	0x0080 | 0x00080000)
	;SID := GetProcessOwner(hToken, UserName, Domain)
	;MsgBox % SID "`n" UserName "`n" Domain
	;MsgBox % SetProcessOwner(hToken)
	;SID := GetProcessOwner(hToken, UserName, Domain)
	;MsgBox % SID "`n" UserName "`n" Domain
SetProcessOwner(hToken, pSID := -1) {
	if (pSID=-1) || ((pSID+)="")
		pSID := ConvertStringSidToSid(pSID=-1?GetCurrentUserInfo().SID:SID)
	VarSetCapacity(TOKEN_OWNER, A_PtrSize, 0), NumPut(pSID, TOKEN_OWNER, 0)
	, Ok := DllCall("Advapi32.dll\SetTokenInformation", "Ptr", hToken, "UInt", 4, "Ptr", &TOKEN_OWNER, "UInt", A_PtrSize)
	return Ok, ErrorLevel := Ok?false:A_LastError
}

;obtiene el SID, opcional también el nombre de usuario y dominio del proceso
;Sintaxis: GetProcessSID( [hToken], [out UserName], [out Domain] )
;Return: SID
;Acceso Requerido:
	;hProcess = PROCESS_QUERY_INFORMATION
	;hToken = TOKEN_QUERY
GetProcessSID(hToken, ByRef UserName := "", ByRef Domain := "") {
	Ok := GetTokenInformation(hToken, 1, TOKEN_USER), pSID := NumGet(TOKEN_USER, 0, "UInt")
	if IsByRef(UserName) || IsByRef(Domain)
		LookupAccountSid(pSID, UserName, Domain)
	return ConvertSidToStringSid(pSID)
}

;determina si el proceso está siendo ejecutado sobre WOW64
;Sintaxis: IsWow64Process( [hProcess | ProcessName | /ProcessId] )
;Acceso Requerido: PROCESS_QUERY_LIMITED_INFORMATION
;Return:
	;-1 = error.
	;0 = el proceso se ejecuta sobre 32-bit Windows o el proceso es una aplicación de 64-bit
	;1 = el proceso es ejecutado sobre WOW64
;Ejemplo: MsgBox % IsWow64Process(OpenProcess(, 0x1000))
IsWow64Process(hProcess := -1) {
	if ((hProcess+0) = "") || (SubStr(hProcess, 1, 1) = "/") || (hProcess = -1)
		hProcess := OpenProcess(hProcess, 0x1000), CloseHandle := true
	Ok := DllCall("Kernel32.dll\IsWow64Process", "Ptr", hProcess, "IntP", Wow64Process)
	if (CloseHandle)
		CloseHandle(hProcess)
	return Ok?!!Wow64Process:-1
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684139(v=vs.85).aspx

;lee datos de un área de memoria en un proceso determinado. toda la zona a leer debe ser accesible o la operación fallará
;Sintaxis: ReadProcessMemory( [hProcess], [BaseAddress], [data (out)], [tamaño, en bytes], [NumberOfBytesRead (in_out)], [ReturnType] )
;Parámetros:
	;BaseAddress: un puntero a la dirección base en el proceso específico a leer
	;Data: un puntero a un búfer que recibe el contenido del espacio de direcciones del proceso especificado.
	;Tamaño: el número de bytes que se lee desde el proceso especificado
	;NumberOfBytesRead:  recibe el número de bytes transferidos en el búfer especificado
	;ReturnType: tipo de valor a devolver. defecto=UInt
ReadProcessMemory(hProcess, BaseAddress, Buffer, Bytes := 0, ByRef NumberOfBytesRead := "", ReturnType := "UInt") {
	BaseAddress := IsObject(BaseAddress)?BaseAddress:["UInt", BaseAddress], Error := ErrorLevel
	if IsByRef(NumberOfBytesRead)
		VarSetCapacity(NumberOfBytesRead, NumberOfBytesRead?NumberOfBytesRead:16, 0)
	Result := DllCall("Kernel32.dll\ReadProcessMemory", "Ptr", hProcess, BaseAddress[1], BaseAddress[2], "Ptr", Buffer, "UPtr"
	, Bytes>0?Bytes:VarSetCapacity(Buffer), "UPtrP", IsByRef(NumberOfBytesRead)?&NumberOfBytesRead:0, ReturnType)
	if IsByRef(NumberOfBytesRead)
		NumberOfBytesRead := NumGet(NumberOfBytesRead, 0, "UPtrP")
	return Result, ErrorLevel := Error
}

;escribe datos en un área de memoria en un proceso especificado. toda la zona a escribir debe ser accesible o la operación fallará
;Sintaxis: WriteProcessMemory( [hProcess], [BaseAddress], [Buffer], [Size], [NumberOfBytesWritten] )
WriteProcessMemory(hProcess, BaseAddress, Buffer, Bytes := 0, ByRef NumberOfBytesWritten := "") {
	BaseAddress := IsObject(BaseAddress)?BaseAddress:["UInt", BaseAddress], Error := ErrorLevel
	if IsByRef(NumberOfBytesWritten)
		VarSetCapacity(NumberOfBytesWritten, 16, 0)
	Result :=  DllCall("Kernel32.dll\WriteProcessMemory", "Ptr", hProcess, BaseAddress[1], BaseAddress[2], "Ptr", Buffer, "UPtr"
	, Bytes>0?Bytes:VarSetCapacity(Buffer), "UPtrP", IsByRef(NumberOfBytesWritten)?&NumberOfBytesWritten:0, "UInt")
	if IsByRef(NumberOfBytesWritten)
		NumberOfBytesWritten := NumGet(NumberOfBytesWritten, 0, "UPtrP")
	return Result, ErrorLevel := Error
}

;recupera el estado de terminación del proceso especificado.
;Sintaxis: GetExitCodeProcess( [hProcess] )
;Acceso Requerido: PROCESS_QUERY_LIMITED_INFORMATION
GetExitCodeProcess(hProcess) {
	Ok := DllCall("Kernel32.dll\GetExitCodeProcess", "Ptr", hProcess, "UIntP", ExitCode, "UInt")
	return ExitCode, ErrorLevel := !Ok
}

;suspender proceso
;Acceso Requerido: PROCESS_SUSPEND_RESUME
SuspendProcess(hProcess) {
	return DllCall("ntdll.dll\NtSuspendProcess", "Ptr", hProcess)
}

;reanudar proceso
;Acceso Requerido: PROCESS_SUSPEND_RESUME
ResumeProcess(hProcess) {
	return DllCall("ntdll.dll\NtResumeProcess", "Ptr", hProcess)
}

;terminar proceso por medio de un HANDLE, PID, NOMBRE O RUTA
;Sintaxis: TerminateProcess( [hProcess | ProcessName | /ProcessId | ProcessPath], [ExitCode] )
;Parámetros:
	;ExitCode: código de salida.
;Acceso Requerido: PROCESS_TERMINATE
;Ejemplo: MsgBox % TerminateProcess(A_WinDir "\System32\Notepad.exe")
TerminateProcess(hProcess, ExitCode := 0, SecureMethod := false) {
	if (hProcess+0)
		return DllCall("Kernel32.dll\TerminateProcess", "Ptr", hProcess, "UInt", ExitCode)
	if (SubStr(hProcess, 1, 1) = "/")
		return DllCall("Kernel32.dll\TerminateProcess", "Ptr", h:=OpenProcess(hProcess, 0x0001), "UInt", ExitCode), CloseHandle(h)
	ProcessPath := InStr(hProcess, ":")
	for k, v in ProcessEnum()
		if (ProcessPath && (GetModuleFileName("/" v.ProcessId) = hProcess)) || (!ProcessPath && (v.ProcessName = hProcess))
			Ok += !!TerminateProcess("/" v.ProcessId)
	return Ok ? Ok : false
}

;obtener prioridad del proceso
;Sintaxis: GetProcessPriority( [hProcess] )
;Return: ver SetProcessPriority()
;Acceso Requerido: PROCESS_QUERY_INFORMATION
GetProcessPriority(hProcess) {
	return DllCall("Kernel32.dll\GetPriorityClass", "Ptr", hProcess)
}

;establecer prioridad al proceso
;Sintaxis: SetProcessPriority( [hProcess], [Priority] )
;Parámetros:
	;Priority: espesificar uno de los siguientes valores, ordenados de mas alta a mas baja.
		;0x00000100 = REALTIME_PRIORITY_CLASS
		;0x00000080 = HIGH_PRIORITY_CLASS
		;0x00008000 = ABOVE_NORMAL_PRIORITY_CLASS
		;0x00000020 = NORMAL_PRIORITY_CLASS
		;0x00004000 = BELOW_NORMAL_PRIORITY_CLASS
		;0x00000040 = IDLE_PRIORITY_CLASS
;Acceso Requerido: PROCESS_SET_INFORMATION
SetProcessPriority(hProcess, Priority := 0x00000020) {
	return DllCall("Kernel32.dll\SetPriorityClass", "Ptr", hProcess, "UInt", Priority)
}

;establecer prioridad al thread
;Sintaxis: SetThreadPriority( [hThread], [Priority] )
;Parámetros:
	;Priority: espesificar uno de los siguientes valores, ordenados de mas alta a mas baja.
		;15 = THREAD_PRIORITY_TIME_CRITICAL
		;2 = THREAD_PRIORITY_HIGHEST
		;1 = THREAD_PRIORITY_ABOVE_NORMAL
		;0 = THREAD_PRIORITY_NORMAL
		;-2 = THREAD_PRIORITY_LOWEST
		;-15 = THREAD_PRIORITY_IDLE
;Acceso Requerido: THREAD_SET_INFORMATION o THREAD_SET_LIMITED_INFORMATION 
SetThreadPriority(hThread, Priority := 0) {
	return DllCall("Kernel32.dll\SetThreadPriority", "Ptr", hThread, "UInt", Priority)
}

;obtener priorided del thread
;Sintaxis: SetThreadPriority( [hThread] )
GetThreadPriority(hThread) {
	return DllCall("Kernel32.dll\GetThreadPriority", "Ptr", hThread)
}

;obtener ruta del ejecutable del proceso
;Sintaxis: GetModuleFileName( [hProcess | ProcessName | /ProcessId], [hModule] )
;Acceso Requerido: PROCESS_QUERY_LIMITED_INFORMATION
;Ejemplo: MsgBox % GetModuleFileName("smss.exe")
GetModuleFileName(hProcess := -1, hModule := 0) {
	if ((hProcess+0) = "") || (SubStr(hProcess, 1, 1) = "/") || (hProcess = -1)
		hProcess := OpenProcess(hProcess, 0x1000), CloseHandle := true
	VarSetCapacity(OutputVar, 260 * 2 + 1, 0)
	if !(hModule) && DllCall("Psapi.dll\GetProcessImageFileName", "Ptr", hProcess, "Str", OutputVar, "UInt", 260 + 1) {
		Pos := InStr(OutputVar, "\",, 9), DosDeviceName := SubStr(OutputVar, 1, Pos - 1)
		Loop, Parse, % "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
			if (QueryDosDevice(A_LoopField) = DosDeviceName)
				return A_LoopField ":" SubStr(OutputVar, Pos), CloseHandle(CloseHandle?hProcess:0)
	} if A_Is64bitOS {
		if !DllCall("Kernel32.dll\QueryFullProcessImageNameW", "Ptr", hProcess, "UInt", 0, "Str", OutputVar, "UIntP", 260 + 1)
		&& !DllCall("Psapi.dll\GetModuleFileNameExW", "Ptr", hProcess, "Ptr", hModule, "Str", OutputVar, "UInt", 260 + 1)
			return false, CloseHandle(CloseHandle?hProcess:0)
	} else if !DllCall("Psapi.dll\GetModuleFileNameExW", "Ptr", hProcess, "Ptr", hModule, "Str", OutputVar, "UInt", 260 + 1)
		&& !DllCall("Kernel32.dll\K32GetModuleFileNameExW", "Ptr", hProcess, "Ptr", hModule, "Str", OutputVar, "UInt", 260 + 1)
		&& !DllCall("Kernel32.dll\QueryFullProcessImageNameW", "Ptr", hProcess, "UInt", 0, "Str", OutputVar, "UIntP", 260 + 1)
			return false, CloseHandle(CloseHandle?hProcess:0)
	return OutputVar, CloseHandle(CloseHandle?hProcess:0)
}


















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: AUTORIZACIÓN Y SEGURIDAD ::::::::::::::::::::::::::::::::::
;Parámetros:
	;pSID = pointer a una estructura SID. https://msdn.microsoft.com/en-us/library/windows/desktop/aa379594(v=vs.85).aspx
	;SID = SID STRING
	;SECURITY_DESCRIPTOR = pointer a la estructura https://msdn.microsoft.com/en-us/library/windows/desktop/aa379561(v=vs.85).aspx
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa375742(v=vs.85).aspx
;#############################################################################################################################################
;obtiene información desde hToken
;Sintaxis: GetTokenInformation( [hToken], [TokenInformationClass], [TokenInformation (out)], [ReturnLength] )
;Parámetros:	
	;hToken: usar OpenProcessToken()
	;TokenInformationClass: tipo de información de obtener: https://msdn.microsoft.com/en-us/library/aa379626(v=vs.85).aspx
	;TokenInformation: información
	;ReturnLength: bytes necesarios
;Acceso requerido: 
	;TOKEN_QUERY_SOURCE = para TokenInformationClass-->TokenSource
	;TOKEN_QUERY = para todo lo demás
GetTokenInformation(hToken, TokenInformationClass, ByRef TOKEN_INFORMATION, ByRef ReturnLength := "") {
	DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", TokenInformationClass, "Ptr", 0, "UInt", 0, "UIntP", ReturnLength)
	, VarSetCapacity(TOKEN_INFORMATION, ReturnLength, 0)
	return DllCall("Advapi32.dll\GetTokenInformation", "Ptr", hToken, "UInt", TokenInformationClass, "Ptr", &TOKEN_INFORMATION, "UInt", ReturnLength, "UIntP", ReturnLength)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa446671(v=vs.85).aspx

;obtener LUID de un privilegio
;Sintaxis: LookupPrivilegeValue( [str privilegio] )
;Return: lpLuid
LookupPrivilegeValue(PrivilegeName) {
	Ok := DllCall("Advapi32.dll\LookupPrivilegeValueW", "Ptr", 0, "Ptr", &PrivilegeName, "Int64P", PrivilegeValue, "UInt")
	return PrivilegeValue, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379180(v=vs.85).aspx

;obtener una cadena de carácteres que reprecenta al privilegio
;Sintaxis: LookupPrivilegeName( [lpLuid] )
;Return: String
LookupPrivilegeName(lpLuid) {
	VarSetCapacity(Luid, 8, 0), NumPut(lpLuid, Luid, 0, "Int64")
	, DllCall("Advapi32.dll\LookupPrivilegeNameW", "Ptr", 0, "Ptr", &Luid, "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, (Size + 1) * 2)
	, DllCall("Advapi32.dll\LookupPrivilegeNameW", "Ptr", 0, "Ptr", &Luid, "Str", OutputVar, "UIntP", Size + 1)
	return OutputVar
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379176(v=vs.85).aspx

;comprueba si es un SID válido
;Sintaxis: IsValidSid( [pSID] )
IsValidSid(pSID) {
	return DllCall("Advapi32.dll\IsValidSid", "Ptr", pSID)
}

;convertir sid a formato string
;Sintaxis: ConvertSidToStringSid( [pSID], [out SID] )
;Return: SID
ConvertSidToStringSid(pSID) {
	Size := DllCall("Advapi32.dll\GetLengthSid", "Ptr", pSID)
	, VarSetCapacity(SID, Size * 2)
	, Ok := DllCall("Advapi32.dll\ConvertSidToStringSidW", "Ptr", pSid, "UPtr", &SID)
	return Ok?StrGet(l:=NumGet(SID), Size * 2, "UTF-16"):false,  LocalFree(l)
}

;convertir un SID en formato string a un SID válido
;Sintaxis: ConvertStringSidToSid( [SID] )
;Return: pSID
ConvertStringSidToSid(SID) {
	Ok := DllCall("Advapi32.dll\ConvertStringSidToSidW", "Ptr", &SID, "PtrP", pSID)
	return Ok?pSID:false, LocalFree(pSID)
}

;obtiene el nombre de usuario y dominio
;Sintaxis: LookupAccountSid( [pSID], [nombre se usuario (out)], [dominio (out)] )
LookupAccountSid(pSID, ByRef UserName := "", ByRef Domain := "") {
	DllCall("Advapi32.dll\LookupAccountSidW", "Ptr", 0, "Ptr", pSID, "Ptr", 0, "UIntP", SizeN:=0, "Ptr", 0, "UIntP", SizeD:=0, "Ptr", 0)
	, VarSetCapacity(UserName, SizeN * 2, 0), VarSetCapacity(Domain, SizeD * 2, 0)
	return DllCall("Advapi32.dll\LookupAccountSidW", "Ptr", 0, "Ptr", pSID, "Str", UserName, "UIntP", SizeN, "Str", Domain, "UIntP", SizeD, "Ptr", 0, "UInt")
}

FreeSid(pSID) {
	Ok := 0, Error := ErrorLevel
	for k, v in pSID
		Ok += DllCall("Advapi32.dll\FreeSid", "Ptr", v, "Ptr")=0
	return Ok=pSID.MaxIndex(), ErrorLevel := Error
}

;asigna e inicializa un nuevo descriptór de seguridad con hasta 8 subautoridades
;Sintaxis: InitializeSecurityDescriptor( [out SECURITY_DESCRIPTOR] )
InitializeSecurityDescriptor(ByRef SECURITY_DESCRIPTOR) {
	VarSetCapacity(SECURITY_DESCRIPTOR, 20, 0) ;SECURITY_DESCRIPTOR_MIN_LENGTH = 20
	, DllCall("Advapi32.dll\InitializeSecurityDescriptor", "Ptr", &SECURITY_DESCRIPTOR, "UInt", 1)
	return DllCall("Advapi32.dll\IsValidSecurityDescriptor", "Ptr", &SECURITY_DESCRIPTOR)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa378863(v=vs.85).aspx

;inicializa un identificador de seguridad (SID)
;Sintaxis: AllocateAndInitializeSid( [IdentifierAuthority], [SubAuthorities*] )
;Parámetros:
	;IdentifierAuthority: proporciona el identificador de autoridad de nivel superior a establecer en el SID. puede ser uno de los siguientes valores.
		;0 = SECURITY_NULL_SID_AUTHORITY
		;1 = SECURITY_WORLD_SID_AUTHORITY
		;2 = SECURITY_LOCAL_SID_AUTHORITY
		;3 = SECURITY_CREATOR_SID_AUTHORITY
		;4 = SECURITY_NON_UNIQUE_AUTHORITY
		;5 = SECURITY_NT_AUTHORITY
		;9 = SECURITY_RESOURCE_MANAGER_AUTHORITY
	;SubAuthorities: espesificar las subautoridades hasta un máximo de 8.
AllocateAndInitializeSid(IdentifierAuthority := 1, SubAuthorities*) {
	VarSetCapacity(SID_IDENTIFIER_AUTHORITY, 6, 0), NumPut(IdentifierAuthority, SID_IDENTIFIER_AUTHORITY, 0, "UChar"), Count := 0
	Loop, 8 {
		Authority := "SubAuthority" (A_Index - 1)
		if (SubAuthorities[A_Index]="")
			%Authority% := 0
		else Count := Count + 1, %Authority% := SubAuthorities[A_Index]
	} Ok := DllCall("Advapi32.dll\AllocateAndInitializeSid", "Ptr", &SID_IDENTIFIER_AUTHORITY, "UChar", Count, "UInt", SubAuthority0, "UInt", SubAuthority1
		, "UInt", SubAuthority2, "UInt", SubAuthority3, "UInt", SubAuthority4, "UInt", SubAuthority5, "UInt", SubAuthority6, "UInt", SubAuthority7, "PtrP", pSID)
	return Ok?pSID:false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa375213(v=vs.85).aspx












































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: INTERNET ::::::::::::::::::::::::::::::::::
;Constantes: https://msdn.microsoft.com/en-us/library/windows/desktop/aa383661(v=vs.85).aspx
;#############################################################################################################################################
;comprobar si una conexión a Internet puede ser establecida
;Sintaxis: InternetCheckConnection( [url] )
;Return: 0|1
InternetCheckConnection(URL := "https://www.google.com/") {
	return !!DllCall("Wininet.dll\InternetCheckConnectionW", "Ptr", &URL, "UInt", 1, "UInt", 0, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa384346(v=vs.85).aspx

;descargar archivo
;Sintaxis: Download( [URL], [Archivo], [¿sobreescribir?], [¿recuperar de la memoria caché cuando sea posible?] )
;Nota: omitir el 2do parámetro para obtener el texto sin crear el archivo.
Download(URL, Filename := "", OverWrite := true, UseCache := false) {
	static param := 0
	param++
	if (Filename="") {
		whr := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		, whr.Open("GET", Trim(URL) (UseCache?"":"?f=" param), true), whr.Send(), whr.WaitForResponse()
		return whr.ResponseText
	} if !(OverWrite) && (FileExist(Filename))
		return false, ErrorLevel := 2
	URLDownloadToFile, % Trim(URL) (UseCache?"":"?f=" param), %Filename%
	return !ErrorLevel
}

;comprueba si el equipo está conextado
;Nota: la funcion no comprueba si hay internet o no, usar InternetCheckConnection()
InternetGetConnectedState(Flags := 0x40) {
	return r:=DllCall("Wininet.dll\InternetGetConnectedState", "UInt*", Flags, "UInt", 0, "Int"), ErrorLevel := r?0:A_LastError
}

;obtener tamaño del archivo
;Sintaxis: InternetGetFileSize( [URL], [KB|MB|GB] )
InternetGetFileSize(URL, Units := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	if !(GetModuleHandle("Wininet.dll"))
		hModule := LoadLibrary("Wininet.dll")
	hInternet := InternetOpen(), hInternetUrl := InternetOpenUrl(hInternet, Url)
	if (StrLeft(URL, 4)="ftp:")
		FileSize := DllCall("Wininet.dll\FtpGetFileSize", "Ptr", hInternetUrl, "UIntP", 0)  
	else DllCall("Wininet.dll\HttpQueryInfoW", "Ptr", hInternetUrl, "UInt", 0x20000005, "UIntP", FileSize, "UIntP", 4, "UIntP", 0)
	if (hModule)
		FreeLibrary(hModule)
	return _[Units]?FileSize/_[Units]:FileSize, ErrorLevel := !FileSize, InternetCloseHandle(hInternetUrl, hInternet)
}

;Inicializa la aplicación para el uso de las funciones de WinInet
;Sintaxis: InternetOpen( [nombre de usuario en el protocolo HTTP], [acceso], [nombre del servidor proxi], [nombres de host y/o direcciones IP], [opciones] )
;Accesos: PRECONFIG=0 | DIRECT=1 | PROXY=3 | PRECONFIG_WITH_NO_AUTOPROXY=4
;Opciones: ASYNC=0x10000000 | FROM_CACHE=0x01000000 | OFFLINE=0x01000000
;Return: hInternet (HANDLE)
InternetOpen(Agent := "Microsoft Internet Explorer", AccessType := 4, ProxyName := "", ProxyBypass := "", Flags := 0) {
	return DllCall("Wininet.dll\InternetOpenW", "Ptr", &Agent, "UInt", ProxyName=""?AccessType:(AccessType:=3)
	, "Ptr", AccessType=3?&ProxyName:0, "Ptr", AccessType=3?&ProxyBypass:0, "UInt", Flags, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa385096(v=vs.85).aspx

;abre un recurso especificado por un FTP, HTTP o URL completa
;Sintaxis: InternetOpenUrl( [hInternet], [URL ftp|http|https], [HEADERS], [tamaño], [opciones], [Context] )
;Return: hInternetUrl (HANDLE)
InternetOpenUrl(hInternet, Url, Headers := 0, HeadersLength := 0, Flags := 0x84000000, Context := 0) {
	return DllCall("Wininet.dll\InternetOpenUrlW", "Ptr", hInternet, "Ptr", &Url, "Ptr", Headers, "UInt", HeadersLength, "UInt", Flags, "UInt", Context, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa385098(v=vs.85).aspx

;cerrar HANDLE de internet
;Sintaxis: InternetCloseHandle( [HANDLE 1, HANDLE 2, HANDLE 3, ...] )
InternetCloseHandle(HANDLE*) {
	Error := ErrorLevel, c := 0
	Loop, % (HANDLE.MaxIndex())
		c += !!DllCall("Wininet.dll\InternetCloseHandle", "Ptr", HANDLE[A_Index], "Int")
	return c, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa384350(v=vs.85).aspx

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

;enviar e-mail
;Sintáxis: EmailSend( [email], [contraseña], [email destino], [cuerpo], [asunto] )
;NOTA: para gmail activar el Acceso De Aplicaciones Menos Seguras (emisor): https://www.google.com/settings/security/lesssecureapps
EmailSend(User, Pass, To, Body, Subject := "", CC := "", BCC := "", Attach := "") {
	pmsg := ComObjCreate("CDO.Message")
	, pmsg.From := User
	, pmsg.To := To, pmsg.BCC := BCC, pmsg.CC := CC
	, pmsg.Subject := Subject, pmsg.TextBody := Body
	, sAttach := Attach
	Loop, Parse, % sAttach, `n, `r
		pmsg.AddAttachment(A_LoopField)
	fields := Object()
	, fields.smtpserver := "smtp.gmail.com" ; specify your SMTP server
	, fields.smtpserverport := 465 ; 25
	, fields.smtpusessl := True ; False
	, fields.sendusing := 2 ; cdoSendUsingPort
	, fields.smtpauthenticate := 1 ; cdoBasic
	, fields.sendusername := User
	, fields.sendpassword := Pass
	, fields.smtpconnectiontimeout := 60
	, schema := "http://schemas.microsoft.com/cdo/configuration/"
	, pfld := pmsg.Configuration.Fields
	for field, value in fields
		pfld.Item(schema . field) := value
	pfld.Update()
	try pmsg.Send()
	catch
		return false
	return true
}

Ping(Address, Timeout := 1000, ByRef Data := "", Length := 0, ByRef Result := "", ByRef ResultLength := 0) {
    if ((NumericAddress:=DllCall("ws2_32.dll\inet_addr", "AStr", Address, "UInt"))=0xFFFFFFFF)
		return false, ErrorLevel := 2
	if !GetModuleHandle("icmp.dll")
		hModule := LoadLibrary("icmp.dll")
    if ((hPort:=DllCall("icmp.dll\IcmpCreateFile", "UPtr"))=-1)
		return false, ErrorLevel := 3
    VarSetCapacity(Reply, 278, 0), Count := DllCall("icmp.dll\IcmpSendEcho", "UPtr", hPort, "UInt", NumericAddress
	, "UPtr", &Data, "UShort", Length, "UPtr", 0, "UPtr", &Reply, "UInt", 278, "UInt", Timeout, "UInt")
    If (NumGet(Reply, 4, "UInt")=11001)
		VarSetCapacity(Reply, 278 * Count, 0), DllCall("icmp.dll\IcmpSendEcho", "UPtr", hPort, "UInt", NumericAddress
		, "UPtr", &Data, "UShort", Length, "UPtr", 0, "UPtr", &Reply, "UInt", 278 * Count, "UInt", Timeout)
    If !(NumGet(Reply,4,"UInt")=0)
        return false, ErrorLevel := 4
    l:=DllCall("icmp.dll\IcmpCloseHandle", "UPtr", hPort), ResultLength := VarSetCapacity(Result, NumGet(Reply, 12, "UShort"), 0)
    , MoveMemory(&Result, NumGet(Reply,16), ResultLength), hModule := hModule?FreeLibrary("icmp.dll"):false
    return NumGet(Reply, 8, "UInt"), ErrorLevel := !l
}










































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: DISPOSITIVOS Y APLICACIONES PREDETERMINADAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;IMPRESORAS Y FAXES
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;establecer impresora predeterminada
;Sintaxis: SetDefaultPrinter( [str nombre que puede verse en el panel de control] )
;Return: 0|1
SetDefaultPrinter(Printer := 0) {
	return DllCall("Winspool.drv\SetDefaultPrinterW", "Ptr", &Printer, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd162971(v=vs.85).aspx
 
;obtener impresora predeterminada
;Return: str nombre
;ErrorLevel: 0|1
GetDefaultPrinter() {
	DllCall("Winspool.drv\GetDefaultPrinterW", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, Size * 2, 0)
	, Ok := DllCall("Winspool.drv\GetDefaultPrinterW", "Str", OutputVar, "UIntP", Size, "Int")
	return OutputVar, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/dd144876(v=vs.85).aspx
 
;enumerar todos los dispositivos de impresora y fax
;Return: [{uint Flags, str Description, str Name, str Comment}]
	;for k, v in EnumPrinters()
	;	MsgBox % "#" k "`nFlags: " v.Flags "`nDescription: " v.Description
	;		. "`nName: " v.Name "`nComment: " v.Comment
EnumPrinters() {
	DllCall("Winspool.drv\EnumPrintersW", "UInt", 0x00000002, "Ptr", 0, "UInt", 1, "Ptr", 0, "UInt", 0, "UIntP", Size, "UIntP", 0)
	, VarSetCapacity(PRINTER_INFO_1, Size * 2, 0)
	, DllCall("Winspool.drv\EnumPrintersW", "UInt", 0x00000002, "Ptr", 0, "UInt", 1, "Ptr", &PRINTER_INFO_1, "UInt", Size, "UIntP", 0, "UIntP", Count)
	, Offset := A_PtrSize=4?-16:-28, List := []
	Loop, % Count
		Info := {}, Offset += A_PtrSize=4?16:28
		, Info.Flags := NumGet(PRINTER_INFO_1, Offset, "UInt")
		, Info.Description := StrGet(NumGet(PRINTER_INFO_1, Offset+A_PtrSize))
		, Info.Name := StrGet(NumGet(PRINTER_INFO_1, Offset+(A_PtrSize*2)))
		, Info.Comment := StrGet(NumGet(PRINTER_INFO_1, Offset+(A_PtrSize*3)))
		, List.Push(Info)
	return List
}


















































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: BARRA DE TAREAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establecer porcentaje de progreso en la barra de tareas
;Sintaxis: TaskBarProgress( [ESTADO], [Ventana ID] )
;ESTADOS: 0~100, Normal, Paused, Indeterminate, Error
;Nota: usar TaskBarProgress(-1) cuando ya no lo necesite
TaskBarProgress(hWnd, State := 0) { ;http://ahkscript.org/boards/viewtopic.php?p=48329#p48329
	static States := {0: 0, l: 1, Indeterminate: 1, n: 2, Normal: 2, e: 4, Error: 4, p: 8, Paused: 8}
	static ppv
	if (hWnd=-1)
		return ObjRelease(ppv), ppv := ""
	if !(ppv)
		ppv := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf}")
	_gethwnd(hWnd)
	if (States[State]="")
		return DllCall(NumGet(NumGet(ppv+0)+9*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "Int64", State * 10, "Int64", 1000)
	return DllCall(NumGet(NumGet(ppv+0)+10*A_PtrSize), "Ptr", ppv, "Ptr", hWnd, "UInt", States[State])
} ;https://msdn.microsoft.com/en-us/library/dd391698(v=vs.85).aspx

;quitar/mostrar boton de la ventana en la barra de tareas
;Sintaxis: TaskBarRemove( [ID], [¿mostrar?] )
TaskBarRemove(hWnd, Show := false) {
	_gethwnd(hWnd)
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	, DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (Show?4:5)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd), ObjRelease(hTaskBar)
}

;activa la ventana en la barra de tareas
;TaskBarActivate( [ID], [¿marcar siempre como activo (no visualmente)?] )
TaskBarActivate(hWnd, SetActiveAlt := 0) {
	hTaskBar := ComObjCreate("{56FDF344-FD6D-11d0-958A-006097C9A090}", "{56FDF342-FD6D-11d0-958A-006097C9A090}")
	, DllCall(NumGet(NumGet(hTaskBar+0), 3*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd)
	return DllCall(NumGet(NumGet(hTaskBar+0), (SetActiveAlt?7:6)*A_PtrSize), "Ptr", hTaskBar, "Ptr", hWnd), ObjRelease(hTaskBar)
}

;obtiene posicion de la barra de tareas
;Sintaxis: TaskBarGetPos( [xpos], [ypos], [ancho], [alto] )
TaskBarGetPos(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	return GetWindowPos(GetTaskBar(), x, y, Width, Height)
}

;obtiene hWnd de la barra de tareas, opcional: área de notificacion, reloj y boton inicio
;Sintaxis: GetTaskBar( [área de notificacion], [área de notificacion (iconos ocultos)], [reloj], [boton inicio] )
GetTaskBar(ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := FindWindow("Shell_TrayWnd")
	if IsByRef(hNotifArea)||IsByRef(hOverFNotifArea)||IsByRef(hTrayClock) {
		hNotify := FindWindowEx(hTaskBar,, "TrayNotifyWnd")
		, hSyspager := FindWindowEx(hNotify,, "SysPager")
		if !(hNotifArea := FindWindowEx(hSyspager,, "ToolbarWindow32", "User Promoted Notification Area"))
			if !(hNotifArea := FindWindowEx(hSyspager,, "ToolbarWindow32", "Notification Area"))
				hNotifArea := FindWindowEx(hSyspager,, "ToolbarWindow32")
		if IsByRef(hOverFNotifArea)
			hNotifIcon := FindWindow(, "NotifyIconOverflowWindow"), hOverFNotifArea := FindWindowEx(hNotifIcon,, "ToolbarWindow32"
			, "Overflow Notification Area"), hOverFNotifArea := hOverFNotifArea?hOverFNotifArea:hNotifArea
	} if IsByRef(hTrayClock)
		hTrayClock := FindWindowEx(hNotify,, "TrayClockWClass")
	if IsByRef(hStartButton)
		hStartButton := FindWindowEx(hTaskBar,, "Button"), hStartButton := hStartButton?hStartButton:FindWindowEx(hTaskBar,, "Start")
	return hTaskBar
}

;redibujar barra de tareas, área de notificacion, reloj y boton inicio.
TaskBarRedraw(ByRef hTaskBar := "", ByRef hNotifArea := "", ByRef hOverFNotifArea := "", ByRef hTrayClock := "", ByRef hStartButton := "") {
	hTaskBar := GetTaskBar(hNotifArea, hOverFNotifArea, hTrayClock, hStartButton)
	return i:=WinRedraw(hTaskBar)+WinRedraw(hNotifArea)+WinRedraw(hOverFNotifArea)+WinRedraw(hTrayClock)+WinRedraw(hStartButton)
		, ErrorLevel := i!=5
}

;obtiene los iconos en el area de notificacion +info.
;Nota: requiere WIN_V+
;Ejemplo:
	;for k, v in TaskBarTrayIconsEnum() {
	;	TaskBarTrayIconHide(v.CMD,, v.Hidden)
	;	MsgBox % "hWnd: " v.hWnd "`nCommand: " v.CMD "`nIcon: " v.Icon "`nMsg: " v.Msg "`nHidden: " v.Hidden "`nID: " v.ID "`nTip: " v.Tip
	;	TaskBarTrayIconHide(v.CMD, false, v.Hidden)
	;}
TaskBarTrayIconsEnum() {
	List := [], GetTaskBar(hNotifArea, hOverFNotifArea)
	Loop, Parse, % (hNotifArea=hOverFNotifArea?hNotifArea:hNotifArea "." hOverFNotifArea), .
	{	Index := A_Index, hProcess := OpenProcess(WinGetPid(A_LoopField), 0x38), pAddress := VirtualAlloc(hProcess,, 20)
        , Size := VarSetCapacity(TBBUTTON, A_PtrSize=4?24:32, 0), VarSetCapacity(v2, Size, 0), s3 := VarSetCapacity(v3, 128 * 2, 0)
		Loop, % SendMessage(A_LoopField, 0x418,,,,, "UIntP") {
			SendMessage(A_LoopField, 0x417, "Int", A_Index-1, "UInt", pAddress), ReadProcessMemory(hProcess, pAddress, &TBBUTTON, Size)
            , Bitmap := NumGet(TBBUTTON, 0, "Int"), Command := NumGet(TBBUTTON, 4, "Int"), Statyle := NumGet(TBBUTTON, 8, "UInt")
			, Data := NumGet(TBBUTTON, A_PtrSize=4?12:16, "Ptr"), String := NumGet(TBBUTTON, A_PtrSize=4?16:24, "Ptr")
			, ReadProcessMemory(hProcess, ["Ptr", Data], &v2, Size), hWnd := NumGet(v2, 0, "Ptr"), ID := NumGet(v2, A_PtrSize)
			, Msg  := NumGet(v2, A_PtrSize=4?8:12), hIcon := NumGet(v2, A_PtrSize=4?20:24, "Ptr"), ReadProcessMemory(hProcess, ["Ptr", String], &v3, s3)
			, List.Push({hWnd: hWnd, CMD: Command, ID: ID, Msg: Msg, Icon: hIcon, Hidden: (Index=2), Tip: StrGet(&v3, s3, "UTF-16")})
		} VirtualFree(hProcess, pAddress), CloseHandle(hProcess)
	} return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb760478%28v=vs.85%29.aspx

;ocultar/mostrar icono en el área de notificación.
;Sintaxis: TaskBarTrayIconHide( [hWnd], [0|1] )
TaskBarTrayIconHide(CMD, Hide := true, Hidden := false) {
	GetTaskBar(hNotifArea, hOverFNotifArea)
	if (Hidden) || !(SendMessage(hNotifArea, 0x404,, CMD, "Int", !!Hide))
		return SendMessage(hOverFNotifArea, 0x404,, CMD, "Int", !!Hide), SendMessage(hOverFNotifArea, 0x1A)
	return true, SendMessage(hNotifArea, 0x1A)
}

;habilitar/deshabilitar icono en el área de notificación.
;Sintaxis: TaskBarTrayIconEnable( [hWnd], [0|1] )
TaskBarTrayIconEnable(CMD, Enable := true, Hidden := false) {
	GetTaskBar(hNotifArea, hOverFNotifArea)
	if (Hidden) || !(SendMessage(hNotifArea, 0x400+1,, CMD, "Int", !!Enable))
		return SendMessage(hOverFNotifArea, 0x400+1,, CMD, "Int", !!Enable)
	return true
}





















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ESCRITORIO & EXPLORADOR & PAPELERA DE RECICLAJE & MENU INICIO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;PAPELERA DE RECICLAJE
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;recupera el tamaño de la papelera de reciclaje (en bytes) y el número de elementos que contiene para una unidad especificada.
;Sintaxis: RecycleBinGetSize( [unidad], [unidades (KB|MB|GB)], [elementos (salida)] )
RecycleBinGetSize(Path, Units := "", ByRef i64NumItems := "") {
	static _ := {"KB": 1024, "MB": 1024 ** 2, "GB": 1024 ** 3}
	cbSize := VarSetCapacity(SHQUERYRBINFO, A_PtrSize=4?20:36, 0), NumPut(cbSize, SHQUERYRBINFO, 0, "UInt")
	, Result :=  DllCall("Shell32.dll\SHQueryRecycleBinW", "Str", StrLeft(Trim(Path)) ":\", "Ptr", &SHQUERYRBINFO)
	, i64Size := NumGet(SHQUERYRBINFO, 4, "Int64"), i64NumItems := IsByRef(i64NumItems)?NumGet(SHQUERYRBINFO, 12, "Int64"):""
	return _[Units]?i64Size/_[Units]:i64Size, ErrorLevel := Result
}

;vacía la Papelera de reciclaje en la unidad especificada.
;Sintaxis: RecycleBinEmpty( [unidad], [¿ocultar dialgos de confirmacion?], [¿ocultar dialogos de progreso?], [¿no reproducir sonidos?] )
RecycleBinEmpty(Path, NoConfirmation := true, NoProgressUI := true, NoSound := true) {
	r := DllCall("Shell32.dll\SHEmptyRecycleBinW", "Ptr", A_ScriptHwnd, "Str", StrLeft(Trim(Path)) ":"
	, "UInt", (NoConfirmation?0x00000001:0)|(NoProgressUI?0x00000002:0)|(NoSound?0x00000004:0))
	return !r, ErrorLevel := r
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;EXPLORADOR
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;reiniciar explorador de windows
RestartWindowsExplorer() {
	Loop, Parse, % WinEnum(), `n
	{ 	ThreadId := GetWindowThreadProcessId(A_LoopField, ProcessId)
		if (GetModuleFileName("/" ProcessId) = A_WinDir "\explorer.exe")
			PostMsg(A_LoopField, 0x0016,, 0x1)
			, PostMsg(A_LoopField, 0x0012)
}	} ;http://www.replicator.org/journal/200908012325-how-to-shutdown-explorerexe-gracefully-from-c

;obtener ruta de la ventana del explorador de windows espesificada
;Sintaxis: GetExplorerWindowPath( [hWnd] )
;ErrorLevel: 
	;0 = Ok
	;1 o 2 = Error
	;3 = es posible que la ruta sea una biblioteca o el quipo, devuelve el nombre
	;4 = la ventana espesificada es inválida
GetExplorerWindowPath(hWnd := -1) {
	static spn := {"Documentos": "Documents", "Música": "Music", "Imágenes": "Pictures", "Juegos": "Games"}
	Class := GetWindowClass(hWnd), hWnd := hWnd=-1?IsWindow():hWnd
	if (Class=="Progman") || (Class=="WorkerW")
		return A_Desktop, ErrorLevel := false
	if (Class="CabinetWClass") || (Class="ExploreWClass") {
		for this in ComObjCreate("Shell.Application").Windows {
			if (this.hWnd=hWnd) {
				if (this.LocationURL="") {
					if (this.LocationName="")
						return false, ErrorLevel := true
					;Loop, Files, %A_AppData%\Microsoft\Windows\Libraries\*.*, F
					;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace
					;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FolderDescriptions
					return this.LocationName, ErrorLevel := this.LocationName=""?2:3
				} return RTrim(StrReplace(UriDecode(LTrim(LTrim(Trim(this.LocationURL), "ftp:///"), "file:///")), "/", "\"), "\")
	}	}	} return false, ErrorLevel := 4
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;MENÚ INICIO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;muestra el menú inicio
ShowStartMenu() {
	return PostMessage(IsWindow(), 0x112, "UInt", 0xF130)
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;ESCRITORIO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;muestra el escritorio y establece foco en él
;Sintaxis: ShowDesktop( [¿esperar? (segundos)], [¿redibujar?] )
ShowDesktop(Wait := -1, Redraw := false) {
	ComObjCreate("shell.application").ToggleDesktop(), WindowActive(GetDesktop(), true)
	, WinWaitActive(GetDesktop(), Wait)
	if (Redraw)
		DesktopRedraw()
}

;obtener hWnd del control SysListView32 del escritorio (control de los iconos)
;Ejemplo: 
	;MsgBox % "hDesktopListView: " GetDesktop(hShellWin, hDesktopWnd, hProgman, hWorkerW) "`nhShellWin: " hShellWin
		;. "`nhDesktopWnd: " hDesktopWnd "`nhProgman: " hProgman "`nhWorkerW: " hWorkerW
GetDesktop(ByRef hShellWin := "", ByRef hDesktopWnd := "", ByRef hProgman := "", ByRef hWorkerW := "") {
	hProgman := FindWindow("Progman")
	if (hShellViewWin:=FindWindowEx(hProgman,, "SHELLDLL_DefView"))
		hDesktopListView := FindWindowEx(hShellViewWin,, "SysListView32")
	if IsByRef(hShellWin)
		hShellWin := DllCall("User32.dll\GetShellWindow")
	if IsByRef(hDesktopWnd) || IsByRef(hWorkerW) || !(hShellViewWin) {
		hDesktopWnd := DllCall("User32.dll\GetDesktopWindow")
		if IsByRef(hWorkerW) || !(hShellViewWin)
			hWorkerW := FindWindowEx(hDesktopWnd,, "WorkerW")
		if !(hShellViewWin) {
			hShellViewWin := FindWindowEx(hWorkerW,, "SHELLDLL_DefView")
			if !(hShellViewWin) && !(hWorkerW2:=0) 
				Loop {
					hWorkerW2 := FindWindowEx(hDesktopWnd, hWorkerW2, "WorkerW")
					hShellViewWin := FindWindowEx(hWorkerW2,, "SHELLDLL_DefView")
				} until !(hWorkerW2) || (hShellViewWin)
			if (hShellViewWin)
				hDesktopListView := FindWindowEx(hShellViewWin,, "SysListView32")
		}
	} return hDesktopListView
}

;redibujar escritorio
DesktopRedraw(ByRef hDesktop := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop()
	return WinRedraw(hDesktop)
}

;obtener cantidad de iconos en el escritorio
DesktopIconCount(ByRef hDesktop := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop()
	return LV_GetItemCount(hDesktop)
}

;obtener una lista con todos los iconos visibles del escritorio
DesktopIconList(ByRef hDesktop := "", ByRef ProcessId := "") {
	hDesktop := hDesktop?hDesktop:GetDesktop(), Count := DesktopIconCount(hDesktop)
	, ProcessId := ProcessId?ProcessId:WinGetPid(hDesktop)
	Loop, %Count%
		List .= LV_GetItemTextEx(hDesktop, A_Index,, ProcessId) "`n"
	return Rtrim(List, "`n")
}

;guardar captura de pantalla
;Sintaxis: SaveScreenshot( [archivo destino], [coordenadas] )
;Archivo destino:  .bmp, .jpg, .png, .tif, .gif
;Coordenadas:
	;--> Array con las coordenadas: [x, y, ancho, alto].
	;--> Toda la pantalla: Screen. Defecto.
	;--> Ventana activa: Window | A. Nota: la ventana debe estar visible.
	;--> Array con el ID de una ventana: ["ID", hWnd]. Nota: la ventana debe estar visible.
;Ejemplos:
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_1.jpg", [0, 0, 500, 350]) ;por coordenadas.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_2.jpg", "Screen") ;pantalla entera.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_3.jpg", "Window") ;ventana activa.
	;MsgBox % SaveScreenshot(A_Desktop "\Screenshot_4.jpg", ["ID", GetTaskbar()]) ;ventana espesificada (barra de tareas).
SaveScreenshot(Filename, Pos := "Screen") {
	GdiplusStartup(hModule), k := 0x0
	if (Pos="Window") || (Pos="A") || (Pos[1]="ID") 
		GetWindowPos(k:=IsObject(Pos)?Pos[2]:IsWindow(), x, y, w, h)
	else x := ((Pos="Screen")||(Pos[1]="")||!(Pos[1]>-1))?0:Pos[1], y := ((Pos="Screen")||(Pos[2]="")||!(Pos[2]>-1))?0:Pos[2]
	, w := ((Pos="Screen")||(Pos[3]="")||!(Pos[3]>0))?A_ScreenWidth:Pos[3], h := ((Pos="Screen")||(Pos[4]="")||!(Pos[4]>0))?A_ScreenHeight:Pos[4]
	pBitmap := GdipBitmapFromScreen(x "|" y "|" w "|" h, 0x40000000+0x00CC0020), GdipSetInterpolationMode(pBitmap)
	, GdipSetSmoothingMode(pBitmap), GdipSetTextRenderingHint(pBitmap), GdipSaveBitmapToFile(pBitmap, Filename,, k), GdipDisposeImage(pBitmap)
	return true, GdiplusShutdown(, hModule)
}

;obtiene la posición de los iconos del escritorio.
;Ejemplo: 
	;for k, v in DesktopGetIconsPos()
	;	MsgBox %  "Nombre: " k "`nPosición: " v[1] "x" v[2]
DesktopGetIconsPos(ByRef hDesktop := "", ByRef ProcessId := "") {
	Array := []
	Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
		Pos := LV_GetItemPosEx(hDesktop, A_Index,,, ProcessId)
		, Array[A_LoopField] := [Pos[1], Pos[2]]
	return Array
}

;establece la posición de los iconos del escritorio.
;Ejemplo: guardar y reestablecer la posicion de los iconos
	;DesktopIconsPos := DesktopGetIconsPos(hDesktop, ProcessId)
	;MsgBox mueva un icono en el escritorio!
	;DesktopSetIconsPos(DesktopIconsPos, hDesktop, ProcessId)
	;MsgBox los iconos han sido restaurados a su posición original!
	;ExitApp
DesktopSetIconsPos(IconsPos, ByRef hDesktop := "", ByRef ProcessId := "") {
	i := 0
	Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
	{	if (IconsPos[A_LoopField][1]!="") {
			IconIndex := "", ItemName := A_LoopField
			Loop, Parse, % DesktopIconList(hDesktop, ProcessId), `n
			{	if (A_LoopField=ItemName) {
					IconIndex := A_Index
					break
			}} if (IconIndex="")
					continue
			i+=LV_SetItemPosEx(hDesktop, IconIndex, IconsPos[A_LoopField][1], IconsPos[A_LoopField][2], ProcessId)
			, r := A_Index
	}} return i=r, ErrorLevel := !(i=r)
}

;cambiar imagen de fondo del escritorio
;Sintaxis: SetDesktopWallpaper( [imagen], [ancho], [alto], [archivo] )
;Ancho / Alto: espesificar las nuevas dimenciones para la imagen o dejar vacío para no modificar
;Archivo: espesificar el archivo donde guardar la imagen a establecer como fondo de escritorio con extension .bmp
SetDesktopWallpaper(Image, Width := "", Height := "", File := "") {
	File := File?File:A_AppData "\Microsoft\Windows\Themes\TranscodedWallpaper.bmp", SplitPath(Image,,, Ext)
	if !(Ext="bmp")
		GdiplusStartup(hModule), ImageConvert(Image, File, Width, Height), GdiplusShutdown(, hModule)
	else CopyFile(Image, File, true)
	return r:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0014, "UInt", 0, "Ptr", &File, "UInt", 0x0001|0x0002), ErrorLevel := !r
}

;obtener ruta de la imagen de fondo del escritorio
;Sintaxis: GetDesktopWallpaper()
GetDesktopWallpaper() {
	VarSetCapacity(OutputVar, 260 * 2, 0)
	, Ok := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0073, "UInt", 260, "Str", OutputVar, "UInt", 0)
	return OutputVar, ErrorLevel := !Ok
}

DesktopGetShellWindows() {
	static SWDesktop
	if !(IsObject(SWDesktop)) {
		ShellWindows := ComObjCreate("Shell.Application").Windows
		VarSetCapacity(_hwnd, 4, 0), SWDesktop := ShellWindows.FindWindowSW(0, "", 8, ComObj(0x4003, &_hwnd), 1)
	} return SWDesktop, ErrorLevel := !IsObject(SWDesktop)
}

;refrezcar escritorio
DesktopRefresh() {
	return IsObject(SWDesktop:=DesktopGetShellWindows()), SWDesktop.Refresh()
}

;obtener elementos seleccionados
;Sintaxis: DesktopSelectedItems( [total], [¿quitar seleccion?] )
;Ejemplo:
	;Loop, Parse, % DesktopSelectedItems(c), `n
	;	MsgBox % A_LoopField
	;MsgBox % "Total: " c
DesktopSelectedItems(ByRef Count := "", Deselect := false) {
	sfv := DesktopGetShellWindows().Document, items := sfv.SelectedItems
    Loop % (Count:=items.Count) {
		List .= (List=""?"":"`n") items.Item(A_Index-1).Name
		if (Deselect)
			sfv.SelectItem(items.Item(A_Index-1), false)
	} return List, ErrorLevel := !IsObject(items)
} ;http://msdn.microsoft.com/en-us/library/dd894076
	
;seleccionar/deseleccionar item
;Sintaxis: DesktopSelectItem( [nombre], [0|1] )
DesktopSelectItem(Name, State := true) {
	sfv := DesktopGetShellWindows().Document, items := sfv.SelectedItems
	return !(ErrorLevel:=!IsObject(items)), sfv.SelectItem(items.Item(Name), !!State)
}

;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;ESCRITORIO VIRTUAL (WIN_10+)
;----------------------------------------------------------------------------------------------------------------------------------------------------------------
;determina si la ventana espesificada es visible en el escritorio virtual actual
;Sintaxis: IsWindowOnCurrentVirtualDesktop( [hWnd] )
;Return: 0 | 1
IsWindowOnCurrentVirtualDesktop(hWnd) {
	_gethwnd(hWnd)
	return IVirtualDesktopManager.IsWindowOnCurrentVirtualDesktop(hWnd)
}































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: NOTIFICACIONES & MENSAJES ::::::::::::::::::::::::::::::::::
;Para usar con OnMessage():
	;Links:
		;Keyboard Input Notifications: https://msdn.microsoft.com/en-us/library/windows/desktop/ff468861(v=vs.85).aspx
		;Virtual-Key Codes: https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
	;Uso:
		;Para registrar: OnMessage( [mensaje], [función] )
		;Para anular: OnMessage( [mensaje], "" )
		;Para obtener función: OnMessage( [mensaje] )
	;Notas:
		;la variable A_Gui identifica a la ventana activa sobre la cual se procesa el mensaje
		;los mensajes registrados con OnMessage() solo tienen efecto cuando hay una ventana activa del proceso invocador
;#############################################################################################################################################
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;NOTIFICACIONES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;registra los clics o movimientos del mouse en el icono del área de notificacion
;Sintaxis: RegisterTrayIconClickNotification( [funcion a llamar al hacer clic] )
;Mensajes que recibe la funcion:
	;Parametro 1: Normal | RightClick | DoubleClick | MouseOver
	;Parametro 2: Valor original sin modificar
RegisterTrayIconClickNotification(Func, lParam := "*") {
	static Event := {514: "Normal", 517: "RightClick", 515: "DoubleClick", 512: "MouseOver"}
	static Call
	if (lParam!="*") {
		if IsFunc(Call)
			return %Call%(Event[lParam], lParam), NormalClickCount := 0
	} else if !IsFunc(Func)
		return true, OnMessage(0x404, Call:="")
	else return OnMessage(0x404, A_ThisFunc), Call := Func
}

;registra el estado de la tapa del portatil
;Sintaxis: RegisterPowerSettingNotification( [funcion a llamar cuando la tapa se abra/cierre] )
;Mensajes que recibe la funcion:
	;Parametro 1: Closed | Opened
	;Parametro 2: Mensaje
;EJEMPLO:
	;RegisterPowerSettingNotification("WM_POWERBROADCAST")
	;WM_POWERBROADCAST(wParam, lParam){
	;	SoundBeep, % wParam="Opened"?750:250
	;}
RegisterPowerSettingNotification(Func, lParam := "*") {
	static Call, hPower
	if (lParam!="*") {
		if IsFunc(Call) {
			if (NumGet(lParam+0, 0, "UInt")=0xBA3E0F4D)
				%Call%(Func=0x8013?(Numget(lParam+0, 20, "UChar")?"Opened":"Closed"):"", lParam)
	}} else if !IsFunc(Func) {
		return DllCall("User32.dll\UnregisterPowerSettingNotification", "Ptr", hPower), OnMessage(0x218, Call:="")
	} else {
		VarSetCapacity(GLSC, 16), DllCall("ole32\CLSIDFromString", "WStr", "{BA3E0F4D-B817-4094-A2D1-D56379E6A0F3}", "Ptr", &GLSC)
		return hPower:=DllCall("User32.dll\RegisterPowerSettingNotification", "Ptr", A_ScriptHwnd, "Ptr", &GLSC, "UInt", 0)
			, OnMessage(0x218, A_ThisFunc), Call := Func
}} ;http://ahkscript.org/boards/viewtopic.php?p=51804#p51804

;registra para recibir notificaciones de cambio de sesión
;Sintaxis: RegisterSessionNotification( [estado], [sesion], [funcion que recibe las notificaciones] )
;Estado: 1 = activar | 0 = desactivar || Sesion: 1 = todas las sesiones | 0 = solo la sesion actual
;Notificaciones: http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
;Param1=valor modificado | param2=valor sin modificar
RegisterSessionNotification(Status, Session := 1, Func := "") { ;http://ahkscript.org/boards/viewtopic.php?p=49343&sid=7aec8109cd649383ae6743a2ef766c8d#p49343
	if Status&&IsFunc(Func)&&DllCall("wtsapi32.dll\WTSRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd, "UInt", Session)
        return 1, OnMessage(0x02B1, "WM_WTSSESSION_CHANGE"), WM_WTSSESSION_CHANGE(0,0,Func), ErrorLevel := 0
    else if DllCall("wtsapi32.dll\WTSUnRegisterSessionNotificationEx", "Ptr", 0, "Ptr", A_ScriptHwnd)
		return 1, OnMessage(0x02B1, ""), ErrorLevel := 0
    return 0, Func := "", ErrorLevel := 1
} WM_WTSSESSION_CHANGE(wParam, lParam, SetFunc := "*") {
	static Func
	static code := {0x1: "CONSOLE_CONNECT", 0x2: "CONSOLE_DISCONNECT", 0x4: "REMOTE_CONNECT"
		, 0x4: "REMOTE_DISCONNECT", 0x5: "SESSION_LOGON", 0x6: "SESSION_LOGOFF"
		, 0x7: "SESSION_LOCK", 0x8: "SESSION_UNLOCK", 0x9: "SESSION_REMOTE_CONTROL"}
	return true, i:=SetFunc!="*"?(Func:=SetFunc):%Func%(code[wParam], wParam)
} ;https://msdn.microsoft.com/library/aa383828%28vs.85,en-us%29

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
;MENSAJES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
PostMsg(hWnd, Msg, wParam := 0, lType := 0) {
	return DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", Msg, "Ptr", wParam, "Ptr", IParam)
} PostMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0) {
	Error := !DllCall("User32.dll\PostMessageW", "Ptr", hWnd, "UInt", Msg, wType, wParam, IType, IParam, "Int")
	return !Error, ErrorLevel := Error
}

SendMsg(hWnd, Msg, ByRef wParam := 0, ByRef lParam := 0, ReturnType := "UPtrP", Timeout := 5000, Flags := 0x0002) {
	if IsObject(wParam)
		wType := wParam.1, wParam := wParam.2
	else wType := (wParam+0)=""?"Str":"Ptr"
	if IsObject(lParam)
		lType := lParam.1, lParam := lParam.2
	else lType := (lParam+0)=""?"Str":"Ptr"
	Ok := DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", Abs(Msg), wType, wParam, lType, lParam, "UInt", Flags, "UInt", Timeout, ReturnType, OutputVar)
	return OutputVar, ErrorLevel := Ok?false:A_LastError
} SendMessage(hWnd, Msg, wType := "Ptr", ByRef wParam := 0, IType := "Ptr", ByRef IParam := 0, ReturnType := "UPtrP", Timeout := 5000) {
	Error := !DllCall("User32.dll\SendMessageTimeoutW", "Ptr", hWnd, "UInt", Msg
	, wType, wParam, IType, IParam, "UInt", 0x0002, "UInt", Timeout, ReturnType, OutputVar, "UInt")
	return OutputVar, ErrorLevel := Error?(Error+(A_LastError=124)):false ;ERROR_TIMEOUT = 124
}

WM_COPYDATA(hWnd, dwData := 1, Size := 0, lpData := 0) {
	_gethwnd(hWnd), VarSetCapacity(COPYDATASTRUCT, 3*A_PtrSize, 0)
	, NumPut(dwData, COPYDATASTRUCT, 0, "UPtr")
	, NumPut(Size?Size:((StrLen(lpData)+1)*2), COPYDATASTRUCT, A_PtrSize, "UInt")
	, NumPut(lpData, COPYDATASTRUCT, 2*A_PtrSize, "Ptr")
	return SendMsg(hWnd, 0x4A, &COPYDATASTRUCT)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649011(v=vs.85).aspx



















































;#############################################################################################################################################
;SHELL INTERFACE (IShellItems & ShellItemArray)
;Parámetros:
	;Path: cadena de carácteres que reprecenta la ruta a un archivo o carpeta existente.
	;PIDL: pointer a una lista de identificadores de elemento.
	;IShellItems: Objeto del cual se puede obtener PIDL
	;ShellItemArray: Array que contiene IShellItems
	;IDLists: espesificar un Array con PIDLs y/o Paths. Ejemplo: [A_Desktop, A_ProgramFiles, ParseDisplayName(A_WinDir)]
	;RIID: espesificar un CLSID, puede ser un pointer o string
	;----------------------------------------------------------------------------------------------------------------------------------
	;UsesShortFileNames: establecer en verdadero para usar nombres de archivo corto
;SO: Windows Vista en adelante.
;Links:
	;Shell Interfaces: https://msdn.microsoft.com/en-us/library/windows/desktop/bb774328(v=vs.85).aspx
		;ShellItemArray: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761106(v=vs.85).aspx
			;IShellItem: https://msdn.microsoft.com/en-us/library/windows/desktop/bb761144(v=vs.85).aspx
				;PIDL: https://msdn.microsoft.com/en-us/library/windows/desktop/bb759800(v=vs.85).aspx
;#############################################################################################################################################
;convertir Path a PIDL
;Sintaxis: ParseDisplayName( [Path] )
;Return: PIDL
ParseDisplayName(Path, IBindCtx := 0, sfgaoIn := 0, ByRef SFGAOF := 0) {
	Error := DllCall("Shell32.dll\SHParseDisplayName", "WStr", Path, "Ptr", IBindCtx, "PtrP", PIDL, "UInt", sfgaoIn, "UInt", SFGAOF)
	return PIDL, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762236(v=vs.85).aspx

;convertir PIDL a Path
;Sintaxis: GetPathFromIDList( [PIDL], [UsesShortFileNames] )
;Return: Path
GetPathFromIDList(PIDL, UsesShortFileNames := false) {
	VarSetCapacity(Path, 512 * 2, 0)
	, Ok := DllCall("Shell32.dll\SHGetPathFromIDListEx", "Ptr", PIDL, "WStr", Path, "UInt", 512, "UInt", UsesShortFileNames?0x0001:0x0000, "Int")
	return RTrim(Path, "\"), ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762195(v=vs.85).aspx

;crear ShellItemArray desde un Array con PIDLs o Paths (o espesificar directamente el PIDL o Path si es uno solo).
;Sintaxis: CreateShellItemArrayFromIDLists( [IDLists] )
CreateShellItemArrayFromIDLists(IDLists) { 
	VarSetCapacity(ITEMIDLIST, IDLists.MaxIndex() * A_PtrSize, 0), IDLists := IsObject(IDLists)?IDLists:[IDLists], Count := 0
	for Index, PIDL in IDLists {
		if (PIDL := ((PIDL+0)=""?ParseDisplayName(PIDL):PIDL))
			NumPut(PIDL, ITEMIDLIST, (A_Index - 1) * A_PtrSize, "Ptr"), Count += 1
	} Error := DllCall("Shell32.dll\SHCreateShellItemArrayFromIDLists", "UInt", Count, "Ptr", &ITEMIDLIST, "PtrP", IShellItemArray)
	Loop, % (Count)
		CoTaskMemFree(NumGet(ITEMIDLIST, (A_Index - 1) * A_PtrSize, "Ptr"))
	return IShellItemArray, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762146(v=vs.85).aspx

;obtener IDLists desde ShellItemArray
;Sintaxis: GetIDListsFromShellItemArray( [IShellItemArray], [ConvertToPath] )
;ErrorLevel:
	;-1 = no se han encontrado items
	;0 = OK
	;1 = no se ha podido obtener los items
;Ejemplo con CreateShellItemArrayFromIDLists():
	;IShellItemArray := CreateShellItemArrayFromIDLists([A_Desktop, A_MyDocuments, ParseDisplayName(A_AppData)])
	;for k, v in GetIDListsFromShellItemArray(IShellItemArray)
	;	MsgBox % GetPathFromIDList(v)
GetIDListsFromShellItemArray(IShellItemArray, ConvertToPath := false) {
	List := []
	;IShellItemArray::GetCount method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761098(v=vs.85).aspx)
	Error := DllCall(NumGet(NumGet(IShellItemArray+0), 7*A_PtrSize), "Ptr", IShellItemArray, "UIntP", Count)
	Loop, % (Count) {
		;IShellItemArray::GetItemAt method (https://msdn.microsoft.com/en-us/library/windows/desktop/bb761100(v=vs.85).aspx)
		if (DllCall(NumGet(NumGet(IShellItemArray+0), 8*A_PtrSize), "Ptr", IShellItemArray, "UInt", A_Index-1, "PtrP", IShellItem) = 0) {
			if (ConvertToPath) ;PIDL --> Path
				Path := GetPathFromIDList(GetIDListFromObject(IShellItem)), List.Push(Path), CoTaskMemFree(Path)
			else List.Push(GetIDListFromObject(IShellItem))
			ObjRelease(IShellItem)
	}	} return Error?false:(Count?List:false), ErrorLevel := Error?true:(Count?false:-1)
}

;obtener PIDL desde IShellItem
;Sintaxis: GetIDListFromObject( [objeto] )
;Return: PIDL
GetIDListFromObject(Object) {
	DllCall("Shell32.dll\SHGetIDListFromObject", "Ptr", Object, "PtrP", PIDL)
	return PIDL
}
	
;crear IShellItem
;Sintaxis 1: CreateShellItem( [pidlParent], [psfParent], [PIDL o Path] )
;Sintaxis 2: CreateShellItem( [PIDL o Path] )
;Return: IShellItem
;Ejemplo: MsgBox % CreateShellItem(0, 0, A_Desktop)
CreateShellItem(pidlParent, psfParent := 0, PIDL := 0) {
	if (psfParent=0) && (PIDL=0)
		PIDL := pidlParent, psfParent := pidlParent := 0
	if ((PIDL+0)="")
		PIDL := ParseDisplayName(PIDL), free := true
	Error := DllCall("Shell32.dll\SHCreateShellItem", "Ptr", pidlParent, "Ptr", psfParent, "Ptr", PIDL, "PtrP", IShellItem)
	if (free)
		CoTaskMemFree(PIDL)
	return Error?false:IShellItem
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762143(v=vs.85).aspx

;Crear IShellItem desde PIDL
;Sintaxis: CreateItemFromIDList( [PIDL], [RIID] )
;Ejemplo: MsgBox % CreateItemFromIDList(A_Desktop, "{43826d1e-e718-42ee-bc55-a1e261c37bfe}")
CreateItemFromIDList(PIDL, RIID) {
	if ((PIDL+0)="")
		PIDL := ParseDisplayName(PIDL), free := true
	if ((RIID+0)="")
		CLSIDFromString(RIID, CLSID), RIID := &CLSID
	Error := DllCall("Shell32.dll\SHCreateItemFromIDList", "Ptr", PIDL, "Ptr", RIID, "PtrP", IShellItem)
	if (free)
		CoTaskMemFree(PIDL)
	return Error?false:IShellItem
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762133(v=vs.85).aspx


































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: NOMBRES Y RUTAS DE ARCHIVOS/DIRECTORIOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recupera la ruta y el nombre completo del archivo/carpeta especificado.
;Sintaxis: GetFullPathName( [archivo], [carácteres (out)] )
;Nota: el archivo no necesariamente debe existir. si la ruta no es absoluta usa el directorio de trabajo actual
GetFullPathName(Filename, ByRef Length := "") {
	Size := DllCall("Kernel32.dll\GetFullPathNameW", "Str", Filename, "UInt", 0, "Ptr", 0, "PtrP", 0, "UShort"), VarSetCapacity(OutputVar, Size * 2, 0) 
	, Length := DllCall("Kernel32.dll\GetFullPathNameW", "Str", Filename, "UInt", Size, "Str", OutputVar, "PtrP", 0, "UShort")
	return Length?RTrim(OutputVar, "\"):Filename, ErrorLevel := !Length
}

;convierte la ruta especificada a su forma larga
;Sintaxis: GetLongPathName( [ruta], [carácteres (out)] )
GetLongPathName(Filename, ByRef Length := "") {
	Size := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0, "UShort"), VarSetCapacity(OutputVar, Size * 2, 0)
	, Length := DllCall("Kernel32.dll\GetLongPathNameW", "Str", "\\?\" Filename, "Str", OutputVar, "UInt", Size, "UShort")
	return Length?RTrim(LTrim(OutputVar, "\\?\"), "\"):Filename, ErrorLevel := !Length
}

;convierte la ruta especificada a su forma corta
;Sintaxis: GetShortPathName( [ruta], [carácteres (out)] )
GetShortPathName(Filename, ByRef Length := "") {
	Size := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" Filename, "Ptr", 0, "UInt", 0, "UShort"), VarSetCapacity(OutputVar, Size * 2, 0)
	, Length := DllCall("Kernel32.dll\GetShortPathNameW", "Str", "\\?\" Filename, "Str", OutputVar, "UInt", Size, "UShort")
	return Length?RTrim(LTrim(OutputVar, "\\?\"), "\"):Filename, ErrorLevel := !Length
}

;obtiene una ruta valida (solo archivos) removiendo caracteres no permitidos, espacios, parámetros y comillas.
GetValidPathName(Filename) {
	Filename := Trim(RegExReplace(Filename, "[\Q*/?" Chr(34) "<>|`n\E]"))
	if (IsFile(Filename))
		return Filename, ErrorLevel := false
	if IsFile(i:=StrLeft(Filename, InStr(Filename, A_Space)-1))
		return i, ErrorLevel := 0
	Loop, Parse, % Filename, %A_Space%, %A_Tab%
	{ _ .= (A_Index=1?"":" ") A_LoopField 
		if (IsFile(_))
			return _, ErrorLevel := false
	} return Filename, ErrorLevel := true
} 

;recupera la ruta completa de un directorio
;Sintaxis: GetKnownFolderPath( [GUID] )
;Parámetros:
	;GUID: espesificar un valor CSIDL, un CLSID.
		;Nota: para WIN_XP solo soporta valores CSIDL.
		;WIN_V+ = https://msdn.microsoft.com/en-us/library/windows/desktop/dd378457%28v=vs.85%29.aspx
		;WIN_XP = https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494(v=vs.85).aspx
		;constantes: https://www.omniref.com/ruby/gems/windows-pr/1.0.0/symbols/Windows::Shell::CSIDL_ADMINTOOLS
;Ejemplos:
	;MsgBox % GetKnownFolderPath(0x0030) "`n" ErrorLevel ;WIN_XP+
	;MsgBox % GetKnownFolderPath({724EF170-A42D-4FEF-9F26-B60E846FBA4F}) "`n" ErrorLevel ;WIN_V+
GetKnownFolderPath(GUID) {
	VarSetCapacity(OutputVar, 512 * 2, 0)
	if ((GUID+0)="") {
		CLSIDFromString(GUID, CLSID)
		Error := DllCall("Shell32.dll\SHGetKnownFolderPath", "Ptr", &CLSID, "UInt", 0, "Ptr", 0, "PtrP", OutputVar)
		return StrGet(OutputVar, "UTF-16"), CoTaskMemFree(OutputVar), ErrorLevel := Error
	} Error := DllCall("Shell32.dll\SHGetFolderPathW", "Ptr", 0, "Int", GUID, "Ptr", 0, "UInt", 0, "Str", OutputVar)
	return OutputVar, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762188(v=vs.85).aspx

;convierte una lista de archivos separados por `n o un array (que tambiene puede contener mas arrays con `n) en un nuevo array con archivos válidos con su ruta completa en su forma larga
;Sintaxis: GetValidArrayFiles( [archivos], [¿comprobar si el archivo existe?=1], [espesificar la ruta del archivo si solo se espesificó el nombre], [carácteres totales], [¿remover duplicados?=1] )
;Ejemplo:
	;for Index, File in GetValidArrayFiles( ["a", "b`nc", "d", ["e", ["f`ng", [[[[[["h"]]]]]]]], "i`nj`nk"], false, "C:\" )
		;MsgBox % "#" Index "`n" File
GetValidArrayFiles(Files, Exist := true, Path := "", ByRef Length := "", RemoveDuplicates := true) {
	Items := [], Files := IsObject(Files)?GVAF_GetFiles(Files):StrSplit(Files, "`n", "`r"), Length := 0 ;transformar archivos separados por `n en un array
	for k, v in Files ;buscar en los archivos espesificados
	{	if ((Exist && IsFile(Path v)) || !(Exist)) && !((v:=GetFullPathName(GetLongPathName(Path v)))="") && (Ok:=true) {
			if (RemoveDuplicates) ;¿buscar archivos duplicados?
				for k2, v2 in Items  ;buscar en los archivos añadidos 
					if (v=v2) && !(Ok:=false) ;si se encontro, establece Ok en 0
						break
			if (Ok) ;Ok = 1 => [no se encontraron archivos duplicados]
				Items.Push(v), Length += StrLen(v) ;añadir archivo y sumar carácteres
	}} return Items.MaxIndex()?Items:0, ErrorLevel := Items.MaxIndex()?0:1 ;si se añadieron archivos, devuelve el Array, de lo contrario devuelve 0
} GVAF_GetFiles(Array) { ;obtiene un nuevo array de un array con arrays y `n
	Items := []
	for k, v in Array {
		if IsObject(v) && v.MaxIndex()
			for k, v in GVAF_GetFiles(v)
				Items.Push(v)
		for k2, v2 in StrSplit(v, "`n", "`r")
			Items.Push(v2)
	} return Items
}





























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ADMINISTRACIÓN DE ENERGÍA ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa373163(v=vs.85).aspx
;Parámetros:
	;GUID: espesificar el plan de energia. si no se espesifica, usa el plan activo (en uso actualmente)
		;{a1841308-3541-4fab-bc81-f71556f20b4a} = GUID_MAX_POWER_SAVINGS (economizador)
		;{381b4222-f694-41f0-9685-ff5bb260df2e} = GUID_TYPICAL_POWER_SAVINGS (equilibrado)
		;{8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c} = GUID_MIN_POWER_SAVINGS (alto rendimiento)
	;AC = conectado a la corriente. defecto.
	;DC = con batería
	;Porcentaje = un número entre 1 y 100 inclusive que indican el porcentaje del estado del procesador. dejar vacío para no modificar.
;Notas:
	;para que algunos cambios tengan efecto inmediato, usar PowerSetActivePlan() con el plan modificado
	;para obtener una lista con todos los planes, usar PowerEnumeratePlans()
;#############################################################################################################################################
;recupera el estado de alimentación del sistema
;Sintaxis: GetSystemPowerStatus( [ACLineStatus], [BatteryFlag], [BatteryLifePercent], [SystemStatusFlag], [BatteryLifeTime], [BatteryFullLifeTime] )
;Parámetros:
	;ACLineStatus:  estado de alimentacion C.A (corriente alterna)
		;0 = fuera de linea
		;1 = en linea
		;255 = desconocido
	;BatteryFlag: estado de carga de la batería
		;1 = Alto		>66
		;2 = Bajo		<33
		;4 = Critico	<5
		;8 (o 9?) = Carga
		;128 = sin batería
		;255 = desconocido (no se ha podido leer la información)
	;BatteryLifePercent: porcentaje de carga de la batería, entre 0 y 100; o 255  si el estado es desconocido.
	;SystemStatusFlag: estado de ahorro de batería. WIN_10+
		;1 = ahorro de batería activado. ahorrar energía cuando sea posible.
		;0 = ahorro de batería desactivado
	;BatteryLifeTime: segundos restantes de la duración de la batería; o -1 si se desconoce.
	;BatteryFullLifeTime: segundos restantes para la carga completa de la batería; o -1 si se desconoce.
GetSystemPowerStatus(ByRef ACLineStatus := "", ByRef BatteryFlag := "", ByRef BatteryLifePercent := "", ByRef SystemStatusFlag := "", ByRef BatteryLifeTime := "", ByRef BatteryFullLifeTime := "") {
	VarSetCapacity(SYSTEM_POWER_STATUS, 12, 0), Ok := DllCall("Kernel32.dll\GetSystemPowerStatus", "Ptr", &SYSTEM_POWER_STATUS, "UInt")
	, ACLineStatus := NumGet(SYSTEM_POWER_STATUS, 0, "UChar"), BatteryFlag := NumGet(SYSTEM_POWER_STATUS, 1, "UChar")
	, BatteryLifePercent := NumGet(SYSTEM_POWER_STATUS, 2, "UChar"), SystemStatusFlag := NumGet(SYSTEM_POWER_STATUS, 3, "UChar")
	, BatteryLifeTime := NumGet(SYSTEM_POWER_STATUS, 4, "UInt"), BatteryFullLifeTime := NumGet(SYSTEM_POWER_STATUS, 8, "UInt")
	return Ok, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa372693(v=vs.85).aspx

;cambiar estado minimo y/o maximo del procesador
;Sintaxis: PowerWriteProcessorStateValueIndex( [GUID], [porcentaje minimo], [porcentaje máximo], [AC/DC] )
;Return: 0(ERROR) | 1(OK)
;ErrorLevel: 0(OK) | 1(ERROR)
PowerWriteProcessorStateValueIndex(GUID := "", Min := "", Max := "", Mode := "AC") {
	if !(GUID)
		PowerEnumeratePlans(GUID), GUID := "{" GUID.GUID "}"
	mi := ma := true, CLSIDFromString(GUID, GUID_POWER_SAVING)
	, CLSIDFromString("{54533251-82be-4824-96c1-47b60b740d00}", GUID_PROCESSOR_SETTINGS_SUBGROUP)
	if !(Min="")
		CLSIDFromString("{893DEE8E-2BEF-41E0-89C6-B55D0929964C}", GUID_PROCESSOR_THROTTLE_MINIMUM)
		, mi:=DllCall("PowrProf.dll\PowerWrite" Mode "ValueIndex", "Ptr", 0, "Ptr", &GUID_POWER_SAVING
			, "Ptr", &GUID_PROCESSOR_SETTINGS_SUBGROUP, "Ptr", &GUID_PROCESSOR_THROTTLE_MINIMUM, "UInt", Min, "UInt")=0
	if !(Max="")
		CLSIDFromString("{BC5038F7-23E0-4960-96DA-33ABAF5935EC}", GUID_PROCESSOR_THROTTLE_MAXIMUM)
		, ma:=DllCall("PowrProf.dll\PowerWrite" Mode "ValueIndex", "Ptr", 0, "Ptr", &GUID_POWER_SAVING
			, "Ptr", &GUID_PROCESSOR_SETTINGS_SUBGROUP, "Ptr", &GUID_PROCESSOR_THROTTLE_MAXIMUM, "UInt", Max, "UInt")=0
	return mi&&ma, ErrorLevel := !(mi&&ma)
}

;enumera todos los planes de energía
;Sintaxis: PowerEnumeratePlans( [plan activo] )
;Parámetros:
	;Plan Activo: devuelve un objeto con información del plan activo.
;Return: [index, {GUID, NAME, ¿DEFAULT?}]
;Ejemplo:
	;for k, v in PowerEnumeratePlans()
	;	MsgBox % "#" k "`nGUID: " v.GUID "`nNombre: " v.Name "`nDefecto: " v.Default
PowerEnumeratePlans(ByRef ActivePlan := "") {
	List := {}
	for k, v in StrSplit(CMD("powercfg /l"), ":", A_Space A_Tab)
		if (A_Index>1) {
			Info := {}, Info.GUID := SubStr(Trim(v), 1, 36), Info.Default := !!InStr(v, "*")
			, Info.Name := Trim(StrSplit(SubStr(v, InStr(v, "(")+1), ")")[1]), List.Push(Info)
			if (Info.Default)
				ActivePlan := Info
		} return List
}

;cambia el plan activo
;Sintaxis: PowerSetActivePlan( [GUID] )
PowerSetActivePlan(GUID) {
	CMD("powercfg /s " RegExReplace(GUID, "[^0-9a-zA-Z-]"))
	return !ErrorLevel
}



































































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: PORTAPAPELES ::::::::::::::::::::::::::::::::::
;Notas:
	;• [NECESARIO!] antes de usar cualquier función, debe llamar a OpenClipboard().
	;• [IMPORTANTE!] cuando termine de usar el portapapeles, debe llamar CloseClipboard().
;Parámetros:
	;• Formato / Format = https://msdn.microsoft.com/en-us/library/windows/desktop/ff729168(v=vs.85).aspx
	;• Data / hMem = HANDLE a los datos en el formato espesificado
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES NECESARIAS
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;abre el portapapeles y evita que otras aplicaciones modifiquen el contenido del portapapeles
;Sintaxis: OpenClipboard( [ms a esperar si no se puede abrir, por defecto 1000ms o 1s], [retraso para comprobar, por defecto 50ms] )
;Return: 0|1
OpenClipboard(Wait := 1000, Delay := 50) {
	Error := ErrorLevel
	if !DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd, "Int") {
		Loop
			Sleep, %Delay%
		until (Ok:=DllCall("User32.dll\OpenClipboard", "Ptr", A_ScriptHwnd, "Int")) || (A_Index=Ceil(Wait/Delay))
		return Ok, ErrorLevel := Error
	} else return true, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649048(v=vs.85).aspx

;cierra el portapapeles
;Sintaxis: OpenClipboard( [ms a esperar si no se puede cerrar, por defecto 1000ms o 1s], [retraso para comprobar, por defecto 50ms] )
;Return: 0|1
CloseClipboard(Wait := 1000, Delay := 50) {
	Error := ErrorLevel
	if !DllCall("User32.dll\CloseClipboard", "Int") {
		Loop
			Sleep, %Delay%
		until (Ok:=DllCall("User32.dll\CloseClipboard", "Int")) || (A_Index=Ceil(Wait/Delay))
		return Ok, ErrorLevel := Error
	} return true, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649035(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES
;Nota: necesario abrir el portapapeles antes
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;vacía el portapapeles y libera los HANDLES a los datos en el portapapeles
EmptyClipboard() {
	return DllCall("User32.dll\EmptyClipboard", "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649037(v=vs.85).aspx

;establecer texto en el portapapeles (solo válido para Texto y Archivos)
;Sintaxis: SetClipboardText( [texto], [codificación], [modo] )
;Modos (para incluir varios archivos y/o carpetas (si no existen son omitidos), crear un Array o usar `n):
	;Str (defecto): el 1er parámetro es interpretado como texto
	;Copy: el 1er parámetro es interpretado como archivos y carpetas a copiar (mismo efecto que «Copiar» desde el explorador de windows).
	;Cut: el 1er parámetro es interpretado como archivos y carpetas a mover (mismo efecto que «Cortar» desde el explorador de windows)
;Ejemplos:
	;#1 (copiar texto) = OpenClipboard(), SetClipboardText("Hola, øomo estás?"), CloseClipboard()
	;#2 (copiar archivos) = OpenClipboard(), MsgBox(SetClipboardText(ComSpec "`n" A_WinDir "\explorer.exe",, "Copy"))
SetClipboardText(Text, Encoding := "CP0", Mode := "Str") {
	EmptyClipboard() ;necesario vaciar el portapepeles
	if (Mode="Str") { ;Text
		hGlobal := GlobalAlloc(Bytes:=StrLen(Text) + 1), hLockGlob := GlobalLock(hGlobal)
		, StrPut(Text, hLockGlob+0, Bytes, Encoding), GlobalUnlock(hGlobal)
		return r := SetClipboardData(0x1, hGlobal), GlobalFree(hGlobal), ErrorLevel := !r
	} else if (Mode="Copy") || (Cut:=(Mode="Cut")) { ;Copy | Cut
		Files := GetValidArrayFiles(Text,,, Length) ;obtener un array solo con los archivos existentes
		, hGlobal := GlobalAlloc(20 + (Length + Files.MaxIndex() + 1) * 2, 0x42)
		, hLockGlob := GlobalLock(hGlobal), NumPut(20, hLockGlob+0, 0, "UInt") ;DROPFILES
		, NumPut(1, hLockGlob+0, 16, "UInt"), Offset := 0 ;0 = ANSI | 1 = UNICODE
		for k, v in Files ;añadir la ruta de los archivos al bloque de memoria hGlobal
			Offset += StrPut(v, (hLockGlob+20)+Offset, StrLen(v)+1, "UTF-16") * 2 ;=> Encoding = UTF-16 --> *2
		GlobalUnlock(hGlobal), r := SetClipboardData(15, hGlobal) ;establecer archivos
		, hGlobal := GlobalAlloc(4, 0x42), hLockGlob := GlobalLock(hGlobal) ;FillMemory(hLockGlob, 1, Cut?0x02:0x05)
		, NumPut(Cut?0x02:0x05, hLockGlob+0, 0, "UChar"), GlobalUnlock(hGlobal) ;0x02 = cortar | 0x05 = copiar
		, f := SetClipboardData(RegisterClipboardFormat("Preferred DropEffect"), hGlobal) ;establecer modo (copiar o cortar)
		return f&&r, GlobalFree(hGlobal), ErrorLevel := !f||!r ;si se añadieron los archivos y el modo correctamente, devuelve 1 y ErrorLevel=0
	} return false, ErrorLevel := true ;no se espesifico Str, Copy o Cut, devuelve 0 y ErrorLevel=1
}

;obtiene el texto en el portapapeles (solo válido para Texto y Archivos)
GetClipboardText() {
	Format := GetClipboardFormat()
	if (Format.HasKey(15)) { ;Files (CF_HDROP)
		Text := GetClipboardData(15), hLockGlob := GlobalLock(Text)
		if !(Count:=DllCall("Shell32.dll\DragQueryFileW", "Ptr", hLockGlob, "UInt", 0xFFFFFFFF, "Ptr", 0, "UInt", 0)) ;obtiene la cantidad de archivos
			return "", ErrorLevel := true ;ErrorLevel=1 => [no hay archivos]
		Loop, %Count%
			Size := DllCall("Shell32.dll\DragQueryFileW", "Ptr", hLockGlob, "UInt", A_Index-1, "Ptr", 0, "UInt", 0)
			, VarSetCapacity(Name, (Size+1) * 2, 0), DllCall("Shell32.dll\DragQueryFileW", "Ptr", hLockGlob
			, "UInt", A_Index-1, "Str", Name, "UInt", Size + 1), OutputVar .= Name=""?"":Name "`n"
		return RTrim(OutputVar, "`n"), GlobalUnLock(Text), ErrorLevel := OutputVar=""
	} else if (Unicode:=Format.HasKey(13)) || (Format.HasKey(1)) || (OEM:=Format.HasKey(7)) ;Text
		return StrGet(GetClipboardData(Unicode?13:OEM?7:1), Unicode?"UTF-16":"CP0"), ErrorLevel := false
	return "", ErrorLevel := 2 ;ErrorLevel=2 => formato de momento no soportado
}

;enumera los datos disponibles en el portapapeles
;Return:
	;0 = no hay formatos o ha ocurrido un ERROR
	;[] = array con los formatos OK
;ErrorLevel: 0(OK) | N(ERROR, donde N es un número)
EnumClipboardFormats() {
	Formats := [], Format := 0
	Loop {
		Format := DllCall("User32.dll\EnumClipboardFormats", "UInt", Format, "UInt")
		if !(A_LastError=0) ;ERROR_SUCCESS=0
			return false, ErrorLevel := A_LastError
		if (Format)
			Formats.Push(Format)
		else break
	} return Formats, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649038(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES VARIAS
;Notas:
	;para las siguientes funciones no es necesario usar OpenClipboard()
;-------------------------------------------------------------------------------------------------------------------------------------------------------------
;espera a que el portapapeles contenga datos
;Sintaxis: ClipWait( [segundos], [¿cualquier tipo de datos?] )
ClipWait(Seconds := -1, AnyFormats := true) {
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (AnyFormats&&DllCall("User32.dll\CountClipboardFormats"))
		||(!AnyFormats&&(DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 1, "Int")
		||DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", 15, "Int")))
			return true, ErrorLevel := false
		if (Seconds>=0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 50
}}

;obtener texto seleccionado (usa el portapapeles)
;Sintaxis: GetSelectedText( [¿no reestablecer portapapeles?] )
GetSelectedText(NoRestoreClipboard := false) {
	Error := ErrorLevel
	if !(NoRestoreClipboard)
		Clip := ClipboardAll
	OpenClipboard(), EmptyClipboard(), CloseClipboard(), Sleep(10)
	, SendKeys("{LCTRL DOWN}c{LCTRL UP}"), Sleep(10), ClipWait(1)
	if !(NoRestoreClipboard)
		Text := Clipboard, Clipboard := Clip
	else Text := Clipboard
	return Text, ErrorLevel := Error
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;almacena información con el formato espesificado en el portapapeles
;Sintaxis: SetClipboardData( [formato], [data] )
SetClipboardData(Format, hMem) {
	return DllCall("User32.dll\SetClipboardData", "UInt", Format, "Ptr", hMem, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649051(v=vs.85).aspx

;recupera datos del portapapeles en el formato espesificado
;Sintaxis: GetClipboardData( [formato] )
GetClipboardData(Format) {
	return DllCall("User32.dll\GetClipboardData", "UInt", Format, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms649039(v=vs.85).aspx

;obtiene loas formatos actualmente usados en el portapapeles
GetClipboardFormat() {
	Format := {}
	Loop, Parse, % "2|8|17|5|0x0082|0x008E|0x0083|0x0081|14|0x0300|0x03FF|15|16|3|7|0x0080|9|10|0x0200|0x02FF|11|41|6|13|12", |
		if DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", A_LoopField, "Int")
			Format[A_LoopField] := A_LoopField
	return Format
} IsClipboardFormatAvailable(Format) {
	return DllCall("User32.dll\IsClipboardFormatAvailable", "UInt", Format, "Int")
}

;registra un nuevo formato válido para el portapapeles
RegisterClipboardFormat(Format) {
	return DllCall("User32.dll\RegisterClipboardFormatW", "Ptr", &Format, "UInt")
}






































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ARRAY Y OBJETOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OBJETOS
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Devuelve una matriz asociativa de objetos COM activos,donde cada tecla es el apodo, artículo o sufijo del objeto.
;Si se especifica un prefijo, sólo los objetos cuyos apodos del elemento que coincida con el prefijo dado son devueltos, y el prefijo se omite de las teclas devueltas.
GetActiveObjects(Prefix := "", CaseSensitive := false) {
    DllCall("ole32.dll\CoGetMalloc", "UInt", 1, "Ptr*", malloc), objects := {}
    , DllCall("ole32.dll\CreateBindCtx", "UInt", 0, "Ptr*", bindCtx)
    , DllCall(NumGet(NumGet(bindCtx+0)+8*A_PtrSize), "Ptr", bindCtx, "Ptr*", rot)
    , DllCall(NumGet(NumGet(rot+0)+9*A_PtrSize), "Ptr", rot, "Ptr*", enum)
    while DllCall(NumGet(NumGet(enum+0)+3*A_PtrSize), "Ptr", enum, "UInt", 1, "Ptr*", mon, "Ptr", 0) = 0
    {	DllCall(NumGet(NumGet(mon+0)+20*A_PtrSize), "Ptr", mon, "Ptr", bindCtx, "Ptr", 0, "Ptr*", pname) 
        , name := StrGet(pname, "UTF-16"), DllCall(NumGet(NumGet(malloc+0)+5*A_PtrSize), "Ptr", malloc, "Ptr", pname)
        if InStr(name, Prefix, CaseSensitive) = 1 {
            DllCall(NumGet(NumGet(rot+0)+6*A_PtrSize), "Ptr", rot, "Ptr", mon, "Ptr*", punk)
            if (pdsp := ComObjQuery(punk, "{00020400-0000-0000-C000-000000000046}"))
                obj := ComObject(9, pdsp, 1), ObjRelease(punk)
            else obj := ComObject(13, punk, 1)
            objects[SubStr(name, StrLen(Prefix) + 1)] := obj
        } ObjRelease(mon)
    } ObjRelease(enum), ObjRelease(rot), ObjRelease(bindCtx), ObjRelease(malloc)
    return objects
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=6494

;registra un objeto como el objeto activo para su clase (permite manejar un script desde otro proceso)
;Sintaxis: RegisterActiveObject( [obj], [CLSID], [opciones], [nombre] )
;CLISD: CLSID del objeto activo o dejar vacio para poner fin a un objeto activo
;Nombre: espesificar un nombre para agregar el CLSID al registro
;Ejemplo:
	;obj := new MyClass("{436cf066-cf70-4ca9-990f-c7083fea8367}", "AHK") ;crear objeto [CLSID, Nombre]
	;x := ComObjActive("{436cf066-cf70-4ca9-990f-c7083fea8367}") ;obtener objeto (usado desde otro proceso/script) -->
	;x.MyFunc("Test!") ;llama a la funcion MyFunc() dentro de la clase MyClass, igual que obj.MyFunc("Test!") <--
	;ExitApp
	;class MyClass {
	;	__New(CLSID, Name) {
	;		RegisterActiveObject(this, CLSID,, Name) ;«this» es el objeto (MyClass)
	;	} MyFunc(String) {
	;		MsgBox %String%
	;	}
	;}
RegisterActiveObject(Object, CLSID := "", Flags := 0, AppId := "") {
	static l := {}
	if !(CLSID) && !((r:=l.Remove(Object))="") ;eliminar objeto activo
		return !(r:=DllCall("OleAut32.dll\RevokeActiveObject", "UInt", r, "Ptr", 0)), ErrorLevel := r
	if !(CLSID) || (I[Object]) || !(VarSetCapacity(c, 16, 0)) 
		return false, ErrorLevel := I[Object]?2:true ;ErrorLevel 2 = el objeto ya se encuentra registrado
	if ((h:=DllCall("Ole32.dll\CLSIDFromString", "WStr", CLSID, "Ptr", &c))<0)
		return false, ErrorLevel := 3 ;ErrorLevel 3 = CLSID inválido
	if ((h:=DllCall("OleAut32.dll\RegisterActiveObject", "Ptr", &Object, "Ptr", &c, "UInt", Flags, "UInt*", r, "UInt"))<0)
		return false, ErrorLevel := Format("0x{:x}", h) ;ErrorLevel X = RegisterActiveObject ERROR
	if !(AppId="") ;agregar al registro con el nombre espesificado (usuario actual)
		RegWrite(, "HKCU\Software\Classes\" AppId,, AppId)
		, RegWrite(, "HKCU\Software\Classes\" AppId "\CLSID",, CLSID)
		, RegWrite(, "HKCU\Software\Classes\CLSID\" CLSID,, AppId)
	return r, ErrorLevel := !r, l[Object] := r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221551(v=vs.85).aspx

CreateDIBSection(Width, Height, hDC := 0, bpp := 32, ByRef ppvBits := 0) {
	hDC2 := hDC?hDC:GetDC()
	, VarSetCapacity(BITMAPINFO, 40, 0), NumPut(Width, BITMAPINFO, 4, "UInt")
	, NumPut(Height, BITMAPINFO, 8, "UInt"), NumPut(40, BITMAPINFO, 0, "UInt")
	, NumPut(1, BITMAPINFO, 12, "UShort"), NumPut(0, BITMAPINFO, 16, "UInt")
	, NumPut(bpp, BITMAPINFO, 14, "UShort"), hbm := DllCall("Gdi32.dll\CreateDIBSection"
	, "Ptr", hDC2, "Ptr", &BITMAPINFO, "UInt", 0, "PtrP", ppvBits, "Ptr", 0, "UInt", 0, "Ptr")
	if !(hDC)
		ReleaseDC(0, hDC2)
	return hbm
}

;recupera información para el objeto grafico espesificado
;Sintaxis: GetObject( [objeto], [bytes], [objeto (out)], [var_bytes] )
;var_bytes: establecer capacidad de la variable, si se espesifica el 3er parámetro no debe ser una Adress(&). -1 para usar bytes
;Nota: para calcular el tamaño, dejar el 2do parámetro vacío o en 0
GetObject(Object, Bytes := 0, ByRef OutObject := 0, VarCap := 0) {
	if ((Bytes+0)="") || !(Bytes) || !(Bytes>0) ;calcular tamaño, en bytes
		Bytes := DllCall("Gdi32.dll\GetObjectW", "Ptr", Object, "Int", 0, "Ptr", 0, "UInt")
	if (VarCap) ;OutObject | else &OutObject
		VarSetCapacity(OutObject, 0), VarSetCapacity(OutObject, VarCap=-1?Bytes:VarCap, 0)
	return DllCall("Gdi32.dll\GetObjectW", "Ptr", Object, "Int", Bytes, "Ptr", VarCap?&OutObject:OutObject, "UInt")
} ;https://msdn.microsoft.com/en-us/library/dd144904(v=vs.85).aspx

;Sintaxis: SelectObject( [hDC], [objeto] )
;Return: Object | Value
SelectObject(hDC, Object) {
	return DllCall("Gdi32.dll\SelectObject", "Ptr", hDC, "Ptr", Object, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/dd162957(v=vs.85).aspx

DeleteObject(Object*) {
	Ok := 0, Error := ErrorLevel
	Loop, % Object.MaxIndex()
		Ok := !!DllCall("Gdi32.dll\DeleteObject", "Ptr", Object[A_Index], "Int")
	return Ok=Object.MaxIndex(), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/dd183539(v=vs.85).aspx

;crea un objeto que se puede utilizar para pasar un valor ByRef
;Modo De Uso:
	;ComVar := ComVar() --> crear 
	;ComVar[] --> recupera el valor
	;ComVar[] := Val --> establece el valor.
	;ComVar.ref --> recupera un objeto ByRef para pasar a una función COM
ComVar(Value*) {
	static base := {__Get: "ComVarGet", __Set: "ComVarSet", __Delete: "ComVarDel"}
	static ComObjParam := A_AhkVersion<2?"ComObjParameter":"ComObject"
	arr := ComObjArray(17, 1) , oval := ComObjValue(arr), data := SafeArrayAccessData(oval)
	if Value.MaxIndex()
		arr[0] := Value[1]
	return {ref: %ComObjParam%(0x400C, data), _: arr, base: base}
} ComVarGet(cv, p*) {
	if !(p.MaxIndex())
		return cv._[0]
} ComVarSet(cv, v, p*) {
	if !(p.MaxIndex())
		return cv._[0] := v
} ComVarDel(cv) {
	SafeArrayUnaccessData(ComObjValue(cv._))
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3964

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;ARRAY
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener carácteres totales en un array/objeto
;Sintaxis: Array_Length( [array], [profundidad] )
Array_Length(Array, Depth := -1) {
	Length := 0
	for k, v in Array {
		if IsObject(v) && ((Depth>1) || (Depth<0))
			Length += Array_Length(v, Depth-1)
		else Length += StrLen(v)
	} return Length
}

;devolver la estructura de un Array/Objeto como String
;Return: String
Array_Print(Array, Depth := -1, IndentLevel := "    ") {
   for k, v in Array {
      List .= IndentLevel "[" k "]"
      if (IsObject(v)) && ((Depth>1) || (Depth<0))
         List .= "`n" Array_Print(v, Depth-1, IndentLevel)
      else List .= A_Space "=>" A_Space v
      List .= "`n"
   } return RTrim(List)
} ;https://autohotkey.com/boards/viewtopic.php?p=66474#p66474

;devuelve el número de elementos en un Array u Objeto, sin importar el tipo.
;Sintaxis: Array_Count( [Array], [Profundidad] )
;Sintaxis 2: NumGet(&Array, 4*A_PtrSize)
;Return: N / N>=0 E N
Array_Count(Array, Depth := -1) {
	Count := 0
	for k, v in Array {
		if IsObject(v) && ((Depth>1) || (Depth<0))
			Count += Array_Count(v, Depth-1) ;, Count -= Count>0
		Count++
	} return Count
} ;https://autohotkey.com/boards/viewtopic.php?p=66474#p66474

;If [object] in [values*]
;comprueba si existe un valor espesificado en un Array u Objeto
;Sintaxis: InArray( [array], [valor], [¿sensible a mayúsculas?] )
;Return: 0|1
InArray(Array, Value, CaseSensitive := false) {
	if IsObject(Value) {
		for k, v in Value
			for k, a in Array
				if ((CaseSensitive) && (a==v)) || (!(CaseSensitive) && (a=v))
					return true
	} else for k, v in Array
		if ((CaseSensitive) && (v==Value)) || (!(CaseSensitive) && (v=Value))
			return true
	return false
}

;If [object] contains [values*]
;comprueba si algún valor del Array u Objeto espesificado contiene el valor espesificado
;Sintaxis: Array_Contains( [array], [valor], [¿sensible a mayúsculas?] )
;Return: 0|1
Array_Contains(Array, Value, CaseSensitive := false) {
	if IsObject(Value) {
		for k, v in Value
			for k, a in Array
				if InStr(a, v, !!CaseSensitive)
					return true
	} else for k, v in Array
		if InStr(v, Value, !!CaseSensitive)
			return true
	return false
} ;https://autohotkey.com/boards/viewtopic.php?p=66474#p66474

;busca un valor en un Array y devuelve la posición. si es un objeto, devuelve el nombre de la clave
;Sintaxis: Array_Find( [array], [valor] )
;Return: Key Name/Index
;ErrorLevel: 1 = no se encontró el valor
Array_Find(Array, Value, CaseSensitive := false) {
	if IsObject(Value) {
		for k, v in Value
			for k, a in Array
				if ((CaseSensitive) && (a==v)) || (!(CaseSensitive) && (a=v))
					return k, ErrorLevel := false
	} else for k, v in Array
		if ((CaseSensitive) && (v==Value)) || (!(CaseSensitive) && (v=Value))
			return k, ErrorLevel := false
	return "", ErrorLevel := true
}

;eliminar un valor espesificado en un Array u Objeto
;Sintaxis: Array_Remove( [array], [str], [casesensitive], [instr], [max] )
;Parámetros:
	;Str: cadena de buscar
	;CaseSensitive: espesificar 1 para hacer sensible a mayúsculas
	;InStr: usar InStr()
	;Max: espesificar la cantidad máxima a remover (si se encuentran mas de 1 valor), dejar en -1 para quitar todos.
Array_Remove(Array, Str, CaseSensitive := false, InStr := false, Max := -1) {
	Count := 0
	for k, v in Array
		if (InStr && InStr(v, Str, !!CaseSensitive)) || (!InStr && ((CaseSensitive && Str==v) || (!CaseSensitive && Str=v))) {
			if (Count=Max)
				break
			Array.RemoveAt(A_Index)
			Count++
		} return Array
}

;hacer una copia de un array que, al modificarlo, no se ve afectado el original
;Sintaxis: Array_Clone( [Array] )
;Return: Array
;AHK: Clone := Object.Clone()
Array_Clone(Array) {
	OutArray := []
	for k, v in Array
		OutArray.Push(v)
	return OutArray
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;MANIPULACIÓN DE ARRAY
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/ms221145(v=vs.85).aspx
;Parámetros:
	;SafeArray: descriptior de un Array creado por SafeArrayCreate()
	;ArrayData: puntero a los datos del Array
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: SafeArrayAccessData( [SafeArray] )
;ErrorLevel: 0 = OK
;Return: ArrayData
SafeArrayAccessData(SafeArray) {
	Error := DllCall("OleAut32.dll\SafeArrayAccessData", "Ptr", SafeArray, "PtrP", ArrayData, "Int")
	return ArrayData, ErrorLevel := Error ;S_OK=0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221620(v=vs.85).aspx

;Sintaxis: SafeArrayUnaccessData( [SafeArray] )
;Return: 0|1
;ErrorLevel: 0 = OK
SafeArrayUnaccessData(SafeArray) {
	Error := DllCall("OleAut32.dll\SafeArrayUnaccessData", "Ptr", SafeArray, "Int")
	return !Error, ErrorLevel := Error ;S_OK=0
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221203(v=vs.85).aspx

;Sintaxis: SafeArrayCreate( [BaseType], [Dimensions], [VectorBounds], [InformationType] )
;Return: SafeArray
SafeArrayCreate(BaseType := 17, Dimensions := 1, VectorBounds := 0, InformationType := 0) {
	if (InformationType)
		return DllCall("OleAut32.dll\SafeArrayCreateEx", "UInt", BaseType, "UInt", Dimensions, "Ptr", VectorBounds, "PtrP", InformationType, "Ptr")
	else return DllCall("OleAut32.dll\SafeArrayCreate", "UInt", BaseType, "UInt", Dimensions, "Ptr", VectorBounds, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221234(v=vs.85).aspx

;destruir SafeArray
;Return: 0|1
;ErrorLevel: 0 = OK
SafeArrayDestroy(SafeArray) {
	Error := DllCall("OleAut32.dll\SafeArrayDestroy", "Ptr", SafeArray, "Int")
	return !Error, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221702(v=vs.85).aspx


SafeArrayDestroyDescriptor(SafeArray) {
	Error := DllCall("OleAut32.dll\SafeArrayDestroyDescriptor", "Ptr", SafeArray, "Int")
	return !Error, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221681(v=vs.85).aspx

SafeArrayDestroyData(SafeArray) {
	Error := DllCall("OleAut32.dll\SafeArrayDestroyData", "Ptr", SafeArray, "Int")
	return !Error, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221418(v=vs.85).aspx

SafeArrayGetVartype(SafeArray) {
	Error := DllCall("OleAut32.dll\SafeArrayGetVartype", "Ptr", SafeArray, "PtrP", BaseType, "Int")
	return BaseType, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms221539(v=vs.85).aspx




































































































;**********************************************************************************************************************************************************************************************************************************
; ------> Variables.
;**********************************************************************************************************************************************************************************************************************************
;define el contenido de la variable de entorno especificada para el proceso actual.
;Sintaxis: EnvAdd( [nombre], [valor], [user|system] )
;Nota: espesificar un Valor vacío para eliminar.
SetEnvironmentVariable(VarName, Value := "", Mode := "") {
	if (Mode="User")
		RegWrite, REG_SZ, HKCU\Environment, % VarName, % Value
	else if (Mode="System")
		RegWrite, REG_SZ, HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment, % VarName, % Value
	else return DllCall("Kernel32.dll\SetEnvironmentVariableW", "Ptr", &VarName, "Ptr", Value=""?0:&Value)
	return !ErrorLevel
}	

;Recupera el contenido de la variable especificada desde el bloque de entorno del proceso invocador
GetEnvironmentVariable(EnvVarName, ByRef UserEnv := "", ByRef SystemEnv := "") { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683188%28v=vs.85%29.aspx
	if IsByRef(UserEnv)
		RegRead, UserEnv, HKCU\Environment, % EnvVarName
	if IsByRef(SystemEnv)
		RegRead, SystemEnv, HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment, % EnvVarName
	Size := DllCall("Kernel32.dll\GetEnvironmentVariableW", "Ptr", &EnvVarName, "Ptr", 0, "UInt", 0)
	, VarSetCapacity(OutpuVar, Size * 2, 0)
	, Ok := DllCall("Kernel32.dll\GetEnvironmentVariableW", "Ptr", &EnvVarName, "Str", OutpuVar, "UInt", Size)
	return OutpuVar, ErrorLevel := !Ok
}

;Notifica el sistema operativo y todas las aplicaciones que se ejecutan que las variable(s) del sistema han cambiado .
UpdateEnvironmentVariable() {
	SendMsg(0xFFFF, 0x001A,, "Environment")
	return !ErrorLevel
}

;Recupera la ruta a la raíz del directorio del usuario actual
A_UserProfile() {
	return GetEnvironmentVariable("USERPROFILE")
}

A_AllUsersProfile() {
	DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Userenv.dll\GetAllUsersProfileDirectory", "Str", OutputVar, "UIntP", Size)
	return OutputVar
}

A_Profiles() {
	DllCall("Userenv.dll\GetProfilesDirectoryW", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Userenv.dll\GetProfilesDirectoryW", "Str", OutputVar, "UIntP", Size)
	return OutputVar
}

A_DefaultUserProfile() {
	DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Userenv.dll\GetDefaultUserProfileDirectoryW", "Str", OutputVar, "UIntP", Size)
	return OutputVar
}

A_UserName() {
	DllCall("Advapi32.dll\GetUserNameW", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, (Size * 2) + 1)
	, DllCall("Advapi32.dll\GetUserNameW", "Str", OutputVar, "UIntP", Size + 1)
	return OutputVar
} 

;obtiene el dominio y nombre de usuario
A_UserNameEx() {
	DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, (Size * 2) + 1)
	, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", OutputVar, "UIntP", Size + 1)
	return OutputVar
}

;recupera el dominio del usuario actual
A_UserDomain(ByRef UserName := "") {
	DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, (Size * 2) + 1)
	, DllCall("Secur32.dll\GetUserNameExW", "UInt", 2, "Str", OutputVar, "UIntP", Size + 1)
	return StrSplit(OutputVar, "\").1, UserName := StrSplit(OutputVar, "\").2
}

;Recupera/Establece el nombre NetBIOS del equipo local.
;Este nombre se estableció al inicio del sistema, cuando el sistema lo lee desde el registro.
A_ComputerName(NewName := " ") {
	if !(NewName=" ")
		return DllCall("Kernel32.dll\SetComputerNameW", "Ptr", &NewName)
	DllCall("Kernel32.dll\GetComputerNameW", "Ptr", 0, "UIntP", Size)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Kernel32.dll\GetComputerNameW", "Str", OutputVar, "UIntP", Size)
	return OutputVar
}

;recupera la ruta del directorio de sistema utilizado por WOW64.
;NOTA: Este directorio no está presente en Windows de 32 bits.
A_SysDir64() {
	Size := DllCall("Kernel32.dll\GetSystemWow64DirectoryW", "Ptr", 0, "UInt", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Kernel32.dll\GetSystemWow64DirectoryW", "Str", OutputVar, "UInt", Size)
	return OutputVar
}

;recupera la ruta del directorio de sistema.
;El directorio del sistema contiene los archivos del sistema, como las bibliotecas y los controladores de vínculos dinámicos.
A_SysDir() {
	Size := DllCall("Kernel32.dll\GetSystemDirectoryW", "Ptr", 0, "UInt", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Kernel32.dll\GetSystemDirectoryW", "Str", OutputVar, "UInt", Size)
	return OutputVar
}

A_SysWinDir() { ;recupera la ruta del directorio compartido de Windows en un sistema multi-usuario.
	Size := DllCall("Kernel32.dll\GetSystemWindowsDirectoryW", "Ptr", 0, "UInt", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Kernel32.dll\GetSystemWindowsDirectoryW", "Str", OutputVar, "UInt", Size)
	return OutputVar
}

A_WinDir() {
	Size := DllCall("Kernel32.dll\GetWindowsDirectoryW", "Ptr", 0, "UInt", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Kernel32.dll\GetWindowsDirectoryW", "Str", OutputVar, "UInt", Size)
	return OutputVar
}

A_Temp() {
	Size := DllCall("Kernel32.dll\GetTempPathW", "UInt", 0, "Ptr", 0)
	, VarSetCapacity(OutputVar, (Size * 2) + 1)
	, DllCall("Kernel32.dll\GetTempPathW", "UInt", Size + 1, "Str", OutputVar)
	return RTrim(OutputVar, "\")
}

A_ComSpec() {
	return GetEnvironmentVariable("ComSpec")
}

A_LocalAppData() {
	return GetEnvironmentVariable("LOCALAPPDATA")
}

;tamaño de la zona de trabajo en el monitor de pantalla principal.
;el área de trabajo es la parte de la pantalla que no está oculta por la barra de tareas o las barras de herramientas de escritorio de aplicaciones.
;Sintaxis: A_MonitorWorkArea( [xpos], [ypos], [ancho], [alto] )
A_MonitorWorkArea(ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 8 * 2, 0), i := {}
	, r := DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0030, "UInt", 0, "Ptr", &RECT, "UInt", 0)
	, i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	, i.w := i.Width := Width := NumGet(RECT,  8, "Int") - x
	, i.h := i.Height := Height := NumGet(RECT, 12, "Int") - y
	return i, ErrorLevel := !r
}

A_Time(Delimiter := "") {
	CurrentTime := SplitTime()
	return CurrentTime[1] Delimiter CurrentTime[2] Delimiter CurrentTime[3] Delimiter
		. CurrentTime[4] Delimiter CurrentTime[5] Delimiter CurrentTime[6]
}

;------------------------------------------------------------------------------------------------------------------------------------------------

A_ProgramFiles() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{905e63b6-c1bf-494e-b29c-65b732d3d21a}":0x0026)
}

A_Programs() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}":0x0002)
}

A_ProgramsCommon() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}":0X0017)
}

A_AppData() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}":0x001a)
}

A_AppDataCommon() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}":0x0023)
}

A_Desktop() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}":0x0010)
}

A_DesktopCommon() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}":0x0019)
}

A_StartMenu() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}":0x000b)
}

A_StartMenuCommon() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{A4115719-D62E-491D-AA7C-E74B8BE3B067}":0x0016)
}

A_Startup() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{B97D20BB-F46A-4C97-BA10-5E3608430854}":0x0007)
}

A_StartupCommon() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}":0x0018)
}

A_MyDocuments() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{FDD39AD0-238F-46AF-ADB4-6C85480369C7}":0x0005)
}

A_DocumentsCommon() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{ED4824AF-DCE4-45A8-81E2-FC7965083634}":0x002e)
}

A_MyMusic() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{4BD8D571-6D19-48D3-BE97-422220080E43}":0x000d)
}

A_MyPictures() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{33E28130-4E1E-4676-835A-98395C3BC3BB}":0x0027)
}

A_MyVideo() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{18989B1D-99B5-455B-841C-AB7C74E4DDFC}":0x000e)
}

A_Recent() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{AE50C081-EBD2-438A-8655-8A092E34987A}":0x0008)
}

A_SendTo() {
	return GetKnownFolderPath(IsWindowsVistaOrGreater()?"{8983036C-27C0-404B-8F08-102D10DCFD74}":0x0009)
}

;------------------------------------------------------------------------------------------------------------------------------------------------

;espacio
A_Space(Count := 1) {
	Loop, %Count%
		_ .= Chr(32)
	return _
}

;tabulación
A_Tab(Count := 1) {
	Loop, %Count%
		_ .= Chr(9)
	return _
}

;comilla
A_Quote(Count := 1) {
	Loop, %Count%
		_ .= Chr(34)
	return _
}

;obtiene un array con los parámetros usados para ejecutar el script
;EJEMPLO: MsgBox( A_Args()[1] "`n" A_Args()[2] "`n" A_Args()[3] "`n" A_Args()[4] "`n" A_Args()[5] "`n`nTotal: " A_Args()[0] )
A_Args() { ;http://ahkscript.org/boards/viewtopic.php?t=4357 || By SKAN
	static Args
	if (Args)
		return Args
	CommandLineString := DllCall("Kernel32.dll\GetCommandLineW", "Str"), Args := [], Skip := A_IsCompiled ? 1 : 2
	, pArgs := DllCall("Shell32.dll\CommandLineToArgvW", "WStr", CommandLineString, "PtrP", nArgs) 
	Loop, %nArgs% {
		if (A_Index > Skip)
			hArgs := NumGet( (A_Index - 1) * A_PtrSize + pArgs )
			, Args[A_Index - Skip] := StrGet( hArgs, "UTF-16" )
	} return Args, Args[0] := nArgs-Skip, DllCall("Kernel32.dll\LocalFree", "Ptr", pArgs)
}









































































;**********************************************************************************************************************************************************************************************************************************
; ------> Otros.
;**********************************************************************************************************************************************************************************************************************************
;cambiar el icono del área de notificación por un número.
;Sintaxis: SetTrayIconNumber( [Number], [TextColor], [BKColor] )
;Parámetros:
	;Number: un numero entre 0 y 99, inclusive.
	;TextColor: color del texto ARGB.
	;BKColor: color de fondo ARGB.
;Nota: un color ARGB es un color RGB pero con un numero adelante que indica el nivel de transparencia. ver RGBToARGB().
;Ejemplo:
	;GdiplusStartup()
	;Menu, Tray, Icon
	;Loop 99
	;	Sleep(100), SetTrayIconNumber(A_Index)
	;ExitApp
SetTrayIconNumber(Number := 0, TextColor := "0xFFFFFF", BKColor := "0x00000000") {
	GdiplusStartup(hModule), pBitmap := GdipCreateBitmap(16, 16), G := GdipGraphicsFromImage(pBitmap)
	, GdipFillRectangle(G, pBrush := GdipCreateSolidBrush(BKColor), 0, 0, 16, 16)
	, GdipDeleteBrush(pBrush), pBrush := GdipCreateSolidBrush(TextColor)
	, GdipTextToGraphics(G, Number, "x-2 y0 w20 h20 Center r4 s12 Bold c" pBrush, "Segoe UI")
	, GdipDeleteBrush(pBrush), hIcon := GdipCreateHICONFromBitmap(pBitmap)
	, GdipDeleteGraphics(G), GdipDisposeImage(pBitmap), GdiplusShutdown(, hModule)
	try Menu, Tray, Icon, HICON:*%hIcon%
	catch
		return false, DestroyIcon(hIcon)
	return true, DestroyIcon(hIcon)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762159(v=vs.85).aspx

;determina si el script ya se está ejecutando en el mismo directorio y con igual nombre.
;Ejemplo de uso:
	;#SingleInstance Off
	;#Persistent
	;MsgBox % Instance()
Instance(Close := false) {
	static hMutex ;ERROR_ALREADY_EXISTS = 183 | ERROR_ACCESS_DENIED = 0x00000005
	if (Close)
		return DllCall("Kernel32.dll\ReleaseMutex", "Ptr", hMutex)+DllCall("Kernel32.dll\CloseHandle", "Ptr", hMutex)
	Name := "_" StrLeft(StrReplace(StrReplace(A_ScriptFullPath, "\"), ":"), 259)
	, hMutex := DllCall("Kernel32.dll\CreateMutexW", "Ptr", 0, "Int", false, "Str", "Local\" Name)
	return A_LastError=183?(hMutex?hMutex:false):false
		, ErrorLevel := hMutex=""?true:(A_LastError=0x00000005?true+1:false)
}

;hModule := GetModuleHandle("User32.dll"), hModule := hModule?hModule:LoadLibrary("User32.dll")
;Address := GetProcAddress(hModule, "GetSysColor") ;DllCall("User32.dll\GetSysColor", "Int", 16, "UInt")
;MsgBox % DllCall(Address, "Int", 16, "UInt") ". ErrorLevel: " ErrorLevel "`n`nFreeLibrary: " FreeLibrary(hModule)
GetModuleHandle(DllFile, Flags := 0x00000002) { ;GetModuleHandle( [dll] )
	Error := ErrorLevel
	Ok := DllCall("Kernel32.dll\GetModuleHandleExW", "UInt", Flags, "Str", DllFile, "PtrP", hModule, "UInt")
	return Ok?hModule:false, ErrorLevel := Error
}

GetProcAddress(hModule, Function) { ;GetProcAddress( [hModule --> GetModuleHandle()/LoadLibrary()], [func] )
	Error := ErrorLevel
	return DllCall("Kernel32.dll\GetProcAddress", "Ptr", hModule, "AStr", Function, "Ptr"), ErrorLevel := Error
}

LoadLibrary(DllFile, Flags := 0x000000) { ;LoadLibrary( [file] )
	Error := ErrorLevel
	return DllCall("Kernel32.dll\LoadLibraryExW", "Str", DllFile, "UInt", 0, "UInt", Flags, "Ptr"), ErrorLevel := Error
}

FreeLibrary(hModule) {
	Error := ErrorLevel
	return DllCall("Kernel32.dll\FreeLibrary", "Ptr", hModule), ErrorLevel := Error
}

;establece el directorio de trabajo.
SetCurrentDirectory(DirName) {
	return DllCall("Kernel32.dll\SetCurrentDirectoryW", "Ptr", &DirName)
}

;obtiene el directorio de trabajo
GetCurrentDirectory() {
	Size := DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt", 0, "Ptr", 0)
	, VarSetCapacity(OutputVar, Size * 2)
	, DllCall("Kernel32.dll\GetCurrentDirectoryW", "UInt", Size, "Str", OutputVar)
	return OutputVar
}

;obtener último error
GetLastError(ByRef Description := "") {
	LastError := DllCall("Kernel32.dll\GetLastError", "UInt")
	if IsByRef(Description)
		, VarSetCapacity(Description, 0), VarSetCapacity(Description, 64000 * 2)
		, DllCall("Kernel32.dll\FormatMessageW", "UInt", 0x1000, "Ptr", 0, "UInt", LastError, "UInt", 0x800, "Ptr", &Description, "UInt", 64000, "UInt", 0)
		, VarAdjustCapacity(Description)
	return LastError
}

;establecer último error
SetLastError(ErrorCode) {
	DllCall("User32.dll\SetLastErrorEx", "UInt", ErrorCode, "UInt", 0)
}

SetTimer(Label := "", PeriodOnOffDelete := "On", ThreadPriority := 0) {
	SetTimer, % Label, % PeriodOnOffDelete, % ThreadPriority
} gosub(Label, Check := true) {
	if (Check&&IsLabel(Label))
		gosub, %Label%
} Sleep(Delay := -1) {
	Sleep, % Delay
} RunAsAdmin() {
	if !(A_IsAdmin) && (%true%!=A_ScriptFullPath) && (IsWindowsVistaOrGreater()) {
		_ := A_IsCompiled?A_ScriptFullPath:A_AhkPath
		Run, *RunAs "%_%" "%A_ScriptFullPath%" "%A_ScriptFullPath%",, UseErrorLevel
		if !(ErrorLevel)
			ExitApp
		return false
	} return true
} RunAsAdminInit() { ;} ;<-- //RunAsAdmin
	static RunAsAdminInit := RunAsAdminInit()
	SetBatchLines, -1
	ComObjError(false) ;desactivar las notificaciones de errores COM (Component Object Model).
	SetWorkingDir, % A_ScriptDir ;establece el directorio de trabajo.
	SetTitleMatchMode, 2 ;el título de una ventana puede contener «WinTitle» en cualquier lugar dentro para ser valido.
	SendMode, Input ;SendInput es generalmente mas rápido y mas fiable.
	CoordMode, Mouse, Screen
	SetControlDelay, -1
	SetKeyDelay, -1, -1, -1
	SetMouseDelay, -1
	SetWinDelay, -1
	SetDefaultMouseSpeed, 0
	DetectHiddenWindows, On
	DetectHiddenText, On
	ProcessSetPrivilege := ProcessAdjustPrivileges(-1, "SeDebugPrivilege,SeShutdownPrivilege"
		. ",SeIncreaseBasePriorityPrivilege,SeIncreaseWorkingSetPrivilege,SeLockMemoryPrivilege,SeSecurityPrivilege,SeSystemtimePrivilege"
		. ",SeTakeOwnershipPrivilege,SeTimeZonePrivilege,SeUndockPrivilege,SeAssignPrimaryTokenPrivilege,SeCreateTokenPrivilege"
		. ",SeManageVolumePrivilege,SeTrustedCredManAccessPrivilege,SeBackupPrivilege,SeRestorePrivilege")
} PixelGetColor(x := "", y := "", AltSlowRGB := 0) {
	if (x="")||(y="")
		MouseGetPos(x_, y_)
	PixelGetColor, OutputVar, % (x="")?x_:x, % (y="")?y_:y, %AltSlowRGB%
	return OutputVar
} FormatTime(Time, Format := "yyyyMMddHmmss") {
	FormatTime, hTime, %Time%, % Format=""?"dd/MM/yyyy (HH:mm:ss tt)":Format
	return hTime
}

;separar tiempo
;Sintaxis: SplitTime( [YYYYMMDDHH24MISS], [año], [mes], [dia], [hora], [min], [seg], [AM/PM] )
;Nota: devuelve un Array con el tiempo en el siguiente orden: año, mes, día, hora, min, seg, am/pm.
;Ejemplo: MsgBox % (i:=SplitTime()) i[3] "/" i[2] "/" i[1] " (" i[4] ":" i[5] ":" i[6] ")"
SplitTime(Time := "", ByRef Year := "", ByRef Mon := "", ByRef Day := "", ByRef Hour := "", ByRef Min := "", ByRef Sec := "", ByRef Mark := "") {
	FormatTime, Time, %Time%, yyyy,MM,dd,HH,mm,ss,tt
	Time := StrSplit(Time, ",")
	Loop, Parse, % "Year,Mon,Day,Hour,Min,Sec,Mark", `,
		%A_LoopField% := Time[A_Index]
	return Time
}

;traducir texto vía google translate
;Sintaxis: Translate( [texto], [entrada], [salida] )
;EJEMPLO: MsgBox % Translate("Hello, this is a test", "en", "es")
Translate(String, From := "", To := "") { ;no fiable
	i := ComObjCreate("WinHttp.WinHttpRequest.5.1")
	, url := "https://translate.google.com/translate_a/single?client=t&sl=" From "&tl=" To
	     . "&dt=bd&dt=ex&dt=ld&dt=md&dt=qca&dt=rw&dt=rm&dt=ss&dt=t&dt=at&ie=UTF-8&oe=UTF-8&otf=2&srcrom=0&ssel=0&tsel=3&q=" string
	, i.Open("GET", url, true)
	, i.SetRequestHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko)")
	, i.Send(), i.WaitForResponse()
	return RegExReplace(i.ResponseText, "^.*?" Chr(34) "(.*?)" Chr(34) ".*$")
}




























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: REGISTRO ::::::::::::::::::::::::::::::::::
;Parámetros:
	;Key: espesificar una de las siguientes. HKCR, HKCU, HKLM, HKU o HKCC.				HKPD
	;SubKey: espesificar la subclave.
	;FullKey: Key\SubKey.
	;ValueName: nombre de un valor en la clave espesificada. dejar vacío para afectar al valor por defecto o no espesificar el parámetro para no usar.
	;ValueType: tipo del valor. puede ser uno de los siguientes. https://msdn.microsoft.com/en-us/library/windows/desktop/ms724884(v=vs.85).aspx
		;REG_SZ 					= 1		(string)
		;REG_EXPAND_SZ 	= 2		(string, enviroment)
		;REG_BINARY 			= 3		(any binary format data)
		;REG_DWORD 			= 4		(32-Bit, max: 0xFFFFFFFF)
		;REG_MULTI_SZ 		= 7		(string, multiline)
		;REG_QWORD			= 11		(64-Bit, max: 0xFFFFFFFFFFFFFFFF)
	;----------------------------------------------------------------------------------------------
	;hKey: HANDLE a la Clave y/o SubClave. si la función tiene el parámetro SubKey y éste se espesifica, hKey debe hacer referencia solo a la Clave
		;Notas:
			;para obtener el HANDLE a la clave, usar RegOpenKey()
			;no es necesario que espesifique el HANDLE, también puede espesificar Key o FullKey.
	;DesiredAccess: acceso deseado para la clave. https://msdn.microsoft.com/en-us/library/windows/desktop/ms724878%28v=vs.85%29.aspx
		;0x0002 = KEY_SET_VALUE
		;0x00010000 = DELETE
		;0x0008 = KEY_ENUMERATE_SUB_KEYS
		;0x0001 = KEY_QUERY_VALUE
		;0x20019 = KEY_READ 
;Registry Element Size Limits: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724872(v=vs.85).aspx
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724875(v=vs.85).aspx
;Notas:
	;todas las funciones trabajan con WIN_XP exepto cuando se utiliza el parámetro SubKey, si lo permite o cuando se espesifica WIN_V+ en la funcion.
		;Este parámetro está para hacer mas facíl trabajar con varias subclaves, ya que solo se estaria abriendo la clave principal, lo que mejora el rendimiento.
		;por ejemplo, si va a utilizar cualquier clave bajo HKCU, solo debe usar RegOpenKey("HKCU") una sola vez, y solo pasar hKey como HANDLE; Todo esto en vez de abrir clave\subclave por cada subclave en la clave.
;#############################################################################################################################################
;abre una clave
;Sintaxis: RegOpenKey( [FullKey], [DesiredAccess], [in_out CreateIfNotExist] )
;Parámetros:
	;CreateIfNotExist:
		;In: espesificar TRUE para crear la clave si no existe.
		;Out: devuelve uno de los siguientes valores.
			;0x00000001 = REG_CREATED_NEW_KEY (la clave no existía y fué creada).
			;0x00000002 = REG_OPENED_EXISTING_KEY (la clave existe y fue abierta sin cambios).
;Return: hKey
RegOpenKey(FullKey, DesiredAccess := 0xF003F, ByRef CreateIfNotExist := false) {
	static RootKeys := {"HKEY_CLASSES_ROOT": 0x80000000, "HKCR": 0x80000000
		, "HKEY_CURRENT_USER": 0x80000001, "HKCU": 0x80000001
		, "HKEY_LOCAL_MACHINE": 0x80000002, "HKLM": 0x80000002
		, "HKEY_USERS": 0x80000003, "HKU": 0x80000003
		, "HKEY_PERFORMANCE_DATA": 0x80000004, "HKPD": 0x80000004
		, "HKEY_CURRENT_CONFIG": 0x80000005, "HKCC": 0x80000005}
	RegView := GetRegViewMode(), SplitKey(FullKey, Key, SubKey)
	if !RootKeys.HasKey(Key)
		return false
	if (CreateIfNotExist)
		Error := DllCall("Advapi32.dll\RegCreateKeyExW", "UInt", RootKeys[Key], "Ptr", &SubKey, "UInt", 0, "Ptr", 0, "UInt", 0, "UInt", DesiredAccess|RegView, "Ptr", 0, "PtrP", hKey, "UIntP", CreateIfNotExist:=0)
	else Error := DllCall("Advapi32.dll\RegOpenKeyExW", "UInt", RootKeys[Key], "Ptr", &SubKey, "UInt", 0, "UInt", DesiredAccess|RegView, "PtrP", hKey)
	return Error?false:hKey
} RegCloseKey(hKey*) {
	Error := ErrorLevel, Ok := 0
	for k, v in hKey
		Ok += DllCall("Advapi32.dll\RegCloseKey", "Ptr", v)=0 ;ERROR_SUCCESS = 0
	return Ok=hKey.MaxIndex(), ErrorLevel := Error
}

;separa una clave en clave, subclave y remueve espacios de la clave.
;Return: Clave\SubClave
;Sintaxis: SplitKey( [FullKey], [out Key], [out SubKey] )
SplitKey(ByRef FullKey, ByRef Key := "", ByRef SubKey := "") {
	FullKey := RTrim(FullKey, "\")
	return FullKey := ((Key:=Trim((KeyPos:=InStr(FullKey, "\"))?SubStr(FullKey, 1, KeyPos-1):FullKey))
		. (KeyPos?"\":"") (SubKey:=KeyPos?SubStr(FullKey, (KeyPos+1)):"", "\"))
}

;transforma una clave en su forma larga/corta
;Sintaxis: RegFormatKey( [Key], [Long] )
;Parámetros:
	;Long: establecer en TRUE para usar la forma larga.
RegFormatKey(Key, Long := 0) {
	static _0 := {"HKEY_CLASSES_ROOT": "HKCR", "HKEY_CURRENT_CONFIG": "HKCC", "HKEY_CURRENT_USER": "HKCU", "HKEY_LOCAL_MACHINE": "HKLM", "HKEY_USERS": "HKU"}
	static _1 := {"HKCR": "HKEY_CLASSES_ROOT", "HKCC": "HKEY_CURRENT_CONFIG", "HKCU": "HKEY_CURRENT_USER", "HKLM": "HKEY_LOCAL_MACHINE", "HKU": "HKEY_USERS"}
	if (p:=InStr(Key:=Trim(Key, "`r`n" A_Space "\" A_Tab), "\"))
		s := StrTrimLeft(Key, p-1), Key := StrLeft(Key, p-1)
	return (Long?(_1[Key]?_1[Key]:Key):(_0[Key]?_0[Key]:Key)) s
}

;eliminar valor por defecto, o valor espesífico
;Sintáxis: RegDeleteKeyValue( [hKey], [SubKey], [ValueName] )
;Acceso Requerido: KEY_SET_VALUE
;Return: 0|1
;Notas:
	;cuando usa el parámetro SubKey, solo es válido para WIN_V+. Para hacerlo comparible con WIN_XP+ espesificar la clave y subclave en hKey.
;Ejemplo: eliminar valor y valor por defecto.
	;MsgBox % RegDeleteKeyValue("HKCU\Software",, "ValueName") ;eliminar valor ValueName de la subclave Software
	;MsgBox % RegDeleteKeyValue("HKCU\Software") ;eliminar valor por defecto de la subclave Software
	;MsgBox % RegDeleteKeyValue("HKCU") ;eliminar valor por defecto de la clave HKCU
RegDeleteKeyValue(hKey, SubKey := "", ValueName := "") {
	if ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x0002))
		return false, ErrorLevel := -1
	if (SubKey = "")
		Error := DllCall("Advapi32.dll\RegDeleteValueW", "Ptr", hKey, "Ptr", &ValueName)
	else Error := DllCall("Advapi32.dll\RegDeleteKeyValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName)
	if (Close)
		RegCloseKey(hKey)
	return Error=0, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724848(v=vs.85).aspx

;eliminar clave junto con todas las subclaves y valores
;Sintaxis: RegDeleteTree( [hKey], [SubKey], [Recurse] )
;Parámetros:
	;Recurse: establecer en FALSE para evitar eliminar la clave y sus valores si tiene subclaves.
;Acceso Requerido:
	;Para eliminar una clave y sus valores: KEY_SET_VALUE | DELETE
	;Para eliminar la clave junto con todas sus subclaves y valores: KEY_SET_VALUE | DELETE | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE
;Return: 0|1
RegDeleteTree(hKey, SubKey := "", Recurse := true) { ;WIN_V+
	if ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x0002|0x00010000|(Recurse?0x0008|0x0001:0)))
		return false, ErrorLevel := -1
	if !(Recurse) {
		Error := DllCall("Advapi32.dll\RegDeleteKeyExW", "Ptr", hKey, "Ptr", &SubKey, "UInt", GetRegViewMode(), "Ptr", 0)
	} else { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724847(v=vs.85).aspx
		Error := DllCall("Advapi32.dll\RegDeleteTreeW", "Ptr", hKey, "Ptr", &SubKey)
		if (SubKey="")
			Error := DllCall("Advapi32.dll\RegDeleteKeyExW", "Ptr", hKey, "Ptr", &SubKey, "UInt", GetRegViewMode(), "Ptr", 0)
	} if (Close)
		RegCloseKey(hKey)
	return Error=0, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379776(v=vs.85).aspx

;copia una clave junto con todas sus subclaves y valores
;Sintaxis: RegCopyTree( [hKey], [SubKey], [in_out KeyDest], [Recurse] )
;Parámetros:
	;KeyDest: 
		;In: espesificar la clave\subclave destino. si no existe la crea.
		;Out: además de espesificar una clave, espesificar un variable de salida para devolver un HANDLE a la nueva clave.
			;Nota: para devolver el HANDLE, sumar 2 al 4to parámetro (Recurse).
	;Recurse: establecer en FALSE para copiar solo la clave, sus valores y el valor por defecto. solo válido cuando se usa FullKey en hKey (no usar HANDLE)
;Acceso Requerido: KEY_READ 
;Notas:
	;si la clave destino ya existe, los valores que coincidan con el mismo nombre son reescritos, los demás no los modifica.
	;cuando usa el parámetro SubKey, solo es válido para WIN_V+. Para hacerlo comparible con WIN_XP+ espesificar la clave y subclave en hKey.
;Ejemplo: 
	;MsgBox % RegCopyTree("HKCU\SubKey",, "HKCU\NewSubKey")
	;MsgBox % RegCopyTree("HKCU\SubKey2",, "HKCU\NewSubKey", false)
RegCopyTree(hKey, SubKey := "", ByRef KeyDest := "", Recurse := true) { 
	if (Recurse) && ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x20019))
		return false, ErrorLevel := -1
	if !(hKeyDest:=RegOpenKey(KeyDest,, true)) || !hKey
		return false, ErrorLevel := -2
	if (Recurse) { ;copiar clave, subclaves y valores
		if (SubKey = "")
			Error := DllCall("Shlwapi.dll\SHCopyKeyW", "Ptr", hKey, "Ptr", 0, "Ptr", hKeyDest, "UInt", 0)
		else Error := DllCall("Advapi32.dll\RegCopyTreeW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", hKeyDest)
	} else { ;copiar clave y valores
		hKey := RegOpenKey(hKey "\" SubKey, 0x0001), Close := true, Index := 0
		while RegEnumValue(hKey, Index++, ValueName,,, ValueType) ;busca todos los valores en la clave y los copia.
			Data := RegGetValue(hKey,, ValueName), RegSetKeyValue(ValueType, hKeyDest,, ValueName, Data)
		Data := RegGetValue(hKey,,, ValueType), Error := ErrorLevel?!RegDeleteKeyValue(hKeyDest):!RegSetKeyValue(ValueType, hKeyDest,,, Data)
	} if (Close)
		RegCloseKey(hKey)
	if !((Recurse=2) || (Recurse=3)) || !IsByRef(KeyDest)
		RegCloseKey(hKeyDest)
	else KeyDest := hKeyDest
	return Error=0, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379768(v=vs.85).aspx

;establecer datos y tipo a un valor espesífico en el registro
;Sintaxis: RegSetKeyValue( [ValueType], [hKey], [SubKey], [ValueName], [Datos] )
;Acceso Requerido: KEY_SET_VALUE
;Notas:
	;para establecer valores de tipo REG_BINARY, debe espesificarlo en hexadecimal, para convertir string a hex usar StrToHex()
	;cuando usa el parámetro SubKey, solo es válido para WIN_V+. Para hacerlo comparible con WIN_XP+ espesificar la clave y subclave en hKey.
;Ejemplo:
/*
	MsgBox % RegSetKeyValue("REG_SZ", "HKCU\SubKey",,, "Default Value")
		MsgBox % RegGetValue("HKCU\SubKey",,, ValueType) "`n`n" ValueType
	MsgBox % RegSetKeyValue("REG_SZ", "HKCU\SubKey",, "ValueName 1", "Data")
		MsgBox % RegGetValue("HKCU\SubKey",, "ValueName 1", ValueType) "`n`nValueType: " ValueType
	MsgBox % RegSetKeyValue("REG_EXPAND_SZ", "HKCU\SubKey",, "ValueName 2", "Data")
		MsgBox % RegGetValue("HKCU\SubKey",, "ValueName 2", ValueType) "`n`nValueType: " ValueType
	MsgBox % RegSetKeyValue("REG_MULTI_SZ", "HKCU\SubKey",, "ValueName 3", "Line 1`nLine 2")
		MsgBox % RegGetValue("HKCU\SubKey",, "ValueName 3", ValueType) "`n`nValueType: " ValueType
	MsgBox % RegSetKeyValue("REG_DWORD", "HKCU\SubKey",, "ValueName 4", 0xFFFFFFFF)
		MsgBox % RegGetValue("HKCU\SubKey",, "ValueName 4", ValueType) "`n`nValueType: " ValueType
	MsgBox % RegSetKeyValue("REG_QWORD", "HKCU\SubKey",, "ValueName 5", 0xFFFFFFFFFFFFFFFF)
		MsgBox % RegGetValue("HKCU\SubKey",, "ValueName 5", ValueType) "`n`nValueType: " ValueType
	MsgBox % RegSetKeyValue("REG_BINARY", "HKCU\SubKey",, "ValueName 6", StrToHex("--> REG_BINARY DATA <-- ", ""))
		MsgBox % HexToStr(RegGetValue("HKCU\SubKey",, "ValueName 6", ValueType)) "`n`nValueType: " ValueType "`n`nErrorLevel: " ErrorLevel
	ExitApp
*/ 
RegSetKeyValue(ValueType, hKey, SubKey := "", ValueName := "", Data := "") {
	if ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x0002, true))
		return false, ErrorLevel := -1
	if (ValueType="REG_SZ") || (ValueType=1) {
		if (SubKey = "")
			Error := DllCall("Advapi32.dll\RegSetValueExW", "Ptr", hKey, "Ptr", &ValueName, "UInt", 0, "UInt", 1, "Ptr", &Data, "UInt", (StrLen(Data)*2) + 1)
		else Error := DllCall("Advapi32.dll\RegSetKeyValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", 1, "Ptr", &Data, "UInt", (StrLen(Data)*2) + 1)
	} else if (ValueType="REG_EXPAND_SZ") || (ValueType=2) {
		if (SubKey = "")
			Error := DllCall("Advapi32.dll\RegSetValueExW", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "UInt", 2, "Ptr", &Data, "UInt", (StrLen(Data)*2) + 1)
		else Error := DllCall("Advapi32.dll\RegSetKeyValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", 2, "Ptr", &Data, "UInt", (StrLen(Data)*2) + 1)
	} else if (ValueType="REG_BINARY") || (ValueType=3) {
		Loop, % Size := (VarSetCapacity(Data2, StrLen(Data)) / 2)
			NumPut(Int("0x" SubStr(Data, 1, 2)), Data2, A_Index - 1, "UChar"), Data := SubStr(Data, 3)
		if (SubKey = "")
			Error := DllCall("Advapi32.dll\RegSetValueExW", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "UInt", 3, "Ptr", &Data2, "UInt", Size)
		else Error := DllCall("Advapi32.dll\RegSetKeyValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", 3, "Ptr", &Data2, "UInt", Size)
	} else if (ValueType="REG_DWORD") || (ValueType="REG_QWORD") || (ValueType=11) || (ValueType=4) {
		Data := Hex(Data), Data := (Data+0)=""?0:Data, Type := (ValueType="REG_QWORD"||ValueType=11)?11:4, Size := (ValueType="REG_QWORD"||ValueType=11)?8:4
		if (SubKey = "")
			Error := DllCall("Advapi32.dll\RegSetValueExW", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "UInt", Type, "PtrP", Data, "UInt", Size)
		else Error := DllCall("Advapi32.dll\RegSetKeyValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", Type, "PtrP", Data, "UInt", Size)
	} else if (ValueType="REG_MULTI_SZ") || (ValueType=7) {
		Loop, Parse, % Data, `n, `r
			Data2 .= A_LoopField=""?"":A_LoopField "`r`n"
		if (SubKey = "")
			Error := DllCall("Advapi32.dll\RegSetValueExW", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "UInt", 7, "Ptr", &Data2, "UInt", (StrLen(Data2)*2) + 2)
		else Error := DllCall("Advapi32.dll\RegSetKeyValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", 7, "Ptr", &Data2, "UInt", (StrLen(Data2)*2) + 2)
	} else Error := -2
	if (Close)
		RegCloseKey(hKey)
	return Error=0, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724921(v=vs.85).aspx

;obtener datos de un valor
;Sintaxis: RegGetValue( [hKey], [SubKey], [ValueName], [out ValueType] )
;Acceso Requerido: KEY_QUERY_VALUE
;Notas:
	;los valores de tipo REG_BINARY se obtienen en hexadecimal, para converit a string usar HexToStr()
	;cuando usa el parámetro SubKey, solo es válido para WIN_V+. Para hacerlo comparible con WIN_XP+ espesificar la clave y subclave en hKey.
	;al parecer, la función RegGetValue (usada cuando usa el parámetro SubKey, WIN_V+) devuelve un ValueType incorrecto para REG_EXPAND_SZ (devuelve REG_SZ), usar RegExistValue() para obtener el tipo correcto.
RegGetValue(hKey, SubKey := "", ValueName := "", ByRef ValueType := "") { 
	if ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x0001))
		return "", ErrorLevel := -1
	if (SubKey = "")
		DllCall("Advapi32.dll\RegQueryValueExW", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "Ptr", 0, "Ptr", 0, "UIntP", Size)
	else DllCall("Advapi32.dll\RegGetValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", 0x0000FFFF, "Ptr", 0, "Ptr", 0, "UIntP", Size)
	VarSetCapacity(Data, Size, 0), Offset := 0, VarSetCapacity(ValueType, 0)
	if (SubKey = "")
		Error := DllCall("Advapi32.dll\RegQueryValueExW", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "UIntP", ValueType, "Ptr", &Data, "UIntP", Size)
	else Error := DllCall("Advapi32.dll\RegGetValueW", "Ptr", hKey, "Ptr", &SubKey, "Ptr", &ValueName, "UInt", 0x0000FFFF, "UIntP", ValueType, "Ptr", &Data, "UIntP", Size)
	ValueType := RegFormatValueType(ValueType, Type)
	if (ValueType = "REG_SZ") || (ValueType = "REG_EXPAND_SZ") || (ValueType = "REG_MULTI_SZ") {
		Loop {
			if (Length := StrLen(Data2 := StrGet(&Data + Offset, Size, "UTF-16")))
				Data3 .= Data2 "`n", Offset += Length * 2 + 2
		} until !(Length)
		Data := Trim(Data3, "`n")
	} else if (ValueType = "REG_QWORD") || (ValueType = "REG_DWORD") {
		Data := NumGet(Data, 0, Type)
	} else if (ValueType = "REG_BINARY") {
		Loop, % (Size)
			Data2 .= Hex(NumGet(Data, (A_Index - 1) * 1, "UChar"), 2, true, "")
		Data := Data2
	} else Error := -2
	if (Close)
		RegCloseKey(hKey)
	return Error=0?Data:"", ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724868(v=vs.85).aspx

;busca valor por valor en una clave espesífica con el Indice espesificado
;Sintaxis: RegEnumValue( [hKey], [Index, en base 0], [out ValueName], [opt sizeof_ValueName, en carácteres], [0], [out ValueType], [out Data], [sizeof_Data] )
;Return:
	;0 = ERROR
	;1 = OK o ErrorLevel=255
;ErrorLevel:
	;0 = OK
	;255 = se ha encontrado el valor en el Index espesificado.
	;[X] = ERROR
RegEnumValue(hKey, dwIndex, ByRef lpValueName, lpcchValueName := 0, lpReserved := 0, ByRef lpType := 0, ByRef lpData := 0, lpcbData := 0) {
	if (lpcchValueName=0) ;si no se espesificó el tamaño para ValueName, establecerlo en 32767 bytes, que es el máximo.
		VarSetCapacity(lpValueName, 0), lpcchValueName := VarSetCapacity(lpValueName, 32767 * 2 + 1, 0)
	Error := DllCall("Advapi32.dll\RegEnumValueW", "Ptr", hKey, "UInt", dwIndex, "Ptr", &lpValueName, "UIntP", lpcchValueName
		, "Ptr", lpReserved, "UIntP", lpType, "Ptr", lpData, "Ptr", lpcbData), VarAdjustCapacity(lpValueName)
	return Error=0||Error=256, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724865(v=vs.85).aspx

;guardar clave junto con todas las subclaves y valores a un archivo
;Sintaxis: RegSaveKey( [FullKey], [Filename], [Overwrite] )
;Privilegio Requerido: SeBackupPrivilege
RegSaveKey(FullKey, Filename, Overwrite := true) {
	if FileExist(Filename) {
		if !(Overwrite)
			return false, ErrorLevel := -1
		DeleteFile(Filename)
	} SplitKey(FullKey, Key, SubKey), hKey := RegOpenKey(FullKey, 0x0001|0x0008)
	if (Key="HKCR") ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724917(v=vs.85).aspx
		Error := DllCall("Advapi32.dll\RegSaveKeyW", "Ptr", hKey, "Ptr", &Filename, "Ptr", 0)
	else Error := DllCall("Advapi32.dll\RegSaveKeyExW", "Ptr", hKey, "Ptr", &Filename, "Ptr", 0, "UInt", 2)
	return Error=0, ErrorLevel := Error, RegCloseKey(hKey)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724919(v=vs.85).aspx

;restaurar todas las subclaves y valores a una clave espesífica desde un archivo
;Sintaxis: RegSaveKey( [FullKey], [Filename] )
;Privilegio Requerido: SeRestorePrivilege
RegRestoreKey(FullKey, Filename) {
	hKey := RegOpenKey(FullKey, 0x0004|0x0002, true)
	, Error := DllCall("Advapi32.dll\RegRestoreKeyW", "Ptr", hKey, "Ptr", &Filename, "UInt", 0x00000008)
	return Error=0, ErrorLevel := Error, RegCloseKey(hKey)
}

;abrir Regedit y navegar hasta la clave espesificada
;Sintaxis: RegOpen( [FullKey] )
;Ejemplo: MsgBox % RegOpen("HKLM\SOFTWARE\Classes\*")
RegOpen(FullKey) {
	FullKey := RegFormatKey(FullKey, true), TerminateProcess(A_WinDir "\regedit.exe")
	if !RegSetKeyValue(1, "HKCU\Software\Microsoft\Windows\CurrentVersion\Applets\Regedit",, "LastKey", FullKey)
		return false
	Run, %A_WinDir%\regedit.exe, %A_WinDir%, UseErrorLevel, PID
	return ErrorLevel?false:PID
}

;obtener informción de una clave
;Sintaxis: RegQueryInfoKey( [hKey], [out SubKeys], [out Values] )
;Parámetros:
	;SubKeys: devuelve al cantidad de subclaves en la clave espesificada
	;Values: devuelve la cantidad de valores en la clave espesificada, incluido el valor por defecto, si lo tiene.
;Ejemplo: MsgBox % RegQueryInfoKey("HKCU", SubKeys, Values) "`nSubKeys: " SubKeys "`nValues: " Values
RegQueryInfoKey(hKey, ByRef SubKeys := 0, ByRef Values := 0) {
	if ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x0001))
		return false, ErrorLevel := -1
	Error := DllCall("Advapi32.dll\RegQueryInfoKeyW", "Ptr", hKey, "Ptr", 0, "Ptr", 0, "Ptr", 0, IsByRef(SubKeys)?"UIntP":"Ptr", SubKeys
		, "Ptr", 0, "Ptr", 0, IsByRef(Values)?"UIntP":"Ptr", Values, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
	if (Close)
		RegCloseKey(hKey)
	return Error=0, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724902(v=vs.85).aspx

;comprueba si existe una clave 
;Sintaxis: RegExistKey( [FullKey], [¿buscar en subclaves?] )
;Return: Key
RegExistKey(Key, Recurse := false) {
	hKey := RegOpenKey(Key, 0x0001)
	return !!hKey, RegCloseKey(hKey)
}

;comprueba si existe un valor en la clave espesificada
;Sintaxis: RegExistValue( [hKey], [valor] )
;Return: ValueType
;Nota: dejar el 2do parámetro vacío para comprobar si existe el valor predeterminado.
RegExistValue(hKey, ValueName := "") {
	if ((hKey+0)="") && (Close := true) && !(hKey := RegOpenKey(hKey, 0x0001))
		return false
	Error := DllCall("Advapi32.dll\RegQueryValueEx", "Ptr", hKey, "Ptr", &ValueName, "Ptr", 0, "UIntP", ValueType, "Ptr", 0, "Ptr", 0)
	if (Close)
		RegCloseKey(hKey)
	return Error=0?RegFormatValueType(ValueType):false
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PARA USO INTERNO
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Return: 
	;0x0000 = DEFAULT
	;0x0200 = KEY_WOW64_32KEY  (as 32-Bit)
	;0x0100 = KEY_WOW64_64KEY  (as 64-Bit)
GetRegViewMode() {
	if (A_RegView=32)
		return 0x0200
	if (A_RegView=64) ;) || (A_PtrSize=8)
		return 0x0100
	return 0x0000
}

RegFormatValueType(ValueType, ByRef Type := "") {
	static ValueTypes := {1: "REG_SZ", 2: "REG_EXPAND_SZ", 3: "REG_BINARY", 4: "REG_DWORD", 7: "REG_MULTI_SZ", 11: "REG_QWORD"}
	if IsByRef(Type)
		Type := (ValueType=1||ValueType=2||ValueType=7)?"UTF-16":ValueType=11?"UInt64":ValueType=4?"UInt":ValueType=3?"CP0":""
	return ValueTypes[ValueType]?ValueTypes[ValueType]:-1
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;importar clave
;Sintaxis: RegImport( [Filename], [Wait] )
RegImport(Filename, Wait := false) { ;RegRestoreKey()
	if (Wait)
		RunWait, %A_WinDir%\regedit.exe -v -s "%FileName%",, UseErrorLevel
	else Run, %A_WinDir%\regedit.exe -v -s "%FileName%",, UseErrorLevel
	return !ErrorLevel
}

;exportar clave
;Sintaxis: RegExport( [Key], [Filename], [Wait], [OverWrite] )
RegExport(Key, Filename, Wait := false, OverWrite := true) { ;RegSaveKey()
	if !(OverWrite) && (FileExist(Filename))
		return false, ErrorLevel := -1
	Key := RegFormatKey(Key, true)
	if (Wait)
		RunWait, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%",, UseErrorLevel
	else Run, %A_WinDir%\regedit.exe -e "%Filename%" "%Key%",, UseErrorLevel
	return !ErrorLevel
}

RegRead(Key, ValueName*) {
	if (ValueName.MaxIndex())
		RegRead, Value, %Key%, % ValueName[1]
	else RegRead, Value, %Key%
	return Value
}

RegDelete(Key, ValueName*) {
	if !(Key)
		return false, ErrorLevel := true
	if (ValueName.MaxIndex()) {
		hRegKey := RegOpenKey(Key, 0x0002)
		for k, v in ValueName
			Result := DllCall("Advapi32.dll\RegDeleteValueW", "Ptr", hRegKey, "Str", v)
		DllCall("Advapi32.dll\RegCloseKey", "Ptr", hRegKey), ErrorLevel := Result?true:false
	} else RegDelete, %Key%
	return ErrorLevel?false:Key
}

RegWrite(ValueType := 0, Key := "", ValueName := "", Value*) {
	static ValueTypes := {"REG_BINARY": "REG_BINARY", "BINARY": "REG_BINARY"
		, "REG_DWORD": "REG_DWORD", "DWORD": "REG_DWORD"
		, "REG_EXPAND_SZ": "REG_EXPAND_SZ", "EXPAND": "REG_EXPAND_SZ"
		, "REG_MULTI_SZ": "REG_MULTI_SZ", "MULTI": "REG_MULTI_SZ"
		, "REG_SZ": "REG_SZ", "SZ": "REG_SZ"}
	if !(Type:=ValueTypes[ValueType])
		Key := Key?Key:ValueType, Type := "REG_SZ"
	if !(Key)
		return false
	if (ValueName="") && !(Value.MaxIndex()) 
		RegWrite, %Type%, %Key%
	else if (ValueName="")
		RegWrite, %Type%, %Key%,, % Value[1]
	else if (Value.MaxIndex())
		RegWrite, %Type%, %Key%, %ValueName%, % Value[1]
	else RegWrite, %Type%, %Key%, %ValueName%
	return ErrorLevel?false:Key
}

;renombrar una clave
;Sintaxis: RegRenameKey( [clave\subclave], [nuevo nombre], [¿sobreescribir si ya existe una clave con el mismo nombre?] )
;ErrorLevel: 2 = ya existe una clave con el mismo nombre | 3 = el nuevo nombre espesificao no es válido | 4 = la clave a renombrar no es válida
;Ejemplo: RegRenameKey("HKLM\Software\AutoHotKey", "AutoHotKey_Rename")
RegRenameKey(Key, NewName, OverWrite := false) {
	NewName := StrReplace(NewName, "\")
	if (NewName="") || !(InStr(Key, "\"))
		return false, ErrorLevel := NewName=""?3:4
	SplitPath, Key,, BKey
	return RegMoveKey(Key, BKey "\" NewName, OverWrite)
}

;mover clave junto con todos los valores y subclaves
;Sintaxis: RegMoveKey( [clave\subclave], [clave\subclave destino], [¿sobreescribir?] )
;ErrorLevel: 2 = ya existe la clave destino
;Ejemplo: 
	;MsgBox % RegMoveKey("HKLM\Software\AutoHotKey", "HKCU\AutoHotKey") "," ErrorLevel
	;MsgBox % RegMoveKey("HKCU\AutoHotKey", "HKLM\Software\AutoHotKey") "," ErrorLevel
RegMoveKey(Key, KeyDest := "", OverWrite := false) {
	if (RegExistKey(KeyDest)) {
		if !(OverWrite)
			return false, ErrorLevel := 2
		RegDelete(KeyDest)
	} Result := RegCopyKey(Key, KeyDest)
	if (Result)
		return Result, RegDelete(Key), ErrorLevel := !Result
	return false
}

;copiar clave junto con todos los valores, opcional incluir subclaves
;Sintaxis: RegCopyKey( [clave\subclave], [clave\subclave destino], [¿copiar subclaves?=true] )
;Nota: si la clave destino no existe, la crea.
;Ejemplo: RegCopyKey("HKLM\Software\AutoHotKey", "HKCU\AutoHotKey")
RegCopyKey(Key, KeyDest, Recurse := true) { ;KEY_READ = 0x20019 | KEY_ALL_ACCESS = 0xF003F
	hRegKey := RegOpenKey(Key, 0x20019, Result:=false), hRegKeyDest := RegOpenKey(KeyDest,, true)
	if (Recurse) {
		if (IsWindowsVistaOrGreater()) ;if OS Version >= Win V | ERROR_SUCCESS = 0
			Result := DllCall("Advapi32.dll\RegCopyTreeW", "Ptr", hRegKey, "Ptr", 0, "Ptr", hRegKeyDest) ;WIN_V+
		else Result := DllCall("Shlwapi.dll\SHCopyKeyW", "Ptr", hRegKey, "Ptr", 0, "Ptr", hRegKeyDest, "UInt", 0) ;WIN_2000+
	} else {
		Loop, Reg, %Key%, V
			RegWrite(A_LoopRegType, KeyDest, A_LoopRegName, RegRead(Key, A_LoopRegName))
		if (Value:=RegRead(Key))
			RegWrite(, KeyDest,, Value)
	} return !Result, RegCloseKey(hRegKeyDest, hRegKey), ErrorLevel := Result
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379768(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/bb773482(v=vs.85).aspx

;devuelve una clave o valor que no exista
;Sintaxis: RegFNKey( [clave], [valor], [inicio], [fin] )
;Ejemplo:
	;RegDelete("HKCU\Lol"),RegDelete("HKCU\Lol(1)"),MsgBox(RegFNKey("HKCU\Lol")),RegWrite("HKCU\Lol"),MsgBox(RegFNKey("HKCU\Lol"))
	;,RegWrite("HKCU\Lol(1)"),MsgBox(RegFNKey("HKCU\Lol")),RegDelete("HKCU\Lol"),RegDelete("HKCU\Lol(1)")
RegFNKey(Key, Value := "", Start := "(", End := ")") {
	if (Value="") {
		Loop {
			if RegExistKey(tmpkey?tmpkey:Key)
				tmpkey := tmpkey?StrReplace(tmpkey, Start (A_Index-1) End, Start A_Index End):Key Start 1 End
			else return tmpkey?tmpkey:Key
	}} else {
		Loop {
			if RegExistKey(Key, tmpkey?tmpkey:Value)
				tmpkey := tmpkey?StrReplace(tmpkey, Start (A_Index-1) End, Start A_Index End):Value Start 1 End
			else return tmpkey?tmpkey:Value
}}}

;establecer seguridad para la clave
;Sintaxis: RegSetSecurity( [clave\subclave], [usuario], [acceso] )
;Parámetros: ver FileSetSecurity()
;Nota: la función falla si el usuario actual no es el propietario. usar RegSetOwner()
RegSetSecurity(Key, Trustee := "", AccessMask := 0x1F01FF, Flags := 1, AccesFlag := 0) { ;WIN_V+
	Trustee := Trustee=""?A_UserNameEx():Trustee
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key, 3, 1)
	, Owner := oADsSecurityDescriptor.Owner
	if !(Trustee=Owner) && !(Owner="") && !(Trustee="")
		RegSetOwner(Key, Trustee)
	oDiscretionaryAcl := oADsSecurityDescriptor.DiscretionaryAcl
	, oAccessControlEntry := ComObjCreate("AccessControlEntry")
	, oAccessControlEntry.Trustee := Trustee
	, oAccessControlEntry.AccessMask := AccessMask
	, oAccessControlEntry.AceFlags := Flags
	, oAccessControlEntry.AceType := AccesFlag
	, oDiscretionaryAcl.AddAce(oAccessControlEntry)
	, oADsSecurityUtility.SetSecurityDescriptor(Key, 3, oADsSecurityDescriptor, 1)
}

;establecer el propietario
;Sintaxis: RegSetOwner( [clave], [usuario] )
;Parámetros:
	;Usuario: espesificar el dominio\usuario o el SID del usuario. por defecto usa el usuario actual.
RegSetOwner(Key, Owner := "", Recurse := false) {
	Owner := Owner=""?A_UserNameEx():Owner
	, oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key, 3, 1)
	if !(oADsSecurityDescriptor.Owner=Owner)
		oADsSecurityDescriptor.Owner := Owner
		, oADsSecurityUtility.SetSecurityDescriptor(Key, 3, oADsSecurityDescriptor, 1)
	if (Recurse)
		Loop, Reg, %Key%, KR
			oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key:=(A_LoopRegKey "\"
			. (A_LoopRegSubkey=""?"":A_LoopRegSubkey "\") A_LoopRegName), 3, 1)
			, oADsSecurityDescriptor.Owner := Owner
			, oADsSecurityUtility.SetSecurityDescriptor(Key, 3, oADsSecurityDescriptor, 1)
}

;obtiene el dominio y nombre de usuario propietario
;Sintaxis: RegGetOwner( [clave] )
;Return: dominio\usuario
RegGetOwner(Key) { ;WIN_V+
	oADsSecurityUtility := ComObjCreate("ADsSecurityUtility")
	, oADsSecurityUtility.SecurityMask := 0x1
	, oADsSecurityDescriptor := oADsSecurityUtility.GetSecurityDescriptor(Key, 3, 1)
	return oADsSecurityDescriptor.Owner
}





















































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: EDIT CONTROL ::::::::::::::::::::::::::::::::::
NOTAS:
	;para establecer o quitar un estilo, usar WinSetStyle(hWnd, Estilo)
	;para obtener el estilo, usar WinGetStyle(hWnd)
#############################################################################################################################################
*/
;obtiene el número de líneas
;Sintaxis: Edit_GetLineCount( [hWnd] )
;Nota: si no hay texto en el control, devuelve 1. el valor nunca será inferior a 1.
Edit_GetLineCount(hWnd) {
	return SendMessage(hWnd, 0x00BA,,,,, "Int")
}

;obtiene el texto de una linea
;Sintaxis: Edit_GetLineText( [hWnd], [Linea] )
Edit_GetLineText(hWnd, Line := -1) {
	nSize := 32767 ;SendMessage(hWnd, 0x00C1,, Line-1)
	, Line := Line=-1?Edit_GetCurrentLine(hWnd):Line
	, VarSetCapacity(LineText, nSize, 0), NumPut(nSize, LineText, 0, "UShort")
	, SendMessage(hWnd, 0x00C4, "Int", Line-1, "Int", &LineText)
	return LineText 
}

;obtiene el índice de la línea que contiene el índice de caracteres especificado en un control de edición multilínea
;Sintaxis: Edit_GetCurrentLine( [hWnd], [índice] )
;Nota: por defecto obtiene la linea actual.
Edit_GetCurrentLine(hWnd, Line := -1) {
	return SendMessage(hWnd, 0x00C9, "Int", Line=-1?-1:Line-1,,, "Int")+1
}

;obtiene el número de columna en el que reside el cursor (punto de inserción de texto). 
;Sintaxis: Edit_GetColumn( [hWnd], [inicio (salida)], [fin (salida)] )
;Inicio: columna donde empieza la seleccion
;Fin: columna donde termina la seleccion
;Notas: 
	;si no hay texto seleccionado, el 2do y 3er parametro devuelven el mismo resultado.
	;la primera columna es 1.
	;si hay texto seleccionado en el control, devuelve el número de columna donde comienza la selección.
Edit_GetColumn(hWnd, ByRef Starting := "", ByRef End := "") {
	VarSetCapacity(s, 4), VarSetCapacity(e, 4)
	, SendMessage(hWnd, 0x00B0,, &s,, &e)
	, Starting := NumGet(s, 0, "UInt")+1, End := NumGet(e, 0, "UInt")+1
	return Starting
}

;obtiene el hWnd del Edit de un ComboBox. opcional también el del DropDownList
;Sintaxis: Edit_GetComboBox( [hWnd], [ComboBox (salida)], [DropDownList (salida)] )
Edit_GetComboBox(hWnd, ByRef DropDownList := "", ByRef EditRect := "", ByRef DDLRect := "") {
	nSize := VarSetCapacity(COMBOBOXINFO, 40+(A_PtrSize*3), 0)
	, NumPut(nSize, COMBOBOXINFO, 0, "UInt")
	, r:=DllCall("User32.dll\GetComboBoxInfo", "Ptr", hWnd, "Ptr", &COMBOBOXINFO)
	return NumGet(COMBOBOXINFO, 40+A_PtrSize, "UPtr")
		, DropDownList := IsByRef(DropDownList)?NumGet(COMBOBOXINFO, 44+A_PtrSize, "UPtr"):""
		, EditRect := IsByRef(EditRect)?NumGet(COMBOBOXINFO, 28+A_PtrSize, "Ptr"):""
		, DDLRect := IsByRef(DDLRect)?RECT(NumGet(COMBOBOXINFO, 12+A_PtrSize, "Ptr")):""
		, ErrorLevel := !r
}

;obtiene el texto
;Sintaxis: Edit_GetText( [hWnd] )
Edit_GetText(hWnd) {
	nSize := SendMessage(hWnd, 0x000E,,,,, "UInt")
	, VarSetCapacity(Text, (nSize * 2) + 1, 0)
	, SendMessage(hWnd, 0x000D, "UInt", nSize+1,, &Text)
	return Text
}

;recupera informacion de la barra de desplazamiento.
;Sintaxis: Edit_GetScrollBarInfo( [hWnd], [barra], [enabled], [pressed], [offscreen], [visible], [coordenadas] )
;Barra: 0 = horizontal | 1 = vertical (defecto)
;Enabled: la barra está deshabilitada. (0|1)
;Pressed: se pulsa sobre la barra. (0|1)
;OffScreen: la ventana tiene un tamaño tal que la barra no se muestra actualmente. (0|1)
;Visible: indica que la barra existe. (0|1)
Edit_GetScrollBarInfo(hWnd, ScrollBar := 1, ByRef Enabled := "", ByRef Pressed := "", ByRef OffScreen := "", ByRef Visible := "", ByRef RECT := "") {
	VarSetCapacity(SCROLLBARINFO, 60, 0), NumPut(60, SCROLLBARINFO, 0, "UInt")
	return r:=DllCall("User32.dll\GetScrollBarInfo", "Ptr", hWnd
		, "Int", ScrollBar=0?0xFFFFFFFA:ScrollBar=1?0xFFFFFFFB:ScrollBar
		, "Ptr", &SCROLLBARINFO), SBInfo := NumGet(SCROLLBARINFO, 36, "UInt")
	, RECT := IsByRef(RECT)?NumGet(SCROLLBARINFO, 16, "Ptr"):"", Visible := SBInfo&0x8000?false:true, ErrorLevel := !r
	, Pressed := SBInfo&0x8?true:false, OffScreen := SBInfo&0x10000?true:false, Enabled := SBInfo&0x1?false:true
}

;obtiene la señal textual que se muestra por el control de edición
;Sintaxis: Edit_GetCueBannerText( [hWnd] )
Edit_GetCueBannerText(hWnd, nSize := 2048) {
	VarSetCapacity(Text, nSize, 0)
	, SendMessage(hWnd, 0x1502,, &Text, "UInt", nSize)
	return Text
}

;obtiene el carácter de contraseña que se muestra en el control
;Sintaxis: Edit_GetPasswordChar( [hWnd] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_GetPasswordChar(hWnd) {
	SendMessage(hWnd, 0x00D2)
}

;obtiene las coordenadas del control
;Sintaxis: Edit_GetPos( [hWnd], [x], [y], [ancho], [alto] )
Edit_GetPos(hWnd, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	VarSetCapacity(RECT, 16, 0)
	, r:=DllCall("User32.dll\GetWindowRect", "Pr", hWnd, "Ptr", &RECT)
    , i := {}, i.w := i.Width := Width := NumGet(RECT, 8, "Int")-NumGet(RECT, 0, "Int")
	, i.h := i.Height := Height := NumGet(RECT, 12, "Int")-NumGet(RECT, 4, "Int")
	, DllCall("User32.dll\ScreenToClient", "Ptr", DllCall("User32.dll\GetParent", "Ptr", hWnd), "Ptr", &RECT)
	, i.x := x := NumGet(RECT, 0, "Int"), i.y := y := NumGet(RECT, 4, "Int")
	return i, ErrorLevel := !r
}

;obtener ancho de los margenes izquierdo y derecho
;Sintaxis: Edit_GetMargins( [hWnd], [margen izquierdo (out)], [margen derecho (out] )
Edit_GetMargins(hWnd, ByRef Left := "", ByRef Right := "") {
	OutputVar := SendMessage(hWnd, 0x00D4)
	return [Left := OutputVar & 0xffff, Right := OutputVar >> 16]
}

;obtiene la parte editable del control
;Sintaxis: Edit_GetRect( [hWnd], [x (out)], [y (out)], [ancho (out)], [alto (out)] )
;Return: Array(x, y, ancho, alto)
Edit_GetRect(hWnd, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "") {
	VarSetCapacity(RECT, 16, 0), SendMessage(hWnd, 0xB2,,,, &RECT)
	return RECT(RECT, x, y, w, h)
}
	
;--------------------------------------------------------------------------------------------------------------------------
;establece la parte editable del control
;Sintaxis: Edit_SetRect( [hWnd], [x], [y], [ancho], [alto] )
Edit_SetRect(hWnd, x := "", y := "", w := "", h := "") {
	if (x="") || (y="") || (w="") || (h="")
		Edit_GetRect(hWnd, _x, _y, _w, _h)
	RECT(RECT, x=""?_x:x, y=""?_y:y, w=""?_w:w, h=""?_h:h)
	return SendMessage(hWnd, 0xB3,,,, &RECT)
}
	
;establece el límite de texto
;Sintaxis: Edit_SetLimitText( [hWnd], [limite de caracteres 1~64000] )
Edit_SetLimitText(hWnd, Limit := 64000) {
	return SendMessage(hWnd, 0x00C5,, Limit)
}

;establece la señal textual que se muestra por el control de edición para pedir al usuario para obtener información
;Sintaxis: Edit_SetCueBannerText( [hWnd], [texto], [¿mostrar siempre?] )
;Nota: no se puede establecer en un control de edición multilínea.
Edit_SetCueBannerText(hWnd, Text := "", Flag := false) {
	return SendMessage(hWnd, 0x1501, "Int", Flag,, &Text)
}

;selecciona un rango de caracteres en un control de edición
;Sintaxis: Edit_SetSel( [hWnd], [inicio], [fin] )
;Notas:
	;espesificar -1 en el 1er parametro para deseleccionar todo.
	;espesificar 0 en el 1er parametro y -1 en el 2do para seleccionar todo (defecto).
Edit_SetSel(hWnd, Starting := 0, End := -1) {
	return SendMessage(hWnd, 0x00B1,, Starting>0?Starting-1:Starting,, End>0?End-1:End)
}

;establecer el estilo ReadOnly (el usuario no puede cambiar el texto)
;Sintaxis: Edit_SetReadOnly( [hWnd], [0|1] )
Edit_SetReadOnly(hWnd, State := true) {
	return SendMessage(hWnd, 0x00CF, "Int", State)
}

;muestra un asterisco (*) (o el carácter espesificado) para cada carácter escrito en el control de edición.
;Sintaxis: Edit_SetPasswordChar( [hWnd], [0|1|Carácter] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_SetPasswordChar(hWnd, PassChar := true) {
	return r:=SendMessage(hWnd, 0x00CC,, PassChar=0?0:Asc(PassChar=1?"*":PassChar))
		, WinRedraw(hWnd), ErrorLevel := !r
}

;establece el texto espesificado
;Sintaxis: Edit_SetText( [hWnd], [Texto] )
;Nota: puede usar Edit_ReplaceSelText() como alternativa.
Edit_SetText(hWnd, Text := "") {
	return SendMessage(hWnd, 0x000C,,,, &Text)
}

;establecer ancho de los margenes derecho y/o izquierdo
;Sintaxis: Edit_SetMargins( [hWnd], [margen izquierdo], [margen derecho] )
Edit_SetMargins(hWnd, Left := "", Right := "") {
	if (Left="") || (Right="")
		Edit_GetMargins(hWnd, L, R), Left := Left=""?L:Left, Right := Right=""?R:Right
	return true, SendMessage(hWnd, 0x00D3, "UInt", 0x0001|0x0002,, (Left & 0xffff) + (Right << 16))
}

;establecer icono en el lado izquierdo o derecho
;Sintaxis: Edit_SetIcon( [hWnd], [Icono], [color], [etiqueta al hacer clic en la imagen], [¿lado derecho?] )
;Icono: espesificar el icono o un Array con el [icono, indice]
;Color: espesificar un Array. [color de fondo del Gui, color de fondo del control]
;Return: devuelve un Array. [hWnd de la ventana, hWnd del Picture control] 
;Nota: destruir la ventana cuando se deje de usar. Usar WinDestroy(hWnd de la ventana)  o GuiDestroy
;Ejemplo:
	;Gui, Add, Edit, w300 h21 HWNDhEdit, This is an Edit Control!
	;Gui, Show
	;Info := Edit_SetIcon(hEdit, ["shell32", 32],, "MyLabel")
	;return
	;MyLabel:
	;MsgBox
	;return
	;GuiClose:
	;WinDestroy(Info[1]) ;destruir ventana
	;ExitApp
Edit_SetIcon(hWnd, Icon, Color := "", Label := "", Right := false) {
	Index := IsObject(Icon)?(Icon[2]>1?Icon[2]:1):1, Icon := IsObject(Icon)?Icon[1]:Icon
	, GetWindowPos(hWnd,,, w, h, 1), h := h-5, Color := IsObject(Color)?Color:["", "White"]
	try {
		Gui, New, +HWNDID -Caption +Parent%hWnd%
		Gui, %ID%:Color, % Color[1], % Color[2]
		Gui, %ID%:Margin, 0, 0
		Gui, %ID%:Add, Picture, % "HWNDhPic h" h " w" h " Icon" Index (IsLabel(Label)?" g" Label:""), %Icon%
		Gui, %ID%:Show, % "x" (Right?w-h-2:2) " y2 h" h " w" h
	} catch
		return false, WinDestroy(ID), ErrorLevel := true
	return [ID, hPic], WinSetStyle(hWnd, "+" 0x02000000), Edit_SetMargins(hWnd, Right?"":h+4, Right?h+4:""), ErrorLevel := !(ID)
}

;--------------------------------------------------------------------------------------------------------------------------

;comprueba si el control tiene el foco del teclado.
;Sintaxis: Edit_HasFocus( [hWnd], [hWnd del control que tiene el foco (salida)] )
Edit_HasFocus(hWnd, ByRef hWndFocus := "") {
	nSize := VarSetCapacity(GUITHREADINFO, A_PtrSize=4?48:72, 0)
	, NumPut(nSize, GUITHREADINFO, 0, "UInt")
	, DllCall("User32.dll\GetGUIThreadInfo", "Ptr", 0, "Ptr", &GUITHREADINFO)
	, hWndFocus := NumGet(GUITHREADINFO, A_PtrSize=4?12:16, "Ptr")
	return (r:=hWnd=hWndFocus), ErrorLevel := !r
}

;comprueba si el control admite multilinea
;Sintaxis: Edit_IsMultiline( [hWnd] )
Edit_IsMultiline(hWnd) {
	return WinGetStyle(hWnd)&0x0004
}

;comprueba si tiene el estilo ReadOnly (el usuario no puede cambiar el texto)
;Sintaxis: Edit_ReadOnly( [hWnd] )
Edit_ReadOnly(hWnd) {
	return WinGetStyle(hWnd)&0x0800
}

;compruea si tiene el estilo ES_PASSWORD
;Sintaxis: Edit_PasswordChar( [hWnd] )
;Nota: solo es válido para un Edit de una sola linea.
Edit_PasswordChar(hWnd) {
	return WinGetStyle(hWnd)&0x0020
}

;muestra/oculta un globo de informacion asociado con un control de edición
;Sintaxis: Edit_ShowBalloonTip( [hWnd], [Título], [Texto], [Icono] )
;Iconos: Informacion = 1-4 | advertencia = 2-5 | error = 3-6
;Nota: para ocultar, no espesificar ningún parámetro.
Edit_ShowBalloonTip(hWnd, Info*) {
	if !Info.MaxIndex()
		return SendMessage(hWnd, 0x1504)
	Title := Info[1], Text := Info[2], Icon := Info[3]?Info[3]:0
	, nSize := VarSetCapacity(EDITBALLOONTIP, A_PtrSize=4?16:32, 0)
	, NumPut(nSize, EDITBALLOONTIP, 0, "UInt"), NumPut(&Title, EDITBALLOONTIP, A_PtrSize, "Ptr")
	, NumPut(&Text, EDITBALLOONTIP, A_PtrSize*2, "Ptr"), NumPut(Icon, EDITBALLOONTIP, A_PtrSize*3, "Int")
	return SendMessage(hWnd, 0x1503,,,, &EDITBALLOONTIP)
}

;habilita/deshabilita las barras de desplazamiento.
;Sintaxis: Edit_EnableScrollBar( [hWnd], [barra], [modo], [otras opciones, ver nota] )
;Barra: 0 = horizontal | 1 = vertical | 3 = ambas
;Modo: 0 = deshabilitar | 1 = habilitar (defecto)
;Nota: para mas opciones ver: https://msdn.microsoft.com/en-us/library/windows/desktop/bb787579%28v=vs.85%29.aspx
Edit_EnableScrollBar(hWnd, wSBflags, Enable := true, wArrow := -1) {
	return DllCall("User32.dll\EnableScrollBar", "Ptr", hWnd, "UInt", wSBflags
		, "UInt", wArrow=-1?(Enable?0x0:0x3):wArrow)
}

;muestra/oculta las barras de desplazamiento.
;Sintaxis: Edit_ShowScrollBar( [hWnd], [barra], [modo] )
;Barra: 0 = horizontal | 1 = vertical | 3 = ambas
;Modo: 0 = ocultar | 1 = mostrar (defecto)
Edit_ShowScrollBar(hWnd, ScrollBar, Show := true) {
	return DllCall("User32.dll\ShowScrollBar", "Ptr", hWnd, "UInt", ScrollBar, "Int", !!Show)
}

;sustituye el texto seleccionado
;Sintaxis: Edit_ReplaceSelText( [hWnd], [texto] )
Edit_ReplaceSelText(hWnd, Text := "") {
	return SendMessage(hWnd, 0x00C2, "Int", true,, &Text)
}

;eliminar el texto seleccionado
;Sintaxis: Edit_SelClear( [hWnd] )
Edit_SelClear(hWnd) {
	return SendMessage(hWnd, 0x0303)
}

;copiar el texto seleccionado al portapapeles
;Sintaxis: Edit_SelCopy( [hWnd] )
Edit_SelCopy(hWnd) {
	return SendMessage(hWnd, 0x0301)
}

;cortar el texto seleccionado al portapapeles
;Sintaxis: Edit_SelCut( [hWnd] )
Edit_SelCut(hWnd) {
	return SendMessage(hWnd, 0x0300)
}

;pegar el texto del portapapeles
;Sintaxis: Edit_SelPaste( [hWnd] )
Edit_SelPaste(hWnd) {
	return SendMessage(hWnd, 0x0302)
}

;muestra un dialogo para elegir la fuente y la aplica al control
;Sintaxis: Edit_SelectFont( [hWnd], [calidad (ver FontCreate)], [¿redibujar?] )
;EJEMPLO:
	;Gui, Add, Edit, x5 y5 w490 h270 HWNDhWnd +HScroll, Fuente ~ Edit Control, AutoHotKey %A_AhkVersion%
	;Gui, Add, Button, x20 y280 w455 h25 gSelectFont, Cambiar Fuente
	;Gui, Show, w500 h315
	;Gui, +OwnDialogs +AlwaysOnTop ;OwnDialogs impide interactuar con la ventana hasta cerrar el dialogo
	;return
	;GuiClose:
	;ExitApp
	;SelectFont:
	;Edit_SelectFont(hWnd, 5, true)
	;return
Edit_SelectFont(hWnd, Quality := 2, Redraw := false) {
	static Color := [], List := []
	for k, v in List
		if !IsWindow(k)
			DeleteObject(v), List.RemoveAt(A_Index)
	FontInfo := FontQuery(ControlGetFont(false, hWnd))
	, FontInfo := FontSelect(DllCall("User32.dll\GetParent", "Ptr", hWnd), FontInfo[1]
		, [Color[hWnd], FontInfo[2], FontInfo[3], FontInfo[4], FontInfo[5], FontInfo[6]])
	if (ErrorLevel)
		return false
	ControlSetColor(false, hWnd, FontInfo[1]), Color[hWnd] := FontInfo[1]
	, hFont := FontCreate(FontInfo[0], FontInfo[2], FontInfo[3]
	, FontInfo[4], FontInfo[5], FontInfo[6], Quality), List[hWnd] := hFont
	return ControlSetFont(false, hWnd, hFont, Redraw)?hFont:false
}






























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: BUTTON CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece un icono a un boton
;Sintaxis: SetButtonIcon( [hWnd], [Icono], [opciones] )
;Parámetros:
	;Opciones: espesificar la letra seguida de un valor.
		;W = ancho | H = alto
		;L = margen izquierdo | R = margen derecho
		;T = margen superior | B = margen inferior
		;A = alineación (0 = izquierda, 1 = derecha, 2 = superior, 3 = inferior, 4 = centro)
	;Icono: espesificar una lista de imágenes, una imagen o un array [imagen, indice]
		;Indice 1 = Normal
		;Indice 2 = Al posicionar el cursor por encima del boton
		;Indice 3 = Al precionar
		;Indice 4 = Deshabilitado
		;Indice 5 = Defecto (para evitar que el boton quede sin imagen, espesificar la misma imagen que en el indice 1)
;Nota: cuando ya no use el control y antes de eliminarlo, eliminar la imagen usando IL_Destroy(GetButtonImageList(Button_hWnd))
;Ejemplo:
	/*
	Gui, Add, Button, HWNDB1 w100 h25, Button1
		SetButtonIcon(B1, A_AhkPath) ;normal
	Gui, Add, Button, HWNDB2 w25
		SetButtonIcon(B2, [A_WinDir "\explorer.exe", 1]) ;Array [imagen, indice]
	ImageList := IL_Create(5, 1, 1) ;usar imagenes grandes
	IL_Add(ImageList, A_Windir "\regedit.exe") ;indice 1 = NORMAL
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 2 = CURSOR
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 3 = CLIC
	IL_Add(ImageList, A_Windir "\System32\cmd.exe") ;indice 4 = DESHABILITADO
	IL_Add(ImageList, A_Windir "\regedit.exe") ;indice 5 = DEFECTO --> NORMAL
	Gui, Add, Button, HWNDB3 w100 h45
		SetButtonIcon(B3, ImageList, "A4") ;ImageList
	Gui, Show
	return
	GuiClose:
	Exitapp
	*/
SetButtonIcon(hWnd, ImageList, Options := "L2") {
	Flag := SplitFlags(Options, "\d", "w", "h", "l", "t", "r", "b", "a")
	if !(ImageList+0)
		v := ImageList_Create(1, 1,, Flag[1]>0?Flag[1]:16, Flag[2]>0?Flag[2]:16)
		, IL_Add(v, IsObject(ImageList)?ImageList[1]:ImageList, ImageList[2]>1?ImageList[2]:1), ImageList := v
	VarSetCapacity(BUTTON_IMAGELIST, 20 + A_PtrSize, 0)
	, NumPut(ImageList, BUTTON_IMAGELIST, 0, "Ptr")
	, NumPut(Flag[3]?Flag[3]:0, BUTTON_IMAGELIST, 0 + A_PtrSize, "UInt")
	, NumPut(Flag[4]?Flag[4]:0, BUTTON_IMAGELIST, 4 + A_PtrSize, "UInt")
	, NumPut(Flag[5]?Flag[5]:0, BUTTON_IMAGELIST, 8 + A_PtrSize, "UInt")
	, NumPut(Flag[6]?Flag[6]:0, BUTTON_IMAGELIST, 12 + A_PtrSize, "UInt")
	, NumPut(Flag[7]?Flag[7]:0, BUTTON_IMAGELIST, 16 + A_PtrSize, "UInt")
	return SendMsg(hWnd, 0x1602,, &BUTTON_IMAGELIST)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb775975(v=vs.85).aspx

;simula clic en el boton.
;Sintaxis: ButtonClick( [hWnd] )
;Nota: la ventana debe estar activa.
ButtonClick(hWnd) {
	return SendMsg(hWnd, 0x00F5)
}

;obtener ID a la lista de imágenes del boton espesífico
;Sintaxis: GetButtonImageList( [hWnd] )
GetButtonImageList(hWnd) { ;BCM_GETIMAGELIST
   VarSetCapacity(ImageList, A_PtrSize + 24, 0)
   , SendMsg(hWnd, 0x1603,, &ImageList)
   return NumGet(ImageList)
}































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: STATUS BAR CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;recuperar el texto
;Sintaxis: SB_GetText( [hWnd], [parte] )
SB_GetText(hWnd, Index := 1) {
	Size := SendMessage(hWnd, 0x040C, "Int", Index-1) & 0xffff ;LOWORD
	, VarSetCapacity(Text, Size * 2, 0)
	, SendMessage(hWnd, 0x040D, "Int", Index-1, "Str", Text)
	return Text
}

;obtener cantidad de partes
;Sintaxis: SB_GetParts( [hWnd] )
SB_GetParts(hWnd) {
	return SendMessage(hWnd, 0x0406)
}

;obtener color de fondo RGB
;Sintaxis: SB_GetBKColor( [hWnd] )
SB_GetBKColor(hWnd) {
	WinSetRedraw(hWnd, false)
	, Color := SB_SetBKColor(hWnd, "Red")
	, SB_SetBKColor(hWnd, Color)
	return Color, WinSetRedraw(hWnd)
}

;-------------------------------------------------------------------------------------------------------------------------------------------

;cambiar color de fondo
;Sintaxis: SB_SETBKCOLOR( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB
;Return: devuelve el color anterior
;Nota: usar -Theme en las opciones al crear el control.
SB_SetBKColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x2001,,, "UInt", _getcolor(Color, true)))
}













































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: LISTVIEW CONTROL ::::::::::::::::::::::::::::::::::
;Parámetros:
	;hWnd = hwnd del control
	;Item = Indice. 0 = todos
;#############################################################################################################################################
;obtiene la cantidad de items
LV_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1000+4,,,,, "Int")
}

;elimina item. dejar vacio el segundo parámetro para eliminar todos los items
LV_DeleteItem(hWnd, Item := 0) {
	return SendMessage(hWnd, 0x1000+(Item>0?8:9), "Int", Item>0?Item-1:0)
}

;eliminar columna
LV_DeleteColumn(hWnd, Column := 1) {
	return SendMessage(hWnd, 0x1000+28, "Int", Column-1)
}

;actualiza un item
LV_Update(hWnd, Item) {
	return SendMessage(hWnd, 0x1000+42, "Int", Item-1)
}

;redibujar items
LV_RedrawItem(hWnd, ItemFirst := 0, ItemLast := "") {
	If (ItemFirst > 0)
		ItemLast := ItemLast=""?ItemFirst:ItemLast
	else ItemLast := (ItemFirst:=SendMessage(hWnd, 0x1027))+SendMessage(hWnd, 0x1028)
	return SendMessage(hWnd, 0x1000+21, "Int", ItemFirst-1, "Int", ItemLast-1), DllCall("User32.dll\UpdateWindow", "Ptr", hWnd)
}

;cambiar texto a un item
;Sintaxis: LV_SetItemText( [LV], [texto], [item], [columna] )
LV_SetItemText(hWnd, pszText := "", Item := 1, Column := 1) {
	VarSetCapacity(LVITEM, A_PtrSize=4?60:80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	, NumPut(&pszText, LVITEM, A_PtrSize=4?20:24, "Ptr"), NumPut(StrLen(pszText)+1, LVITEM, A_PtrSize=4?24:32, "Int")
	return SendMessage(hWnd, 0x1000+116, "Int", Item-1,, &LVITEM)
}

;obtener texto de un item
;Sintaxis: LV_GetItemText( [LV], [item], [columna] )
LV_GetItemText(hWnd, Item := 0, Column := 1, MaxChars := 514) {
	VarSetCapacity(LVITEM, A_PtrSize = 4 ? 60 : 72, 0)
	, NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int"), cchTextMax := (VarSetCapacity(pszText, MaxChars, 0) / 2) + 1
	, NumPut(&pszText, LVITEM, A_PtrSize = 4 ? 20 : 24, "Ptr"), NumPut(cchTextMax, LVITEM, A_PtrSize = 4 ? 24 : 32, "Int")
	, TextLength := SendMessage(hWnd, 0x1000+115, "Int", Item-1,, &LVITEM, "UIntP")
	return StrGet(&pszText, TextLength)
} LV_GetItemTextEx(hWnd, Item, Column := 1, ByRef ProcessId := "") {
	ProcessId := ProcessId?ProcessId:WinGetPid(hWnd), hProcess := OpenProcess(ProcessId, 0x0008|0x0010|0x0020)
	, pAddress := VirtualAlloc(hProcess,, A_PtrSize=4?60:80), pAddress2 := VirtualAlloc(hProcess,, cchTextMax:=1024+1)
	, VarSetCapacity(LVITEM, A_PtrSize=4?60:80, 0), NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Column-1, LVITEM, 8, "Int")
	, VarSetCapacity(pszText, cchTextMax * 2, 1), NumPut(pAddress2, LVITEM, A_PtrSize=4?20:24, "Ptr")
	, NumPut(cchTextMax, LVITEM, A_PtrSize=4?24:32, "Int"), WriteProcessMemory(hProcess, pAddress, &lvItem, A_PtrSize=4?60:80)
	, r:=SendMessage(hWnd, 0x1000+115, "Int", Item-1, "UInt", pAddress), ReadProcessMemory(hProcess, pAddress2, &pszText, cchTextMax)
	return pszText, VirtualFree(hProcess, pAddress), VirtualFree(hProcess, pAddress2), CloseHandle(hProcess), ErrorLevel := !r
} ;http://www.autohotkey.com/board/topic/81820-how-to-get-specific-row-text-in-a-syslistview32-easily/

;busca items uno por uno.
;Sintaxis: LV_GetNextItem( [LV], [modo] )
;Modos: F = foco | S = seleccionado
LV_GetNextItem(hWnd, Item := 0, Mode := "") {
	Index := SendMessage(hWnd, 0x1000+12, "Int", Item, "UInt", Mode="S"?0x0002:Mode="F"?0x0001:0x0000)
	return Index, ErrorLevel := Index=-1
}

;establece/quita/alterna estilos extendidos a la ventana.
;Sintaxis: LV_SetExStyle( [hWnd], [+-^Estilos] )
;ESTILOS: https://msdn.microsoft.com/en-us/library/windows/desktop/bb774732(v=vs.85).aspx
	;0x010000 = dibujo vía doble búfer, lo que reduce el parpadeo
	;0x00000004 = activa las casillas de verificación para los elementos (checkbox)
	;0x00000001 = muestra líneas de cuadrícula alrededor de los elementos y subelementos (grid)
LV_SetExStyle(hWnd, ExStyle) {
	Key := SubStr(ExStyle:=Trim(ExStyle), 1, 1), ExStyle := (Key="+"||Key="-"||Key="^")?SubStr(ExStyle, 2):ExStyle
	if (Key="-")
		return SendMessage(hWnd, 0x1036, "UInt", ExStyle)
	if (Key="^")
		return LV_SetExStyle(hWnd, ((LV_GetExStyle(hWnd)&ExStyle)?"-":"") ExStyle)
	return SendMessage(hWnd, 0x1036, "UInt", ExStyle, "UInt", ExStyle)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761165%28v=vs.85%29.aspx
 
;obtener estilo extendido.
;Sintaxis: LV_GetExStyle( [hWnd] )
LV_GetExStyle(hWnd) {
	return SendMessage(hWnd, 0x1037,,,,, "UInt")
}

LV_GetSelected(Col := 1, Type := "F") {
	RowNumber := 0
	while (RowNumber:=LV_GetNext(RowNumber, Type))
		LV_GetText(Text, RowNumber, Col), Result .= Text "`n"
	return RTrim(Result, "`n")
}

;determina si un item es visible
;Sintaxis: LV_IsItemVisible( [ID], [item] )
LV_IsItemVisible(hWnd, Item) {
	return SendMessage(hWnd, 0x10B6, "Int", Item-1)
}

;Establece el espacio entre iconos en la vista de iconos.
;Sintaxis: LV_SetIconSpacing( [ID], [eje x, distancia en pixeles], [eje y, distancia en pixeles] )
LV_SetIconSpacing(hWnd, cx, cy) {
	cx := ((cx<4)&&(cx!=-1))?4:cx, cy := ((cy<4)&&(cy!=-1))?4:cy
	return SendMessage(hWnd, 0x1035,,,, LOWORD(cx)+HIWORD(cy, false))
}

;obtiene el espacio entre iconos en la vista de iconos.
;Sintaxis: LV_GetIconSpacing( [ID], [eje x, distancia en pixeles (salida)], [eje y, distancia en pixeles (salida)] )
LV_GetIconSpacing(hWnd, ByRef cx := "", ByRef cy := "") {
	IcSp := SendMessage(hWnd, 0x1033)
   return [cx:=(IcSp & 0xFFFF), cy:=(IcSp >> 16)]
}

;obtener posicion de un item
;Sintaxis: LV_GetItemPos( [ID], [item], [x (salida)], [y (salida)] )
;Nota: devuelve un Array con la posicion xy.
LV_GetItemPos(hWnd, Item, ByRef x := "", ByRef y := "") {
	VarSetCapacity(POINT, A_PtrSize*2, 0), SendMessage(hWnd, 0x1010,, Item-1,, &POINT)
	return [x:=NumGet(POINT, 0, "Int"), y:=NumGet(POINT, 4, "Int")]
} LV_GetItemPosEx(hWnd, Item, ByRef x := "", ByRef y := "", ByRef ProcessId := "") {
	ProcessId := ProcessId?ProcessId:WinGetPid(hWnd), hProcess := OpenProcess(ProcessId, 0x0008|0x0010|0x0020)
	, pAddress := VirtualAlloc(hProcess,, 0x00001000), SendMessage(hWnd, 0x1000+16, "Int", Item-1,, pAddress)
	, VarSetCapacity(RECT, 16, 0), ReadProcessMemory(hProcess, pAddress, &RECT, 16)
	return [x:=NumGet(RECT, 0, "Int"), y:=NumGet(RECT, 4, "Int")], VirtualFree(hProcess, pAddress), CloseHandle(hProcess)
} ;http://www.autohotkey.com/board/topic/9760-lvm-geticonposition/

;establece la posicion de un item
;Sintaxis: LV_SetItemPos( [ID], [item], [x], [y] )
LV_SetItemPos(hWnd, Item, x := "", y := "") {
	if (x="") || (y="")
		LV_GetItemPos(hWnd, Item, _x, _y)
	return SendMessage(hWnd, 0x100F,, Item-1,, LOWORD(x=""?_x:x)+HIWORD(y=""?_y:y, false))
} LV_SetItemPosEx(hWnd, Item, x := "", y := "", ProcessId := "") {
	if (x="") || (y="")
		LV_GetItemPosEx(hWnd, Item, _x, _y, ProcessId)
	return SendMessage(hWnd, 0x100F,, Item-1,, LOWORD(x=""?_x:x)+HIWORD(y=""?_y:y, false))
}

;obtiene el número de columna en las coordenadas espesificadas.
;Sintaxis: LV_SubItemHitTest( [hWnd], [x], [y] )
;Nota: si no espesifica las coordenadas, por defecto usa las del cursor.
LV_SubItemHitTest(hWnd, x := -1, y := -1, ScreenToClient := false) {
	if !(x>0) || !(y>0)
		CursorGetPos(_x, _y,, ((x=-1)&&(y=-1))?hWnd:(ScreenToClient?hWnd:false))
	, VarSetCapacity(LVHITTESTINFO, 24, 0), NumPut((x>0)?x:_x, LVHITTESTINFO, 0, "Int")
	, NumPut((y>0)?y:_y, LVHITTESTINFO, 4, "Int"), r:=SendMessage(hWnd, 0x1039,,,, &LVHITTESTINFO)
	return (r=-1)?0:NumGet(LVHITTESTINFO, 16, "Int")+1, ErrorLevel := (r=-1)
}

;buscar elementos en el control que contengan el texto expesificado, los demás son eliminados.
;Sintaxis: LV_SearchEx( [items], [texto a buscar], [columnas], [elementos máximos a mostrar], [hWnd del control] )
;Items: espesificar un array con los items en el control. Sintaxis: [["item 1, col 1", "item 1, col 2"], ["item 2, col 1"]]
;Columna: espesificar las columnas en las que buscar separadas por coma. por defecto busca en todas (-1).
;Notas: usar LV_SetExStyle(hWnd, 0x00010000) para reducir el parpadeo. usar SetTimer() para cuando haya muchos items.
;Return: devuelve un array con la cantidad de items encontrados.
/* ::::: EJEMPLO DE USO :::::
Gui, Add, ListView, x0 y0 w585 h180 HWNDhWnd, Nombre|Descripción
Gui, Add, Edit, x0 y185 w585 h25 gFind HWNDFind
Gui, Show, w586 h242, Test LV_SearchEx()
Items := [], LV_SetExStyle(hWnd, 0x00010000), WinSetRedraw(hWnd, false)
Loop, 50 {
	LV_Add(, "Item " A_Index " (" Chr(A_Index) ")", "Descripción " A_Index " (" Chr(A_Index*2) ")")
	Items.Push(["Item " A_Index " (" Chr(A_Index) ")", "Descripción " A_Index " (" Chr(A_Index*2) ")"])
} LV_ModifyCol(1, "AutoHdr"), WinSetRedraw(hWnd)
return
GuiClose:
ExitApp
Find:
LV_SearchEx(Items, ControlGetText(0, Find), -1, -1, hWnd)
return
*/
LV_SearchEx(Items, Text := "", Col := -1, Max := -1, hWnd := "") {
	static Func := Func("LV_SearchExFind")
	if !(LV_GetCount()>40) ||!XXX
		return LV_SearchExFind(Items, Text, Col, Max, hWnd)
	return SetTimer(Func.Bind(Items, Text, Col, Max, hWnd), -350)
} LV_SearchExFind(Items, Text, Col, Max, hWnd) {
	static Func := Func("LV_SearchEx_Find")
	WinSetRedraw(hWnd=""?A_DefaultListView:hWnd, false), LV_Delete(), OuputVar := []
	while (LV_GetCount())
		Sleep, -1
	Loop, % ((Text="")?0:Items.MaxIndex()) {
		if (CurrentItemIndex:=A_Index) && (OuputVar.MaxIndex()>=Max) && (Max!=-1)
			break
		CurrentItemText := IsObject(Items[A_Index])?Items[A_Index]:[Items[A_Index]]
		Loop, % CurrentItemText.MaxIndex() {
			if (Col!=-1) && !(Contains(Col, A_Index, ",", A_Space A_Tab))
				continue
			if (InStr(CurrentItemText[A_Index], Text)) && ((Max=-1) || !(OuputVar.MaxIndex()>=Max)) {
				OuputVar.Push(LV_Add(, Items[CurrentItemIndex]*))
				break
	}}} if !(OuputVar.MaxIndex()) && (Text="") {
		Loop, % (Items.MaxIndex())
			LV_Add(, Items[A_Index]*)
	} return OuputVar, WinSetRedraw(hWnd=""?A_DefaultListView:hWnd)
}

;buscar elemento en el control que contenga el texto expesificado y lo selecciona.
;Sintaxis 1: LV_Search( [texto a buscar], [columnas separadas por coma, por defecto busca en todas] )
;Return: 0 si no se encontraron items.
;Nota: usar SetTimer() para cuando haya muchos items.
LV_Search(Text, Col := -1) {
	static Func := Func("LV_SearchSelect")
	if (Text="")
		return false
	if !(LV_GetCount()>40) ||!XXX
		return LV_SearchSelect(Text, Col)
	return SetTimer(Func.Bind(Text, Col), -350)
} LV_SearchSelect(Text, Col) {
	return LV_SearchFind(Text, Col, 1) || LV_SearchFind(Text, Col, 0) || LV_SearchFind(Trim(Text), Col, 0)
} LV_SearchFind(Text, Col, CaseSensitive) {
	if !(Count:=LV_GetCount())
		return false
	Loop, % (Count)
		LV_Modify(A_Index, "-Select")
	Loop, % (Count) {
		RowNumber := A_Index
		Loop, % (LV_GetCount("Col")) {
			if !(Col=-1) && !(contains(Col, A_Index, ",", A_Space A_Tab))
				continue
			LV_GetText(CurrentItemText, RowNumber, A_Index)
			if (CurrentItemText="")
				continue
			if (InStr(CurrentItemText, Text, CaseSensitive))
				return RowNumber, LV_Modify(RowNumber, "+Select +Focus Vis")
	}} return false
}

LV_SetItemState(hWnd, Item, State, Set := "*") {
	VarSetCapacity(LVITEM, A_PtrSize=4?60:72, 0), NumPut(0x00000008, LVITEM, 0, "UInt")
	, NumPut(Item-1, LVITEM, 4, "Int"), NumPut(Set="*"?State:Set, LVITEM, 12, "UInt"), NumPut(State, LVITEM, 16, "UInt")
	return SendMessage(hWnd, 0x102B, "Int", Item-1,, &LVITEM)
}





























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: TREEVIEW CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;Obtener item
;Sintaxis: TV_GetNextItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773622%28v=vs.85%29.aspx
;Nota: espesificar 'CARET' para obtener el item seleccionado (3er parametro)
TV_GetNextItem(hWnd, Item := 0, Mode := "NEXT") {
	static Modes := {"CARET": 0x0009, "CHILD": 0x0004, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "LASTVISIBLE": 0x000A, "NEXT": 0x0001
	, "NEXTSELECTED": 0x000B, "NEXTVISIBLE": 0x0006, "PARENT": 0x0003, "PREVIOUS": 0x0002, "PREVIOUSVISIBLE": 0x0007, "ROOT": 0x0000}
	return SendMessage(hWnd, 0x110A, "UInt", Modes[Mode],, Item)
}

;obtiene la cantidad de items
;Sintaxis: TV_GetItemCount( [ID], [Modo] )
;Modos: ALL|SELECTED|VISIBLE
TV_GetItemCount(hWnd, Mode := "ALL") {
	if (Mode="ALL")
		return SendMessage(hWnd, 0x1105)
	else if (Mode="VISIBLE")
		return SendMessage(hWnd, 0x1110)
	else if (Mode="SELECTED") {
		ItemSelectedCount := 0
		while TV_GetNextItem(hWnd,, "NEXTSELECTED")
			ItemSelectedCount++
		return ItemSelectedCount
	} return 0, ErrorLevel := 1
}

;seleccionar item
;TV_SelectItem( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773736%28v=vs.85%29.aspx
TV_SelectItem(hWnd, Item := 0, Mode := "CARET") {
	static Modes := {"CARET": 0x0009, "DROPHILITE": 0x0008, "FIRSTVISIBLE": 0x0005, "NOSINGLEEXPAND": 0x8000}
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x110B, "UInt", Modes[Mode],, Item-1)
}

;hacer visible un item
;TV_VisibleItem( [ID], [Item] )
TV_VisibleItem(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1114,,,, Item-1)
}

;editar etiqueta del item
;TV_EditLabel( [ID], [Item] )
TV_EditLabel(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	return SendMessage(hWnd, 0x1141,,,, Item-1)
}

;eliminar un item o 'todos (defecto)'
;Sintaxis: TV_DeleteItem( [ID], [Item] )
TV_DeleteItem(hWnd, Item := 0) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1101,,,, -65536)
	return SendMessage(hWnd, 0x1101,,,, Item-1)
}

;expandir/contraer/invertir items
;Sintaxis: TV_Expand( [ID], [Item], [Modo] )
;Modos: https://msdn.microsoft.com/en-us/library/windows/desktop/bb773568%28v=vs.85%29.aspx
TV_Expand(hWnd, Item := 0, Mode := "EXPAND") {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	static Modes := {"COLLAPSE": 0x0001, "COLLAPSERESET": 0x8000, "EXPAND": 0x0002, "EXPANDPARTIAL": 0x4000, "TOGGLE": 0x0003}
	return SendMessage(hWnd, 0x1102, "UInt", Modes[Mode],, Item-1)
}

;cambiar nombre
;Sintaxis: TV_SetItemText( [ID], [texto], [Item] )
TV_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	, VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	, NumPut(0x0001, TVITEMEX, 0, "UInt"), NumPut(Item-1, TVITEMEX, 4, "Ptr")
	, NumPut(&NewText, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
	, NumPut(StrLen(NewText), TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
	return return SendMessage(hWnd, 0x113F,,,, &TVITEMEX)
}

;obtener nombre
;Sintaxis: TV_GetItemText( [ID], [Item] )
TV_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TV_GetNextItem(hWnd,, "CARET")+1
	, VarSetCapacity(TVITEMEX, A_PtrSize = 4 ? 56 : 64, 0)
	, NumPut(0x0001, TVITEMEX, 0, "UInt"), NumPut(Item-1, TVITEMEX, 4, "Ptr")
    , VarSetCapacity(TVTEXT, 256 * 2, 0), NumPut(&TVTEXT, TVITEMEX, A_PtrSize = 4 ? 16 : 20, "Ptr")
    , NumPut(256, TVITEMEX, A_PtrSize = 4 ? 20 : 24, "Int")
    , SendMessage(hWnd, 0x113E,,,, &TVITEMEX)
    return StrGet(NumGet(TVITEMEX, A_PtrSize = 4 ? 16 : 20, "UPtr"))
}
























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: TAB CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;obtener cantidad de items
;Sintaxis: TC_GetItemCount( [ID] )
TC_GetItemCount(hWnd) {
	return SendMessage(hWnd, 0x1304)
}

;obtener posicion del item que tiene el foco o el item seleccionado.
;Sintaxis: TC_GetItemFocus( [ID], [¿seleccionado=true?] )
TC_GetItemFocus(hWnd, Selected := true) {
	return SendMessage(hWnd, Selected?0x130B:0x132F)+1
}

;obtener texto de un item
;Sintaxis: TC_GetItemText( [ID], [Item] )
TC_GetItemText(hWnd, Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	, VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	, NumPut(0x0001, TCITEM, 0, "UInt"), VarSetCapacity(TCTEXT, 256 * 2, 0)
	, NumPut(&TCTEXT, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	, NumPut(256, TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	, SendMessage(hWnd, 0x133C,, Item-1,, &TCITEM)
	return StrGet(NumGet(TCITEM, A_PtrSize = 4 ? 12 : 16, "UPtr"))
}

;cambiar texto de un item
;Sintaxis: TC_SetItemText( [ID], [Texto], [Item] )
TC_SetItemText(hWnd, NewText := "", Item := 0) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	, VarSetCapacity(TCITEM, A_PtrSize = 4 ? 28 : 40, 0)
	, NumPut(0x0001, TCITEM, 0, "UInt"), NumPut(&NewText, TCITEM, A_PtrSize = 4 ? 12 : 16, "Ptr")
	, NumPut(StrLen(NewText), TCITEM, A_PtrSize = 4 ? 16 : 20, "Int")
	return SendMessage(hWnd, 0x133D,, Item-1,, &TCITEM)
}

;dar foco a un item o seleccionarlo
;Sintaxis: TC_SetItemFocus( [ID], [Item], [¿seleccionar?] )
;Notas: si se omite el 2do parametro, auto-selecciona el item anterior o 'siguiente si no hay anterior'.
TC_SetItemFocus(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		Item := ((i:=TC_GetItemFocus(hWnd, Select))-1)>0?i-1:(i=1?i+(TC_GetItemCount(hWnd)>1?1:0):1)
	return SendMessage(hWnd, Select?0x130C:0x1330,, Item-1)
}

;deselecciona todos los items o todos menos el item seleccionado
;Sintaxis: TC_Reset( [ID], [¿evitar deseleccionar el item seleccionado?] )
TC_Reset(hWnd, Mode := 0) {
	return SendMessage(hWnd, 0x1332,, Mode)
}

;eliminar un item, opcional seleccionar el anterior (o siguiente si no hay anterior)
;Sintaxis: TC_DeleteItem( [ID], [Item], [¿seleccionar el item anterior?] )
;Nota: dejar vacio el 2do parametro (o establecerlo <0) para eliminar todos los items.
TC_DeleteItem(hWnd, Item := 0, Select := 1) {
	if !(Item>0)
		return SendMessage(hWnd, 0x1309)
	i := SendMessage(hWnd, 0x1308,, Item-1)
	if Select
		TC_SetItemFocus(hWnd, ((Item-1)>0?(Item-1):1))
	return i, ErrorLevel := !i
}

;resalta el item
;Sintaxis: TC_HighlightItem( [ID], [Item], [Estado 0|1] )
TC_HighlightItem(hWnd, Item := 0, State := 1) {
	Item := Item>0?Item:TC_GetItemFocus(hWnd)
	return SendMessage(hWnd, 0x1333, "Int", Item-1, "Int", State)
}

;resalta la pestaña al posicionar el mouse por encima
TC_HighlightStyle(hWnd) {
	Control, Style, 0x54010040,, ahk_id %hWnd%
}






































 







/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: COMBOBOX & DROPDOWNLIST CONTROL ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
*/
;renombrar item
;Sintaxis: CB_SetText( [hWnd], [texto], [posición], [¿seleccionar item?] )
;Nota: si no espesifica el 3er parámetro, no se modifica ningún item, solo cambia el texto en el control.
CB_SetText(hWnd, Text := "", Index := 0, Select := false) {
	if !(Index)
		return ControlSetText(0, hWnd, Text)
	CB_DeleteString(hWnd, Index)
	return CB_AddString(hWnd, Text, Index), i:=Select?CB_SelectItem(hWnd, Index):""
}

;establece la señal textual que se muestra por el control de edición para pedir al usuario para obtener información
;Sintaxis: CB_SetCueBanner( [hWnd], [texto] )
CB_SetCueBanner(hWnd, Text := "") {
	Result := SendMessage(hWnd, 0x1703,,,, &Text)
	return (Result=1), ErrorLevel := (Result!=1)
}

;ajustar la altura del campo de selección o la altura de los elementos de lista.
;Sintaxis: CB_SetItemHeight( [hWnd], [Altura], [modo] )
;Modos: por defecto modifica ambos.
	;1 = modificar la altura del campo de selección.
	;2 = modificar  la altura de los elementos de lista.
CB_SetItemHeight(hWnd, Height, Mode := 3) {
	If (Mode=1)
		return PostMessage(hWnd, 0x153, "Int", -1, "UInt", Height)
	if (Mode=2)
		return PostMessage(hWnd, 0x153, "Int", 0, "UInt", Height)
	return r:=(CB_SetItemHeight(hWnd, Height, 1)+CB_SetItemHeight(hWnd, Height, 2)), ErrorLevel := (r!=2)
}

;seleccionar texto.
;Sintaxis: CB_SetEditSel( [hWnd], [inicio], [fin] )
;Uso:
	;Quitar seleccion: CB_SetEditSel(hWnd, -1, -1)
	;Seleccionar todo (defecto): CB_SetEditSel(hWnd, 1, -1)
	;Seleccionar parte del texto: CB_SetEditSel(hWnd, 3, 5)
CB_SetEditSel(hWnd, Start := 1, End := -1) {
	return r:=SendMessage(hWnd, 0x0142,,, "UInt", LOWORD(Start-1)+HIWORD(End-1, false)), ErrorLevel := !r
}

;---------------------------------------------------------------------------------------------------------------------

;limita el número de caracteres que el usuario puede ingresar en el control.
;Sintaxis: CB_LimitText( [hWnd], [caracteres máximos permitidos 1~2147483646] )
;Nota: el mensaje no afecta a los item en el control.
CB_LimitText(hWnd, Limit := 30000) {
	return SendMessage(hWnd, 0x0141, "UShort", Limit)
}

;selecciona el item por texto
;Sintaxis: CB_SelectString( [hWnd], [texto] )
;Nota: si se encuentra el item, devuelve la posición.
CB_SelectString(hWnd, Text) {
	List := []
	Loop, % (Count:=CB_GetCount(hWnd)) {
		if ((List[A_Index]:=CB_GetText(hWnd, A_Index))==Text) {
			Index := A_Index
			break
	}} if !(Index) {
		Loop, % (Count) {
			if (List[A_Index]=Text) {
				Index := A_Index
				break
	}}} Index := SendMessage(hWnd, 0x014D, "Int", Index?Index-1:-1,, &Text)
	return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}

;selecciona el item por posición
;Sintaxis: CB_SelectString( [hWnd], [posición] )
;Nota: si se encuentra el item, devuelve la posición.
;ErrorLevel: 1 = error | 2 = la posición ingresada es mayor al número de items
CB_SelectItem(hWnd, Pos) {
	if ((Count:=CB_GetCount(hWnd))<Pos)
		return false, ErrorLevel := 2
	Loop, % (Count) {
		if (A_Index=Pos) {
			Text := CB_GetText(hWnd, A_Index), Index := SendMessage(hWnd, 0x014D, "Int", A_Index-2,, &Text)
			return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}}}

;añadir item
;Sintaxis: CB_AddString( [hWnd], [texto], [posición], [¿seleccionar?] )
;Posición: si no se espesifica y el control no tiene el estilo CBS_SORT, se añade al final de la lista.
	;si se espesifica -1, se añade al final de la lista.
;Nota: devuelve la posición del item.
;ErrorLevel: 1 = error al añadir | 2 = espacio insuficiente.
CB_AddString(hWnd, Text := "", Pos := 0, Select := false) {
	Index := SendMessage(hWnd, Pos?0x014A:0x0143, Pos?"Int":"Ptr", Pos?(Pos=-1?-1:Pos-1):0,, &Text)
	return (Index=-1)||(Index=-2)?0:Index+1, i:=Select?CB_SelectItem(hWnd, Index+1):"", ErrorLevel := (Index=-1)?1:(Index=-2)?2:0
}

;eliminar item
;Sintaxis: CB_DeleteString( [hWnd], [indice] )
;Indice: espesificar -1 para eliminar todos los items (defecto).
;Nota: devuelve la cantidad de items restantes en el control.
CB_DeleteString(hWnd, Index := -1) {
	Index := SendMessage(hWnd, (Index=-1)?0x014B:0x0144, (Index=-1)?"Ptr":"Int", (Index=-1)?0:(Index-1))
	return Index, ErrorLevel := (Index=-1)
}

;obtiene la posición del item mediante el texto espesificado; ya sea exacto, desde una posición espesífica o contenido.
;Sintaxis: CB_FindString( [hWnd], [texto], [inicio] )
;Inicio: espesificar la posición en la que empezar la busqueda, al terminar, retoma desde el inicio.
	;por defecto (-1), busca desde el primer item.
;Nota: devuelve la posición del item.
CB_FindString(hWnd, Text, Pos := -1) {
	Count := CB_GetCount(hWnd), Pos := (Pos=-1)?-1:((Pos>Count)||(Pos<1)?-1:Pos)
	if !((Index:=SendMessage(hWnd, 0x0158, "Int", (Pos=-1)?-1:(Pos-1),, &Text))>-1) || (Count<Index) {
		if !((Index:=SendMessage(hWnd, 0x014C, "Int", (Pos=-1)?-1:(Pos-1),, &Text))>-1) || (Count<Index) {
			List := []
			Loop, % (Count:=CB_GetCount(hWnd)) {
				if (InStr(List[A_Index]:=CB_GetText(hWnd, A_Index), Text, true)) {
					Index := A_Index-1
					break
			}} if !(Index>-1) {
				Loop, % (Count) {
					if (InStr(List[A_Index], Text)) {
						Index := A_Index-1
						break
	}}}}} return (Index=-1)?0:Index+1, ErrorLevel := (Index=-1)
}

;---------------------------------------------------------------------------------------------------------------------

;recupera la cantidad de items en el control
;Sintaxis: CB_GetCount( [hWnd] )
CB_GetCount(hWnd) {
	return SendMessage(hWnd, 0x0146)
}

;obtiene el texto seleccionado, opcional la posición inicial y final del texto seleccionado
;Sintaxis: CB_GetSelected( [hWnd], [inicio], [fin] )
;Nota: si no hay texto seleccionado, el 2do y 3er parámetro devuelven la posición del cursor.
CB_GetSelected(hWnd, ByRef Start := "", ByRef End := "") {
	Pos := SendMessage(hWnd, 0x0140), Text := CB_GetText(hWnd)
	, Start := LOWORD(Pos)+1, End := HIWORD(Pos)+1
	return (Start=End)?"":StrTrimLeft(StrLeft(Text A_Space, End-1), Start-1)
}

;obtiene el texto actual o de un item.
;Sintaxis: CB_GetText( [hWnd], [posición] )
;Posición: por defecto (-1) obtiene el texto actual.
CB_GetText(hWnd, Index := -1) {
	if (Index=-1)
		return ControlGetText(0, hWnd)
	Length := SendMessage(hWnd, 0x0149, "Int", Index-1)
	, VarSetCapacity(Text, (Length * 2) + 1, 0)
	, SendMessage(hWnd, 0x0148, "Int", Index-1, "Str", Text)
	return Text
}





















































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: PROGRESS BAR CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece el valor mínimo y máximo.
;Sintaxis: PB_SetRange( [hWnd], [min], [max] )
PB_SetRange(hWnd, Min := 0, Max := 100) {
	Min := (Min>-1)?Min:0, Max := (Max>Min)?Max:(Min+1)
	return SendMessage(hWnd, 0x0406, "Int", Min, "Int", Max)
}

;establecer estado.
;Sintaxis: PB_SetState( [hWnd], [estado] )
;Estado: Normal | Error | Paused
PB_SetState(hWnd, State := 1) {
	if (State="Normal") || (State="N") || (State=1)
		return SendMessage(hWnd, 0x0410, "Int", 1)
	if (State="Error") || (State="E") || (State=2)
		return SendMessage(hWnd, 0x0410, "Int", 2)
	if (State="Paused") || (State="P") || (State=3)
		return SendMessage(hWnd, 0x0410, "Int", 3)
	return false, ErrorLevel := true
}

;establecer/incrementar/decrementar valor.
;Sintaxis: PB_SetPos( [hWnd], [+/- valor] )
;Devuelve: la posición anterior.
;Nota: si el valor está fuera del rango del control, la posición se establece en el límite más cercano.
PB_SetPos(hWNd, Value := "+10") {
	M := InStr(Value, "+"), L := InStr(Value, "-")
	if (M) || (L) ;+/-
		Pos := PB_GetPos(hWnd), Value := (M?(Pos+StrReplace(Value, "+")):(Pos-StrReplace(Value, "-")))
	return SendMessage(hWnd, 0x0402, "Int", Value)
}

;establece el color de la barra de indicador de progreso.
;Sintaxis: PB_SetBarColor( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB.
;Nota: devuelve el color anterior.
PB_SetBarColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x0409,,,, _getcolor(Color, true)))
}

;establee el color de fondo de la barra de progreso.
;Sintaxis: PB_SetBKColor( [hWnd], [color] )
;Color: espesificar el nombre del color o RGB.
;Nota: devuelve el color anterior.
PB_SetBKColor(hWnd, Color) {
	return RGB(SendMessage(hWnd, 0x2001,,,, _getcolor(Color, true)))
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;establece la barra de progreso para el modo de marquesina. esto hace que la barra de progreso para moverse como una marquesina.
;Sintaxis: PB_SetMarquee( [hWnd], [0|1], [retraso, en milisegundos] )
PB_SetMarquee(hWnd, State := true, Delay := 0) {
	WinSetStyle(hWnd, (State?"+":"-") 0x08)
	return SendMessage(hWnd, 0x040A, "Int", !!State, "UInt", (Delay>-1)?Delay:0)
}

;muestra el progreso en una barra de desplazamiento suave.
;Sintaxis: PB_SetSmooth( [hWnd], [0|1], [¿reverse?] )
;Reverse: el comportamiento de animación que la barra de progresa lo utiliza cuando se mueve hacia atrás
PB_SetSmooth(hWnd, State := true, Reverse := false) {
	Pos := PB_GetPos(hWnd), r:=WinSetStyle(hWnd, (State?"+":"-") (Reverse?0x10:0x01))
	return r, PB_SetPos(hWnd, Pos), ErrorLevel := !r
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;obtener el valor minimo y maximo.
;Sintaxis: PB_GetRange( [hWnd], [min (out)], [max (out)] )
;Nota: devuelve un Array con los valores [min, max].
PB_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	VarSetCapacity(PBRANGE, 8, 0), SendMessage(hWnd, 0x0407,,,, &PBRANGE)
	return [Min:=NumGet(PBRANGE, 0, "Int"), Max:=NumGet(PBRANGE, 4, "Int")]
}

;obtener estado.
;Sintaxis: PB_GetState( [hWnd] )
;Devuelve: Normal | Error | Paused
PB_GetState(hWnd) {
	State := SendMessage(hWnd, 0x0411)
	return (r:=(State=1)?"Normal":(State=2)?"Error":(State=3)?"Paused":""), ErrorLevel := !r
}

;obtener valor.
;Sintaxis: PB_GetPos( [hWnd] )
PB_GetPos(hWnd) {
	return SendMessage(hWnd, 0x0408)
}

;obtiene el color RGB de la barra de indicador de progreso.
;Sintaxis: PB_GetBarColor( [hWnd] )
PB_GetBarColor(hWnd) {
	return RGB(SendMessage(hWnd, 0x040F))
}

;obtiene el color RGB de fondo de la barra de progreso.
;Sintaxis: PB_GetBKColor( [hWnd] )
PB_GetBKColor(hWnd) {
	return RGB(SendMessage(hWnd, 0x040E))
}
























































;#############################################################################################################################################
;::::::::::::::::::::::::::::::::::::::::::::: SLIDER CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establecer posicion
;Sintaxis: TB_SetPos( [hWnd], [valor], [¿redibujar?] )
TB_SetPos(hWnd, Value, Redraw := true) {
	return SendMessage(hWnd, 0x0405, "Int", !!Redraw, "Int", Value)
}

;establecer valor minimo y maximo.
;Sintaxis: TB_SetRange( [hWnd], [min], [max], [¿redibujar?] )
TB_SetRange(hWnd, Min := 0, Max := 100, Redraw := true) {
	Min := (Min>-1)?Min:0, Max := (Max>Min)?Max:(Min+1)
	return SendMessage(hWnd, 0x0406, "Int", !!Redraw,, LOWORD(Min)+HIWORD(Max, false))
}

;----------------------------------------------------------------------------------------------------------------------------------------------

;obtener posicion
;Sintaxis: TB_GetPos( [hWnd] )
TB_GetPos(hWnd) {
	return SendMessage(hWnd, 0x0400)
}

;obtener valor minimo y maximo.
;Sintaxis: TB_GetRange( [hWnd], [min (out)], [max (out)] )
;Nota: devuelve un Array [min, max].
TB_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	return [Min:=SendMessage(hWnd, 0x0401), Max:=SendMessage(hWnd, 0x0402)]
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: UPDOWN CONTROL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;establece el control "compañero"
;Sintaxis: UD_SetBuddy( [hWnd], [hWnd compañero] )
;Nota: devuelve el hWnd del compañero anterior
UD_SetBuddy(hWnd, Buddy) {
	return SendMessage(hWnd, 0x0469,, Buddy)
}

;establece el rango minimo y maximo
;Sintaxis: UD_SetRange( [hWnd], [min -2147483648], [max 2147483647] )
;Nota: dejar vacío para no modificar
UD_SetRange(hWnd, Min := "", Max := "") {
	if (Min="") || (Max="")
		UD_GetRange(hWnd, mi, ma)
	SendMessage(hWnd, 0x046F, "Int", Min=""?mi:Min, "Int", Max=""?ma:Max)
	return !ErrorLevel
}

;------------------------------------------------------------------------------------------------------------------------------------------

;obtiene el hWnd del control "compañero"
;Sintaxis: UD_GetBuddy( [hWnd] )
UD_GetBuddy(hWnd) {
	return SendMessage(hWnd, 0x046A)
}

;recupera el rango minimo y maximo
;Sintaxis: UD_GetRange( [hWnd], [min (out)], [max (out)] )
UD_GetRange(hWnd, ByRef Min := "", ByRef Max := "") {
	VarSetCapacity(Min, 16, 0), VarSetCapacity(Max, 16, 0)
	, SendMessage(hWnd, 0x0470,, &Min,, &Max)
	return [Min:=NumGet(Min, 0, "Int"), Max:=NumGet(Max, 0, "Int")]
}





























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: GUI & DIALOGOS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;obtener color de fondo por defecto usado por autohotkey en las ventanas (gui)
GetGuiDefaultColor() {
	return RGB((((l:=DllCall("User32.dll\GetSysColor","Int",15,"UInt"))>>16)&0xFF)|(l&0x00FF00)|((l&0xFF)<<16))
}

;MessageBox
;Sintaxis: MsgBox( [opciones], [titulo], [texto], [tiempo fuera] )
;NOTA: la variable global A_MsgBoxResult contiene el resultado.
;EJEMPLO:
	;MsgBox % "Resultado: " MsgBox() "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(0) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox("") "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(4112, "ERROR!",, 1 ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(20, "Título" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(34,, "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
	;MsgBox % "Resultado: " MsgBox(16694, "Título", "Texto" ) "`nA_MsgBoxResult: " A_MsgBoxResult
MsgBox(Info*) {
	global A_MsgBoxResult
	if !(Info.MaxIndex())
		MsgBox, 0, *, Press OK to continue., % Info[4]
	else if (Info[1]!=""&&Info[2]=""&&Info[3]="")
		MsgBox, 0, *, % Info[1], % Info[4]
	else MsgBox, % Info[1], % Info[2]=""?"*":Info[2], % Info[3], % Info[4]
	Loop, Parse, % "Yes,No,Ok,Cancel,Abort,Ignore,Retry,Timeout,Continue,TryAgain", `,
		IfMsgBox, %A_LoopField%
			return ErrorLevel:=A_MsgBoxResult:=A_LoopField
}

;Sintaxis: ToolTip( [texto], [xpos], [ypos], [tiempo fuera, en segundos] )
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
ToolTip(Text := "", xpos := "", ypos := "", TimeOut := 0) {
	static ToolTip := Func("ToolTip").Bind()
	SetTimer(ToolTip, "Off")
	if (Text="") {
		ToolTip,,,, 20
	} else {
		ToolTip, %Text%, %xpos%, %ypos%, 20
		if (TimeOut)
			SetTimer(ToolTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
}}

;cambiar fuente y color de los ToolTips.
;Sintaxis 1: ToolTipFont( [opciones], [fuente] )
;Sintaxis 2: ToolTipColor( [color de fondo], [color del texto] )
ToolTipFont(Options := "", FontName := "", hWnd := "") {
    static hFont := 0
	if (hWnd)
		SendMessage, 0x30, hfont, 0,, ahk_id %hwnd%
	else  hfont := Options="Default"?0:ToolTipChange("Font", Options, FontName), ToolTipHook()
} ToolTipColor(Background := "", Text := "", hWnd := "") {
    static bc := "", tc := ""
    if !(hWnd)
		bc := ((Background="")||(Background="Default"))?"":ToolTipChange("Color", Background)
		, tc := ((Text="")||(Text="Default"))?"":ToolTipChange("Color", Text), ToolTipHook()
    else {
        VarSetCapacity(empty, 2, 0)
        , DllCall("UxTheme.dll\SetWindowTheme", "Ptr", hWnd, "Ptr", 0, "Ptr", ((bc!="")||(tc!=""))?&empty:0)
        if (bc!="")
            SendMessage, 1043, %bc%,,, ahk_id %hWnd%
        if (tc!="")
            SendMessage, 1044, %tc%,,, ahk_id %hWnd%
}} ToolTipHook() {
    static hook := 0
    if !(hook)
        hook := DllCall("User32.dll\SetWindowsHookExW", "Int", 4
            , "Ptr", RegisterCallback("ToolTipWndProc", "Fast", 3), "Ptr", 0
            , "UInt", DllCall("Kernel32.dll\GetCurrentThreadId"), "Ptr")
} ToolTipWndProc(nCode, _wp, _lp) {
    Critical, 999 ;lParam  := NumGet(_lp+0*A_PtrSize) | wParam  := NumGet(_lp+1*A_PtrSize)
    uMsg    := NumGet(_lp+2*A_PtrSize), hWnd    := NumGet(_lp+3*A_PtrSize)
    if ((nCode>=0) && ((uMsg=1081) || (uMsg=1036)) && WinExist("ahk_class tooltips_class32 ahk_id " hWnd))
        ToolTipColor(,, hwnd), ToolTipFont(,, hwnd)
    return DllCall("User32.dll\CallNextHookEx", "Ptr", 0, "Int", nCode, "Ptr", _wp, "Ptr", _lp, "Ptr")
} ToolTipChange(Cmd, Arg1, Arg2 := "") {
    static htext := 0, hgui := 0, hWnd := 0
    if !htext {
		Gui, New:+HWNDhWnd +E0x20 +0x40000000
        Gui, %hWnd%: Add, Text, +hwndhtext
    } Gui %hWnd%: %Cmd%, %Arg1%, %Arg2%
    if (Cmd = "Font") {
        GuiControl, Font, %htext%
        SendMessage, 0x31, 0, 0,, ahk_id %htext%
        return ErrorLevel
    } if (Cmd = "Color") {
        hdc := DllCall("User32.dll\GetDC", "ptr", htext, "ptr")
        SendMessage, 0x138, hdc, htext,, ahk_id %hWnd%
        clr := DllCall("Gdi32.dll\GetBkColor", "ptr", hdc, "uint")
        , DllCall("User32.dll\ReleaseDC", "ptr", htext, "ptr", hdc)
        return clr
}} ;http://ahkscript.org/boards/viewtopic.php?p=55014#p55014

;muestra un mensaje cerca del icono del área de notificacion.
;Sintaxis: TrayTip( [titulo], [texto], [tiempo fuera, en segundos], [opciones] )
;OPCIONES:
	;0 = sin icono | 1 = Info (defecto) | 2 = Advertencia | 3 = Error | M/16 = sin sonido (0M, 1M, 2M, 3M, 3+16, etc...)
;Nota: espesificar un número negativo en tiempo fuera para usar milisegundos
TrayTip(Title := "", Text := "", TimeOut := 0, Options := 1) {
	static x
	static TrayTip := Func("TrayTip").Bind()
	if !(x)
		RegWrite("REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "EnableBalloonTips", 2)
		, RegWrite("REG_DWORD", "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "Start_NotifyNewApps", x:=1)
	SetTimer(TrayTip, "Off")
	if (Text="") && (Title="") {
		TrayTip
	} else {
		TrayTip, %Title%, %Text%, 30, % RegExReplace(Options, "[^0-9]")+(InStr(Options, "M")?16:0)
		if (TimeOut)
			SetTimer(TrayTip, (TimeOut>0?(-(TimeOut*1000)):TimeOut))
}}

;dialogo Abrir Con...
;Sintaxis: OpenWithDialog( [owner window hwnd], [archivo] )
OpenWithDialog(hWnd, Filename) {
	VarSetCapacity(OPENASINFO,  (StrLen(Filename) * 2) + 4, 0)
	, NumPut(&Filename, OPENASINFO, 0, "Ptr"), NumPut(5, OPENASINFO, 2 * A_PtrSize)
	, r := DllCall("Shell32.dll\SHOpenWithDialog", "Ptr", hWnd, "Ptr", &OPENASINFO)
	if (ErrorLevel)
		return DllCall("shell32\OpenAs_RunDLLW", "Ptr", hWnd, "UInt", 0, "WStr", Filename)
	return r=0, ErrorLevel := r!=0
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;GUI
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;color para los controles
;conversor de colores: http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
;Sintaxis: GuiControlColor( [control], [color del texto], [color de fondo] )
GuiControlColor( ControlId, TextColor := "Black", BackgroundColor := "White", Force := false) {
	if (Force)
		CtlColors.Detach(ControlId)
	CtlColors.Change(ControlId, BackgroundColor, TextColor)
} 

;crear control RichEdit
;Sintaxis: GuiAddRichEdit( [Options], [Text] )
;Parámetros:
	;Options: opciones para el control.
		;Nota: si se detecta un salto de linea en el texto, usa +Multi automáticamente, a menos que espesifique -Multi.
	;Text: texto por defecto.
;Retuen: Object
;Nota: para ver las funciones disponibles, ver la clase __RichEditClass
;Ejemplo:
	/*
	Gui, New,, Ejemplo ClassRICHEDIT50W
	RichEdit1 := GuiAddRichEdit( "w425 h175", "Normal Text.`nText Color.`nBK Color.`nOther Font Options." A_Tab(100) "`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n`n")
		RichEdit1.SetRect(RichEdit1.GetRect(, y)[1] + 10, y + 2) ;x + 10 | y + 2
		RichEdit1.SetFont({TextColor: "Red", BKColor: 0xCEE7FF}, true, 13, 13+11)
		RichEdit1.SetFont({BKColor: 0xFF0080}, true, 25, 25+9)
		RichEdit1.SetFont({Italic: true, Bold: true, Underline: true, Strike: true, Name: "Times New Roman", Size: 16}, true, 35, 35+19)
		RichEdit1.ScrollPos := 0
		RichEdit1.SetColor(0xCEE7FF) ;color de fondo
		RichEdit1.Zoom := 200 ;establecer Zoom en 200 %
		RichEdit1.ReadOnly := true ;solo lectura
	RichEdit2 := GuiAddRichEdit("w425 h25")
		RichEdit2.Text := ["F1 = Cambiar Color | F2 = Cambiar Fuente | F3 = Random", 0] ;establecer texto.
		RichEdit2.SetFont({Size:12, UnderlineType: 7, Underline: true, Disabled: 1}) ;tamaño de la fuente 12
		RichEdit2.Limit := 54 ;limitar texto a 54 carácteres
	Gui, Show
	return
	GuiClose:
	ExitApp
	F1::RichEdit2.ChooseColor() ;CAMBIAR COLOR
	F2::RichEdit2.ChooseFont() ;CAMBIAR FUENTE
	F3::RichEdit2.SetFont({UnderlineType: Random(0, 18), Underline: true, Size: Random(10, 14), TextColor: _randcolor()}) ;RANDOM
	F4::RichEdit1.ScrollPos := [20, 0] ;CAMBIAR POSICION DE LA BARRA DE DESPLAZAMIENTO
	F5::RichEdit1.ShowScrollBar(1, ShowScrollBar:=!ShowScrollBar), RichEdit1.ShowScrollBar(0, ShowScrollBar) ;OCULTAR / MOSTRAR BARRA DE DESPLAZAMIENTO
	F6:: ;INFO
	Info := RichEdit1.GetStatistics()
	ToolTip % "Linea: " Info.CaretLine "`nColumna: " Info.CaretCol "`nSeleccionado: " Info.SelLength "`n"
		. "Caracteres: " Info.CharLength " en " Info.LineCount " Lineas.`nSelección: " Info.SelStart " - " Info.SelEnd
	return
	F7::RichEdit1.SaveFileDlg() ;GUARDAR
	F8::RichEdit1.LoadFileDlg() ;CARGAR
	*/
GuiAddRichEdit(Options := "", Text := "") { ;WIN_V+
	return new __RichEditClass(Options, Text)
}




















































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: LISTA DE IMÁGENES (ImageList), IMÁGENES & ICONOS & BITMAP & PIXEL ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;BITMAP
;Link: https://msdn.microsoft.com/en-us/library/dd183385(v=vs.85).aspx
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Sintaxis: CreateBitmap( [ancho], [alto], [Planes], [BitsPerPel], [&lpvBits] )
;Return: hBitmap
CreateBitmap(Width := 0, Height := 0, Planes := 1, BitsPerPel := 24, lpvBits := 0) {
	return DllCall("Gdi32.dll\CreateBitmap", "Int", Width, "Int", Height, "UInt", Planes, "UInt", BitsPerPel, "Ptr", lpvBits, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/dd183485(v=vs.85).aspx

;Sintaxis: CreateCompatibleBitmap( [hDC], [ancho], [alto] )
;Return: hcBitmap (DDB)
CreateCompatibleBitmap(hDC := 0, Width := 0, Height := 0) {
	return DllCall("Gdi32.dll\CreateCompatibleBitmap", "Ptr", hDC, "Int", Width, "Int", Height, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/dd183488(v=vs.85).aspx

;Sintaxis: SetBitmapBits( [hBitmap], [Bytes/Color], [&BitsColorData] )
;Return: Bytes = OK. 0 = ERROR
SetBitmapBits(hBitmap, Bytes, BitsColorData := 0) {
	if (BitsColorData=0)
		VarSetCapacity(l, 4, 0), Numput(_getcolor(Bytes), l, 0, "UInt"), BitsColorData := &l, Bytes := 4
	return DllCall("Gdi32.dll\SetBitmapBits", "Ptr", hBitmap, "UInt", Bytes, "Ptr", BitsColorData, "UInt")
} ;https://msdn.microsoft.com/en-us/library/dd162962(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;LISTA DE IMÁGENES
;Parámetros:
	;hImageList / ImageList := identificador (HANDLE) a la lista de imágenes
	;Index: espesificar la posición de la imágen, en algunas funciones, el 0 afecta/incluye a todas
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/ff485948(v=vs.85).aspx
;SO: WIN_V+
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;elimina una lista de imágenes 
;Sintaxis: ImageList_Destroy( [ImageList] )
;Return: 0=ERROR
ImageList_Destroy(ImageList) {
	return DllCall("Comctl32.dll\ImageList_Destroy", "Ptr", ImageList, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761524(v=vs.85).aspx

;elimina una imagen de una lista de imágenes
;Sintaxis: ImageList_Remove( [ImageList], [Index] )
;Return: 0=ERROR
ImageList_Remove(ImageList, Pos := 0) {
	return DllCall("ComCtl32.dll\ImageList_Remove", "Ptr", ImageList, "Int", Pos - 1, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761564(v=vs.85).aspx

;crea una lista de imágenes 
;Sintaxis: ImageList_Create( [InitialCount], [GrowCount], [LargeIcons], [Width], [Height], [Flags] )
;Parámetros:
	;InitialCount: número de imágenes que la lista de imágenes inicialmente contiene.
	;GrowCount: número de imágenes por el cual la lista de imágenes puede crecer cuando el sistema necesita para hacer espacio para las nuevas imágenes.
	;LargeIcons: espesificar 1 para usar el icono predeterminado grande del sistema, por defecto usa el pequeño.
	;Width: espesificar el ancho para todas las imágenes en la lista de imágenes, en píxeles.
	;Height: espesificar el alto para todas las imágenes en la lista de imágenes, en píxeles.
	;Flags: https://msdn.microsoft.com/en-us/library/windows/desktop/bb775232(v=vs.85).aspx
;Return: hImageList
;Notas:
	;si usa Width, LargeIcons no tiene efecto para el ancho de las imágenes.
	;si usa Height, LargeIcons no tiene efecto para el alto de las imágenes.
ImageList_Create(InitialCount := 2, GrowCount := 5, LargeIcons := false, Width := 0, Height := 0, Flags := 0x00000021) {
	static SM_
	if !(SM_)
		SM_ := {CXICON: GetSystemMetrics(11) ;el ancho predeterminada de un icono, en píxeles.
			, CXSMICON: GetSystemMetrics(49)  ;el ancho recomendado de un icono pequeño, en píxeles.
			, CYICON: GetSystemMetrics(12) ;la altura predeterminada de un icono, en píxeles.
			, CYSMICON: GetSystemMetrics(50)} ;la altura recomendada de un icono pequeño, en píxeles.
	return DllCall("Comctl32.dll\ImageList_Create", "Int", Width>0?Width:LargeIcons?SM_.CXICON:SM_.CXSMICON
		, "Int", Height>0?Height:LargeIcons?SM_.CYICON:SM_.CYSMICON
		, "UInt", Flags, "Int", InitialCount , "Int", GrowCount, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761522(v=vs.85).aspx

;crea un duplicado de una lista de imágenes existente
;Sintaxis: ImageList_Duplicate( [ImageList] )
;Return: hImageList
ImageList_Duplicate(ImageList) {
	return DllCall("Comctl32.dll\ImageList_Duplicate", "Ptr", ImageList, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761540(v=vs.85).aspx

;recupera el número de imágenes en una lista de imágenes
;Sintaxis: ImageList_GetImageCount( [ImageList] )
;Return: INT
ImageList_GetImageCount(ImageList) {
	return DllCall("ComCtl32.dll\ImageList_GetImageCount", "Ptr", ImageList, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761552(v=vs.85).aspx

;recupera las dimensiones de las imágenes en una lista de imágenes
;Sintaxis: ImageList_GetIconSize( [ImageList], [ancho (out)], [alto (out)] )
;Return: 0=ERROR
ImageList_GetIconSize(ImageList, ByRef Width := "", ByRef Height := "") {
	return DllCall("ComCtl32.dll\ImageList_GetIconSize", "Ptr", ImageList, "IntP", Width, "IntP", Height, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761550(v=vs.85).aspx

;obtener identificador (HANDLE) de un icono en la lista de imagenes
;Sintaxis: ImageList_GetIcon( [ImageList], [Index], [flags] )
;Parámetros:
	;Flags: una combinacion de valores que espesifican el estilo de dibujo.
;Return: hIcon
ImageList_GetIcon(ImageList, Index := 1, Flags := 0x0) {
	return DllCall("Comctl32.dll\ImageList_GetIcon", "Ptr", ImageList, "Int", Index-1, "UInt", Flags, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb761548(v=vs.85).aspx

;reemplaza una imagen
;Sintaxis: ImageList_ReplaceIcon( [ImageList], [Index], [hIcon] )
;Parámetros:
	;Index: espesificar el indice. por defecto la añade al final.
	;hIcon: espesificar un HANDLE a una imagen o la ruta completa a una imagen/archivo. para espesificar un indice, usar un Array [archivo, indice].
;Return:
	;0 = ERROR
	;[Index > 0] = OK
ImageList_ReplaceIcon(ImageList, Index := 0, hIcon := 0) {
	if ((hIcon+0)="")
		hIcon := LoadImage(hIcon.1?hIcon.1:hIcon, hIcon.2,,, Type), DestroyIcon := true
	Index := DllCall("Comctl32.dll\ImageList_ReplaceIcon", "Ptr", ImageList, "Int", Index-1, "Ptr", hIcon, "Int") + 1
	if (DestroyIcon)
		if (Type=0)
			DeleteObject(hIcon)
		else DestroyIcon(hIcon)
	return Index
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb775215(v=vs.85).aspx

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;IMÁGENES
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener ancho y alto de una imagen
;Sintaxis: ImageGetDimension( [imagen], [ancho (out)], [alto (out)] )
;Return: OK=[ancho, alto] | ERROR=0
ImageGetDimension(Image, ByRef Width := "", ByRef Height := "") {
	GdiplusStartup(hModule), pBitmap := GdipCreateBitmapFromFile(Image), pGraphics := GdipGraphicsFromImage(pBitmap)
	, Ok := GdipGetImageDimensions(pBitmap, Width, Height), GdipDeleteGraphics(pGraphics), GdipDisposeImage(pBitmap)
	return Ok?[Width, Height]:false, GdiplusShutdown(, hModule), ErrorLevel := !Ok
}

;convertir imágenes
;Sintaxis: ImageConvert( [imagen], [directorio\nombre.ext], [ancho], [alto], [¿preservar la relacion de aspecto?], [profundidad de bits 24/32 (solo .bmp)] )
;Extensiones soportadas: png, bmp, jpg, tiff, gif
;Return: 0|1
;Nota: el archivo salida es reescrito (si existe)
ImageConvert(Image, Output := "", Width := "", Height := "", PreserveAspectRatio := true, BitDepth := 32) {
	GdiplusStartup(hModule), SplitPath(Output,,, Ext), pBitmapFile := GdipCreateBitmapFromFile(Image)
	, CurrentWidth := GdipGetImageWidth(pBitmapFile), CurrentHeight := GdipGetImageHeight(pBitmapFile)
	, NewWidth := Width=""?CurrentWidth:Width, NewHeight := Height=""?CurrentHeight:Height
	if (PreserveAspectRatio) && ((r1:=CurrentWidth/NewWidth)>(r2:=CurrentHeight/NewHeight))
		NewHeight := CurrentHeight/r1
	else if (PreserveAspectRatio)
		NewWidth := CurrentWidth/r2
	pBitmap := GdipCreateBitmap(NewWidth, NewHeight, (Ext="bmp"&&BitDepth=24)?0x00021808:0x26200A)
	, pGraphics := GdipGraphicsFromImage(pBitmap), GdipSetSmoothingMode(pGraphics), GdipSetInterpolationMode(pGraphics)
	, GdipDrawImage(pGraphics, pBitmapFile, false, false, NewWidth, NewHeight), GdipDisposeImage(pBitmapFile)
	, Ok := GdipSaveBitmapToFile(pBitmap, Output), GdipDisposeImage(pBitmap), GdipDeleteGraphics(pGraphics)
	return Ok, GdiplusShutdown(, hModule), ErrorLevel := !Ok
} ;http://ahkscript.org/boards/viewtopic.php?f=6&p=49878&sid=8974c43be898318cea6b8dc509f2e6df#p49878

;Sintaxis: CopyImage( [hImage], [0=BITMAP, 2=CURSOR, 3=ICONO], [ancho], [alto], [opciones] )
;Parámetros:
	;Opciones: 
		;0x00000008 = eliminar imagen original despues de copiar
		;0x00004000 = LR_COPYFROMRESOURCE
		;0x00000004 = LR_COPYRETURNORG
		;0x00002000 = LR_CREATEDIBSECTION
		;0x00000040 = LR_DEFAULTSIZE
		;0x00000001 = LR_MONOCHROME
;Return: hImage
CopyImage(hImage, Type := 0, Width := 32, Height := 32, Flags := 0x00002000) {
	return DllCall("User32.dll\CopyImage", "Ptr", hImage, "UInt", Type, "Int", Width, "Int", Height, "UInt", Flags, "Ptr")
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;ICONOS
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener HANDLE a una imagen
;Sintaxis: LoadImage( [Filename], [Index], [Width], [Height], [ImageType] )
;Parámetros:
	;Filename: espesificar la ruta a la imagen, puede ser icono, bitmap, cursor, exe, dll ...
	;Index: espesificar el indice, puede ser positivo o negativo. espesificar 0 para obtener el número de imagenes en el archivo.
	;Width: espesificar el ancho nuevo. dejar en 0 para usar el original.
	;Height: espesificar el alto nuevo. dejar en 0 para usar el original.
	;ImageType: devuelve uno de los siguientes valores que permite identificar el tipo de imagen.
		;0 = hBitmap
		;1 = hIcon
		;2 = Cursor
;Return:
	;hIcon / Cursor = usar DestroyIcon() para eliminar el HANDLE
	;hBitmap = usar DeleteObject() para eliminar el HANDLE
LoadImage(Filename, Index := 1, Width := 0, Height := 0, ByRef ImageType := "") {
	if (Index=0)
		return DllCall("Shell32.dll\ExtractIconW", "Ptr", A_ScriptHwnd, "Ptr", &Filename, "UInt", -1)
	Index := (Index+0)=""?1:Abs(Index)
	return LoadPicture(Filename, "GDI+ Icon" Index " w" Width " h" Height, ImageType)
}

;eliminar HANDLE a un icono
;Sintaxis: DestroyIcon( [hIcon*] )
;Return: 0|1
;Nota: para eliminar hBitmap usar DeleteObject()
DestroyIcon(hIcon*) {
	Ok := 0, Error := ErrorLevel
	Loop, % hIcon.MaxIndex()
		Ok += !!DllCall("User32.dll\DestroyIcon", "UPtr", hIcon[A_Index], "Int")
	return Ok=hIcon.MaxIndex(), ErrorLevel := Error
}

;duplicar icono
DuplicateIcon(hIcon) {
	return r:=DllCall("Shell32.dll\DuplicateIcon", "Ptr", A_ScriptHwnd, "Ptr", hIcon), ErrorLevel := !r
}

;dibuja un icono o cursor en el contexto de dispositivo especificado
DrawIcon(hDC, Left := 0, Top := 0, hIcon := 0, Width := 32, Height := 32, istepIfAniCur := 0, hbrFlickerFreeDraw := 0, Flags := 3) {
	return DllCall("User32.dll\DrawIconEx", "Ptr", hDC, "Int", Left, "Int", Top, "Ptr", hIcon, "Int", Width
	, "Int", Height, "UInt", istepIfAniCur, "Ptr", hbrFlickerFreeDraw, "UInt", Flags, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms648065(v=vs.85).aspx

;----------------------------

;extraer icono
;Sintaxis 1: ExtractIcon( [archivo], [índice | 0 para obtener el número de iconos] )
;Sintaxis 2: ExtractIconEx( [archivo], [indice], [ancho], [alto] )
ExtractIcon(Icon, Index := 1) {
	if (Index=-1)
		return r:=DllCall("User32.dll\DestroyIcon", "UPtr", Icon), ErrorLevel := !r
	if !(hIcon:=DllCall("Shell32.dll\ExtractIconW", "Ptr", A_ScriptHwnd, "Str", Icon, "UInt", Index-1))
		hIcon := ExtractIconEx(Icon, Index)
	return hIcon, ErrorLevel := !hIcon
} ExtractIconEx(Icon, Index := 1, Width := 16, Height := 16) {
	r := DllCall("User32.dll\PrivateExtractIconsW", "Str", Icon, "Int", Index-1, "Int", Width, "Int", Height, "UIntP", hIcon, "UInt", 0, "UInt", 1, "UInt", 0)
	return hIcon, ErrorLevel := !r || (r=0xFFFFFFFF)
}








































/*#############################################################################################################################################
::::::::::::::::::::::::::::::::::::::::::::: CONTROL ::::::::::::::::::::::::::::::::::
NOTAS:
	• espesificar -1 en el 2do parametro para referirse al control que tiene el foco en la ventana espesificada.
	• espesificar -2 en el 2do parametro para referirse al control bajo el cursor.
	• espesificar -3 en el 2do parametro para referirse al último control espesificado.
	• el 1er parametro (hWnd) solo es necesario si se epesifica ClassN del control (Ej. Static1) en el 2do.
	• para actuar directamente sobre el ID de un control, espesificar el ID en el 2do parámetro y establecer el 1ero en 0
	• Parámetros:
		;--> hWnd = ID de la ventana que contiene el control.
		;--> Control = hWnd o nombre (ClassN, donde N es un número) del control.
#############################################################################################################################################
*/
;destruir control en una ventana creada por el script
;Sintaxis: ControlDestroy( [hWnd], [control] )
;Nota: para destruir todos los controles en una ventana, usar WinDestroy( [hWnd], true)
ControlDestroy(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinDestroy(Control)
}

;obtener posicion
;Sintaxis: ControlGetPos( [hWnd], [control], [x], [y], [ancho], [alto] )
ControlGetPos(hWnd, Control, ByRef x := "", ByRef y := "", ByRef Width := "", ByRef Height := "") {
	_gethwnd(hWnd, Control)
	ControlGetPos, x, y, Width, Height,, ahk_id %Control%
	i := {}, i.w := i.Width := Width, i.h := i.Height := Height, i.x := x, i.y := y
	return i
}

;establece foco en un control / obtiene el foco del control de la ventana espesificada
;Sintaxis: ControlFocus( [hWnd], [Control] )
;Nota: espesificar solo el 1er parámetro para obtener le hWnd al control que tiene el foco.
ControlFocus(hWnd, Control := "GetFocus") {
	if (Control="GetFocus")
		return GetWindowThreadInfo(hWnd).hwndFocus
	_gethwnd(hWnd, Control)
	return WindowActive(Control, true)
}

;establecer texto
;Sintaxis: ControlSetText( [hWnd], [Control], [Texto] )
ControlSetText(hWnd, Control, NewText := "") {
	_gethwnd(hWnd, Control)
	return SendMsg(Control, 0x000C,, &NewText)?Control:false
}

;obtener texto
;Sintaxis: ControlGetText( [hWnd], [Control] )
ControlGetText(hWnd, Control) {
	_gethwnd(hWnd, Control), Size := SendMsg(Control, 0x000E)
	, VarSetCapacity(OutputVar, Size * 2 + 1)
	, Ok := SendMsg(Control, 0x000D, Size + 1, &OutputVar)
	return OutputVar, VarSetCapacity(OutputVar, -1), ErrorLevel := !Ok
} 

;comprueba si un control existe en una ventana espesifica.
;Sintaxis: ControlExist( [hWnd], [control] )
;Nota: devuelve el id del control.
ControlExist(hWnd, Control) {
	dhw := A_DetectHiddenWindows
	DetectHiddenWindows, On
	_gethwnd(hWnd)
	ControlGet, ControlId, hWnd,, %Control%, ahk_id %hWnd%
	DetectHiddenWindows, %dhw%
	return ControlId?ControlId:Control
}

;enviar un boton del raton o evento de la rueda.
;Sintaixs: ControlClick( [hWnd], [control], [left|right|middle|wheelleft|wheelright], [clics], [opciones] )
ControlClick(hWnd, Control, WhichButton := "LEFT", ClickCount := 1, Options := 0) {
	_gethwnd(hWnd, Control)
	ControlClick,, ahk_id %Control%,, %WhichButton%, %ClickCount%, %Options%
	return ErrorLevel?false:Control
}

;mover control
;Sintaxis: ControlMove( [hWnd], [control], [x], [y], [ancho], [alto] )
ControlMove(hWnd, Control, x := "", y := "", Width := "", Height := "") {
	_gethwnd(hWnd, Control)
	ControlMove,, %x%, %y%, %Width%, %Height%, ahk_id %Control%
	return ErrorLevel?false:Control
}

;hace una variedad de cambios en un control.
;Sintaxis: Control( [hWnd], [control], [comando], [valor] )
Control(hWnd, Control, Cmd, Value) {
	_gethwnd(hWnd, Control)
	if (Cmd="TabSelect")
		SendMessage(Control, 0x1330, "Int", Value), ErrorLevel := !SendMessage(Control, 0x130C, "Int", Value,,, "Int")
	else Control, %Cmd%, %Value%,, ahk_id %Control%
	return ErrorLevel?false:Control
}

;determina si el control está habilitado, lo habilita, dehabilita o alterna el estado actual.
ControlEnabled(hWnd, Control, State := "") {
	_gethwnd(hWnd, Control)
	return WinEnabled(Control, State)
}

;determina si el control es visible, lo muestra, lo oculta o alterna el estado actual.
ControlVisible(hWnd, Control, State := "") {
	_gethwnd(hWnd, Control)
	return WinVisible(Control, State)
}

;redibujar control
ControlRedraw(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return WinRedraw(Control)
}

;cambiar la fuente de un control
;Sintaxis: ControlSetFont( [hWnd], [control], [hFont], [¿redibujar?] )
;hFont: usar FontCreate()
;EJEMPLO:
	;Gui, Add, Edit, x15 y45 w465 h395 HWNDhWnd, Fuente ~ Edit Control, AutoHotKey %A_AhkVersion%
	;ControlSetFont(0, hWnd, FontCreate("Times New Roman", 17, true, true, true, 5))
	;Gui, Show, w500 h500
	;return
	;GuiEscape:
	;GuiClose:
	;ExitApp
ControlSetFont(hWnd, Control, hFont := "", Redraw := false) {
	_gethwnd(hWnd, Control)
	return SendMessage(Control, 0x30,, hFont, "Int", !!Redraw, "UInt")
}

;obtiene la fuente del control
;Sintaxis: ControlGetFont( [hWnd], [control] )
;Return: hFont
;Nota: usar FontQuery para obtener información de la fuente
ControlGetFont(hWnd, Control) {
	_gethwnd(hWnd, Control)
	return SendMsg(Control, 0x31,,, "Ptr")
}

;cambiar color del texto y fondo de un control
;Sintaxis: ControlSetColor( [hWnd], [Control], [color del texto, nombre o RGB], [color de fondo, nombre o RGB] )
;NOTA: necesario CtlColors_Class
ControlSetColor(hWnd, Control, TC := "Black", BG := "White") {
	_gethwnd(hWnd, Control)
	return CtlColors.Change(Control, Hex(_getcolor(BG), 6,, ""), Hex(_getcolor(TC), 6,, ""))
}

;permitir/bloquear el redibujado de un control
;Sintaxis: ControlSetRedraw( [hWnd], [control], [0|1] )
ControlSetRedraw(hWnd, Control, Redraw := true) {
	_gethWnd(hWnd, Control)
	return WinSetRedraw(Control, Redraw)
}

;cambiar color de fondo y texto
;Sintaxis: SetControlColor( [hWnd control], [color de fondo], [color del texto] )
;Color: RGB o Nombre
;Controles soportados (clases): Static, ListBox, Edit
;Return: el valor depende del tipo de control sobre el cual se aplica
	;Picture Control: hBitmap. cuando ya no lo nesesite, debe pasar hBitmap a DeleteObject().
	;Otros: 0|1
;Ejemlo:
/*
	Gui, +AlwaysOnTop +HWNDhGui
	Gui, Add, Text, x0 y100 w140 h15 HWNDhWnd +Center, Text Color
	SetControlColor(hWnd, 0x0079F2, "White")
	Loop, Parse, % "Aqua|Black|Blue|Fuchsia|Gray|Green|Lime|Maroon|Purple|Red|Silver|Teal|White|Yellow", |
	{ 	Gui, Add, Picture, % "x" ((A_Index-1)*10) " y0 w10 h95 HWNDhWnd"
		%A_LoopField% := SetControlColor(hWnd, A_LoopField)
	} Gui, Show, w140 h115
	Sleep, 3000
	Loop, Parse, % "Aqua|Black|Blue|Fuchsia|Gray|Green|Lime|Maroon|Purple|Red|Silver|Teal|White|Yellow", |
		DeleteObject(%A_LoopField%), WinRedraw(hGui), Sleep(500)
	GuiClose:
	ExitApp
*/
SetControlColor(hWnd, BackgroundColor := "White", TextColor := "") {
	static Controls := {}
	If Controls.HasKey(BackgroundColor) {
		if !(Controls[BackgroundColor].T = "")
			DllCall("Gdi32.dll\SetTextColor", "Ptr", hWnd, "UInt", Controls[BackgroundColor].T)
		DllCall("Gdi32.dll\SetBkColor", "Ptr", hWnd, "UInt", Controls[BackgroundColor].B)
		, DllCall("Gdi32.dll\SetDCBrushColor", "Ptr", hWNd, "UInt", Controls[BackgroundColor].B)
		return GetStockObject(18)
	} if DllCall("User32.dll\IsWindow", "Ptr", hWnd) {
		Class := GetWindowClass(hWnd), Style := WinGetStyle(hWnd)
		if (Class = "Static") && ((Style = 1342177280) || (Style = (1342177280+0x4E))) {
			SetBitmapBits(hBitmap := CopyImage(CreateBitmap(1, 1),, 0, 0, 0x2008), _getcolor(BackgroundColor))
			, WinSetStyle(hWnd, "+0x4E"), SendMsg(hWnd, 0x0172,, hBitmap) ;0x0172 = STM_SETIMAGE
			return ErrorLevel?DeleteObject(hBitmap)*0:hBitmap
		} Loop, Parse, % "0x0133|0x0134|0x0138", |
			if !(OnMessage(A_LoopField) = A_ThisFunc)
				OnMessage(A_LoopField, A_ThisFunc)
		Controls.RemoveAt(hWNd, ""), BackgroundColor := _getcolor(BackgroundColor), TextColor := _getcolor(TextColor)
		If !(BackgroundColor="") && !((B:=((BackgroundColor&0xFF0000)>>16)|(BackgroundColor&0x00FF00)|((BackgroundColor&0x0000FF)<<16))="")
			Controls[hWnd] := {B: B, T: TextColor=""?"":((TextColor&0xFF0000)>>16)|(TextColor&0x00FF00)|((TextColor&0x0000FF)<<16)}
		return DllCall("User32.dll\RedrawWindow", "Ptr", hWnd, "Ptr", 0, "Ptr", 0, "UInt", 0x0405)
	} return false
}

;obtener estilo del control
;Sintaxis: ControlGetStyle( [hWnd], [control] )
ControlGetStyle(hWnd, Control) {
	_gethWnd(hWnd, Control)
	ControlGet, OutputVar, Style,,, ahk_id %Control%
	return OutputVar
}

;obtener estilo extendido del control
;Sintaxis: ControlGetExStyle( [hWnd], [control] )
ControlGetExStyle(hWnd, Control) {
	_gethWnd(hWnd, Control)
	ControlGet, OutputVar, ExStyle,,, ahk_id %Control%
	return OutputVar
}

;establecer estilo al control
;Sintaxis: ControlSetStyle( [hWnd], [control], [-+^estilo] )
ControlSetStyle(hWnd, Control, Style) {
	_gethWnd(hWnd, Control)
	Control, Style, %Style%,, ahk_id %Control%
	return !ErrorLevel
}

;establecer estilo extendido al control
;Sintaxis: ControlSetExStyle( [hWnd], [control], [-+^estilo] )
ControlSetExStyle(hWnd, Control, ExStyle) {
	_gethWnd(hWnd, Control)
	Control, ExStyle, %ExStyle%,, ahk_id %Control%
	return !ErrorLevel
}

;crear control
;Sintaxis: CreateControl( [hWnd ventana], [clase], [x], [y], [ancho], [alto], [texto], [estilo], [estilo extendido] )
;Return: devuelve el hWnd
;Clases: Button, ComboBox, Edit, ListBox, RichEdit, RICHEDIT_CLASS, SCROLLBAR, STATIC
CreateControl(hWnd, Class, x, y, Width, Height, Caption := "", Style := 0x56000000, ExStyle := 0x0) {
	return CreateWindow(x, y, Width, Height, Caption, Style, ExStyle, hWnd,, Class)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632679(v=vs.85).aspx












































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: MOUSE/CURSOR Y TECLADO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;desplazamiento acelerado, más rápido gire la rueda, más líneas se desplazará por tic
;Sintaxis: MouseAutoWheelSpeed( [TimeOut (ms)], [Boost], [Limit], [ToolTip] )
;DESCRIPCION - PARÁMETROS:
	;TimeOut: tiempo fuera en el que se resetea el desplazamiento, en milisegundos
	;Boost: si se desplaza una distancia larga en una sola sesión, aplicar factor de impulso adicional (0=desactivado)
	;Limit: velcidad máxima (espesificar 0 para desactivar)
	;ToolTip: espesificar 1 (o el tiempo fuera, en milisegundos) para mostrar la velocidad de dezplazamiento como ToolTip
;NOTA: devuelve la velocidad actual (la misma que se muestra con ToolTip activado)
;EJEMPLO: WheelUp::MouseAutoWheelSpeed(,,, 1)
MouseAutoWheelSpeed(TimeOut := 500, Boost := 30, Limit := 60, ToolTip := 0) {
	static d := 0, i := 0
	t := A_TimeSincePriorHotkey, ToolTip := !(ToolTip>-1)?0:((ToolTip=1)?TimeOut:ToolTip)
	, TimeOut := (TimeOut>0)?TimeOut:500, Boost := (Boost>-1)?Boost:30
	if (A_PriorHotkey=A_ThisHotkey) && (t<TimeOut) && (Limit>0) {
		d := (d+1), v := ((t<80)&&(t>1))?((250.0/t)-1):1
		if (Boost>1&&d>Boost) {
			z := (v>i)?(i:=v):(v:=i)
			v *= (d/Boost)
		} v := (v>1)?((v>Limit)?Limit:Floor(v)):1
		if (ToolTip)
			ToolTip("×" v,,, -ToolTip)
		return ClickMouse( A_ThisHotkey,,, v )
	} else {
		d := (i:=0)
		if (ToolTip)
			ToolTip("×" 1,,, -ToolTip)
		return ClickMouse(A_ThisHotkey)
}} ;http://www.autohotkey.com/board/topic/48426-accelerated-scrolling-script/

;clics o mantiene pulsado un botón del ratón, o girar la rueda del ratón
;Sintaxis: MouseClick( [boton/rueda], [xpos], [ypos], [repeticiones], [velocidad de movimiento (x,y)] )
ClickMouse(WhichButton := "Left", x := "", y := "", ClickCount := 1, Speed := 0, DU := "", R := "") {
	Loop, %ClickCount%
		MouseClick, %WhichButton%, %x%, %y%,, %Speed%, %DU%, %R%
	return ClickCount
}

;enviar pulsaciones de teclas a un control o ventana activa
;Sintaxis: SendKeys( [hWnd / Keys], [Control], [Keys], [Repeticiones], [retraso (ms)] )
SendKeys(hWnd := -1, Control := "", Keys := "", Count := 1, Delay := "") {
	if (Keys != "")
		_gethwnd(hWnd, Control)
	Loop {
		if (Keys = "")
			SendInput, % hWnd
		else ControlSend,, % Keys, ahk_id %Control%
		if (A_Index != Count) && (Delay != "")
			Sleep, % Delay
	} until (A_Index = Count)
}

;espera por una tecla a ser precionada o liberada
;Sintaxis: KeyWait( [tecla], [opciones], [tiempo fuera, en segundos] )
;OPCIONES:
	;D = espera a que la tecla sea precionada
	;[Vacío] (defecto) = espera a que la tecla sea liberada por el usuario
KeyWait(KeyName, Options := "", TimeOut := 0) {
	KeyWait, %KeyName%, % Options (TimeOut?" T" TimeOut:"")
	return !ErrorLevel
}

;Activa o desactiva la función de rastros del mouse
;Sintáxis: MouseTrails( [Número o dejar vacio para recuperar el estado actual.] )
;Nota: especifique un número mayor a 1 para activar. para desactivar especifique 0 o 1
;Ejemplos: MouseTrails( 10 ) | MouseTrails( 0 ) | MouseTrails(  )
MouseTrails(N := "", Save := false) {
	if (N != "")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005D, "UInt", N, "Str", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x005E, "UInt", 0, "UIntP", N, "UInt", 0)
	return N
}

;cambia o recupera la velocidad actual del mouse
;Sintáxis: MouseSpeed( [establecer velocidad / dejar vacio], [¿guardar cambios?] )
MouseSpeed(Value := "", Save := false) {
	if (Value!="")
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x71, "UInt", 0, "UInt", (Value>20)?20:(Value<1)?1:Value, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x70, "UInt", 0, "UIntP", Value, "UInt", 0)
	return Value
}

;recupera/cambia el número de líneas para desplazarse cuando se mueve la rueda ratón verticalmente
;Sintaxis: MouseScrollLines( [valor], [¿guardar cambios?] )
MouseScrollLines(Lines := -1, Save := false) {
	if (Lines >= 0)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0069, "UInt", Lines, "UInt", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0068, "UInt", 0, "UIntP", Lines, "UInt", 0)
	return Lines
}

;establece/recupera el tiempo (ms) de doble clic para el ratón
;Sintaxis: MouseDoubleClick( [milisegundos (1~5000)] )
MouseDoubleClick(ms := -1) {
	if (ms >= 0)
		return DllCall("User32.dll\SetDoubleClickTime", "UInt", ms)
	return DllCall("User32.dll\GetDoubleClickTime")
}

;Invierte o restaura los botones izquierdo y derecho del ratón
;Sintaxis: MouseSwap( 0|1 )
MouseSwap(fSwap := false) {
	return DllCall("User32.dll\SwapMouseButton", "Int", !!fSwap)
}

;recupera/establece el número de caracteres para desplazarse cuando se mueve la rueda horizontal ratón
;Sintaxis: MouseWheelScrollChars( [valor, defecto = 3], [¿guardar?] )
MouseWheelScrollChars(Value := "", Save := false) {
	if (Value!="")
		return DllCall("User32.dll\SystemParametersInfo", "UInt", 0x006D, "UInt", Value, "UIntP", 0, "UInt", Save?(0x0001|0x0002):0)
	DllCall("User32.dll\SystemParametersInfo", "UInt", 0x006C, "UInt", 0, "UIntP", Value, "UInt", 0)
	return  Value
}

;Mueve el cursor a las coordenadas de pantalla especificadas
;Sintaxis: MouseSetPos( [x], [y], [velocidad] )
MouseSetPos(x := "", y := "", Speed := "", R := 0) {
	if (Speed!="")
		return MouseMove(x, y, Speed, R)
	if (x="") || (y="")
		CursorGetPos(x_, y_)
	return DllCall("User32.dll\SetCursorPos", "Int", x=""?x_:x, "Int", y=""?y_:y)
} CursorSetPos(x := "", y := "", Speed := 0, R := 0) {
	return MouseSetPos(x, y, Speed, R)
} MouseMove(x, y, Speed := -1, R := "") {
	MouseMove, %x%, %y%, % Speed>-1?Speed:A_DefaultMouseSpeed, % R?"R":""
	return !ErrorLevel
}

;recupera la posicion del cursor, ventana y control bajo el cursor.
;Sintaxis: MouseGetPos( [x (out)], [y (out)], [ventana (out)], [control (out)], [modo] )
;Modos:
	;2 = devuelve el hWnd en ves de ClassN en el 4to parámetro
;Return: [x, y, ventana (solo si se espesificó una variable), control (solo si se espesificó una variable)]
MouseGetPos(ByRef x := "", ByRef y := "", ByRef  Window := "", ByRef Control := "", Mode := 0) {
	if IsByRef(Control) || (Control)
		MouseGetPos, x, y, Window, Control, %Mode%
	else if IsByRef(Window) || (Window)
		MouseGetPos, x, y, Window,, %Mode%
	else MouseGetPos, x, y,,, %Mode%
	return [x, y, Window, Control]
} 

;recupera la posicion xy del cursor.
;Sintaxis: CursorGetPos( [x (out)], [y (out)], [ventana (out)], [hWNd ScreenToClient] )
;Return: [x, y]
CursorGetPos(ByRef x := "", ByRef y := "", ByRef Window := "", ScreenToClient := 0) {
	VarSetCapacity(POINT, 8, 0)
	, Ok := DllCall("User32.dll\GetCursorPos", "Ptr", &POINT, "Int")
	if (ScreenToClient)
		Ok := Ok?DllCall("User32.dll\ScreenToClient", "Ptr", ScreenToClient, "Ptr", &POINT, "UInt"):false
	if (IsByRef(Window))
		Window := DllCall("User32.dll\WindowFromPoint", "Int64", NumGet(POINT, 0, "Int64"), "Ptr")
	return Ok?POINT(POINT, x, y):false, ErrorLevel := !Ok
}

;obtener el texto en las coordenadas espesificadas
;Sintaxis: MouseGetText( [x], [y] )
;Ejemplo:
	;for k, v in MouseGetText()
	;	MsgBox % k ": " v
	;ExitApp
MouseGetText(x := "", y := "", Encoding := "UTF-16") {
	static uia
	if (x="") || (y="")
		CursorGetPos(_x, _y), x := x=""?_x:x, y := y=""?_y:y
	if !(uia) ;https://msdn.microsoft.com/en-us/library/windows/desktop/ff384838%28v=vs.85%29.aspx
		uia := ComObjCreate("{ff48dba4-60ef-4201-aa87-54103eef594e}", "{30cbe57d-d9d0-452a-ab13-7ac5ac4825ee}")
	Item := {}, DllCall(_vt(uia,7),"Ptr",uia,"int64",x|y<<32,"Ptr*",element)
	if !(element)
		return "", ErrorLevel := true
	DllCall(_vt(element,23),"Ptr",element,"Ptr*",name),DllCall(_vt(element,10),"Ptr",element,"UInt",30045,"Ptr",_variant(var))
	,DllCall(_vt(element,10),"Ptr",element,"uint",30092,"Ptr",_variant(lname)), DllCall(_vt(element,10),"Ptr",element,"uint",30093,"Ptr",_variant(lval))
	,a:=StrGet(name,"utf-16"),b:=StrGet(NumGet(val,8,"Ptr"),Encoding),c:=StrGet(NumGet(lname,8,"Ptr"),Encoding)
	,d:=StrGet(NumGet(lval,8,"Ptr"),Encoding),a?Item.Push(a):0,b&&_vas(Item,b)?Item.Push(b):0,c&&_vas(Item,c)?Item.Push(c):0
	,d&&_vas(Item,d)?Item.Push(d):0,DllCall(_vt(element,21),"Ptr",element,"Uint*",type)
	if (type=50004)
		e:=MouseGetText_ElementWhole(uia,element),e&&_vas(item,e)?item.Push(e):false
	return Item, ObjRelease(element), ErrorLevel := false
} MouseGetText_ElementWhole(uia, element) {
	static init := 1, trueCondition, walker
	if (init)
		init:=DllCall(_vt(uia,21),"ptr",uia,"ptr*",trueCondition),init+=DllCall(_vt(uia,14),"ptr",uia,"ptr*",walker)
	DllCall(_vt(uia,5),"ptr",uia,"ptr*",root), DllCall(_vt(uia,3),"ptr",uia,"ptr",element,"ptr",root,"int*",same), ObjRelease(root)
	if (same)
		return
	hr:=DllCall(_vt(walker,3),"ptr",walker,"ptr",element,"ptr*",parent)
	if !(e:="") && !(parent)
		return
	DllCall(_vt(parent,6),"ptr",parent,"uint",2,"ptr",trueCondition,"ptr*",array), DllCall(_vt(array,3),"ptr",array,"int*",length)
	Loop % (length)
		DllCall(_vt(array,4),"ptr",array,"int",A_Index-1,"ptr*",newElement), DllCall(_vt(newElement,23),"ptr",newElement,"ptr*",name)
		, e.=StrGet(name,"utf-16"), ObjRelease(newElement)
	return e, ObjRelease(array), ObjRelease(parent)
} _vas(obj,ByRef txt) {
	for k,v in obj
		if (v=txt)
			return false
	return true
}_variant(ByRef var,type:=0,val:=0) {
	return (VarSetCapacity(var,8+2*A_PtrSize)+NumPut(type,var,0,"short")+NumPut(val,var,8,"ptr"))*0+&var
}_vt(p,n) {
	return NumGet(NumGet(p+0,"ptr")+n*A_PtrSize,"ptr")
} ;http://www.autohotkey.com/board/topic/94619-ahk-l-screen-reader-a-tool-to-get-text-anywhere/

;muestra/oculta el cursor
;Sintaxis: CursorShow( [Estado (0|1)], [Modo (0|1)], [Reestablecer (segundos)], [¿esperar?] )
;REESTABLECER: tiempo fuera en el que el cursor se muestra/oculta (dependiedo el estado espesificado)
;EJEMPLO: CursorShow(0,, 5, true)
CursorShow(State, Mode := 0, TimeOut := 0, WaitTimeOut := false) {
	;--------------------------------------------------------------------------------------------------------------
	static hCursor, hCursorImage, Cursor, LastState, LastMode
	static CursorShow := Func("CursorShow").Bind(-1)
	if (State=-1)
		return i := CursorShow( !LastState, LastMode ), ErrorLevel := !i
	;--------------------------------------------------------------------------------------------------------------
	if (TimeOut > 0) { ;alternar: State=0|1, Mode=0|1, TimeOut>0
		if !CursorShow( LastState:=State, LastMode:=Mode )
			return 0, ErrorLevel := 1
		if WaitTimeOut
			Sleep(TimeOut*1000)
		else return SetTimer(CursorShow, -(TimeOut*1000))
		return i := CursorShow( !State, Mode ), ErrorLevel := !i
	} ;--------------------------------------------------------------------------------------------------------------
	if (Mode) ;solo afecta a las ventanas creadas por el script: State=0|1, Mode=1, TimeOut=0
		Loop {
			NewDisplayCounter := DllCall("User32.dll\ShowCursor", "Int", State)
			if (State&&(NewDisplayCounter>=0))||(!State&&(NewDisplayCounter<=-1))
				return 1, ErrorLevel := 0
			if (NewDisplayCounter=OldDisplayCounter)||(State&&(NewDisplayCounter<OldDisplayCounter))
			||(!State&&(NewDisplayCounter>OldDisplayCounter))
				return 0, ErrorLevel := 1
			OldDisplayCounter := NewDisplayCounter
		}
	;--------------------------------------------------------------------------------------------------------------
	if (State) ;restaura los cursores: State=1, Mode=0, TimeOut=0
		return CursorReload()
	VarSetCapacity( AndMask, 32 * 4, 0xFF ), VarSetCapacity( XorMask, 32 * 4, 0 ), i := 0
	Loop, Parse, % "32650,32512,32515,32649,32651,32513,32641,32648,32640,32646,32643,32645,32642,32644,32516,32514", `,
	{ if !(Cursor) {
			hCursor := hCursorImage := []
			, hCursor[A_Index] := DllCall("User32.dll\CreateCursor", "Ptr", 0, "Int", 0, "Int", 0
				, "Int", GetSystemMetrics(13)
				, "Int", GetSystemMetrics(14)
				, "Ptr", &AndMask, "Ptr", &XorMask)
			, hCursorImage[A_Index] := DllCall("User32.dll\CopyImage", "Ptr", hCursor[A_Index], "UInt", 2, "Int", 0, "Int", 0, "UInt", 0)
		} i += DllCall("User32.dll\SetSystemCursor", "Ptr", hCursorImage[A_Index], "UInt", A_LoopField)
	} return Cursor := i, ErrorLevel := !i
} ;--------------------------------------------------------------------------------------------------------------

;vuelve a cargar los cursores del sistema
CursorReload() {
	return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0)
}

;cambiar cursor
;Sintaxis: SetSystemCursor( [cursor type] )
;Cursor Type: ARROW|IBEAM|WAIT|CROSS|UPARROW|SIZENWSE|SIZENESW|SIZEWE|SIZENS|SIZEALL|NO|HAND|APPSTARTING|HELP
;Nota: para restaurar dejar vacío
SetSystemCursor(Cursor := "") {
	static SystemCursors := "32512IDC_ARROW|32513IDC_IBEAM|32514IDC_WAIT|32515IDC_CROSS|32516IDC_UPARROW|32642IDC_SIZENWSE|32643IDC_SIZENESW"
		. "|32644IDC_SIZEWE|32645IDC_SIZENS|32646IDC_SIZEALL|32648IDC_NO|32649IDC_HAND|32650IDC_APPSTARTING|32651IDC_HELP"
	If !(Cursor)
		return DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0)
	If (StrLen(SystemCursors) = 221)
		Loop, Parse, % SystemCursors, |
			SystemCursors := StrReplace(SystemCursors, A_LoopField, DllCall("User32.dll\LoadCursor", "UInt", 0, "Int", SubStr(A_LoopField, 1, 5)) A_LoopField)
	Cursor := SubStr(SystemCursors, InStr(SystemCursors "|", "IDC_" Cursor "|") - 5 - (p:=(StrLen(SystemCursors) - 221)) / 14, 5)
	Loop, Parse, % SystemCursors, |
		DllCall("User32.dll\SetSystemCursor", "Ptr", DllCall("User32.dll\CopyIcon", "UInt", Cursor), "UInt",  SubStr(A_LoopField, 6, p))
}



























































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SISTEMA & CONFIGURACIÓN & INFORMACIÓN DE VERSIÓN ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;INFORMACIÓN DE VERSIÓN
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/ff468915(v=vs.85).aspx
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;recupera la descripción para el idioma asociado con un identificador de idioma Microsoft.
;Sintaxis: VerLanguageName( [ID Idioma] )
;Identificadores de Idiomas: https://msdn.microsoft.com/en-us/library/windows/desktop/dd318693(v=vs.85).aspx
;Return: String
;Ejemplo: MsgBox % VerLanguageName(A_Language) 
VerLanguageName(LangCP) {
	VarSetCapacity(Lang, 212 * 2, 0), LangCP := InStr(LangCP, "x")?LangCP:"0x" LangCP
	, Size := DllCall("Version.dll\VerLanguageNameW", "UInt", LangCP, "Str", Lang, "UInt", 212, "UInt")
	return Lang, ErrorLevel := !Size
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647463(v=vs.85).aspx

;obtener información de la version del archivo.
;Sintaxis: GetFileVersionInfo( [archivo] )
;Return: {Comments, InternalName, ProductName, CompanyName, LegalCopyright, ProductVersion, FileDescription, LegalTrademarks, PrivateBuild, FileVersion, OriginalFilename, SpecialBuild}
;ErrorLevel:
	;0 = OK
	;1 = no se ha podido obtener la información de la version
	;2 = no se ha podrido obtener el tamaño requerido
	;3 = error en VerQueryValue.
;Ejemplo:
	;for k, v in GetFileVersionInfo(A_WinDir "\regedit.exe")
	;	MsgBox % k " = " v
GetFileVersionInfo(Filename) {
	;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647005(v=vs.85).aspx
	if !(Size := DllCall("Version.dll\GetFileVersionInfoSizeW", "Ptr", &Filename, "Ptr", 0, "UInt")) 
		return false, ErrorLevel := 2 
	
	;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647003(v=vs.85).aspx
	VarSetCapacity(VS_VERSIONINFO, Size * 2, 0)
	if !DllCall("Version.dll\GetFileVersionInfoW", "Ptr", &Filename, "UInt", 0, "UInt", Size, "Ptr", &VS_VERSIONINFO, "Int")
		return false, ErrorLevel := true

	;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647464(v=vs.85).aspx
	if !DllCall("Version.dll\VerQueryValueW", "Ptr", &VS_VERSIONINFO, "Str", "\VarFileInfo\Translation", "PtrP", VERINFO, "UIntP", 0, "Int")
		return false, ErrorLevel := 3
	LangCP := "\StringFileInfo\" Format("{:04X}{:04X}", NumGet(VERINFO+0, "UShort"), NumGet(VERINFO+2, "UShort")) "\"
	
	Info := {}
	Loop, Parse, % "Comments|InternalName|ProductName|CompanyName|LegalCopyright|ProductVersion|FileDescription|LegalTrademarks|PrivateBuild|FileVersion|OriginalFilename|SpecialBuild", |
		if DllCall("Version.dll\VerQueryValueW", "Ptr", &VS_VERSIONINFO, "Str", LangCP A_LoopField, "PtrP", VERINFO, "UIntP", Size, "Int")
			Info[A_LoopField] := StrGet(VERINFO, Size)
	return Info
}

;igual a GetFileVersionInfo()
GetFileVersionInfoEx(Filename) { ;WIN_V+
	;https://msdn.microsoft.com/en-us/library/windows/desktop/aa969435(v=vs.85).aspx
	if !(Size := DllCall("Version.dll\GetFileVersionInfoSizeExW", "UInt", 0x01, "Ptr", &Filename, "Ptr", 0, "UInt")) 
		return false, ErrorLevel := 2 
	
	;https://msdn.microsoft.com/en-us/library/windows/desktop/aa969434(v=vs.85).aspx
	VarSetCapacity(VS_VERSIONINFO, Size * 2, 0)
	if !DllCall("Version.dll\GetFileVersionInfoExW", "UInt", 0x01, "Ptr", &Filename, "UInt", 0, "UInt", Size, "Ptr", &VS_VERSIONINFO, "Int")
		return false, ErrorLevel := true
	
	;https://msdn.microsoft.com/en-us/library/windows/desktop/ms647464(v=vs.85).aspx
	if !DllCall("Version.dll\VerQueryValueW", "Ptr", &VS_VERSIONINFO, "Str", "\VarFileInfo\Translation", "PtrP", VERINFO, "UIntP", 0, "Int")
		return false, ErrorLevel := 3
	LangCP := "\StringFileInfo\" Format("{:04X}{:04X}", NumGet(VERINFO+0, "UShort"), NumGet(VERINFO+2, "UShort")) "\"
	
	Info := {}
	Loop, Parse, % "Comments|InternalName|ProductName|CompanyName|LegalCopyright|ProductVersion|FileDescription|LegalTrademarks|PrivateBuild|FileVersion|OriginalFilename|SpecialBuild", |
		if DllCall("Version.dll\VerQueryValueW", "Ptr", &VS_VERSIONINFO, "Str", LangCP A_LoopField, "PtrP", VERINFO, "UIntP", Size, "Int")
			Info[A_LoopField] := StrGet(VERINFO, Size)
	return Info
}

;comparar dos versiones 
;Sintaxis: VersionCompare( [version1], [version2], [resultado] )
;Resultado: +(ver1 > ver2) | -(ver1 < ver2) | =(ver1 = ver2)
;Return: 0(Ver1 = Ver2) | 1(Ver1 > Ver2) | 2(Ver1 < Ver2)
VersionCompare(version1, version2, ByRef OutputVar := "") {
	if !(v2:=Trim(RegExReplace(version2, "[^0-9.]"), "."))
		return true, OutputVar := "+"
	if !(v1:=Trim(RegExReplace(version1, "[^0-9.]"), "."))
		return 2, OutputVar := "-"
	vA := StrSplit(v1, "."), vB := StrSplit(v2, ".")
	Loop, % (vA.MaxIndex()>vB.MaxIndex()?vA.MaxIndex():vB.MaxIndex()) {
		if (vA.MaxIndex()<A_Index)
			vA[A_Index] := 0
		if (vB.MaxIndex()<A_Index)
			vB[A_Index] := 0
		if (vA[A_Index]>vB[A_Index])
			return true, OutputVar := "+"
		if (vB[A_Index]>vA[A_Index])
			return 2, OutputVar := "-"
	} return false, OutputVar := "="
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;CONFIGURACIÓN
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;recupera el valor de configuración del sistema métrico o sistema especificado.
;Sintaxis: GetSystemMetrics( [valor] )
;Parámetros:
	;Valores: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385(v=vs.85).aspx
;Nota: todas las dimenciones son recuperadas en pixeles
GetSystemMetrics(Index*) {
	if (Index.MaxIndex()=1)
		return DllCall("User32.dll\GetSystemMetrics", "Int", Index.1, "Int")
	OutputVar := []
	for k, v in Index
		OutputVar.Push(DllCall("User32.dll\GetSystemMetrics", "Int", v, "Int"))
	return OutputVar
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385(v=vs.85).aspx

;recupera el identificador de idioma para el idioma de interfaz de usuario por defecto del sistema operativo.
GetSystemDefaultUILanguage() {
	return Hex(DllCall("Kernel32.dll\GetSystemDefaultUILanguage", "UShort"), 4, true)
}

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;SISTEMA
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;modo de inicio del sistema
;Sintaxis: SystemBoot()
;Return: 0(normal) | 1(a prueba de fallos) | 2(a prueba de fallos con acceso a la red)
SystemBoot() {
	return GetSystemMetrics(67)
}

;notifica al sistema que las asociaciones de tipo de archivo han cambiado.
SystemAssocChanged() {
	return DllCall("Shell32.dll\SHChangeNotify", "UInt", 0x08000000, "UInt", 0, "Ptr", 0, "Ptr", 0, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762118%28v=vs.85%29.aspx

;Apagar Equipo
;Sinraxis: Shutdown( [código], [forzar], [WaitToKillTimeout] )
;Parámetros:
	;Código: espesificar uno de los siguientes valores.
		;0 = (WIN_8+) apaga y preparar el sistema para un inicio más rápido
		;1 / S = apagar
		;2 / R = reiniciar
		;3 / L = cerrar sesion
		;4 = apaga el ardenador y alimentación
		;5 = suspender 
		;6 / H = hibernar
		;7 = apagar monitor
		;8 = encender monitor 
		;9 = poner el monitor en bajo consumo
		;10 = bloquear el equipo
	;Forzar: espesificar 1 para forzar el cierre de aplicaciones pasado cierto intervalo, o 2 para el apagado de emergencia (puede ocacionar perdida de información en aplicaciones si no se cierran correctamente).
	;WaitToKillTimeout: espesificar el tiempo máximo de espera para que las aplicaciónes finalizen de manera correcta, en segundos. pasado este tiempo se fuerza el cierre de la aplicacion y/o servicio.
;Return: 0=ERROR
;Nota: el proceso invocador requiere el privilegio SeShutdownPrivilege, que es habilitado al inicio por defecto.
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/aa376883(v=vs.85).aspx
Shutdown(Code, Force := false, WaitToKillTimeout := 0) {
	if (WaitToKillTimeout) {
		RegWrite, REG_SZ, HKLM\SYSTEM\CurrentControlSet\Control, WaitToKillServiceTimeout, % WaitToKillTimeout
		RegWrite, REG_SZ, HKCU\Control Panel\Desktop, WaitToKillAppTimeout, % WaitToKillTimeout
	} if (Code=0)
		Ok := DllCall("User32.dll\ExitWindowsEx", "UInt", 0x00400000+(Force=1?0x00000010:Force=2?0x00000004:0), "UInt", 0x80000000, "Int")
	else if (Code=1) || (Code="S") {
		if !(Ok := DllCall("User32.dll\ExitWindowsEx", "UInt", 0x00000001+(Force=1?0x00000010:Force=2?0x00000004:0), "UInt", 0x80000000, "Int"))
			Ok := DllCall("Advapi32.dll\InitiateSystemShutdownExW", "Ptr", 0, "Ptr", 0, "UInt", 0, "Int", !!Force, "Int", false, "UInt", 0x80000000, "Int")
	} else if (Code=2) || (Code="R") {
		if !(Ok := DllCall("User32.dll\ExitWindowsEx", "UInt", 0x00000002+(Force=1?0x00000010:Force=2?0x00000004:0), "UInt", 0x80000000, "Int"))
			Ok := DllCall("Advapi32.dll\InitiateSystemShutdownExW", "Ptr", 0, "Ptr", 0, "UInt", 0, "Int", !!Force, "Int", true, "UInt", 0x80000000, "Int")
	} else if (Code=3) || (Code="L")
		Ok := DllCall("User32.dll\ExitWindowsEx", "UInt", 0x00000002+(Force=1?0x00000010:Force=2?0x00000004:0), "UInt", 0x80000000, "Int")
	else if (Code=4)
		Ok := DllCall("User32.dll\ExitWindowsEx", "UInt", 0x00000000+(Force=1?0x00000010:Force=2?0x00000004:0), "UInt", 0x80000000, "Int")
	else if (Code=5)
		CMD("powercfg -h Off"), Run(A_SysDir() "\rundll32.exe powrprof.dll,SetSuspendState 0," !!Force ",0",, "Hide"), Ok := !ErrorLevel
	else if (Code=6)
		CMD("powercfg -h On"), Run(A_SysDir() "\rundll32.exe powrprof.dll,SetSuspendState 1," !!Force ",0",, "Hide"), Ok := !ErrorLevel
	else if (Code=7)
		GetDesktop(,, hDesktop), SendMsg(hDesktop, 0x112, 0xF170, 2), Ok := !ErrorLevel
	else if (Code=8)
		GetDesktop(,, hDesktop), SendMsg(hDesktop, 0x112, 0xF170, -1), Ok := !ErrorLevel
	else if (Code=9)
		GetDesktop(,, hDesktop), SendMsg(hDesktop, 0x112, 0xF170, 1), Ok := !ErrorLevel
	else if (Code=10)
		Ok := DllCall("User32.dll\LockWorkStation", "Int")
	return Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa376868(v=vs.85).aspx | https://msdn.microsoft.com/en-us/library/windows/desktop/aa376874(v=vs.85).aspx

;establece la hora y fecha local
;Sintaxis: GetSystemTime( [time] )
;Parámetros:
	;Time: espesificar un objecto con la información. no incluir para no modificar.
		;Year: 1601~30827
		;Month: 1~12
		;Day: 1~31
		;Hour: 0~23
		;Minute: 0~59
		;Second: 0~59
		;MilliSecond: 0~999
SetSystemTime(Time) {
	static Offset := {Year: 0, Month: 2, Day: 6, Hour: 8, Minute: 10, Second: 12, MiliSecond: 14}
	VarSetCapacity(SYSTEMTIME, 8 * 2, 0), DllCall("Kernel32.dll\GetLocalTime", "Ptr", &SYSTEMTIME)
	for k, v in Time
		NumPut(v, SYSTEMTIME, Offset[k], "UShort")
	return DllCall("Kernel32.dll\SetLocalTime", "Ptr", &SYSTEMTIME)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724936(v=vs.85).aspx

;porcentaje de uso del CPU
SystemCPULoad() {
	static PIT, PKT, PUT
	if !PIT
		DllCall("Kernel32.dll\GetSystemTimes", "Int64P", PIT, "Int64P", PKT, "Int64P", PUT)
	DllCall("Kernel32.dll\GetSystemTimes", "Int64P", CIT, "Int64P", CKT, "Int64P", CUT)
	Return (((SystemTime:=(PKT-CKT)+(PUT-CUT))-(PIT-CIT))*100)//SystemTime,PIT:=CIT,PKT:=CKT,PUT:=CUT
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3413
	
;sistema operativo: información de la versión
SysGetVersion() { ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff561910%28v=vs.85%29.aspx
	static VersionInfo
	if !(VersionInfo)
		VarSetCapacity(RTL_OSVIEX, 284, 0), NumPut(284, RTL_OSVIEX, 0, "UInt")
		, DllCall("ntdll.dll\RtlGetVersion", "Ptr", &RTL_OSVIEX), i := {}
		, i.MajorVersion := NumGet(RTL_OSVIEX, 4, "UInt")
		, i.MinorVersion := NumGet(RTL_OSVIEX, 8, "UInt")
		, i.BuildNumber := NumGet(RTL_OSVIEX, 12, "UInt")
		, i.PlatformId := NumGet(RTL_OSVIEX, 16, "UInt")
		, i.CSDVersion := StrGet(&RTL_OSVIEX + 20, 128, "UTF-16")
		, i.ServicePackMajor := NumGet(RTL_OSVIEX, 276, "UShort")
		, i.ServicePackMinor := NumGet(RTL_OSVIEX, 278, "UShort")
		, i.SuiteMask := NumGet(RTL_OSVIEX, 280, "UShort")
		, i.ProductType := NumGet(RTL_OSVIEX, 282, "UChar")
	return (VersionInfo?VersionInfo:(VersionInfo:=i))
}

SystemGetFontInfo(ByRef Name := "", ByRef Size := "", ByRef Weight := "", ByRef IsItalic := "") {
	nSize := VarSetCapacity(NCM, 500, 0), NumPut(nSize, &NCM, 0, "UInt")
	, i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0029, "UInt", nSize, "Ptr", &NCM, "UInt", 0)
	, Name := StrGet(&NCM+408+28, 32), Height := NumGet(&NCM+408, 0, "Int")
	, Size := DllCall("MulDiv", "Int", -Height, "Int", 72, "Int", A_ScreenDPI)
	, Weight := NumGet(&NCM + 408 + 16, 0, "Int"), IsItalic := NumGet(&NCM + 408 + 20, 0, "UChar")
	return i, ErrorLevel := !i
}

SystemSetFontInfo(Name := "", Size := "", Weight := "", IsItalic := "") {
	nSize := VarSetCapacity(NCM, 500, 0), NumPut(nSize, &NCM, 0, "UInt")
	, DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0029, "UInt", nSize, "Ptr", &NCM, "UInt", 0)
	, Name := Name?StrPut(Name, &NCM+408+28, 32):Name
	, Size := Size?NumPut(-DllCall("MulDiv", "Int", Size, "Int", A_ScreenDPI, "Int", 72), &NCM+408+0, "Int"):Size
	, Weight := Weight?NumPut(Weight, &NCM+408+16, "Int"):Weight
	, IsItalic := IsItalic=1||IsItalic=0?NumPut(IsItalic, &NCM+408+20, "UChar"):IsItalic
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x002A, "UInt", nSize, "Ptr", &NCM, "UInt", 0x01|0x02)
		, ErrorLevel := !i
}

;vuelve a cargar los iconos del sistema
SystemIconsReload() {
	return i:=DllCall("User32.dll\SystemParametersInfoW", "UInt", 0x0058, "UInt", 0, "Ptr", 0, "UInt", 0), ErrorLevel := !i
}

/* -------------------------------------------------------------------------------------------------------------------------------------------------------------
 ::::::::::::::::::::::::::::::::::::::::::::: VERSION HELPER FUNCTIONS ::::::::::::::::::::::::::::::::::
• Ejemplo:
	MsgBox %  "IsWindowsXPOrGreater: " IsWindowsXPOrGreater()
		. "`nIsWindowsXPSP1OrGreater: " IsWindowsXPSP1OrGreater()
		. "`nIsWindowsXPSP2OrGreater: " IsWindowsXPSP2OrGreater()
		. "`nIsWindowsXPSP3OrGreater: " IsWindowsXPSP3OrGreater()
		. "`nIsWindowsVistaOrGreater: " IsWindowsVistaOrGreater()
		. "`nIsWindowsVistaSP1OrGreater: " IsWindowsVistaSP1OrGreater()
		. "`nIsWindowsVistaSP2OrGreater: " IsWindowsVistaSP2OrGreater()
		. "`nIsWindows7OrGreater: " IsWindows7OrGreater()
		. "`nIsWindows7SP1OrGreater: " IsWindows7SP1OrGreater()
		. "`nIsWindows8OrGreater: " IsWindows8OrGreater()
		. "`nIsWindows8Point1OrGreater: " IsWindows8Point1OrGreater()
		. "`nIsWindows10OrGreater: " IsWindows10OrGreater()
		. "`nIsWindowsServer: " IsWindowsServer()
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
IsWindowsVersionOrGreater(MajorVersion, MinorVersion, ServicePackMajor) {
	VersionInfo := SysGetVersion()
	return (VersionInfo.MajorVersion > MajorVersion)?true
	: (VersionInfo.MajorVersion < MajorVersion)?false
	: (VersionInfo.MinorVersion > MinorVersion)?true
	: (VersionInfo.MinorVersion < MinorVersion)?false
	: (VersionInfo.ServicePackMajor >= ServicePackMajor)?true:false
}

IsWindowsXPOrGreater() { ; >= WIN_XP
	return IsWindowsVersionOrGreater(5, 1, 0)
} IsWindowsXPSP1OrGreater() { ; >= WIN_XP SP1
	return IsWindowsVersionOrGreater(5, 1, 1)
} IsWindowsXPSP2OrGreater() { ; >= WIN_XP SP2
	return IsWindowsVersionOrGreater(5, 1, 2)
} IsWindowsXPSP3OrGreater() { ; >= WIN_XP SP3
	return IsWindowsVersionOrGreater(5, 1, 3)
}

IsWindowsVistaOrGreater() { ; >= WIN_V
	return IsWindowsVersionOrGreater(6, 0, 0)
} IsWindowsVistaSP1OrGreater() { ; >= WIN_V SP1
	return IsWindowsVersionOrGreater(6, 0, 1)
} IsWindowsVistaSP2OrGreater() { ; >= WIN_V SP2
	return IsWindowsVersionOrGreater(6, 0, 2)
}

IsWindows7OrGreater() { ; >= WIN_7
	return IsWindowsVersionOrGreater(6, 1, 0)
} IsWindows7SP1OrGreater() { ; >= WIN_7 SP1
	return IsWindowsVersionOrGreater(6, 1, 1)
}

IsWindows8OrGreater() { ; >= WIN_8
	return IsWindowsVersionOrGreater(6, 2, 0)
} IsWindows8Point1OrGreater() { ; >= WIN_8.1
	return IsWindowsVersionOrGreater(6, 3, 0)
}

IsWindows10OrGreater() { ; >= WIN_10
	return IsWindowsVersionOrGreater(10, 0, 0)
}

IsWindowsServer() { ; = WIN_SERVER
	static isWindowsServer
	if (isWindowsServer!="")
		return isWindowsServer
	VersionInfo := SysGetVersion()
	return isWindowsServer:=(((VersionInfo.CSDVersion="")&&(VersionInfo.ProductType!=0x0000001))||(GetSystemMetrics(89)&&!(ErrorLevel)))
}

;devuelve una cadena que identifica al sistema operativo actual.
;Sintaxis 1: WindowsVersion( [Service Pack (salida)] )
;Sintaxis 2: WindowsVersionEx( [¿mostrar Service Pack y Arquitectura?] )
;Sintaxis 3: WinVersion()
;Service Pack: número del último Service Pack instalado en el sistema (0, 1, 2, 3 ...).
;Return: WIN_SERVER2003R2, WIN_HOMESERVER, WIN_SERVER2008, WIN_SERVER2008R2, WIN_SERVER2012, WIN_SERVER2012R2, WIN_SERVER2016
	;WIN_XP, WIN_V, WIN_7, WIN_8, WIN_8.1, WIN_10
;Nota: si hay una nueva version de windows aún no incluida en la funcion, devuelve lo mismo que WinVersion().
;Ejemplo: 
	;MsgBox % "WindowsVersion: " WindowsVersion(SP) " Service Pack " SP
	;	. "`nWindowsVersionEx: " WindowsVersionEx(true)
	;	. "`nWinVersion: " WinVersion()
WindowsVersion(ByRef ServicePackMajor := "") {
	static WindowsVersion, ServicePackMajor2
	if (WindowsVersion!="")
		return WindowsVersion, ServicePackMajor := ServicePackMajor2
	VersionInfo := SysGetVersion()
	return (WindowsVersion:=(((VersionInfo.MajorVersion=5)&&(VersionInfo.MinorVersion=2)&&(VersionInfo.SuiteMask&0x00008000))?"WIN_HOMESERVER"
	: (GetSystemMetrics(89)&&!(ErrorLevel))?"WIN_SERVER2003R2" ;SM_SERVERR2
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=0)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2008"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=1)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2008R2"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=2)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2012"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=3)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2012R2"
	: ((VersionInfo.MajorVersion=10)&&(VersionInfo.MinorVersion=0)&&(VersionInfo.ProductType!=0x0000001))?"WIN_SERVER2016"
	: (VersionInfo.MajorVersion=5)?"WIN_XP"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=0))?"WIN_V"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=1))?"WIN_7"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=2))?"WIN_8"
	: ((VersionInfo.MajorVersion=6)&&(VersionInfo.MinorVersion=3))?"WIN_8.1"
	: ((VersionInfo.MajorVersion=10)&&(VersionInfo.MinorVersion=0))?"WIN_10":WinVersion())), ServicePackMajor := (ServicePackMajor2:=VersionInfo.ServicePackMajor)
} WindowsVersionEx(Ex := false) {
	static WindowsVersionEx, WindowsVersion
	if (Ex=2)
		return ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_OperatingSystem")
	if (WindowsVersionEx)||(WindowsVersion)
		return Ex?WindowsVersion A_Space WindowsVersionEx:WindowsVersion
    for OS in ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_OperatingSystem") {
		WindowsVersion := Trim(OS.Caption), WindowsVersionEx := Trim((OS.CSDVersion?OS.CSDVersion A_Space:"") (A_Is64bitOS?"x64":"x86"))
		return Ex?WindowsVersion A_Space WindowsVersionEx:WindowsVersion
}} WinVersion() { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724833(v=vs.85).aspx
	VersionInfo := SysGetVersion()
	return VersionInfo.MajorVersion "." VersionInfo.MinorVersion "." VersionInfo.BuildNumber
}

;obtiene la arquitectura del sistema operativo
;Return: 32 || 64
;Ejemplo: MsgBox % GetWindowsArchitecture()
GetWindowsArchitecture() {
	Size := A_PtrSize = 8 ? 2 : (IsWow64Process() + 1)
	return 32 * Size
}






































































;#############################################################################################################################################
;  ::::::::::::::::::::::::::::::::::::::::::::: ESTRUCTURAS ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;crear / obtener estructura RECT
;Sintaxis: RECT( [RECT (in_out)], [x (in_out)], [y (in_out)], [ancho (in_out)], [alto (in_out)] )
;RECT:
	;• si se espesifica una estructura RECT válida, devuelve [x, y, ancho, alto]
	;• caso contrario, crea la estructura con las coordinadas y dimenciones espesificadas
;Notas:
	;• cuando se crea la estructura, al ancho se le suma «x», y al alto se le suma «y».
	;• cuando se obtiene la estructura, al ancho se le resta «x», y al alto se le resta «y».
;Ejemplo:
	;RECT(RECT, 0, 5, 10, 40) ;crear RECT. x=0 | y=5 | w=10 | h=40
	;MsgBox % "x" RECT(RECT, x, y, w, h)[1] "`ny: " y "`nw: " w "`nh: " h ;obtener RECT. x=0 | y=5 | w=10 | h=40
	;MsgBox % NumGet(RECT, 12, "Int") ;obtener alto. h=40+5 (h+y) (si se obtiene de esta manera, no se le resta el «y»)
;Return: si se espesifico una estructura válida, devuelve [x, y, w, h], de lo contrario, ""
RECT(ByRef RECT, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "") {
	if (VarSetCapacity(RECT)) ;obtener RECT. 
		return [x:=NumGet(RECT, 0, "Int"), y:=NumGet(RECT, 4, "Int")
			, w:=NumGet(RECT, 8, "Int")-x, h:=NumGet(RECT, 12, "Int")-y]
	VarSetCapacity(RECT, 16, 0) ;crear RECT
	, NumPut(x, RECT, 0, "Int"), NumPut(y, RECT, 4, "Int")
	, NumPut(w+x, RECT, 8, "Int"), NumPut(h+y, RECT, 12, "Int")
} ;https://msdn.microsoft.com/en-us/library/dd162897(v=vs.85).aspx

POINT(ByRef POINT, ByRef x := "", ByRef y := "") {
	if (VarSetCapacity(POINT)) ;obtener POINT
		return [x:=NumGet(POINT, 0, "Int"), y:=NumGet(POINT, 4, "Int")]
	VarSetCapacity(POINT, 8, 0) ;crear POINT
	, NumPut(x, POINT, 0, "Int"), NumPut(y, POINT, 4, "Int")
} ;https://msdn.microsoft.com/en-us/library/dd162805(v=vs.85).aspx





























































































/*#############################################################################################################################################
  ::::::::::::::::::::::::::::::::::::::::::::: VENTANAS ::::::::::::::::::::::::::::::::::
#############################################################################################################################################
NOTAS:
	• las funciones solo aceptan el ID de la ventana, excepto algunas como IsWindow(), IsWinActive(), WinWait(), etc.
	• para el titulo o ahk_xxx usar WinExist( .. ) o IsWindow(, [clase], [proceso/pid], [titulo]).
	• para referirse a la ventana activa, espesificar -1.
	• para referirse a la ventana bajo el cursor, espesificar -2.
	• para referirse a la última ventana espesificada, espesificar -3.
*/
;comprueba si la ventana no responde
WinHugh(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsHungAppWindow", "Ptr", hWnd)
}

;comprueba si la ventana está habilitada, deshabilita, habilita o alterna el estado actual.
;Sintaxis: WinEnabled( [ID] )
WinEnabled(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = true) || (State = false) ;1 = habilitar / deshabilitar
		return DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", State)
	if (State = -1) ;-1 = alternar
		return DllCall("User32.dll\EnableWindow", "Ptr", hWnd, "Int", !WinEnabled(hWnd))
	return DllCall("User32.dll\IsWindowEnabled", "Ptr", hWnd)
}

;comprueba si la ventana es visible, oculta, muestra o alterna el estado actual
WinVisible(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = true) || (State = false) ;1 = mostrar / ocultar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", State?5:0)
	if (State = -1) ;-1 = alternar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", WinVisible(hWnd)?0:5)
	return DllCall("User32.dll\IsWindowVisible", "Ptr", hWnd)
}

;comprueba si la ventana está minimizada, maximiza, minimiza o alterna el estado actual
WinMin(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = true) || (State = false) ;1 = minimizar / maximizar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", State?11:3)
	if (State = -1) ;-1 = alternar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", WinMin(hWnd)?3:11)
	return DllCall("User32.dll\IsIconic", "Ptr", hWnd)
}

;comprueba si la ventana está maximizada, minimiza, maximiza o alterna el estado actual
WinMax(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = true) ||  (State = false) ;1 = maximizar / minimizar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", State?3:11)
	if (State = -1) ;-1 = alternar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", WinMax(hWnd)?11:3)
	return DllCall("User32.dll\IsZoomed", "Ptr", hWnd)
}

;determina si la ventana no está maximizada ni minimizada, minimiza, restaura o alterna el estado de la ventana.
WinNormal(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = true) || (State = false) ;1 = restaurar / minimizar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", State?9:11)
	if (State = -1) ;-1 = alternar
		return DllCall("User32.dll\ShowWindow", "Ptr", hWnd, "Int", WinNormal(hWnd)?11:9)
	return !DllCall("User32.dll\IsZoomed", "Ptr", hWnd) && !DllCall("User32.dll\IsIconic", "Ptr", hWnd)
}

;comprueba si la ventana está activa, envía la ventana antras de todas, activa o alterna el estado.
WindowActive(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = true) { ;1 = activar
		if WinMin(hWnd) ;si está minimizada
			WinNormal(hWnd, true) ;restaurar
		DllCall("User32.dll\AttachThreadInput", "UInt", hThread:=ProcessExist(-2), "UInt", ThreadId:=GetWindowThreadProcessId(hWnd), "Int", true)
		return DllCall("User32.dll\SetForegroundWindow", "Ptr", hWnd), DllCall("User32.dll\BringWindowToTop", "Ptr", hWnd)
		, DllCall("User32.dll\SetFocus", "Ptr", hWnd), DllCall("User32.dll\AttachThreadInput", "UInt", hThread, "UInt", ThreadId, "Int", false)
	} if (State = false) ;0 = enviar atras de todas
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (State = -1) ;-1 = alternar
		return WindowActive(hWnd, !WindowActive(hWnd))
	return hWnd = DllCall("User32.dll\GetForegroundWindow", "Ptr")
}

;comprueba si la ventana tiene el estilo extendido AlwaysOnTop, lo quita, lo establece o lo alterna.
WinAlwaysOnTop(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = -1) ; alternar
		return WinAlwaysOnTop(hWnd, !WinAlwaysOnTop(hWnd))
	if (State = false) ;quitar
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", -2, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	if (State = true) ;establecer
		return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", -1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
	return WinGetExStyle(hWnd)&0x00000008
}

;comprueba si la ventana permite redimencionarla desde los bordes, lo quita, lo establece o lo alterna.
WinResized(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = -1) ;alternar
		return WinResized(hWnd, !WinResized(hWnd))
	if (State = false) ;bloquear
		WinSetStyle(hWnd, -0x00040000, true)
	if (State = true) ;permitir
		WinSetStyle(hWnd, "+0x00040000", true)
	return WinGetStyle(hWnd)&0x00040000
}

;comprueba si la ventana acepta el arrastre de archivos, lo quita, lo establece o lo alterna.
WinDragDrop(hWnd, State := "") {
	_gethwnd(hWnd)
	if (State = -1) ;alternar
		return WinDragDrop(hWnd, !WinDragDrop(hWnd))
	if (State = false) ;bloquear
		WinSetExStyle(hWnd, -0x00000010, true)
	if (State = true) ;permitir
		WinSetExStyle(hWnd, "+0x00000010", true)
	return WinGetExStyle(hWnd)&0x00000010
}

;comprueba si la ventana existe / obtiene la ventana activa.
;Sintaxis: IsWindow( [ID], [clase], [proceso/pid], [título] )
;NOTA: dejar vacio para obtener el ID de la ventana activa
;EJEMPLO: MsgBox % IsWindow(,, "notepad.exe" )
IsWindow(hWnd*) { 
	if !hWnd.MaxIndex()
		return __gsvalue.LastWindowId := DllCall("User32.dll\GetForegroundWindow", "Ptr")
	if !hWnd[1]&&(hWnd[2]||hWnd[3]||hWnd[4]) {
		Loop, Parse, % WinEnum(), `n
		{ if hWnd[2]&&(GetWindowClass(A_LoopField)!=hWnd[2])
				continue
			if (hWnd[4]!="")&&(WinGetTitle(A_LoopField)!=hWnd[4])
				continue
			if hWnd.5 {
				p := WinGetPid(A_LoopField)
				for k, v in ProcessEnum()
					if (v.ProcessId=p) && (v.ParentProcessId=hWnd.3)
						return __gsvalue.LastWindowId := A_LoopField
			} else {
				if hWnd[3]&&(_getpid(A_LoopField,hWnd[3])!=hWnd[3])
					continue
			} return __gsvalue.LastWindowId := A_LoopField
	}} if !hWnd[1]||!DllCall("User32.dll\IsWindow", "Ptr", hWnd[1], "Int")
	||(hWnd[2]&&(GetWindowClass(hWnd[1])!=hWnd[2]))
	||(hWnd[4]&&(WinGetTitle(hWnd[1])!=hWnd[4]))
	||(hWnd[3]&&(_getpid(hWnd[1],hWnd[3])!=hWnd[3]))
		return false
	return __gsvalue.LastWindowId := hWnd[1]
}

;comprueba si es una ventana hija
;Sintaxis: WinChild( [ID ventana padre], [ID ventana hija] )
WinChild(hWnd, ChWnd*) {
	if !ChWnd.MaxIndex()
		return WinGetStyle(hWnd)&0x40000000?hWnd:WinGetTopChild(hWnd)
	_gethwnd(hWnd)
	return DllCall("User32.dll\IsChild", "Ptr", hWnd, "Ptr", ChWnd[1])
}

;comprueba si la ventana está activa
;Sintaxis: IsWinActive( [ID], [clase], [proceso/pid], [titulo] )
IsWinActive(hWnd := "", Class := "", ProcessName := "", Title := "") {
	ActiveWindowId := IsWindow()
	if (!Class&&!ProcessName&&!ActiveWindowId&&!Title)
	||(!hWnd&&!Class&&!ProcessName&&!Title)
	||(hWnd&&(ActiveWindowId!=hWnd))
	||(Class&&(GetWindowClass(hWnd?hWnd:ActiveWindowId)!=Class))
	||(Title&&(WinGetTitle(hWnd?hWnd:ActiveWindowId)!=Title))
	||(ProcessName&&(_getpid(hWnd,ProcessName,ActiveWindowId) != ProcessName))
		return false, ErrorLevel := true
	return true, ErrorLevel := false
}

;convierte en coordenadas de pantalla o relativo a la ventana, suma/quita bordes.
;Sintaxis: WinClient( [ID], [x], [y], [ancho], [alto], [ScreenToClient|ClientToScreen|+/-Borders] )
;Return: [x, y, ancho, alto]
WinClient(hWnd, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "", Mode := "ClientToScreen") {
	if (Mode="+Borders") || (Mode="-Borders") {
        GetWindowPos(hWnd, _x, _y, _w, _h)
        , w := Mode="+Borders"?(w=_w?w:w<_w?w+(_w-w):w):(w=_w?w:w>_w?w-(w-_w):w)
        , h := Mode="+Borders"?(h=_h?h:h<_h?h+(_h-h):h>_h?(_h+(h-_h)):h):(h=_h?h:h>_h?h-(h-_h):h)
		return [x := x=""?_x:x, y := y=""?_y:y, w, h]
	} _gethwnd(hWnd), RECT(RECT, x, y, w, h), Error := !DllCall("User32.dll\" Mode, "Ptr", hWnd, "Ptr", &RECT)
	return RECT(RECT, x, y, w, h), ErrorLevel := Error
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;obtiene una lista con todas las ventanas de nivel superior en la pantalla o controles en la ventana
;W8+: sólo ventanas de nivel superior de las aplicaciones de escritorio
;Sintaxis: WinEnum( [hWnd], [¿incluir ventanas ocultas?], [delimitador], [cantidad (salida)] )
;hWnd: espesificar el hWnd de una ventana para obtener una lista con todos sus controles
WinEnum(hWnd := 0, dhw := true, Delimiter := "`n", ByRef Count := "") {
	EnumAddress := RegisterCallback("EnumWindowsProc", "Fast", 2)
	, _gethwnd(hWnd), Param := {List: "", dhw: dhw, Delimiter: Delimiter, Count: 0}
	, DllCall("User32.dll\EnumChildWindows", "Ptr", hWnd, "Ptr", EnumAddress, "Ptr", &Param)
	return Param.List, Count := Param.Count, GlobalFree(EnumAddress)
} EnumWindowsProc(hWnd, lParam) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633494(v=vs.85).aspx
	Param := Object(lParam)
	if (Param.dhw) || (WinVisible(hWnd))
		Param.List .= (Param.Count?Param.Delimiter:"") hWnd, Param.Count++
    return true
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633493(v=vs.85).aspx

;minimiza todas las ventanas
;Sintaxis: WinMinimizeAll( [¿forzar?] )
;NOTA: si se usa forzar, usar WinMinimizeAllUndo(1) para restaurarlas
	;para dar foco al escritorio usar ShowDesktop()
WinMinimizeAll(Force := false) {
	static Array, ActiveWindow
	if (Force="?"||Force="*")
		return Force="?"?Array:ActiveWindow
	ActiveWindow := IsWindow()
	if Force {
		Array := [], ok := Count := 0
		Loop, Parse, % WinEnum(, false), `n
		{	if !WinMin(A_LoopField) {
				Count++
				if WinMin(A_LoopField, true)
					ok++, Array[ok] := A_LoopField
		}} return ok, ErrorLevel := !(ok=Count)
	} if !(hWindow := FindWindow("Shell_TrayWnd"))
		return ComObjCreate("shell.application").MinimizeAll()
	return PostMessage(hWindow, 0x0111, "UInt", 419)
}

;restaura todas las ventanas
;Sintaxis: WinMinimizeAllUndo( [¿forzar?] )
;NOTA: si se usa forzar, restaura solo las ventanas minimizadas por WinMinimizeAll(1)
WinMinimizeAllUndo(Force := false) {
	if Force {
		ok := Count := 0
		for Index, hWnd in WinMinimizeAll("?") {
			if WinMin(hWnd)&&WinVisible(hWnd)
				ok += !!WinNormal(hWnd, true), Count++
		} return ok, WindowActive(WinMinimizeAll("*"), true), ErrorLevel := !(ok=Count)
	} if !(hWindow := FindWindow("Shell_TrayWnd"))
		return ComObjCreate("shell.application").UndoMinimizeALL()
	return PostMessage(hWindow, 0x0111, "UInt", 416)
}

;recupera un identificador de la ventana de nivel superior cuyo nombre de clase y nombre de la ventana  conincida con lo espesificado
;Sintaxis: FindWindow( [clase], [título] )
;Notas: 
	;• para buscar ventanas secundarias usar FindWindowEx()
	;• no distingue entre mayúsculas y minúsculas
FindWindow(ClassName := "", WindowName*) {
	WinName := WindowName[1], Error := ErrorLevel
	return DllCall("User32.dll\FindWindowW", "Ptr", ClassName=""?0:&ClassName
		, "Ptr", WindowName.MaxIndex()?&WinName:0, "Ptr"), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx

;recupera un identificador a una ventana hija cuyo nombre de clase y nombre de la ventana coincida con lo espesificado
;Sintaxis: FindWindowEx( [ventana superior], [ventana hija de la cual empesar el orden], [clase], [título] )
;Nota: no distingue entre mayúsculas y minúsculas
FindWindowEx(Parent := 0, ChildAfter := 0, ClassName := "", WindowName*) {
	WinName := WindowName[1], Error := ErrorLevel
	return DllCall("User32.dll\FindWindowExW", "Ptr", Parent, "Ptr", ChildAfter, "Ptr", ClassName=""?0:&ClassName
	, "Ptr", WindowName.MaxIndex()?&WinName:0, "Ptr"), ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633500(v=vs.85).aspx

;crear ventana
;Sinstaxis: CreateWindow( [x], [y], [ancho], [alto], [titulo], [estilo], [estilo extendido], [parent], [menu], [clase] )
;Return: devuelve el hWnd
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx
;Estilos exentido: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543(v=vs.85).aspx
CreateWindow(x, y, Width, Height, Caption := "", Style := 0x10CB0000, ExStyle := 0x0, Parent := 0x0, Menu := 0x0, Class := "MDIClient") {
	hWnd := DllCall("User32.dll\CreateWindowExW", "UInt", ExStyle, "Ptr", &Class, "Ptr", &Caption, "UInt", Style
		, "Int", x, "Int", y, "Int", Width, "Int", Height, "Ptr", Parent, "Ptr", Menu, "Ptr", A_ScriptHwnd, "PtrP", 0)
	return hWnd, ErrorLevel := !hWnd
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;centrar ventana, opcional posicionarla arriba/abajo/izquierda/derecha.
;Sintaxis: WinCenter( [ID], [Posición] )
;Posición: se pueden combinar.
	;Center = centrar ventana.
	;Top | Bottom = posicionar arriba. posicionar abajo.
	;Left | Right = posicionar a la izquierda. posicionar a la derecha.
;Notas:
	;• si la ventana está maximizada, se modifica el ancho o el alto dependiendo la posicion.
		;--> si se posiciona arriba o abajo, se modifica el alto (A_ScreenHeight/2-10%).
		;--> si se posiciona a la izquierda o a la derecha, se modifica el ancho (A_ScreenWidth/2-10%).
	;• la ventana se ajusta a la pantalla visible, sin importar la posicion de la barra de tareas (la ventana no es tapada por la barra de tareas)
;Ejemplo: abra Notepad para el ejemplo.
 	;MsgBox % "Centrar ventana: " ((!!WindowActive(WinExist("ahk_class Notepad"), true)+MoveWindow(-3,,, 543, 403)+!!WinCenter(-3))-2)
	;MsgBox % "Posicionar arriba a la izquierda: " WinCenter(-3, "Top Left")
	;MsgBox % "Posicionar arriba a la derecha: " WinCenter(-3, "Top Right")
	;MsgBox % "Posicionar abajo a la izquierda: " WinCenter(-3, "Bottom Left")
	;MsgBox % "Posicionar abajo a la derecha: " WinCenter(-3, "Bottom Right")
	;MsgBox % "Posicionar arriba y centrarla: " WinCenter(-3, "Top Center")
	;MsgBox % "Posicionar abajo y centrarla: " WinCenter(-3, "Bottom Center")
	;MsgBox % "Posicionar a la izquierda y centrarla: " WinCenter(-3, "Left Center")
	;MsgBox % "Posicionar a la derecha y centrarla: " WinCenter(-3, "Right Center")
WinCenter(hWnd, Pos := "") {
	_gethwnd(hWnd), GetWindowPos(hWnd, x, y, w, h), A_MonitorWorkArea(mx, my, mw, mh)
	, T := InStr(Pos, "Top"), B := InStr(Pos, "Bottom"), L := InStr(Pos, "Left"), R := InStr(Pos, "Right"), C := InStr(Pos, "Center")
	if (WinMax(hWnd)) 
		w := (L||R)?Percent(mw/2, 10):mw, h := (T||B)?Percent(mh/2, 10):mh
	if (T) || (B) || (L) || (R)
		return MoveWindow(hWnd, (L?0:R?(mw-w):C?((mw/2)-(w/2)):x) +mx, (T?0:B?(mh-h):C?((mh/2)-(h/2)):y) +my, w, h)
	return MoveWindow(hWnd, ((mw/2) - (w/2)) +mx, ((mh/2) - (h/2)) +my, w, h)
}

;parpadea la ventana especificada. no cambia el estado activo de la ventana.
;Sintaxis: WinFlash( [hWnd], [Flags], [Count], [Timeout] )
;Parámetros:
	;Flags: espesificar uno o mas de los siguientes valores.	
		;0x00000000 = parar (defecto).
		;------------------------------------------------------------------------------
		;0x00000001 = afecta al titulo de la ventana
		;0x00000002 = afecta al boton de la barra de tareas
		;0x00000004 = continuar indefinidamente hasta que se llame a la función con 0x00000000.
		;0x0000000C = continuar hasta que la ventana esté activa
	;Count: el número de veces
	;Timeout: tiempo fuera, en segundos.
WinFlash(hWnd, Flags := 0x00000000, Count := 0, Timeout := 0) {
	_gethwnd(hWnd)
	, Size := VarSetCapacity(FLASHWINFO, 16+A_PtrSize, 0) 
	, NumPut(Size, FLASHWINFO, 0, "UInt")
	, NumPut(hWnd, FLASHWINFO, 4, "Ptr")
	, NumPut(Flags, FLASHWINFO, 4+A_PtrSize, "UInt")
	, NumPut(Count, FLASHWINFO, 4+A_PtrSize +4, "UInt")
	, NumPut(Timeout, FLASHWINFO, 4+A_PtrSize +8, "UInt")
	return DllCall("User32.dll\FlashWindowEx", "Ptr", &FLASHWINFO)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679347(v=vs.85).aspx

;redibujar la ventana
;Sintaxis: WinRedraw( [ID], [x], [y], [ancho], [alto], [¿forzar redibujado?] )
;x / y / Ancho / Alto: espesificar las coordenadas de parte de la ventana a redibujar o dejar en 0 para toda la ventana
WinRedraw(hWnd, x := "", y := "", w := "", h := "", Force := true) {
	_gethwnd(hWnd)
	if !(x="") && !(y="") && !(w="") && !(h="")
		RECT(RECT, x, y, w, h), l := true
	Ok := !!DllCall("User32.dll\InvalidateRect", "Ptr", hWnd, "Ptr", l?&RECT:0, "Int", true)
	if (Force)
		Ok += !!DllCall("User32.dll\UpdateWindow", "Ptr", hWnd)
	return Force?(Ok=2):Ok, ErrorLevel := Force?(Ok!=2):!Ok
}

;Permite producir efectos especiales al mostrar u ocultar ventanas
;Sintaxis: WinAnimate( [ID], [duracion de la animación , en milisegundos], [tipo de animación], [transparencia], [region] )
;TIPOS DE ANIMACIÓN (se pueden combinar):
	;S = Mostrar | H = Ocultar | C = Centrar | R = redibujar al terminar la animacion | T = quitar transparencia antes de producir el efecto (recomendado, si la tiene)
	;1 = Desvanecer | 2 = Diapositiva (combinar con 3/4 y/o 5/6)
	;3 = Izquierda A Derecha | 4 = Derecha A Izquierda
	;5 = Arriba Abajo | 6 = Abajo Arriba
;Nota: usar la opción R al mostrar la ventana.
WinAnimate(hWnd, Time := 200, Mode := "RS1", Transparent := "", Region := "") { 
	_gethwnd(hWnd)
	if InStr(Mode, "T")
		WinSet, Transparent, Off, ahk_id %hWnd%
	for k, v in {S: 0x00020000, 1: 0x00080000, C: 0x00000010, H: 0x00010000, 3: 0x00000001, 4: 0x00000002, 2: 0x00040000, 5: 0x00000004, 6: 0x00000008}
		if InStr(Mode, k)
			l += v
	Ok := DllCall("User32.dll\AnimateWindow", "Ptr", hWnd, "UInt", Time, "UInt", l)
	if InStr(Mode, "R")
		WinRedraw(hWnd)
	if (Transparent != "")
		WinSetTransparent(hWnd, Transparent)
	if (Region != "")
		WinSet, Region, % Region, ahk_id %hWnd%
	return Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632669%28v=vs.85%29.aspx

;mover ventana
;Sintaxis: MoveWindow( [ID], [x], [y], [ancho], [alto], [¿redibujar?] )
MoveWindow(hWnd, x := "", y := "", Width := "", Height := "", Redraw := true) {
	_gethwnd(hWnd)
	if (x="") || (y="") || (Width="") || (Height="")
		GetWindowPos(hWnd, x_, y_, w_, h_)
	x := (x="")?x_:x, y := (y="")?y_:y, Width := (Width="")?w_:Width, Height := (Height="")?h_:Height
	return DllCall("User32.dll\MoveWindow", "Ptr", hWnd, "Int", x, "Int", y, "Int", Width, "Int", Height, "Int", !!Redraw)
}

;cerrar ventana
;Sintaxis: WinClose( [ID], [Segundos a esperar], [¿Forzar?] )
;NOTA: espesificar 0 segundos para esperar indefinidamente
WinClose(hWnd, Seconds := -1, Force := false) {
	_gethwnd(hWnd)
	if (Force)
		r := WinKill(hWnd)
	else r := PostMessage(hWnd, 0x0002)
	if (Seconds>-1)
		WinWaitClose(hWnd, Seconds)
	return !!r, ErrorLevel := !r
}

;forzar cierre de la ventana
;Sintais: WinKill( [hWnd], [¿forzar cierre del proceso?] )
WinKill(hWnd, Force := true) {
	_gethwnd(hWnd)
	if (Force)
		return TerminateProcess("/" WinGetPID(hWnd))
	WinGetPID(hWnd, ThreadId), hThread := OpenThread(ThreadId, 0x0001)
	, r := DllCall("Kernel32.dll\TerminateThread", "Ptr", hThread, "UInt", 0, "UInt")
	if !(r)
		r := DllCall("User32.dll\EndTask", "Ptr", hWnd, "Int", false, "Int", true)
	return !!r, CloseHandle(hThread), ErrorLevel := !r
}

;destruir ventanas creadas por el script
;Sintaxis: WinDestroy( [hWnd], [¿solo eliminar los controles?], [¿detectar controles ocultos?] )
;Return: si elimina los controles, devuelve la cantidad de controles eliminados
WinDestroy(hWnd, DeleteCtrls := false, DetectHiddenWindows := true) {
	_gethwnd(hWnd), Ok := 0, Count := 0
	if (DeleteCtrls) { ;eliminar todos los controles de la ventana -->
		Loop, Parse, % WinEnum(hWnd, DetectHiddenWindows), `n
		{	Ok += !!DllCall("User32.dll\DestroyWindow", "Ptr", A_LoopField)
			Count++
		} return Ok, ErrorLevel := Ok!=Count ;<--
	} return DllCall("User32.dll\DestroyWindow", "Ptr", hWnd)
}

;cierra todas las ventanas que coincidan con los datos espesificados
;Sintaxis: WinCloseEx( [ID], [Clase], [Proceso/PID], [¿forzar?], [¿afectar a las ventanas ocultas?], [titulo] )
WinCloseEx(hWnd := "", Class := "", ProcessName := "", Force := false, DetectHiddenWindows := true, Title*) {
	Win := Total := 0
	Loop, Parse, % WinEnum(, DetectHiddenWindows), `n
	{ if hWnd&&(hWnd!=A_LoopField)
			continue
		if Class&&!(GetWindowClass(A_LoopField)==Class)
			continue
		if ProcessName&&(_getpid(A_LoopField,ProcessName)!=ProcessName)
			continue
		if Title.MaxIndex()&&(WinGetTitle(A_LoopField)!=Title[1])
			continue
		Win += WinClose(A_LoopField,, Force), Total++
	} return Win=Total, ErrorLevel := !(Win=Total)
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;obtener threadid y pid del proceso de la ventana
;GetWindowThreadProcessId( [hWnd], [out ProcessId] )
;Return: ThreadId
GetWindowThreadProcessId(hWnd, ByRef ProcessId := "") {
	_gethwnd(hWnd)
	if IsByRef(ProcessId)
		return DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "UIntP", ProcessId, "UInt")
	return DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "Ptr", 0, "UInt")
} WinGetPID(hWnd, ByRef ThreadId := "", ByRef ProcessName := "", ByRef ProcessPath := "") {
	_gethwnd(hWnd), ThreadId := DllCall("User32.dll\GetWindowThreadProcessId", "Ptr", hWnd, "UIntP", ProcessId, "UInt")
	if (IsByRef(ProcessName))
		ProcessName := ProcessName(ProcessId)
	if (IsByRef(ProcessPath))
		ProcessPath := ProcessPath(ProcessId)
	return ProcessId, ErrorLevel := !ThreadId
}

;recupera información sobre la ventana
;Sintaxis: GetWindowThreadInfo( [hWnd] )
;Return: ver https://msdn.microsoft.com/en-us/library/windows/desktop/ms632604(v=vs.85).aspx
;Ejemplo: MsgBox % GetWindowClass(GetWindowThreadInfo(-1).hwndFocus)
GetWindowThreadInfo(hWnd) {
	_gethwnd(hWnd), WinGetPID(hWnd, ThreadId), Info := {}
	, Size := VarSetCapacity(GUITHREADINFO, 4+4 + (6*A_PtrSize) + 16, 0), NumPut(Size, GUITHREADINFO, 0, "UInt")
	, Ok := DllCall("User32.dll\GetGUIThreadInfo", "UInt", ThreadId, "Ptr", &GUITHREADINFO)
	, Info.Flags := NumGet(GUITHREADINFO, 4, "UInt"), Info.hwndActive := NumGet(GUITHREADINFO, 8, "Ptr")
	, Info.hwndFocus := NumGet(GUITHREADINFO, 8 + A_PtrSize, "UInt"), Info.hwndCapture := NumGet(GUITHREADINFO, 8+A_PtrSize +A_PtrSize, "Ptr")
	, Info.hwndMenuOwner := NumGet(GUITHREADINFO, 8+A_PtrSize +(2*A_PtrSize), "UInt"), Info.hwndMoveSize := NumGet(GUITHREADINFO, 8+A_PtrSize +(3*A_PtrSize), "Ptr")
	, Info.hwndCaret := NumGet(GUITHREADINFO, 8+A_PtrSize +(4*A_PtrSize), "UInt"), Info.rcCaret := RECT(NumGet(GUITHREADINFO, 8+A_PtrSize +(4*A_PtrSize) +4, "Ptr"))
	return Ok?Info:false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633506(v=vs.85).aspx

;obtener coordenadas y dimenciones de la ventana
;Sintaxis: GetWindowPos( [hWNd], [x (out)], [y (out)], [ancho (out)], [alto (out)], [modo] )
;Modos:
	;0 (defecto) = incluir bordes
	;1 = excluir bordes
	;+2 = convertir en coordenadas de pantalla
;Return: [x, y, ancho, alto]
;ErrorLevel: 0|1
GetWindowPos(hWnd, ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "", Mode := 0) {
	_gethwnd(hWnd), VarSetCapacity(RECT, 16, 0)
	;if (Mode=0) || (Mode=2) ;incluir bordes. 0 | 0+2
		Ok := DllCall("User32.dll\GetWindowRect", "Ptr", hWnd, "Ptr", &RECT), RECT(RECT, x, y, w, h)
	if (Mode=1) || (Mode=3) ;excluir bordes. 1 | 1+2
		Ok := DllCall("User32.dll\GetClientRect", "Ptr", hWnd, "Ptr", &RECT), RECT(RECT,,, w, h)
	if (Mode=2) || (Mode=3) ;convertir en coordenadas de pantalla. 0+2 || 1+2
		DllCall("User32.dll\ClientToScreen", "Ptr", hWnd, "Ptr", &RECT)
	return [x, y, w, h], ErrorLevel := !Ok
}

;obtiene el ancho y alto de los bordes de la ventana
;Sintaxis: GetWindowBorder( [ID], [ancho], [alto], [modo] )
;Modos: 0 = normal | 1 = convierte en coordenadas de pantalla
;Return: [ancho, alto]
GetWindowBorder(hWnd, ByRef w := "", ByRef h := "", Mode := 0) {
	GetWindowPos(hWnd,,, w, h, Mode?2:0), GetWindowPos(hWnd,,, w2, h2, Mode?3:1)
	return [w:=w-w2, h:=h-h2]
}

;obtiene el estilo de la ventana
;Ejemplo: MsgBox % Hex(WinGetStyle(-1), 8, 1)
WinGetStyle(hWnd) { ;0x40000 = resize
	static Func := A_PtrSize = 4 ? "GetWindowLongW" : "GetWindowLongPtrW"
	_gethwnd(hWnd), Style := DllCall("User32.dll\" Func, "Ptr", hWnd, "Int", -16, "UInt")
	return Style, ErrorLevel := !Style
}

;obtiene el estilo extendido de la ventana
;Ejemplo: MsgBox % Hex(WinGetExStyle(-1), 8, 1)
WinGetExStyle(hWnd) {
	static Func := A_PtrSize = 4 ? "GetWindowLongW" : "GetWindowLongPtrW"
	_gethwnd(hWnd), ExStyle := DllCall("User32.dll\" Func, "Ptr", hWnd, "Int", -20, "UInt")
	return ExStyle, ErrorLevel := !ExStyle
}

;obtiene el titulo de la ventana especificada.
;Sintaxis: WinGetTitle( [hWnd] )
WinGetTitle(hWnd) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633520%28v=vs.85%29.aspx
	_gethwnd(hWnd)
	, Size := DllCall("User32.dll\GetWindowTextLengthW", "Ptr", hWnd, "Int") + 1
	, VarSetCapacity(OutputVar, Size * 2, 0)
	, Ok := DllCall("User32.dll\GetWindowTextW", "Ptr", hWnd, "Str", OutputVar, "Int", Size * 2, "Int")
	return OutputVar, ErrorLevel := !Ok
}

;obtiene el nombre de la clase a la que pertenece la ventana especificada.
GetWindowClass(hWnd) {
	_gethwnd(hWnd) ;257 = MAX_WNDCLASS_LENGTH
	, VarSetCapacity(OutputVar, (256 + 1) * 2)
	, Ok := DllCall("User32.dll\GetClassNameW", "Ptr", hWnd, "Str", OutputVar, "Int", 256 + 1)
	return OutputVar, ErrorLevel := !Ok
}

;obtener el texto de la ventana
;Sintaxis: WinGetText( [ID] )
WinGetText(hWnd) {
	_gethwnd(hWnd)
	WinGetText, OutputVar, ahk_id %hWnd%
	return OutputVar
}

WinGetTopChild(hWnd) {
	_gethwnd(hWnd), _ := hWnd
	Loop {
		if !(_:=DllCall("User32.dll\GetTopWindow", "Ptr", _, "Ptr"))
			return __?__:hWnd
		__ := _
}	}

WinGetParent(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\GetTopWindow", "Ptr", hWnd, "Ptr")
}

;obtiene el icono de la ventana
;Sintaxis: WinGetIcon( [ID], [tipo] )
;Tipos: 0 = icono pequeño | 1 = icono grande
	;2 = Recupera el icono pequeño que proporciona la aplicación.
		;si la aplicación no proporciona uno, el sistema utiliza el icono generado por el sistema para esa ventana.
WinGetIcon(hWnd, Type := 0) {
	_gethwnd(hWnd)
	return SendMsg(hWnd, 0x007F, Type)
}

;obtener hWnd del menu de la ventana espesificada
;Sintaxis: WinGetMenu( [hWnd] )
WinGetMenu(hWnd) {
	return DllCall("User32.dll\GetMenu", "Ptr", hWnd, "Ptr")
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;ajustar transparencia de la ventana
;Sintaxis: WinSetTransparent( [hWnd], [Alpha], [TransColor] )
;Parámetros:
	;Alpha: espesificar un valor entre 0 y 255. establecer en OFF para desactivar la transparencia
	;TransColor: espesificar un color RGB espesífico.
WinSetTransparent(hWnd, Alpha := "Off", TransColor := "") {
	_gethwnd(hWnd)
	if (Alpha="Off")
		return WinSetExStyle(hWnd, -0x00080000)
	if ((Alpha+0)="")
		return false
	Alpha := Abs(Alpha)>255?255:Abs(Alpha), WinSetExStyle(hWnd, "+" 0x00080000)
	if !(TransColor="")
		VarSetCapacity(COLORREF, 4, 0), NumPut(_getcolor(TransColor), 0, "UInt")
	return DllCall("User32.dll\SetLayeredWindowAttributes", "Ptr", hWnd, "Ptr", TransColor=""?0:&COLORREF, "Int", Alpha, "UInt", TransColor=""?2:3)
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms633540(v=vs.85).aspx

;obtener color y transparencia de la ventana
;Sintaxis: WinSetTransparent( [hWnd], [out Alpha], [out TransColor] )
;Parámetros:
	;Alpha: nivel de transparencia, valor entre 0 y 255. vacío si no se estableció.
	;TransColor: color RGB. vacío si no se stableció.
WinGetTransparent(hWnd, ByRef Alpha := "", ByRef TransColor := "") {
	VarSetCapacity(TransColor, 4, 0)
	return DllCall("User32.dll\GetLayeredWindowAttributes", "Ptr", hWnd, "Ptr", &TransColor, "IntP", Alpha, "UIntP", Flags)
		, TransColor := Flags&1?RGB(NumGet(TransColor, 0, "UInt")):"", Alpha := Flags&2?Alpha:""
}

;establecer el titulo de la ventana espesificada
;Sintaxis: WinSetTitle( [ID], [Titulo], [Modo] )
;Modos: 1 = ocultar el titulo | 2 = ocultar el icono
	;Nota: espesificar el númeo pero negativo para restaurar
WinSetTitle(hWnd, NewTitle := "") {
	_gethwnd(hWnd)
	return DllCall("User32.dll\SetWindowTextW", "Ptr", hWnd, "Ptr", &NewTitle)
}

;cambia el icono de la ventana
;Sintaxis: WinSetIcon( [ID], [Icono], [Índice] )
;Nota: usar DestroyIcon(hPicture) cuando ya no lo necesite.
;ErrorLevel: 
	;0 = OK
	;1 = ERROR
	;2 = no se ha podido obtener un HANDLE a la imagen
;Return: hPicture
WinSetIcon(hWnd, Icon, Index := 1) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms632643%28v=vs.85%29.aspx
	hImage := LoadImage(Icon, Index)
	if !(hImage)
		return false, ErrorLevel := 2
	_gethwnd(hWnd)
	, SendMessage(hWnd, 0x0080, "UInt", 0,, hImage) ;WM_SETICON = 0x0080 | ICON_SMALL := 0
	, SendMessage(hWnd, 0x0080, "UInt", 1,, hImage) ;WM_SETICON = 0x0080 | ICON_BIG := 1
	if (ErrorLevel)
		return false, ErrorLevel := true, DestroyIcon(hImage)
	return hImage, ErrorLevel := false
}

;permitir/bloquear el redibujado de la ventana
;Sintaxis: WinSetRedraw( [hWnd], [0|1] )
WinSetRedraw(hWnd, Redraw := true) {
	_gethWnd(hWnd), Ok := SendMsg(hWnd, 0x000B, !!Redraw)
	if (Ok)
		DllCall("User32.dll\RedrawWindow", "Ptr", hWnd, "Ptr", 0, "Ptr", 0, "UInt", 0x0004|0x0400|0x0001|0x0080)
	return Ok
} ;https://msdn.microsoft.com/en-us/library/dd145219(v=vs.85).aspx

;establecer estilo
;Sintaxis: WinSetStyle( [ID], [+-^Estilo], [SWP_FRAMECHANGED] )
;Estilo: +(añadir) -(quitar) ^(alternar) || por defecto reemplaza el estilo
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600%28v=vs.85%29.aspx
;Nota: algunos cambios necesitan SWP_FRAMECHANGED para que surtan efecto.
WinSetStyle(hWnd, Style, FRAMECHANGED := false) {
	_gethwnd(hWnd), Style := _cvtvalue(WinGetStyle(hWnd), Style)
	, Ok := DllCall("SetWindowLong" (A_PtrSize=4?"":"Ptr") "W", "Ptr", hWnd, "Int", -16, "Int", Style)
	if (FRAMECHANGED) ;http://ahkscript.org/boards/viewtopic.php?f=5&t=9591
		DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x27)
	return Ok, ErrorLevel := !Ok
}

;establecer estilo extendido
;Sintaxis: WinSetExStyle( [ID], [+-^Estilo], [SWP_FRAMECHANGED] )
;Estilo: +(añadir, defecto) -(quitar) ^(alternar)
;Estilos: https://msdn.microsoft.com/en-us/library/windows/desktop/ff700543%28v=vs.85%29.aspx
;Nota: algunos cambios necesitan SWP_FRAMECHANGED para que surtan efecto.
WinSetExStyle(hWnd, ExStyle, FRAMECHANGED := false) {
	_gethwnd(hWnd), ExStyle := _cvtvalue(WinGetExStyle(hWnd), ExStyle)
	, Ok := DllCall("SetWindowLong" (A_PtrSize=4?"":"Ptr") "W", "Ptr", hWnd, "Int", -20, "Int", ExStyle)
	if (FRAMECHANGED) ;http://ahkscript.org/boards/viewtopic.php?f=5&t=9591
		DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x27)
	return Ok, ErrorLevel := !Ok
}

WinSetBottom(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
}

WinSetTop(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\SetWindowPos", "Ptr", hWnd, "Ptr", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x0002|0x0001|0x0010)
}

WinSetParent(hWnd, ParentId) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\SetParent", "Ptr", hWnd, "Ptr", ParentId)
}

;hace una variedad de cambios en el menú de la ventana
;Sintaxis: WinSetMenu( [hWnd], [opciones], [¿restaurar?] )
;Opciones (separar con | para combinar): https://msdn.microsoft.com/en-us/library/windows/desktop/ms646360(v=vs.85).aspx
	;0xF020 = deshabilitar boton minimizar | SC_MINIMIZE
	;0xF030 = deshabilitar boton maximizar | SC_MAXIMIZE
	;0xF060 = deshabilitar boton cerrar | SC_CLOSE
	;0xF010 = deshabilitar mover ventana | SC_MOVE
	;0xF120 = deshabilitar restaurar ventana | SC_RESTORE
	;0xF000 = deshabilitar redimencionar ventana | SC_SIZE
WinSetMenu(hWnd, Options := 0, Restore := false) {
	_gethwnd(hWnd)
	if !(r:=l:=0) && !(hMenu:=DllCall("User32.dll\GetSystemMenu", "Ptr", hWnd, "Int", !!Restore, "Ptr"))
		return !!Restore, ErrorLevel := !Restore ;GetSystemMenu devuelve "" si se usa Restore=1
	Loop, Parse, % Options, |, % A_Space A_Tab
		r += !!DllCall("User32.dll\RemoveMenu", "Ptr", hMenu, "UInt", A_LoopField, "UInt", 0, "Int"), l++
	return r=l, DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd, "Int"), ErrorLevel := r!=l
}

;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

;espera a que la ventana no exista
;Sintaxis: WinWaitClose( [ID], [segundos], [clase], [proceso/pid], [titulo] )
WinWaitClose(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title*) {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWindow(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0&&A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que la ventana se active
;Sintaxis: WinWaitActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title*) {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if IsWinActive(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que la ventana pierda el foco
;Sintaxis: WinWaitNotActive( [ID], [Segundos], [clase], [proceso/pid], [titulo] )
WinWaitNotActive(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "") {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName&&!Title.MaxIndex())
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if !IsWinActive(hWnd, Class, ProcessName, Title[1])
			return true, ErrorLevel := false
		if (Seconds>0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}

;esperar a que la ventana exista
;Sintaxis: WinWait( [ID], [Segundos], [clase], [proceso/pid], [Título] )
;Nota: devuelve el ID 
WinWait(hWnd := "", Seconds := 0, Class := "", ProcessName := "", Title := "", Parent := false) {
	_gethwnd(hWnd)
	if (Seconds=-1) || (!hWnd&&!Class&&!ProcessName)
		return false
	ElapsedTime := A_TickCount+(Seconds*1000)
	Loop {
		if (i:=IsWindow(hWnd, Class, ProcessName, Title, Parent))
			return i, ErrorLevel := false
		if (Seconds>0) && (A_TickCount>=ElapsedTime)
			return false, ErrorLevel := true
		Sleep, 100
}}










































































/*#############################################################################################################################################
 ::::::::::::::::::::::::::::::::::::::::::::: MENU ::::::::::::::::::::::::::::::::::
PARÁMETROS:
	• hWnd = ID de la ventana
	• hMenu = ID del menu. para obtener el ID del menu por nombre, usar MenuGetHandle()
	• Menu = nombre del menu
EJEMPLO:
	Menu, MyMenu, Add, Item 1: Hola, close
	Menu, MyMenu, Add, % "ID: " MenuGetHandle("MyMenu"), close
	MenuCheckRadioItem(MenuGetHandle("MyMenu"), 2)
	Menu, MyMenu, Show
	return
	close:
	ExitApp
#############################################################################################################################################
*/
;ejecuta un comando del menu de la ventana
;Sintaxis: MenuSelectItem( [hWnd], [ID del Menú], [Nombre del Menú] )
;NOTA: espesificar ' > ' para submenús
;Ejemplo: MenuSelectItem( IsWindow(),, "Archivo > Abrir..." )
;VER: MenuGetItemList()
MenuSelectItem(hWnd, MenuItemId := "", MenuItemName := "") {
	if (MenuItemName != "") {
		Loop, Parse, % List:=MenuGetItemList(hWnd), `n, `r
		{ RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
			if (MenuItemName = MenuItem2) {
				MenuItemId := MenuItem1
				break
		}} if (MenuItemId="")
			Loop, Parse, % List, `n, `r
			{ RegExMatch(A_LoopField, "(\d+)`t(.*)", MenuItem)
				if InStr(MenuItem2, MenuItemName) {
					MenuItemId := MenuItem1
					break
	}}} return DllCall("User32.dll\SendNotifyMessageW", "Ptr", hWnd, "UInt", 0x111, "Ptr", MenuItemId, "Ptr", 0)
}

;Invoca un elemento de menú de la barra de menú de la ventana especificada
;Sintaxis: MenuSelect( [hWnd], [Menu Principal], [Submenus*] )
;EJEMPLO: MenuSelect( IsWindow(), "Archivo", "Abrir..." )
;VER: MenuSelectItem()
MenuSelect(hWnd, Menu, Submenu*) {
	if !Submenu.MaxIndex()
		return MenuSelectItem(hWnd,, Menu)
	Loop, % Submenu.MaxIndex()
		_Submenu .= " > " Submenu[A_Index]
	return MenuSelectItem(hWnd,, Menu _Submenu)
}

;redibujar el menú de la ventana.
;Sintaxis: MenuRedraw( [hWnd] )
MenuRedraw(hWnd) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\DrawMenuBar", "Ptr", hWnd)
}

;marcar el menu espesificado. al mismo tiempo desmarca todos los demás en el grupo espesificado
;Sintaxis: MenuCheckRadioItem( [hMenu], [item], [inicio], [fin] )
MenuCheckRadioItem(hMenu, ItemPos, First := 1, Last := 0) {
	if !(Last>0)
		Last := MenuGetItemCount(hMenu)
	return DllCall("User32.dll\CheckMenuRadioItem", "Ptr", hMenu, "UInt", First - 1, "UInt", Last - 1, "UInt", ItemPos - 1, "UInt", 0x0400)
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;comprueba si es un menú válido
;Sintaxis: IsMenu( [hMenu] )
IsMenu(hMenu) {
	return DllCall("User32.dll\IsMenu", "Ptr", hMenu)
}

MenuIsChecked(hMenu, ItemPos) {
	return (DllCall("User32.dll\GetMenuState", "Ptr", hMenu, "UInt", ItemPos - 1, "UInt", 0x0400, "UInt") & 0x08)
}

;-------------------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------------------

;obtener una lista con todos los elementos de los menús de la ventana
;Sintaxis: MenuGetItemList( [hWnd] )
;NOTA: sólo funciona con aplicaciones que utilizan menús estándar de Windows
;EJEMPLO: ver uso de LoopParse con RegExMatch() en: MenuSelectItem()
MenuGetItemList(hWnd, hMenu := 0, Prefix := "") { ;http://ahkscript.org/boards/viewtopic.php?p=48401#p48401
	_gethwnd(hWnd)
	, hMenu := hMenu ? hMenu : DllCall("User32.dll\GetMenu", "Ptr", hWnd)
	, Count := DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
	Loop, %Count% {
		sSize := DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Ptr", 0, "Int", 0, "UInt", 0x00000400)
		, sSize := VarSetCapacity( lpString, (sSize + 1) * 2 ) / 2
		if !DllCall("User32.dll\GetMenuStringW", "Ptr", hMenu, "UInt", A_Index-1, "Str", lpString, "Int", sSize, "UInt", 0x00000400)
			continue
		lpString := StrReplace(lpString, "&")
		, ItemId := DllCall("User32.dll\GetMenuItemID", "Ptr", hMenu, "Int", A_Index-1)
		if (itemID = -1) AND (hSubMenu := DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", A_Index-1)) {
			List .= MenuGetItemList( "", hSubMenu, Prefix lpString " > " ) "`n"
			continue
		} List .= ItemId "`t" Prefix RegExReplace( lpString, "`t.*" ) "`n"
	} return RTrim( List, "`n" )
}

;obtener el ID del submenu del menu espesificado
;Sintaxis: MenuGetSubMenu( [hMenu], [item] )
MenuGetSubMenu(hMenu, ItemPos := 1) {
	return DllCall("User32.dll\GetSubMenu", "Ptr", hMenu, "Int", ItemPos - 1)
}

;determina la cantidad de items en el menu
;Sintaxis: MenuGetItemCount( [hMenu] )
MenuGetItemCount(hMenu) {
	return DllCall("User32.dll\GetMenuItemCount", "Ptr", hMenu)
}











































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: TAREAS PROGRAMADAS ::::::::::::::::::::::::::::::::::
;Nota: requiere WIN_V+
;WIN_XP: https://msdn.microsoft.com/en-us/library/windows/desktop/aa383581(v=vs.85).aspx
;WIN_V+: https://msdn.microsoft.com/en-us/library/windows/desktop/aa383600(v=vs.85).aspx
;#############################################################################################################################################
;recupera todas las tareas programadas
;Sintaxis: SchTasksEnum( [¿buscar tareas en subcarpetas?] )
;Return: for [Index], [v.Name, v.Path] in SchTasksEnum()
;Ejemplo:
	;for k, v in SchTasksEnum(true)
	;	List .= v.path "`n"
	;MsgBox % List
SchTasksEnum(All := false) {
	if !(schservice:=SchTasksInit())
		return false
	RootFolder := schservice.GetFolder("\"), List := []
	, TaskCollection := RootFolder.GetTasks(0)
	for RegisteredTask in TaskCollection
			Task := {}, Task.Path := RegisteredTask.Path, Task.Name := RegisteredTask.Name, List.Push(Task)
	if (All)
		Loop, Parse, % SchTasksFoldersEnum(), `n
		{ 	TaskFolder := schservice.GetFolder(A_LoopField)
			, TaskCollection := TaskFolder.GetTasks(0)
			for RegisteredTask in TaskCollection
					Task := {}, Task.Path := RegisteredTask.Path, Task.Name := RegisteredTask.Name, List.Push(Task)
		} return List
} SchTasksInit(ByRef TaskPath := "", ByRef TaskName := "") {
	static schservice
	if !(IsObject(schservice)) {
		try schservice := ComObjCreate("Schedule.Service")
		catch, OutputVar
			return false, ErrorLevel := OutputVar
		schservice.Connect()
	} if (IsByRef(TaskName)) {
		SplitPath, TaskPath, TaskName, TaskPath
		TaskPath := "\" LTrim(TaskPath, "\")
	} return schservice
}

;enumera todas las subcarpetas en el directorio espesificado
;Sintaxis: SchTasksFoldersEnum( [ruta], [¿enumerar todas las carpetas y subcarpetas del directorio espesificado?] )
;Nota: si no espesifica un ruta (defecto), recupera todas las carpetas y subcarpetas en el directorio raiz.
;Ejemplos:
	;MsgBox % SchTasksFoldersEnum("\") ;recupera todas las carpetas en el directorio raiz.
	;MsgBox % SchTasksFoldersEnum() ;recupera todas las carpetas y subcarpetas en el directorio raiz.
SchTasksFoldersEnum(TaskPath := "", All := false, Prefix := "") {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\" LTrim(TaskPath, "\"))
	, FolderCollection := TaskFolder.GetFolders(0)
	catch, OutputVar
		return "", ErrorLevel := OutputVar
	for RegisteredFolder in FolderCollection {
		if (TaskPath="") || (All) {
			TaskFolder2 := schservice.GetFolder(RegisteredFolder.Path)
			if (TaskFolder2.GetFolders(0).Count>0) {
				List .= SchTasksFoldersEnum(RegisteredFolder.Path, true, RegisteredFolder.Path "`n") "`n"
			} else List .= Prefix RegisteredFolder.Path "`n"
		} else List .= (A_Index=1?"":"`n") RegisteredFolder.Name
	} Sort, List, U D`n
	return List
}

;habilitar tarea
;Sintaxis: SchTasksEnable( [ruta\nombre] )
SchTasksEnable(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Enabled := true
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;deshabilitar tarea
;Sintaxis: SchTasksDisable( [ruta\nombre] )
SchTasksDisable(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Enabled := false
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;crear carpeta\subcarpeta(s...)
;Sintaxis: SchTasksCreateFolder( [carpeta\sub1\sub2\etc...] )
SchTasksCreateFolder(TaskPath) {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\"), TaskFolder.CreateFolder(TaskPath)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;detener tarea
;Sintaxis: SchTasksStop( [ruta\nombre] )
SchTasksStop(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Stop(0)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;ejecutar tarea
;Sintaxis: SchTasksRun( [ruta\nombre], [parámetros] )
SchTasksRun(TaskPath, Params := "") {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, RegisteredTask.Run(Params, RunningTask)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;obtener información de la tarea.
;Sintaxis: SchTasksGetInfo( [ruta\nombre], [estado], [info] )
;Estado: Unknown | Disabled | Queued | Ready | Running
;Info: devuelve la informacion en formato .XML. usar SchTasksSplitInfo() para leer los valores.
;Ejemplo:
	;SchTasksGetInfo("CCleanerSkipUAC", State, RegistrationInfo)
	;MsgBox % State
	;MsgBox % RegistrationInfo
	;Info := SchTasksSplitInfo(RegistrationInfo)
	;MsgBox % "Autor: " Info.Author "`nDominio\Usuario: " Info.UserId "`nLogonType: " Info.LogonType "`nPrioridad: " Info.Priority
	;	. "`nHabilitado: " Info.Enabled "`nOculto: " Info.Hidden "`nComando: " Info.Command "`nArgumentos: " Info.Arguments
SchTasksGetInfo(TaskPath, ByRef State := "", ByRef RegistrationInfo := "") {
	static States := {0: "Unknown", 1: "Disabled", 2: "Queued", 3: "Ready", 4: "Running"}
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	if (IsByRef(State))
		State := States[RegisteredTask.State]
	if (IsByRef(RegistrationInfo))
		RegistrationInfo := RegisteredTask.XML
	return true, ErrorLevel := false
} SchTasksSplitInfo(RegistrationInfo) {
	RegInfo := {}
	Loop, Parse, % "Author,UserId,LogonType,Priority,Enabled,Hidden,Command,Arguments", `,
		RegExMatch(RegistrationInfo, "<" A_LoopField ">(.+)</" A_LoopField ">", TypeID)
		, RegInfo[A_LoopField] := (A_LoopField="Enabled"||A_LoopField="Hidden")?(TypeID1="true"):TypeID1
	return RegInfo
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;establecer prioridad
;Sintaxis: SchTasksSetPriority( [ruta\nombre], [prioridad 0~10 (defecto=7)] )
SchTasksSetPriority(TaskPath, Priority := 7) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, RegisteredTask := TaskFolder.GetTask(TaskName)
	, TaskDefinition := RegisteredTask.Definition
	, TaskSettings := TaskDefinition.Settings
	, TaskSettings.Priority := ((Priority>-1)&&(Priority<11))?Priority:7
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;--------------------------------------------------------------------------------------------------------------------------------------------

;eliminar tarea
;Sintaxis: SchTasksDelete( [ruta\nombre] )
SchTasksDelete(TaskPath) {
	if !(schservice:=SchTasksInit(TaskPath, TaskName))
		return false
	try TaskFolder := schservice.GetFolder(TaskPath)
	, TaskFolder.DeleteTask(TaskName, 0)
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	return true, ErrorLevel := false
}

;eliminar carpeta junto con todas sus subcarpetas
;Sintaxis: SchTasksDeleteFolder( [ruta], [¿eliminar si la carpeta tiene subcarpetas?] )
SchTasksDeleteFolder(TaskPath, Recurse := true) {
	if !(schservice:=SchTasksInit())
		return false
	try TaskFolder := schservice.GetFolder("\")
	catch, OutputVar
		return false, ErrorLevel := OutputVar
	if (Recurse) && (TaskFolder.GetFolders(0).Count>0) {
		Loop, Parse, % SchTasksFoldersEnum("\" LTrim(TaskPath, "\"), true), `n
		{ SplitPath, A_LoopField, TaskName2, TaskPath2
			try TaskFolder2 := schservice.GetFolder("\" LTrim(TaskPath2, "\"))
			, TaskFolder2.DeleteFolder(TaskName2, 0)
	}} try TaskFolder.DeleteFolder(TaskPath, 0)
	return true, ErrorLevel := false
}












































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SONIDO ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PRINCIPALES
;Parámetros:
	;Vol: espesificar un número entre 0.0 y 100.0 inclusive.
	;Channel: índice del canal para ajustar.
	;Tipo: espesificar uno de los siguientes tipos de dispositivos a los que ajustar el volumen, un indice, o el tipo y el indice separados por dos puntos «:».
		;Default = usar el dispositivo actual
		;ALL = todos
		;Capture
		;Render / PlayBack
	;Ejemplos de tipo:
		;Capture:2 (buscar en todos los dispositivos Capture y devuelve solo el de indice 2)
		;PlayBack:1 (buscar en todos los dispositivos PlayBack y devuelve solo el de indice 1)
		;PlayBack (devuelve todos los dispositivos PlayBack)
		;4 (busca en todos los dispositivos y devuelve solo el de indice 4)
;Link MSDN: https://msdn.microsoft.com/en-us/library/ms679028(VS.85).aspx
;Source (Vista Audio Control Reference 2.3 by Lexikos): http://www.autohotkey.net/~Lexikos/docs/VA.html
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;establecer volumen
;Sintaxis: Sound_SetMasterVolume( [Vol], [channel], [tipo] )
Sound_SetMasterVolume(Vol, Channel := 0, Type := "Default") { ;WIN_V+
	for k, v in Sound_GetDevice(Type) {
		hInterface := Sound_GetEndpointVolume(v)
		if (Channel)
			DllCall(NumGet(NumGet(hInterface+0)+11*A_PtrSize), "Ptr", hInterface, "UInt", Channel-1, "Float", Vol/100, "Ptr", 0)
		else DllCall(NumGet(NumGet(hInterface+0)+7*A_PtrSize), "Ptr", hInterface, "Float", Vol/100, "Ptr", 0)
		ObjRelease(hInterface)
}}

;obtener volumen
;Sintaxis: Sound_GetMasterVolume( [channel], [tipo] )
;Return: devuelve los valores separados por coma
Sound_GetMasterVolume(Channel := 0, Type := "Default") { ;WIN_V+
	for k, v in Sound_GetDevice(Type) {
		hInterface := Sound_GetEndpointVolume(v)
		if (Channel)
			DllCall(NumGet(NumGet(hInterface+0)+13*A_PtrSize), "Ptr", hInterface, "UInt", Channel-1, "Float*", Vol)
		else DllCall(NumGet(NumGet(hInterface+0)+9*A_PtrSize), "Ptr", hInterface, "Float*", Vol)
		OutputVar .= Round(Vol*100, 1) ",", ObjRelease(hInterface)
	} return RTrim(OutputVar, ",")
}

;silenciar/restaurar volumen
;Sintaxis: Sound_SetMasterMute( [0|1], [tipo] )
Sound_SetMasterMute(Mute := true, Type := "Default") { ;WIN_V+
	for k, v in Sound_GetDevice(Type)
		hInterface := Sound_GetEndpointVolume(v)
		, DllCall(NumGet(NumGet(hInterface+0)+14*A_PtrSize), "Ptr", hInterface, "Int", !!Mute, "Ptr", 0)
		, ObjRelease(hInterface)
}

;obtiene el estado actual del volumen
;Sintaxis: Sound_GetMasterMute( [tipo] )
;Return: devuelve 1 si está silenciado (separados por coma si se encontraron mas dispositivos)
Sound_GetMasterMute(Type := "Default") { ;WIN_V+
	for k, v in Sound_GetDevice(Type)
		hInterface := Sound_GetEndpointVolume(v)
		, DllCall(NumGet(NumGet(hInterface+0)+15*A_PtrSize), "Ptr", hInterface, "IntP", Mute)
		, ObjRelease(hInterface), OutputVar .= !!Mute ","
	return RTrim(OutputVar, ",")
}

;obtiene el número de canales que tiene el dispositivo de audio espesificado
;Sintaxis: Sound_GetMasterChannelCount( [tipo] )
Sound_GetMasterChannelCount(Type := "Default") { ;WIN_V+
	for k, v in Sound_GetDevice(Type)
		hInterface := Sound_GetEndpointVolume(v)
		, DllCall(NumGet(NumGet(hInterface+0)+5*A_PtrSize), "Ptr", hInterface, "UIntP", ChannelCount)
		, ObjRelease(hInterface), OutputVar := ChannelCount ","
	return RTrim(OutputVar, ",")
}

;obtener una lista  de todos los dispositivos de audio (HANDLE, NOMBRE, INDEX)
;Sintaxis: Sound_EnumDevices( [tipo], [cantidad (out)] )
;Nota: usar ObjRelease() cuando no ya no se necesite. ver ejemplo.
;Ejemplo:
	;for Index, Device in Sound_EnumDevices(, Count)
	;	MsgBox % "Device HANDLE: " Device[1] "`nDevice Name: " Device[2] "`nDevice Number: " Device[3] "`n---------`n" A_Index " de " Count
	;for Index, Device in Sound_EnumDevices(, Count)
	;	MsgBox % ObjRelease(Device[1])
Sound_EnumDevices(Type := "ALL", ByRef Count := "") { ;WIN_V+
	static Types := {ALL: 2, Capture: 1, Render: 0, PlayBack: 0}
	if (Types[Type]="") ;si no se espesifico ALL, Capture, Render o PlayBack
		Index := StrSplit(Type, ":", A_Space A_Tab)[2] ;obtiene el indice. Ej: PlayBack:4
		, Type := ((p:=InStr(Type, "PlayBack"))||(r:=InStr(Type, "Render")))?"PlayBack":(c:=InStr(Type, "Capture"))?"Capture":Type
	obj := ComObjCreate("{BCDE0395-E52F-467C-8E3D-C4579291692E}", "{A95664D2-9614-4F35-A746-DE8DB63617E6}")
	, DllCall(NumGet(NumGet(obj+0)+3*A_PtrSize), "Ptr", obj, "Int", Types[Type]=""?2:Types[Type], "UInt", 1, "PtrP", Devices), ObjRelease(obj)
	, DllCall(NumGet(NumGet(Devices+0)+3*A_PtrSize), "Ptr", Devices, "UIntP", Count), List := []
	Loop, %Count% {
		if (Types[Type]="") && !(A_Index=Type) ;index
			continue
		else if (p||r||c) && !(A_Index=Index) ;type:index (p, r o c solo será verdadero si se espesificó Capture, Render o PlayBack y su indice)
			continue ;else => type => ALL, Capture, Render o PlayBack
		if (DllCall(NumGet(NumGet(Devices+0)+4*A_PtrSize), "Ptr", Devices, "UInt", A_Index-1, "PtrP", Device)=0)
			List.Push([Device, Sound_GetDeviceName(Device), A_Index])
	} return List
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PARA USO INTERNO
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sound_GetDevice(Type := "Default") { ;WIN_V+
	if (Type="Default") {
		obj := ComObjCreate("{BCDE0395-E52F-467C-8E3D-C4579291692E}", "{A95664D2-9614-4F35-A746-DE8DB63617E6}")
		, DllCall(NumGet(NumGet(obj+0)+5*A_PtrSize), "Ptr", obj, "WStr", "", "PtrP", hDevice:=0)
		, DllCall(NumGet(NumGet(obj+0)+4*A_PtrSize), "Ptr", obj, "Int", 0, "Int", 0, "PtrP", hDevice)
		return [hDevice], ObjRelease(obj)
	} OutputVar := []
	for k, v in Sound_EnumDevices(Type)
		OutputVar.Push(v[1])
	return OutputVar
}

Sound_GetEndpointVolume(hDevice, Release := true) { ;WIN_V+
	VarSetCapacity(CLSID, 16, 0)
	, DllCall("Ole32.dll\CLSIDFromString", "WStr", "{5CDF2C82-841E-4546-9722-0CF74078229A}", "Ptr", &CLSID)
	, DllCall(NumGet(NumGet(hDevice+0)+3*A_PtrSize), "Ptr", hDevice, "Ptr", &CLSID, "UInt", 7, "UInt", 0, "PtrP", Interface)
	return Interface, Release := Release?ObjRelease(hDevice):0
}

;obtener nombre del dispositivo
Sound_GetDeviceName(Device) { ;WIN_V+
	static Name
	if !(VarSetCapacity(Name)) && (VarSetCapacity(Name, 20)) && (VarSetCapacity(Name, 16, 0))
		DllCall("Ole32.dll\CLSIDFromString", "WStr", "{A45C254E-DF1C-4EFD-8020-67D146A850E0}", "Ptr", &Name)
		, NumPut(14, &Name, 16)
	VarSetCapacity(Prop, 16), DllCall(NumGet(NumGet(Device+0)+4*A_PtrSize), "Ptr", Device, "UInt", 0, "PtrP", Store)
	, DllCall(NumGet(NumGet(Store+0)+5*A_PtrSize), "Ptr", Store, "Ptr", &Name, "Ptr", &Prop)
	, ObjRelease(Store), OutputVar := NumGet(prop, 8)
	return StrGet(ptr:=OutputVar, "UTF-16"), DllCall("ole32.dll\CoTaskMemFree", "Ptr", ptr) 
}

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Silenciar
;Sintáxis: SoundMute( [Opcion] )
;OPCIONES:
	;0 = restaurar | 1 = silenciar | 2 = alternar
	;-1 (defecto) = devuelve 1 si esta silenciado
Sound_Mute(Mode := -1) {
	if (Mode = -1) {
		SoundGet, OutputVar, MASTER, MUTE
		return OutputVar="On"
	} SoundSet, % Mode=2?"+1":Mode, MASTER, MUTE
	return !ErrorLevel
}

;emite un tono desde el altavoz del PC.
;Sintaxis: SoundBeep( [frequencia 37~32767], [duración] )
Sound_Beep(Frequency := 523, Duration := 150) {
	return DllCall("Kernel32.dll\Beep", "UInt", Frequency, "UInt", Duration)
}



















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: SERVICIOS ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/desktop/ms685942(v=vs.85).aspx
;#############################################################################################################################################
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PRINCIPALES
;Notas:
	;[IMPORTANTE!] usar OpenService() para abrir el servico y obtener un identificador a éste (HANDLE)
	;[IMPORTANTE!] usar CloseServiceHandle() para hService y hSCManager cuando ya no los necesite.
;Parámetros:
	;hSCManager: usar OpenSCManager()
	;hService: usar OpenService()
	;ServiceName: nombre del servicio. este es el mismo nombre que se espesifica al crear un servicio.
	;DisplayName: el nombre para mostrar del servicio. esta cadena tiene una longitud máxima de 256 caracteres.
	;DesiredAccess: acceso deseado. ver "Accesos Para El Servicio" abajo.
	;MachineName: nombre del equipo destino. por defecto se conecta al gestor de control de servicios en el equipo local.
	;DatabaseName: nombre de la base de datos del administrador de control de servicios.
	;ServiceType: valor que determina el tipo de servicio, puede ser uno de los siguientes valores.
		;SERVICE_KERNEL_DRIVER = 0x00000001
		;SERVICE_FILE_SYSTEM_DRIVER  = 0x00000002
		;SERVICE_ADAPTER = 0x00000004
		;SERVICE_RECOGNIZER_DRIVER = 0x00000008
		;SERVICE_WIN32_OWN_PROCESS = 0x00000010
		;SERVICE_WIN32_SHARE_PROCESS = 0x00000020
		;SERVICE_WIN32 = 0x00000030
		;SERVICE_DRIVER = 0x0000000B
		;SERVICE_TYPE_ALL = 0x0000013
		;SERVICE_INTERACTIVE_PROCESS = 0x00000100
		;SERVICE_WIN32_OWN_PROCESS + SERVICE_INTERACTIVE_PROCESS = 0x00000110
		;SERVICE_WIN32_SHARE_PROCESS + SERVICE_INTERACTIVE_PROCESS = 0x00000120
	;StartType: valor que identifica el tipo de inicio del servicio.
		;0x00000002 = SERVICE_AUTO_START
		;0x00000000 = SERVICE_BOOT_START
		;0x00000003 = SERVICE_DEMAND_START
		;0x00000004 = SERVICE_DISABLED
		;0x00000001 = SERVICE_SYSTEM_START
	;ErrorControl = la gravedad del error, y las medidas adoptadas, si este servicio no se inicia. puede ser uno de los siguientes valores.
		;0x00000000 = SERVICE_ERROR_IGNORE
		;0x00000002 = SERVICE_ERROR_SEVERE
		;0x00000001 = SERVICE_ERROR_NORMAL
		;0x00000003 = SERVICE_ERROR_CRITICAL
	;ServiceState = determina el estado actual del servicio. puede ser uno de los siguientes valores.
		;0x00000005 = SERVICE_CONTINUE_PENDING
		;0x00000006 = SERVICE_PAUSE_PENDING
		;0x00000007 = SERVICE_PAUSED
		;0x00000004 = SERVICE_RUNNING
		;0x00000002 = SERVICE_START_PENDING
		;0x00000003 = SERVICE_STOP_PENDING
		;0x00000001 = SERVICE_STOPPED
;Accesos Para El Servicio: https://msdn.microsoft.com/en-us/library/windows/desktop/ms685981(v=vs.85).aspx
	;0xF01FF = SERVICE_ALL_ACCESS  (defecto)
	;0x0002 = SERVICE_CHANGE_CONFIG 
	;0x0008 = SERVICE_ENUMERATE_DEPENDENTS
	;0x0080 = SERVICE_INTERROGATE 
	;0x0040 = SERVICE_PAUSE_CONTINUE
	;0x0001 = SERVICE_QUERY_CONFIG 
	;0x0004 = SERVICE_QUERY_STATUS 
	;0x0010 = SERVICE_START
	;0x0020 = SERVICE_STOP
	;0x0100 = SERVICE_USER_DEFINED_CONTROL
	;0x00010000 = DELETE
	;0x20000 = READ_CONTROL
	;0x1000000 = ACCESS_SYSTEM_SECURITY
	;0x40000 = WRITE_DAC
	;0x80000 = WRITE_OWNER
;Notas:
	;todas las funciones que requieren de hService, requieren de un Acceso espesífico, este es espesificado en cada función. sumar para combinar.
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtiene un HANDLE a un servicio
;Sintaxis: OpenService( [hSCManager], [ServiceName], [DesiredAccess] )
;Return: hService
OpenService(hSCManager, ServiceName, DesiredAccess := 0xF01FF) {
	return DllCall("Advapi32.dll\OpenServiceW", "Ptr", hSCManager, "Ptr", &ServiceName, "UInt", DesiredAccess, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684330(v=vs.85).aspx

;establece una conexión con el gestor de control de servicios en el equipo especificado y abre la base de datos de administrador de control de servicio especificado.
;Sintaxis: OpenSCManager( [MachineName], [DatabaseName], [DesiredAccess] )
;Return: hSCManager
OpenSCManager(MachineName := "", DatabaseName := "", DesiredAccess := 0xF003F) {
	return DllCall("AdvApi32.dll\OpenSCManagerW", "Ptr", MachineName=""?0:&MachineName
	, "Ptr", DatabaseName=""?0:&DatabaseName, "UInt", DesiredAccess, "Ptr")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684323(v=vs.85).aspx

;cierra un identificador a un gestor de control de servicios (hSCManager) o de objeto de servicio (hService)
;Sintaxis: CloseServiceHandle( [HANDLE*] )
;Return: 0|1
CloseServiceHandle(HANDLE*) {
	Error := ErrorLevel, Ok := 0
	for k, v in HANDLE
		Ok += !!DllCall("Advapi32.dll\CloseServiceHandle", "Ptr", HANDLE[k], "Int")
	return HANDLE.MaxIndex()=Ok, ErrorLevel := Error
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms682028(v=vs.85).aspx

;recupera el nombre del servicio (ServiceName) espesificado mediante el nombre a mostrar (DisplayName)
;Sintaxis: GetServiceKeyName( [hSCManager], [DisplayName] )
;Return: ServiceName
;ErrorLevel: 0|1
;Ejemplo: MsgBox % GetServiceKeyName(OpenSCManager(), "Cola de impresión")
GetServiceKeyName(hSCManager, DisplayName) {
	DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Ptr", &DisplayName, "Ptr", 0, "UIntP", Size:=0)
	, VarSetCapacity(ServiceName, (Size+1) * 2, 0)
	, Ok := DllCall("Advapi32.dll\GetServiceKeyNameW", "Ptr", hSCManager, "Ptr", &DisplayName, "Str", ServiceName, "UIntP", Size+1, "Int")
	return ServiceName, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683229(v=vs.85).aspx

;recupera el nombre del servicio a mostrar (DisplayName) espesificado mediante el nombre (ServiceName)
;Sintaxis: GetServiceDisplayName( [hSCManager], [ServiceName] )
;Return: DisplayName
;ErrorLevel: 0|1
;Ejemplo: MsgBox % GetServiceDisplayName(OpenSCManager(), "spooler")
GetServiceDisplayName(hSCManager, ServiceName) {
	DllCall("Advapi32.dll\GetServiceDisplayNameW", "Ptr", hSCManager, "Ptr", &ServiceName, "Ptr", 0, "UIntP", Size:=0)
	, VarSetCapacity(DisplayName, (Size+1) * 2, 0)
	, Ok := DllCall("Advapi32.dll\GetServiceDisplayNameW", "Ptr", hSCManager, "Ptr", &ServiceName, "Str", DisplayName, "UIntP", Size+1, "Int")
	return DisplayName, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683228(v=vs.85).aspx

;envía un código de control al servicio
;Sintaxis: ControlService( [hService], [dwControl], [lpServiceStatus (out)] )
	;dwControl: espesificar uno de los siguientes valores.
		;0x00000003 = SERVICE_CONTROL_CONTINUE. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x00000004 = SERVICE_CONTROL_INTERROGATE. acceso requerido SERVICE_INTERROGATE.
		;0x00000007 = SERVICE_CONTROL_NETBINDADD. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x0000000A = SERVICE_CONTROL_NETBINDDISABLE. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x00000009 = SERVICE_CONTROL_NETBINDENABLE. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x00000008 = SERVICE_CONTROL_NETBINDREMOVE. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x00000006 = SERVICE_CONTROL_PARAMCHANGE. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x00000002 = SERVICE_CONTROL_PAUSE. acceso requerido SERVICE_PAUSE_CONTINUE.
		;0x00000001 = SERVICE_CONTROL_STOP. acceso requerido SERVICE_STOP.
		;128 ~ 255 = USER_DEFINED_CONTROL_CODE. debe tener el acceso SERVICE_USER_DEFINED_CONTROL.
	;lpServiceStatus: recibe un objeto con la información más reciente sobre el estado del servicio
		;ServiceType: define el tipo de servicio. puede ser uno de los siguientes valores.
			;0x00000002 = SERVICE_FILE_SYSTEM_DRIVER
			;0x00000001 = SERVICE_KERNEL_DRIVER
			;0x00000010 = SERVICE_WIN32_OWN_PROCESS
			;0x00000020 = SERVICE_WIN32_SHARE_PROCESS
			;0x00000100 = SERVICE_INTERACTIVE_PROCESS (SERVICE_WIN32_OWN_PROCESS o SERVICE_WIN32_SHARE_PROCESS y LocalSystem_Account)
		;CurrentState: espesifica el estado del servicio. puede ser uno de los siguientes valores.
			;0x00000005 = SERVICE_CONTINUE_PENDING
			;0x00000006 = SERVICE_PAUSE_PENDING
			;0x00000007 = SERVICE_PAUSED
			;0x00000004 = SERVICE_RUNNING
			;0x00000002 = SERVICE_START_PENDING
			;0x00000003 = SERVICE_STOP_PENDING
			;0x00000001 = SERVICE_STOPPED
		;ControlsAccepted: el tipo de control que acepta por esta función.
			;0x00000010 = SERVICE_ACCEPT_NETBINDCHANGE
			;0x00000008 = SERVICE_ACCEPT_PARAMCHANGE
			;0x00000002 = SERVICE_ACCEPT_PAUSE_CONTINUE
			;0x00000100 = SERVICE_ACCEPT_PRESHUTDOWN
			;0x00000004 = SERVICE_ACCEPT_SHUTDOWN
			;0x00000001 = SERVICE_ACCEPT_STOP
		;Win32ExitCode: código de error que el servicio utiliza para informar de un error que se produce cuando se está iniciando o cerrando.
		;ServiceSpecificExitCode: código de error específico que devuelve el servicio cuando se produce un error mientras el servicio está iniciando o cerrando
		;CheckPoint: valor de punto de control, incrementos de servicio periódicamente para informar de su progreso durante un largo inicio, detener, pausar o continuar la operación
		;WaitHint: tiempo estimado para hacer un comienzo en espera, detener, pausar o continuar la operación, en milisegundos
;Acceso Requerido: depende de dwControl.
;Return: 0=ERROR
;ErrorLevel: 0|1
;Notas:
	;lpServiceStatus recibe la información si el valor de retorno es uno de los siguientes.
		;0 = NO_ERROR
		;1052 = ERROR_INVALID_SERVICE_CONTROL
		;1061 = ERROR_SERVICE_CANNOT_ACCEPT_CTRL
		;1062 = ERROR_SERVICE_NOT_ACTIVE
ControlService(hService, dwControl, ByRef lpServiceStatus := "") {
	VarSetCapacity(SERVICE_STATUS, 28, 0), NumPut(1066, SERVICE_STATUS, 12, "UInt"), lpServiceStatus := {}
	, Ok := DllCall("AdvApi32.dll\ControlService", "Ptr", hService, "UInt", dwControl, "Ptr", &SERVICE_STATUS, "Int")
	Loop, Parse, % "ServiceType|CurrentState|ControlsAccepted|Win32ExitCode|ServiceSpecificExitCode|CheckPoint|WaitHint", |
		lpServiceStatus[A_LoopField] := NumGet(SERVICE_STATUS, 4 * (A_Index-1), "UInt")
	return Ok, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms682108(v=vs.85).aspx

;eliminar servicio
;Sintaxis: DeleteService( [hService] )
;Acceso Requerido: DELETE
;Return: 0=ERROR
;Nota:
	;la entrada de la base de datos no es eliminada hasta que no llame CloseServiceHandle()
	;si el servicio esta iniciado, se intenta parar con una llamada a ControlService(, SERVICE_CONTROL_STOP )
DeleteService(hService) {
	return DllCall("Advapi32.dll\DeleteService", "Ptr", hService, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms682562(v=vs.85).aspx

;inicia el servicio
;Sintaxis: StartService( [hService], [dwNumServiceArgs], [&lpServiceArgVectors] )
;Return: 0=ERROR
;Acceso Requerido: SERVICE_START
;Notas:
	;si el servicio está desabilitado, la función fallará.
	;si el servicio está marcado para ser eliminado, la función fallará.
StartService(hService, dwNumServiceArgs := 0, lpServiceArgVectors := 0) {
	return DllCall("Advapi32.dll\StartServiceW", "Ptr", hService, "UInt", dwNumServiceArgs, "Ptr", lpServiceArgVectors, "Int")
}

;obtiene los parámetros de configuración opcionales del servicio espesífico
;Sintaxasis: QueryServiceConfig2( [hService], [dwInfoLevel] )
;Parámetros:
	;dwInfoLevel: espesificar el tipo de información a obtener. si no está definido devuelve un puntero a la ESTRUCTURA correspondiente.
		;12 = SERVICE_CONFIG_LAUNCH_PROTECTED (WIN_8.1+)
		;9 = SERVICE_CONFIG_PREFERRED_NODE
		;8 = SERVICE_CONFIG_TRIGGER_INFO
		;7 = SERVICE_CONFIG_PRESHUTDOWN_INFO
		;6 = SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO
		;5 = SERVICE_CONFIG_SERVICE_SID_INFO
		;4 = SERVICE_CONFIG_FAILURE_ACTIONS_FLAG
			;Return: 0|1.
			;Descripción: https://msdn.microsoft.com/en-us/library/windows/desktop/ms685937(v=vs.85).aspx
		;3 = SERVICE_CONFIG_DELAYED_AUTO_START_INFO
			;Return: devuelve un valor de tipo BOOL.
				;1 = se inicia el servicio después del inicio de otros servicios de inicio automático además de un breve retraso.
				;0 = se inicia el servicio durante el arranque del sistema.
			;Nota: este ajuste se ignora a menos que el servicio es un servicio de inicio automático.
		;2 = SERVICE_CONFIG_FAILURE_ACTIONS
		;1 = SERVICE_CONFIG_DESCRIPTION
			;Return: devuelve la descripcion del servicio.
			;Nota: a partir de WIN_V, puede devolver "Localized String", en la siguiente forma "@[path\]dllname,-strID", usar ReadLocalizedString() para obtener la descripción.
;Acceso Requerido: SERVICE_QUERY_CONFIG
;Return: depende del valor espesificádo en dwInfoLevel
;ErrorLevel: 0|1
;Ejemplo: obtener descripción del servicio spooler (cola de impresión).
	;MsgBox % QueryServiceConfig2(OpenService(OpenSCManager(), "spooler", 0x0001), 1)
QueryServiceConfig2(hService, dwInfoLevel) {
	DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", dwInfoLevel, "Ptr", 0, "UInt", 0, "UIntP", BytesNeeded)
	, VarSetCapacity(SERVICE_QUERY_CONFIG, BytesNeeded * 2, 0)
	, Ok := DllCall("Advapi32.dll\QueryServiceConfig2W", "Ptr", hService, "UInt", dwInfoLevel, "Ptr", &SERVICE_QUERY_CONFIG, "UInt", BytesNeeded, "UIntP", BytesNeeded, "Int")
	if (dwInfoLevel=3) || (dwInfoLevel=4) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms685155(v=vs.85).aspx
		OutputVar := NumGet(SERVICE_QUERY_CONFIG, 0, "Int")
	} else if (dwInfoLevel=1) { ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms685156(v=vs.85).aspx
		OutputVar := StrGet(NumGet(SERVICE_QUERY_CONFIG, 0, "Ptr"), "UTF-16")
	} else return SERVICE_QUERY_CONFIG, ErrorLevel := !Ok
	return OutputVar, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684935(v=vs.85).aspx

;cambia los parámetros opcionales de configuración del servicio
;Sintaxis: ChangeServiceConfig2( [hService], [dwInfoLevel], [lpInfo] )
;Parámetros:
	;dwInfoLevel: ver QueryServiceConfig2() para una lista con valores.
	;lpInfo: datos, depende del valor espesificado en dwInfoLevel.
		;dependiendo del valor de dwInfoLevel. si no se espesifica, debe espesificar un puntero a la ESTRUCTURA correspondiente.
			;SERVICE_CONFIG_DESCRIPTION: espesificar la descripción nueva para el servicio.
;Acceso Requerido: SERVICE_CHANGE_CONFIG
;Return: 0 = ERROR
;Ejemplo: cambiar descripción del servicio spooler (cola de impresión).
	;MsgBox % ChangeServiceConfig2(OpenService(OpenSCManager(), "spooler", 0x0002), 1, "Nueva Descripción") ;1 = SERVICE_CONFIG_DESCRIPTION
ChangeServiceConfig2(hService, dwInfoLevel, lpInfo) {
	if (dwInfoLevel=1) { ;SERVICE_CONFIG_DESCRIPTION
		VarSetCapacity(SERVICE_DESCRIPTION, StrLen(lpInfo) * 2, 0)
		, NumPut(&lpInfo, SERVICE_DESCRIPTION, 0, "Ptr")
		, VarSetCapacity(lpInfo, 0), lpInfo := &SERVICE_DESCRIPTION
	} return DllCall("Advapi32.dll\ChangeServiceConfig2W", "Ptr", hService, "UInt", dwInfoLevel, "Ptr", lpInfo, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms681988(v=vs.85).aspx

;recuperar parámetros de configuración del servicio
;Sintaxis: QueryServiceConfig( [hService] )
;Return: devuelve un Objeto con la información, o 0 en caso de ERROR.
	;ServiceType = valor que espesifíca el tipo de servicio. como ejemplo, el servicio "spooler" suele devolver 272, que es 0x00000110 (SERVICE_WIN32_OWN_PROCESS + SERVICE_INTERACTIVE_PROCESS)
	;StartType = valor que identifica el tipo de inicio del servicio.
	;ErrorControl = la gravedad del error, y las medidas adoptadas, si este servicio no se inicia.
	;BinaryPathName = ruta completa al archivo binario del servicio.
	;LoadOrderGroup = nombre del grupo de ordenamiento de carga a la que pertenece este servicio, si lo tiene.
	;TagId = valor de etiqueta única para este servicio en el grupo especificado por el parámetro loadOrderGroup, si lo tiene.
	;Dependencies = dependencias del servicio.
	;ServiceStartName = nombre de la cuenta sobre la cual trabaja el servicio. Ej: LocalSystem. Ej: \FileSystem\Rdr. Ej: \Driver\Xns.
	;DisplayName = nombre a mostrar para el servicio.
;Acceso Requerido: SERVICE_QUERY_CONFIG
;Nota: los valores se encuentran arriba de todo, al inicio de las funciones con servicios.
;Ejemplo: obtener nombre a mostrar del servicio Spooler.
	;MsgBox % QueryServiceConfig(OpenService(OpenSCManager(), "spooler", 0x0001)).DisplayName
QueryServiceConfig(hService) {
	DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", 0, "UInt", 0, "UIntP", BytesNeeded)
	, VarSetCapacity(QUERY_SERVICE_CONFIG, BytesNeeded * 2, 0)
	, Ok := DllCall("Advapi32.dll\QueryServiceConfigW", "Ptr", hService, "Ptr", &QUERY_SERVICE_CONFIG, "UInt", BytesNeeded, "UIntP", BytesNeeded, "Int")
	, OutputVar := {}, OutputVar.ServiceType := NumGet(QUERY_SERVICE_CONFIG, 0, "UInt")
	, OutputVar.StartType := NumGet(QUERY_SERVICE_CONFIG, 4, "UInt")
	, OutputVar.ErrorControl := NumGet(QUERY_SERVICE_CONFIG, 8, "UInt")
	, OutputVar.BinaryPathName := StrGet(NumGet(QUERY_SERVICE_CONFIG, 12, "Ptr"), "UTF-16")
	, OutputVar.LoadOrderGroup := StrGet(NumGet(QUERY_SERVICE_CONFIG, 12+A_PtrSize, "Ptr"), "UTF-16")
	, OutputVar.TagId := NumGet(QUERY_SERVICE_CONFIG, A_PtrSize=4?20:28, "UInt")
	, OutputVar.Dependencies := StrGet(NumGet(QUERY_SERVICE_CONFIG, A_PtrSize=4?24:36 "Ptr"), "UTF-16")
	, OutputVar.ServiceStartName := StrGet(NumGet(QUERY_SERVICE_CONFIG, A_PtrSize=4?28:44 "Ptr"), "UTF-16")
	, OutputVar.DisplayName := StrGet(NumGet(QUERY_SERVICE_CONFIG, A_PtrSize=4?32:52 "Ptr"), "UTF-16")
	return Ok?OutputVar:false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684932(v=vs.85).aspx

;establecer parámetros de configuración para el servicio
;Sintaxis: ChangeServiceConfig( [hService], [ ServiceType], [StartType], [ErrorControl], [BinaryPathName], [LoadOrderGroup], [TagId], [Dependencies], [ServiceStartName], [Password], [DisplayName] )
;Parámetros:
	;Password: espesificar la contraseña para la cuenta espesificada en ServiceStartName.
;Acceso Requerido: SERVICE_CHANGE_CONFIG
;Return: 0|1
;Notas:
	;dejar el valor por defecto para no modificar.
	;lo valores que debe espesificar en cada parámetro se encuentran al principio de las funciones de servicios o otros en QueryServiceConfig().
;Ejemplo: establecer el servicio Spooler como inicio Manual. 0x00000003 = MANUAL, 0x0002 = SERVICE_CHANGE_CONFIG
	;MsgBox % ChangeServiceConfig(OpenService(OpenSCManager(), "spooler", 0x0002),, 0x00000003)
ChangeServiceConfig(hService, ServiceType := 0xFFFFFFFF, StartType := 0xFFFFFFFF, ErrorControl := 0xFFFFFFFF, BinaryPathName := 0, LoadOrderGroup := 0, TagId := "", Dependencies := 0, ServiceStartName := 0, Password := 0, DisplayName*) {
	dn := DisplayName[1]
	return DllCall("Advapi32.dll\ChangeServiceConfigW", "Ptr", hService, "UInt", ServiceType, "UInt", StartType, "UInt", ErrorControl
		, "Ptr", BinaryPathName=0?0:&BinaryPathName, "Ptr", LoadOrderGroup=0?0:&LoadOrderGroup, TagId=""?"Ptr":"UIntP", TagId=""?0:TagId
		, "Ptr", Dependencies=0?0:&Dependencies, "Ptr", ServiceStartName=0?0:&ServiceStartName, "Ptr", Password=0?0:&Password, "Ptr", DisplayName.MaxIndex()?&dn:0, "Int")
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms681987(v=vs.85).aspx

;recupera el estado actual del servicio especificado basado en el nivel de información especificada.
;Sintaxis: QueryServiceStatusEx( [hService] )
;Acceso Requerido: SERVICE_QUERY_STATUS 
;Return: devuelve un objeto con la informacio, o 0 en caso de ERROR.
	;ServiceType = valor que identifica al tipo de servicio.
	;CurrentState = estado actual del servicio. ver ServiceState arriba de todo, al inicio de las funciones con servicios para una lista con los valores.
	;ControlsAccepted
	;Win32ExitCode
	;ServiceSpecificExitCode
	;CheckPoint
	;WaitHint
	;ProcessId = identificador del proceso (PID) del servicio. devuelve 0 si no se está ejecutando un proceso.
	;ServiceFlags = puede ser uno de los siguientes valores.
		;0x00000000 = el servicio se está ejecutando en un proceso que no es un proceso del sistema, o no se está ejecutando.
		;0x00000001 = el servicio se ejecuta en un proceso del sistema que siempre debe estar en ejecución.
;Nota: para una lista con valores, ver QueryServiceConfig() y ControlService().
QueryServiceStatusEx(hService) {
	DllCall("Advapi32.dll\QueryServiceStatusEx", "Ptr", hService, "UInt", 0, "Ptr", 0, "UInt", 0, "UIntP", BytesNeeded)
	, VarSetCapacity(SERVICE_STATUS_PROCESS, BytesNeeded * 2, 0)
	, Ok := DllCall("Advapi32.dll\QueryServiceStatusEx", "Ptr", hService, "UInt", 0, "Ptr", &SERVICE_STATUS_PROCESS, "UInt", BytesNeeded, "UIntP", BytesNeeded, "Int")
	, OutputVar := {}, OutputVar.ServiceType := NumGet(SERVICE_STATUS_PROCESS, 0, "UInt")
	Loop, Parse, % "CurrentState|ControlsAccepted|Win32ExitCode|ServiceSpecificExitCode|CheckPoint|WaitHint|ProcessId|ServiceFlags", |
		OutputVar[A_LoopField] := NumGet(SERVICE_STATUS_PROCESS, 4 * A_Index, "UInt")
	return Ok?OutputVar:false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684941(v=vs.85).aspx

;recupera el nombre y el estado de cada servicio que depende del servicio especificado; es decir, el servicio especificado debe estar en ejecución antes de que los servicios dependientes se pueden ejecutar.
;Sintaxis: EnumDependentServices( [hService], [ServiceState] )
;Parámetros:
	;ServiceState: el estado de lo servicios a ser enumerados. puede ser uno o mas de los siguientes valores.
		;0x00000001 = SERVICE_ACTIVE
		;0x00000002 = SERVICE_INACTIVE
;Acceso Requerido: SERVICE_ENUMERATE_DEPENDENTS
;Return: Array[ {ServiceName, DisplayName, ServiceType, CurrentState, ControlsAccepted, Win32ExitCode, ServiceSpecificExitCode, CheckPoint, WaitHint} ] o 0 en caso de ERROR.
;Ejemplo: obtener todos los serivios que dependen del servicio  Dhcp.
	;for k, v in EnumDependentServices(OpenService(OpenSCManager(), "Dhcp", 0x0008))
	;	MsgBox % "ServiceName: " v.ServiceName "`nDisplayName: " v.DisplayName "`nCurrentState: " v.CurrentState "`nServiceType: " v.ServiceType
EnumDependentServices(hService, ServiceState := 0x00000003) {
	DllCall("Advapi32.dll\EnumDependentServicesW", "Ptr", hService, "UInt", ServiceState, "Ptr", 0, "UInt", 0, "UIntP", BytesNeeded, "UIntP", 0)
	, VarSetCapacity(ENUM_SERVICE_STATUS, BytesNeeded * 2, 0), OutputVar := [], Offset := 0
	, Ok := DllCall("Advapi32.dll\EnumDependentServicesW", "Ptr", hService, "UInt", ServiceState, "Ptr", &ENUM_SERVICE_STATUS
		, "UInt", BytesNeeded, "UIntP", BytesNeeded, "UIntP", ServicesReturned, "Int")
	Loop, % (ServicesReturned) { ;ServicesReturned = representa el número de servicios que dependen del servicio espesificado
		Info := {}, Info.ServiceName := StrGet(NumGet(ENUM_SERVICE_STATUS, Offset, "Ptr"), "UTF-16")
		, Info.DisplayName := StrGet(NumGet(ENUM_SERVICE_STATUS, Offset+A_PtrSize, "Ptr"), "UTF-16")
		Loop, Parse, % "ServiceType|CurrentState|ControlsAccepted|Win32ExitCode|ServiceSpecificExitCode|CheckPoint|WaitHint", |
			Info[A_LoopField] := NumGet(ENUM_SERVICE_STATUS, (Offset+A_PtrSize) + (4 * A_Index), "UInt")
		OutputVar.Push(Info), Offset += A_PtrSize+28+A_PtrSize
	} return Ok?OutputVar:false
}

;enumera los servicios en la base de datos de control de servicio especificado. el nombre y el estado de cada servicio se proporcionan, junto con datos adicionales basados en el nivel de información específica.
;Sintaxis: EnumServicesStatus( [hSCManager], [ServiceType], [ServiceState], [GroupName] )
;Parámetros:
	;ServiceType: enumerar solo los servicios con los tipos espesificados. por defecto enumera todo los tipos de servicios.
	;ServiceState: enumera solo los servicios con el estado espesificado. por defecto enumera todos los estados de estados. ver EnumDependentServices()
	;GroupName: enumera solo los servicios que pertenescan al grupo espesificado. por defecto enumera todos los servicios de cualquier grupo.
;Return: Array[ {ServiceName, DisplayName, ServiceType, CurrentState, ControlsAccepted, Win32ExitCode, ServiceSpecificExitCode, CheckPoint, WaitHint, ProcessId, ServiceFlags} ] o 0 en caso de ERROR.
;Ejemplo: enumerar todos los servicios, cualquier tipo, cualquier estado, cualquier grupo.
	;for k, v in EnumServicesStatus(hSCManager := OpenSCManager())
	;	MsgBox % "ServiceName: " v.ServiceName "`nDisplayName: " v.DisplayName "`nCurrentState: " v.CurrentState "`nServiceType: " v.ServiceType
EnumServicesStatus(hSCManager, ServiceType := 0x0000006E, ServiceState := 0x00000003, GroupName := "") {
	DllCall("Advapi32.dll\EnumServicesStatusExW", "Ptr", hSCManager, "UInt", 0, "UInt", ServiceType, "UInt", ServiceState
		, "Ptr", 0, "UInt", 0, "UIntP", BytesNeeded, "UIntP", 0, "Ptr", 0, "Ptr", GroupName=""?0:&GroupName) 
	, VarSetCapacity(ENUM_SERVICE_STATUS_PROCESS, BytesNeeded * 2, 0), OutputVar := [], Offset := 0
	, Ok := DllCall("Advapi32.dll\EnumServicesStatusExW", "Ptr", hSCManager, "UInt", 0, "UInt", ServiceType, "UInt", ServiceState, "Ptr", &ENUM_SERVICE_STATUS_PROCESS
		, "UInt", BytesNeeded, "UIntP", BytesNeeded, "UIntP", ServicesReturned, "Ptr", 0, "Ptr", GroupName=""?0:&GroupName, "Int") 
	Loop, % (ServicesReturned) { ;ServicesReturned = representa el número de servicios
		Info := {}, Info.ServiceName := StrGet(NumGet(ENUM_SERVICE_STATUS_PROCESS, Offset, "Ptr"), "UTF-16")
		, Info.DisplayName := StrGet(NumGet(ENUM_SERVICE_STATUS_PROCESS, Offset+A_PtrSize, "Ptr"), "UTF-16")
		Loop, Parse, % "ServiceType|CurrentState|ControlsAccepted|Win32ExitCode|ServiceSpecificExitCode|CheckPoint|WaitHint|ProcessId|ServiceFlags", |
			Info[A_LoopField] := NumGet(ENUM_SERVICE_STATUS_PROCESS, (Offset+A_PtrSize) + (4 * A_Index), "UInt")
		OutputVar.Push(Info), Offset += A_PtrSize+36+A_PtrSize ;36 corresponde a la estructura SERVICE_STATUS_PROCESS y A_PtrSize a ServiceName y DisplayName.
	} return Ok?OutputVar:false
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms682640(v=vs.85).aspx

;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;OTRAS FUNCIONES
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;enumerar todos los servicios y obtener información
;Ejemplo:
	;for k, v in ServiceEnum()
	;	MsgBox % "#" k "`nServicio: " v.Name "`nNombre: " v.Caption "`nProcess ID: " v.ProcessId "`nParámetros: " v.PathName
;Nota: recomendado usar EnumServicesStatus(), es mucho mas rapido que esta función.
ServiceEnum() {
	List := []
	for Srv in ComObjGet("winmgmts:").ExecQuery("SELECT * FROM Win32_Service")
		Info := {}, Info.AcceptPause := Srv.AcceptPause, Info.AcceptStop := Srv.AcceptStop, Info.Caption := Srv.Caption, Info.CreationClassName := Srv.CreationClassName
		, Info.Description := Srv.Description, Info.DesktopInteract := Srv.DesktopInteract, Info.DisplayName := Srv.DisplayName, Info.SystemName := Srv.SystemName
		, Info.CheckPoint := Srv.CheckPoint, Info.DelayedAutoStart := Srv.DelayedAutoStart, Info.ProcessId := Srv.ProcessId, Info.WaitHint := Srv.WaitHint, Info.TagId := Srv.TagId
		, Info.ErrorControl := Srv.ErrorControl, Info.ExitCode := Srv.ExitCode, Info.InstallDate := Srv.InstallDate, Info.Name := Srv.Name, Info.PathName := Srv.PathName
		, Info.ServiceSpecificExitCode := Srv.ServiceSpecificExitCode, Info.ServiceType := Srv.ServiceType, Info.SystemCreationClassName := Srv.SystemCreationClassName
		, Info.Started := Srv.Started, Info.StartMode := Srv.StartMode, Info.StartName := Srv.StartName, Info.State := Srv.State, Info.Status := Srv.Status, List.Push(Info)
	return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa394073(v=vs.85).aspx

;comprueba si existe el servicio
;Sintaxis: ServiceExist( [ServiceName] )
;Return: 0|1
ServiceExist(ServiceName) {
	return RegExistKey("HKLM\SYSTEM\CurrentControlSet\Services\" ServiceName)
}





























































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: UNIDADES ::::::::::::::::::::::::::::::::::
;Parámetros:
	;unidad = ruta o letra de la unidad. solo se toma en cuenta el primer carácter, no espacios.
;#############################################################################################################################################
;dar formato a una unidad
;Sintaxis: DriveFormat( [unidad], [FileSystem], [QuickFormat 0|1], [ClusterSize], [Label] )
;FileSystem: formato del sistema de archivos.
	;NTFS (defecto)
	;FAT32
	;FAT
;QuickFormat: formato rápido mediante la eliminación de archivos desde el disco sin escanear el disco en busca de sectores defectuosos
;ClusterSize: tamaño del clúster. recomendado dejar en 4096.
;Label: etiqueta. 11 carácteres max para FAT y FAT32. 32 carácteres max para NTFS.
DriveFormat(Drive, FileSystem := "NTFS", QuickFormat := true, ClusterSize := 4096, Label := "") { ;WIN_V+
	Drive := SubStr(Trim(Drive), 1, 1) ":", Label := Trim(StrReplace(StrReplace(StrReplace(Label, A_Tab, A_Space), "`r"), "`n"))
	if (FileSystem="FAT") || (FileSystem="FAT32")
		Label := SubStr(Label, 1, 11) ;FAT/32 11max
	else if !(FileSystem="NTFS")
		return false, ErrorLevel := true
	else Label := SubStr(Label, 1, 32) ;NTFS 32max
	for this in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Volume Where DriveLetter = '" Drive "'")
		return !(Error:=this.Format(FileSystem, !!QuickFormat, ClusterSize, Label, !!EnableCompression)), ErrorLevel := Error
	return false, ErrorLevel := -1
} ;https://msdn.microsoft.com/en-us/library/aa390432(v=vs.85).aspx

;cambiar nombre de la unidad
;Sintaxis: DriveSetLabel( [unidad], [nombre] )
DriveSetLabel(Drive, VolumeLabel := "") {
	return r:=DllCall("Kernel32.dll\SetVolumeLabelW", "Str", SubStr(Trim(Drive), 1, 1) ":", "Str", VolumeLabel), ErrorLevel := !r
}

 ;obtener tipo de unidad: Unknown, Removable, Fixed, Network, CDROM, RAMDisk
;Sintaxis: DriveGetType( [Unidad] )
;Tipos: Unknown | Removable | Fixed | Network | CDROM | RAMDisk
;Ejemplo: MsgBox % DriveGetType(A_WinDir)
DriveGetType(Drive) {
	static Types := {0: "Unknown", 1: "", 2: "Removable", 3: "Fixed", 4: "Network", 5: "CDROM", 6: "RAMDisk"}
	Type := DllCall("Kernel32.dll\GetDriveTypeW", "Str", SubStr(Trim(Drive), 1, 1) ":")
	return Types[Type], ErrorLevel := (Types[Type]="Unknown"||!Types[Type])
}

;obtener informacion de la unidad
;Sintaxis: DriveGetInfo( [unidad], [nombre], [sistema de archivos], [serial], [MaximumComponentLength], [FileSystemFlags] )
;Ejemplo:
	;DriveGetInfo(A_WinDir, VolumeName, FileSystem, SerialNumber, MCLength, FileSystemFlags)
	;MsgBox % "VolumeName: " VolumeName "`nFileSystem: " FileSystem "`nSerialNumber: " SerialNumber "`nMCLength: " MCLength "`nFileSystemFlags: " FileSystemFlags
DriveGetInfo(Drive, ByRef VolumeName := "", ByRef FileSystem := "", ByRef SerialNumber := "", ByRef MCLength := "", ByRef FileSystemFlags := "") {
	VarSetCapacity(VolumeName, (260 + 1) * 2), VarSetCapacity(FileSystem, (260 + 1) * 2), Drive := SubStr(Drive, 1, 1)
	r := DllCall("Kernel32.dll\GetVolumeInformationW", "Str", Drive ":", "Str", VolumeName, "UInt", 261, "UIntP"
	, SerialNumber, "UIntP", MCLength, "UIntP", FileSystemFlags, "Str", FileSystem, "UInt", 261)
	if (r) && (VolumeName="")
		RegRead, VolumeName, % "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons\" Drive "\DefaultLabel"
	return r, ErrorLevel := !r
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364993%28v=vs.85%29.aspx

;obtener informacion de la unidad
;Sintaxis: DriveGetInfoEx( [unidad], [nombre], [sistema de archivos], [tipo], [serial], [espacio], [nombre compartido en red] )
;Sistema de archivos: FAT | FAT32 | NTFS | CDFS.
;Tipos: Unknown | Removable | Fixed | Network | CDROM | RAMDisk.
;Espacio (array): [total, disponible, en uso]. en bytes.
;Ejemplo:
	;DriveGetInfoEx(A_WinDir, VolumeName, FileSystem, Type, SerialNumber, Size, ShareName)
	;MsgBox % "VolumeName: " VolumeName "`nFileSystem: " FileSystem "`nType: " Type "`nSerialNumber: " SerialNumber
	;	. "`nTotal: " Round(Size[1]/(1024**3), 2) " GB | Disponible: " Round(Size[2]/(1024**3), 2) " GB | En Uso: " Round(Size[3]/(1024**3), 2) " GB`nShareName: " ShareName
DriveGetInfoEx(Drive, ByRef VolumeName := "", ByRef FileSystem := "", ByRef Type := "", ByRef SerialNumber := "", ByRef Size := "", ByRef ShareName := "") {
	static Types := {0: "Unknown", 1: "Removable", 2: "Fixed", 3: "Network", 4: "CDROM", 5: "RAMDisk"}
	try fso := ComObjCreate("Scripting.FileSystemObject"), d := fso.GetDrive(fso.GetDriveName(Drive))
	catch
		return false, ErrorLevel := true
	if (IsByRef(VolumeName))
		VolumeName := d.VolumeName
	if (IsByRef(FileSystem))
		FileSystem := d.FileSystem
	if (IsByRef(Type))
		Type := Types[d.DriveType]
	if (IsByRef(SerialNumber))
		SerialNumber := d.SerialNumber
	if (IsByRef(Size))
		Size := [t:=d.TotalSize, f:=(d.FreeSpace?d.FreeSpace:d.AvailableSpace), t-f]
	if (IsByRef(ShareName))
		ShareName := d.ShareName
	return true, ErrorLevel := false
} ;https://msdn.microsoft.com/en-us/library/ts2t8ybh(v=vs.84).aspx

;recupera la cantidad de espacio libre en Bytes
;Sintaxis: DriveSpaceFree( [unidad], [KB|MB|GB] )
DriveSpaceFree(Drive, Units := 0) {
	static Size := {KB: 1024, MB: 1024**2, GB: 1024**3}
	VarSetCapacity(FreeSpace, 8, 0), Drive := SubStr(Trim(Drive), 1, 1) ":"
	, Ok := DllCall("Kernel32.dll\GetDiskFreeSpaceExW", "Str", Drive, "UInt64", &FreeSpace, "Ptr", 0, "Ptr", 0, "UInt")
	return Size[Units]?NumGet(FreeSpace, 0, "UInt64")/Size[Units]:NumGet(FreeSpace, 0, "UInt64"), ErrorLevel := !Ok
}

;listar unidades
;Sintaxis: DriveEnum( [CDROM|REMOVABLE|FIXED|NETWORK|RAMDISK|UNKNOWN separados por coma] )
DriveEnum(Type := "") {
	DriveGet, OutputVar, List
	if (Type)
		Loop, Parse, % OutputVar
			if (InVar(DriveGetType(A_LoopField), Type))
				List .= A_LoopField
	return Type?List:OutputVar
}

;expulsar/retraer unidad de CD/DVD. expulsar USB.
;Sintaxis: DriveEject( [unidad], [0|1] )
;NOTA: la funcion espera hasta que la unidad se cierre/expulse.
DriveEject(Drive, Close := false) {
	Drive := SubStr(Drive, 1, 1)
	if ((IpType:=DriveGetType(Drive))="CDROM") || !(IpType) {
		if !(IpType)
			return false, ErrorLevel := true
		Drive, Eject, %Drive%:, % !!Close
		return !ErrorLevel
	} hDrive := CreateFile("\\.\" Drive ":", 0x80000000+0x40000000, 0,, 3)
	, Size := VarSetcapacity(STORAGE_DEVICE_NUMBER, 8 + A_PtrSize, 0), nVT := true
	, DeviceIoControl(hDrive, 0x2D1080,,, &STORAGE_DEVICE_NUMBER, Size)
	, CloseHandle(hDrive), IpType := NumGet(STORAGE_DEVICE_NUMBER, "UInt")
	, sPHDRV := (IpType=0x00000007)?"\\\\.\\PHYSICALDRIVE" NumGet(STORAGE_DEVICE_NUMBER, 4, "UInt"):""
	, queryEnum := ComObjGet("winmgmts:").ExecQuery("Select * from Win32_DiskDrive WHERE DeviceID='" sPHDRV "' AND InterfaceType='USB'")._NewEnum()
	If !(queryEnum[Drive])
		return false, ErrorLevel := true
	if !(GetModuleHandle("SetupAPI.dll"))
		hModule := LoadLibrary("SetupAPI.dll")
	nDID := CM_GetParent(CM_LocateDevNode(Drive.PNPDeviceID))
	while % (nDID && nVT && (A_Index<4)) 
		CM_RequestDeviceEject(nDID, nVT)
	if (hModule)
		FreeLibrary(hModule) 
	return !nVT, ErrorLevel := nVT
} ;http://ahkscript.org/boards/viewtopic.php?f=6&t=4491

;enumera todas las unidades de disco fisico conectadas al equipo (no particiones, estas son incluidas en la información)
DiskDriveEnum(Options := "") {
	List := []
	for this in ComObjGet("winmgmts:\\.\root\CIMV2").ExecQuery("SELECT * FROM Win32_DiskDrive" Options) {
		Info := {}
		Loop, Parse, % "Availability|BytesPerSector|Capabilities|CapabilityDescriptions|Caption|CompressionMethod|ConfigManagerErrorCode|ConfigManagerUserConfig|CreationClassName|"
		. "DefaultBlockSize|Description|DeviceID|ErrorCleared|ErrorDescription|ErrorMethodology|FirmwareRevision|Index|InstallDate|InterfaceType|LastErrorCode|"
		. "Manufacturer|MaxBlockSize|MaxMediaSize|MediaLoaded|MediaType|MinBlockSize|Model|Name|NeedsCleaning|NumberOfMediaSupported|Partitions|"
		. "PNPDeviceID|PowerManagementCapabilities|PowerManagementSupported|SCSIBus|SCSILogicalUnit|SCSIPort|SCSITargetId|SectorsPerTrack|"
		. "SerialNumber|Signature|Size|Status|StatusInfo|SystemCreationClassName|SystemName|TotalCylinders|TotalHeads|TotalSectors|TotalTracks|TracksPerCylinder", |
			Info[A_LoopField] := this[A_LoopField]
		List.Push(Info)
	} return List
} ;https://msdn.microsoft.com/en-us/library/windows/desktop/aa394132(v=vs.85).aspx

;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PARA USO INTERNO
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;envía un código de control directamente a un controlador de dispositivo especificado, haciendo que el dispositivo correspondiente para realizar la operación correspondiente
DeviceIoControl(hDevice, IoControlCode, InBuffer := 0, InBufferSize := 0, ByRef OutBuffer := 0, OutBufferSize := 0, ByRef OutBytesReturned := 0, ByRef InOutOverlapped := 0) {
	Ok := DllCall("Kernel32.dll\DeviceIoControl", "Ptr", hDevice, "UInt", IoControlCode
		, "Ptr", InBuffer, "UInt", InBufferSize
		, "Ptr", OutBuffer, "UInt", OutBufferSize, "UIntP"
		, OutBytesReturned, "Ptr", InOutOverlapped, "Int")
	return Ok, ErrorLevel := !Ok
}

QueryDosDevice(DeviceName) {
	VarSetCapacity(TargetPath, 24 * 2 + 2, 0), DeviceName := SubStr(DeviceName, 1, 1) ":"
	, DllCall("Kernel32.dll\QueryDosDeviceW", "Ptr", &DeviceName, "Ptr", &TargetPath, "UInt", 24 + 2)
	return TargetPath, VarSetCapacity(TargetPath, -1)
}


  

















































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: MONITOR ::::::::::::::::::::::::::::::::::
;Parámetros:
	;hWnd: hWnd a una ventana existente. -1 para la ventana activa (defecto).
	;hMonitor: identificador del monitor, 0 para el monitor primario
	;Monitor_Name: nombreN del monitor o 0 para el monitor primario (defecto). se puede obtener con GetMonitorInfo(hMonitor).Name
	;Monitor: espesificar hMonitor, Monitor_Name o 0 para usar el monitor primario (defecto)
	;nombreN / nombre: nombre del monitor con el número que lo identifica al final. 
;Link: https://msdn.microsoft.com/en-us/library/dd145072(v=vs.85).aspx
;Constantes: https://www.omniref.com/ruby/gems/win-user32-ruby/0.1.1/symbols/WinAPISys::MONITOR_DEFAULTTOPRIMARY
;Class Monitor: https://autohotkey.com/boards/viewtopic.php?t=7854
;#############################################################################################################################################
;obtener información de un monitor
;Sintaxis: GetMonitorInfo( [hMonitor] )
;Return: 
	;0 = ERROR
	;{Name, Primary?, Left, Top, Right, Bottom, wLeft, wTop, wRight, wBottom} = OK
;ErrorLevel: 0|1
;Notas:
	;el ancho es: Right-Left
	;el alto es: Bottom-Top
GetMonitorInfo(hMonitor) {
	Size := VarSetCapacity(MONITORINFOEX, (4+16+16+4 +12) * 2, 0)
	, NumPut(Size, MONITORINFOEX, 0, "UInt")
	, Ok := DllCall("User32.dll\GetMonitorInfoW", "Ptr", hMonitor, "Ptr", &MONITORINFOEX, "UInt")
	, Info := {}, Info.Name := StrGet(&MONITORINFOEX+40) ;Sintaxis: \\.\[nombre][número]
	, Info.Primary := NumGet(MONITORINFOEX, 36, "UInt") ;primario?
	Loop, Parse, % "Left,Top,Right,Bottom,wLeft,wTop,wRight,wBottom", `, ;pos
		Info[A_LoopField] := NumGet(MONITORINFOEX, 4 * A_Index, "Int")
	return Ok?Info:false, ErrorLevel := !Ok
} ;https://msdn.microsoft.com/en-us/library/dd144901(v=vs.85).aspx

;obtener resolucion  y frecuencia
;Sintaxis: GetMonitorSettings( [monitor], [ancho (out)], [alto (out)], [frecuencia (out)] )
;Parámetros:
	;Ancho / Alto: resolución
	;Frecuencia: frecuencia, en hercios (ciclos por segundo), del dispositivo.
;Return: 0|1
;ErrorLevel: 0|1
;Nota: si solo necesita la resolucion, usar GetMonitorResolution() o GetMonitorInfo()
GetMonitorSettings(hMonitor := 0, ByRef Width := "", ByRef Height := "", ByRef Freqency := "", ByRef DEV_MODE := "") {
	Monitor_Name := GetMonitorName(hMonitor)
	, Ok := EnumDisplaySettings(Monitor_Name,, DEV_MODE)
	, Width := NumGet(DEV_MODE, 108 + 64, "UInt")
	, Height := NumGet(DEV_MODE, 112 + 64, "UInt")
	, Freqency := NumGet(DEV_MODE, 120 + 64, "UInt")
	return !!Ok, ErrorLevel := !Ok
}

;establecer resolución y frecuencia
;Sintaxis: SetMonitorSettings( [monitor], [ancho], [alto], [frecuencia, en hercios] )
;Nota: dejar los parámetros vacíos para no modificar
;Return: 0|1
SetMonitorSettings(hMonitor := 0, Width := "", Height := "", Freqency := "") {
	Monitor_Name := GetMonitorName(hMonitor)
	, GetMonitorSettings(Monitor_Name, w, h, f, DEV_MODE)
	, NumPut(0x5c0000, DEV_MODE, 6 + 32, "UInt")
	, NumPut(Width=""?w:Width, DEV_MODE, 108 + 64, "UInt")
	, NumPut(Height=""?h:Height, DEV_MODE, 112 + 64, "UInt")
	, NumPut(Freqency=""?(f?f:0):Freqency, DEV_MODE, 120 + 64, "UInt")
	return DllCall("User32.dll\ChangeDisplaySettingsEx", "Ptr", &Monitor_Name, "Ptr", &DEV_MODE, "Ptr", 0, "UInt", 0x00000001, "Ptr", 0, "Int")=0
}

;obtener ancho y alto actual (resolución) del monitor
;Sintaxis: GetMonitorResolution( [hMonitor], [ancho (out)], [alto (out)], [anchoW (out)], [altoW (out)] )
;Parámetros:
	;Alto: alto total del la pantalla
	;Ancho: ancho total del la pantalla
	;AnchoW: el área se reduce a excluir a la zona ocupada por la barra de tareas y otras barras de herramientas de escritorio registrados
	;AltoW: el área se reduce a excluir a la zona ocupada por la barra de tareas y otras barras de herramientas de escritorio registrados
;Return: [ancho, alto, anchoW, altoW]
;Ejemplo:
	;hMonitor := GetPrimaryDisplayMonitor()
	;MsgBox % GetMonitorResolution(hMonitor,, h, w2, h2)[1] "x" h "`n" w2 "x" h2
GetMonitorResolution(hMonitor, ByRef Width := "", ByRef Height := "", ByRef wWidth := "", ByRef wHeight := "") {
	Info := GetMonitorInfo(hMonitor)
	return [Width:=Info.Right-Info.Left, Height:=Info.Bottom-Info.Top, wWidth:=Info.wRight-Info.wLeft, wHeight:=Info.wBottom-Info.wTop]
}

;recupera un identificador para el monitor de visualización que tiene la mayor superficie de intersección con el rectángulo de delimitación de una ventana especificada
;Sintaxis: MonitorFromWindow( [hWnd] )
;Return: hMonitor
MonitorFromWindow(hWnd := -1) {
	_gethwnd(hWnd)
	return DllCall("User32.dll\MonitorFromWindow", "Ptr", hWnd, "UInt", 0x00000002, "Ptr")
}

;recupera un identificador para el monitor de visualización que tiene la mayor superficie de intersección con un rectángulo especificado
;Sintaxis: MonitorFromRect( [&RECT] )
;Sintaxis 2: MonitorFromPoint [&POINT] )
;Parámetros:
	;RECT: espesificar una estructura rect.
	;POINT: espesificar una estructura point.
;Return: hMonitor
MonitorFromRect(RECT) {
	return DllCall("User32.dll\MonitorFromRect", "Ptr", RECT, "UInt", 0x00000002, "Ptr")
} MonitorFromPoint(POINT) {
	return DllCall("User32.dll\MonitorFromPoint", "Ptr", POINT, "UInt", 0x00000002, "Ptr")
}

;obtener el monitor primario
;Ejemplo: MsgBox % GetMonitorInfo(GetPrimaryDisplayMonitor()).Name ;obtener nombreN del monitor principal
;Return: hMonitor
GetPrimaryDisplayMonitor() {
	return DllCall("User32.dll\MonitorFromWindow", "Ptr", 0, "UInt", 0x00000001, "Ptr")
}

;enumera monitores de visualización (incluyendo pseudo-monitores invisibles asociados con los controladores de mirroring)
;que intersecan una región formada por la intersección de un área de recorte especificada y la región visible de un contexto de dispositivo.
;Sintaxis: EnumDisplayMonitors( [hDC, RECT] )
;Return: 
	;0 = ERROR
	;[{hMonitor, hDC, pRECT}] = OK
;ErrorLevel: 0|1
;Ejemplo:
	;for k, v in EnumDisplayMonitors()
	;	MsgBox % "#" k "`n`nhMonitor: " v.hMonitor "`nNombre: " GetMonitorInfo(v.hMonitor).Name
EnumDisplayMonitors(hDC := 0, RECT := 0) {
	Address := RegisterCallback("MonitorEnumProc", "Fast", 4), Data := {List: []}
	, Ok := DllCall("User32.dll\EnumDisplayMonitors", "Ptr", hDC, "Ptr", RECT, "Ptr", Address, "Ptr", &Data)
	return Ok?Data.List:false, ErrorLevel := !Ok, GlobalFree(Address)
} MonitorEnumProc(hMonitor, hDC, RECT, Data) {
	Data := Object(Data), Data.List.Push({hMonitor: hMonitor, hDC: hDC, RECT: RECT})
	return true
}

;cuenta sólo los monitores de visualización
;Return: int
GetDisplayMonitors() {
	return GetSystemMetrics(80)
}

;obtener DPI del monitor
;Sintaxis: GetMonitorDPI( [monitor] )
;Return: 0 = ERROR
GetMonitorDPI(hMonitor := 0) {
	hDC := GetMonitorDC(hMonitor)
	return GetDeviceCaps(hDC, 88), DeleteDC(hDC) ;LOGPIXELSX=88 | LOGPIXELSY=90
}

;establecer gama
;Sintaxis: SetDeviceGammaRamp( [monitor], [gama] )
;Parámetros:
	;Gama: un valor entre 1 y 255 inclusive. 125 es el predeterminado
;Return: 0|1
SetDeviceGammaRamp(hMonitor := 0, Gamma := 125) { ;WIN_V+
	Gamma := (Gamma > 255) ? 255 : (Gamma < 0) ? 0 : Gamma
	, hDC := GetMonitorDC(hMonitor), Size := VarSetCapacity(Ramp, 1536, 0)
	Loop, % Size / 6
            NumPut((N := (Gamma + 128) * (A_Index - 1)) > 65535 ? 65535 : N, Ramp, 2 * (A_Index - 1), "UShort")
        MoveMemory(&Ramp + 512, &Ramp, 512), MoveMemory(&Ramp + 1024, &Ramp, 512)
	return DllCall("Gdi32.dll\SetDeviceGammaRamp", "Ptr", hDC, "Ptr", &Ramp, "Int"), DeleteDC(hDC)
}

;obtener gama
;Sintaxis: GetDeviceGammaRamp( [monitor] )
;Return: Int
;ErrorLevel: 0|1
GetDeviceGammaRamp(hMonitor := 0) { ;WIN_V+
	hDC := GetMonitorDC(hMonitor), VarSetCapacity(Ramp, 1536, 0)
	, Ok := DllCall("Gdi32.dll\GetDeviceGammaRamp", "Ptr", hDC, "Ptr", &Ramp, "Int")
	return NumGet(Ramp, 2, "UShort") - 128, ErrorLevel := !Ok, DeleteDC(hDC)
}

;obtener hPhysicalMonitor desde hMonitor
GetPhysicalMonitorsFromHMONITOR(hMonitor, ByRef PHYSICAL_MONITOR := "") {
	if !DllCall("Dxva2.dll\GetNumberOfPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UIntP", NumberOfPhysicalMonitors, "Int")
		return false
	VarSetCapacity(PHYSICAL_MONITOR, (A_PtrSize + 256) * NumberOfPhysicalMonitors, 0)
	if !DllCall("Dxva2.dll\GetPhysicalMonitorsFromHMONITOR", "Ptr", hMonitor, "UInt", NumberOfPhysicalMonitors, "Ptr", &PHYSICAL_MONITOR, "Int")
		return false
	return NumGet(PHYSICAL_MONITOR) ;0?
}

/* COMENTADO DEBIDO A QUE GetPhysicalMonitorsFromHMONITOR() NO DEVUELVE hPhysicalMonitor CORRECTAMENTE EN CIERTOS MONITORES
	,LINK REFERENCIA: http://stackoverflow.com/questions/846518/getphysicalmonitorsfromhmonitor-returned-handle-is-always-null
;recupera las capacidades de configuración de un monitor. Llame a esta función para saber qué funciones de configuración del monitor de alto nivel son compatibles con el monitor.
;Sintaxis: GetMonitorCapabilities( [hMonitor], [MonitorCapabilities (out)], [SupportedColorTemperatures (out)] )
;Parámetros:
	;MonitorCapabilities: para comprobar si soporta una capacidad use (MonitorCapabilities & N), donde N es uno de los siguientes valores.+
		;MC_CAPS_NONE = 0x00000000,
		;MC_CAPS_MONITOR_TECHNOLOGY_TYPE = 0x00000001
		;MC_CAPS_BRIGHTNESS = 0x00000002
		;MC_CAPS_CONTRAST = 0x00000004
		;MC_CAPS_COLOR_TEMPERATURE = 0x00000008
		;MC_CAPS_RED_GREEN_BLUE_GAIN = 0x00000010
		;MC_CAPS_RED_GREEN_BLUE_DRIVE = 0x00000020
		;MC_CAPS_DEGAUSS = 0x00000040
		;MC_CAPS_DISPLAY_AREA_POSITION = 0x00000080
		;MC_CAPS_DISPLAY_AREA_SIZE = 0x00000100
		;MC_CAPS_RESTORE_FACTORY_DEFAULTS = 0x00000400
		;MC_CAPS_RESTORE_FACTORY_COLOR_DEFAULTS = 0x00000800
		;MC_RESTORE_FACTORY_DEFAULTS_ENABLES_MONITOR_SETTINGS = 0x00001000
	;SupportedColorTemperatures: para comprobar si soporta una temperatura de color use (SupportedColorTemperatures & N), donde N es uno de los siguientes valores.
		;MC_SUPPORTED_COLOR_TEMPERATURE_NONE = 0x00000000
		;MC_SUPPORTED_COLOR_TEMPERATURE_4000K = 0x00000001
		;MC_SUPPORTED_COLOR_TEMPERATURE_5000K = 0x00000002
		;MC_SUPPORTED_COLOR_TEMPERATURE_6500K = 0x00000004
		;MC_SUPPORTED_COLOR_TEMPERATURE_7500K = 0x00000008
		;MC_SUPPORTED_COLOR_TEMPERATURE_8200K = 0x00000010
		;MC_SUPPORTED_COLOR_TEMPERATURE_9300K = 0x00000020
		;MC_SUPPORTED_COLOR_TEMPERATURE_10000K = 0x00000040
		;MC_SUPPORTED_COLOR_TEMPERATURE_11500K = 0x00000080
;Return: 0|1
GetMonitorCapabilities(hMonitor, ByRef MonitorCapabilities := "", ByRef SupportedColorTemperatures := "") { ;WIN_V+
	hPhysicalMonitor := GetPhysicalMonitorsFromHMONITOR(hMonitor)
	if !DllCall("Dxva2.dll\GetMonitorCapabilities", "Ptr", hPhysicalMonitor, "UIntP", MonitorCapabilities, "UIntP", SupportedColorTemperatures, "Int")
		return false
	return true
} ;https://msdn.microsoft.com/en-us/library/dd692940(v=vs.85).aspx
*/

;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;FUNCIONES PARA USO INTERNO
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;obtener hDC desde hMonitor, Monitor_Name o 0=MONITOR PRIMARIO
;Notas: 
	;usar DeleteDC() para eliminar hDC cuando ya no se necesite
	;para obtener hDC se necesita el nombreN del monitor, por lo cual si se espesifica el nombre, lo usa sin llamar a otras funciones.
GetMonitorDC(hMonitor := 0) {
	Monitor_Name := (hMonitor+0)=""?hMonitor:(hMonitor?GetMonitorInfo(hMonitor).Name:"DISPLAY")
	return CreateDC(Monitor_Name)
}

;obtener nombreN desde hMonitor, Monitor_Name, 0=MONITOR PRIMARIO
;Nota: si se espesifica el nombre del monitor, lo devuelve sin llamar a otras funciones
GetMonitorName(hMonitor) {
	Monitor_Name := (hMonitor+0)=""?hMonitor:GetMonitorInfo(hMonitor?hMonitor:GetPrimaryDisplayMonitor()).Name
	return Monitor_Name
}

;obtiene la estructura DEV_MODE con información de un monitor 
;https://autohotkey.com/board/topic/85382-change-screen-resolution-using-unicode-and-ansi-version/
;https://autohotkey.com/board/topic/96293-changing-multiple-monitor-display-resolutions/
EnumDisplaySettings(Monitor_Name := 0, ModeNum := -1, ByRef DEV_MODE := "") {
	Size := VarSetCapacity(DEV_MODE, 220, 0)
	, NumPut(Size, DEV_MODE, 4 + 32, "UInt")
	return DllCall("User32.dll\EnumDisplaySettingsW", "Ptr", &Monitor_Name, "UInt", ModeNum, "Ptr", &DEV_MODE, "Int") 
} ;https://msdn.microsoft.com/en-us/library/dd162611(v=vs.85).aspx





































































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: ADMINISTRACIÓN DE CONFIGURACIÓN PLUG AND PLAY (PNP) ::::::::::::::::::::::::::::::::::
;Link: https://msdn.microsoft.com/en-us/library/windows/hardware/ff549794(v=vs.85).aspx
;Parámetros:
	;hDevInst: instancia al dispositivo (HANDLE)
	;VetoType: tipo de error, si lo hubo. https://msdn.microsoft.com/en-us/library/windows/hardware/ff549728(v=vs.85).aspx
	;VetoName: recibe una String que representa al error.
;Constantes:
	;CR_SUCCESS = 0x00000000
;#############################################################################################################################################
;obtiene una instancia de dispositivo (HANDLE) para el nodo del dispositivo que está asociado con un ID espesífico de la instancia de un dispositivo en la mquina local.
;Sintaxis: CM_LocateDevNode( [pDeviceID], [Flags], [hMachine] )
;Parámetros:
	;pDeviceID: String que reprecenta el id de la instancia del dispositivo. si no se espesifica, suministra un ID para el dispositivo en la raíz del árbol de dispositivos.
	;Flags: si se espesificó un ID, espesificar el modo en que se suministra.
		;0 = CM_LOCATE_DEVNODE_NORMAL
		;1 = CM_LOCATE_DEVNODE_PHANTOM
		;2 = CM_LOCATE_DEVNODE_CANCELREMOVE
		;4 = CM_LOCATE_DEVNODE_NOVALIDATION
		;7 = CM_LOCATE_DEVNODE_BITS
;Return: hDevInst
;ErrorLevel: 0 = OK
CM_LocateDevNode(pDeviceID := 0, Flags := 0, hMachine := 0) {
	Error := DllCall("SetupAPI.dll\CM_Locate_DevNode_ExW", "PtrP", hDevInst, "Ptr", &pDeviceID, "UInt", Flags, "Ptr", hMachine, "Int")
	return hDevInst, ErrorLevel := Error ;CR_SUCCESS?
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff538751(v=vs.85).aspx

;prepara una instancia de un dispositivo local para ser removido de forma segura, si la unidad es removible. si la unidad puede ser fisicamente ejecutada, asi será.
;Sintaxis: CM_RequestDeviceEject( [hDevInst], [VetoType], [VetoName], [Flags (sin uso = 0)], [hMachine] )
;Return: 0|1
;ErrorLevel: 0 = OK 
CM_RequestDeviceEject(hDevInst, ByRef VetoType := "", ByRef VetoName := "", Flags := 0, hMachine := 0) {
	if IsByRef(VetoName)
		VarSetCapacity(VetoName, 260 * 2, 0)
		, Error := DllCall("SetupAPI.dll\CM_Request_Device_Eject_ExW", "Ptr", hDevInst, "PtrP", VetoType, "Str", VetoName, "UInt", 260, "UInt", Flags, "Ptr", hMachine, "Int")
	else Error := DllCall("SetupAPI.dll\CM_Request_Device_Eject_ExW", "Ptr", hDevInst, "PtrP", VetoType, "Ptr", 0, "UInt", 0, "UInt", Flags, "Ptr", hMachine, "Int")
	return !Error, ErrorLevel := Error ;CR_SUCCESS
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff539807(v=vs.85).aspx

;obtiene una instancia de dispositivo (HANDLE) al nodo padre de un nodo de dispositivo especificado en un arbol de quipos locales o remotos
;Sintaxis: hDevInst( [hDevInst], [Flags (sin uso = 0)], [hMachine] )
;Return: hDevInst
;ErrorLevel: 0 = OK
CM_GetParent(hDevInst, Flags := 0, hMachine := 0) {
	Error := DllCall("SetupAPI.dll\CM_Get_Parent", "PtrP", ohDevInst, "Ptr", hDevInst, "UInt", Flags, "Ptr", hMachine, "Int")
	return ohDevInst, ErrorLevel := Error ;CR_SUCCESS?
} ;https://msdn.microsoft.com/en-us/library/windows/hardware/ff538615(v=vs.85).aspx




















































































































;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: CLASES (para uso interno de otras funciones) ::::::::::::::::::::::::::::::::::
;#############################################################################################################################################
;IVirtualDesktopManager interface
;Exposes methods that enable an application to interact with groups of windows that form virtual workspaces.
;https://msdn.microsoft.com/en-us/library/windows/desktop/mt186440(v=vs.85).aspx
class IVirtualDesktopManager {
	static obj ;IVirtualDesktopManager Object
	
	;create IVirtualDesktopManager Object
	ComObjCreate() {
		if !(this.obj)
			CLSID := "{aa509086-5ca9-4c25-8f95-589d3c07b48a}" ;VirtualDesktopManager clsid
			, IID := "{a5cd92ff-29be-454c-8d04-d82879fb3f1b}" ;IID_IVirtualDesktopManager
			, this.obj := ComObjCreate(CLSID, IID)
	}
	
	;free IVirtualDesktopManager object
	ObjRelease() {
		ObjRelease(this.obj), this.obj := ""
	}

	;IVirtualDesktopManager::IsWindowOnCurrentVirtualDesktop method
	;Indicates whether the provided window is on the currently active virtual desktop.
	;https://msdn.microsoft.com/en-us/library/windows/desktop/mt186442(v=vs.85).aspx
	IsWindowOnCurrentVirtualDesktop(hWnd) {
		this.ComObjCreate()
		, Error := DllCall(NumGet(NumGet(this.obj+0), 3*A_PtrSize), "Ptr", this.obj, "Ptr", hWnd, "IntP", onCurrentDesktop, "UInt")
		return Error=0?onCurrentDesktop:false, ErrorLevel := Error
	}

	;IVirtualDesktopManager::GetWindowDesktopId method
	;Gets the identifier for the virtual desktop hosting the provided top-level window.
	;https://msdn.microsoft.com/en-us/library/windows/desktop/mt186441(v=vs.85).aspx
	GetWindowDesktopId(hWnd, ByRef GUID := "") {
		VarSetCapacity(GUID, 16, 0), this.ComObjCreate()
		return DllCall(NumGet(NumGet(this.obj+0), 4*A_PtrSize), "Ptr", this.obj, "Ptr", hWnd, "Ptr", &GUID, "UInt")=0
	}
	
	;IVirtualDesktopManager::MoveWindowToDesktop method
	;Moves a window to the specified virtual desktop.
	;https://msdn.microsoft.com/en-us/library/windows/desktop/mt186443(v=vs.85).aspx
	MoveWindowToDesktop(hWnd, GUID) {
		this.ComObjCreate()
		return DllCall(NumGet(NumGet(this.obj+0), 5*A_PtrSize), "Ptr", this.obj, "Ptr", hWnd, "Ptr", GUID, "UInt")=0
	}
	
}

;recordar valores espesificados en las funciones
class __gsvalue {
	static LastWindowId ;ultimo ID espesificado para una ventana
	static LastControlId ;ultimo ID espesificado para un control
	static LastProcessId ;ultimo ID espesificado para un proceso
}

;RICH EDIT 4.1 CLASS
;THIS IS A REWRITTEN VERSION OF JUSTME RICHEDIT CLASS (credits for him):  https://autohotkey.com/boards/viewtopic.php?f=6&t=681&hilit=richedit
class __RichEditClass { ;https://msdn.microsoft.com/en-us/library/ff486015(v=vs.85).aspx
	;******************************************************************************************************************************************************************************************
	;Static/Class Variables
	;******************************************************************************************************************************************************************************************
	static hModule, Address
	static Instances := []
	
	;******************************************************************************************************************************************************************************************
	;Instance Variables
	;******************************************************************************************************************************************************************************************
	SelIsVisible := false
	AutoUrl := false
	SaveFileDefaultPath := A_Desktop "\New Document.rtf"
	LoadFileDefaultPath := A_Desktop
	
	;******************************************************************************************************************************************************************************************
	;CREAR OBJETO
	;******************************************************************************************************************************************************************************************
	__New(Options := "", Text := "") {
		if !(this.hModule)
			this.hModule := LoadLibrary("MsftEdit.dll") ;Rich Edit 4.1 (Msftedit.dll)
		if !(this.Address)
			this.Address := RegisterCallback("__RichEditClass.SubClassProc")
		Style := 0x10000000 | 0x10000 | 0x40000000 | 0x80
		if InStr(Options, "+Multi") || (!InStr(Options, "-Multi") && InStr(Text, "`n"))
			Style |= 0x0004 | 0x100000 | 0x200000 | 0x40 | 0x0100 | 0x1000 | 0x2000 | 0x8000
		try Gui, %A_DefaultGui%:Add, Custom, ClassRICHEDIT50W HWNDhWnd +%Style% +E0x20000 %Options%, %Text%
		catch
			return false
		this.Instances.Push(this.hWnd := hWnd), this.Limit := 2147483647, this.EventMask := InStr(Options, "+AltSubmit")?0x0011000D:0x01
		, SendMessage(hWnd, 0x04CA, "UInt", 0x01, "UInt", 0x01), SendMessage(hWnd, 0x0478,,, "UInt", 0x03)
		, DllCall("Comctl32.dll\SetWindowSubclass", "Ptr", hWnd, "Ptr", this.Address, "Ptr", hWnd, "Ptr", 0, "Int")
	} __Delete() {
		DllCall("Comctl32.dll\RemoveWindowSubclass", "Ptr", this.hWnd, "Ptr", this.Address, "Ptr", this.hWnd, "Int")
		, WinDestroy(this.hWnd), this.Instances := Array_Remove(this.Instances, this.hWnd)
		if !(this.Instances.MaxIndex())
			FreeLibrary(this.hModule), GlobalFree(this.Address), this.hModule := this.Address := ""
	} SubClassProc(hWnd, Msg, wParam, lParam, Subclass) { 
		If (hWnd = 0x87)
			return 4
		return DllCall("Comctl32.dll\DefSubclassProc", "Ptr", This, "UInt", hWnd, "Ptr", Msg, "Ptr", wParam)
	}
   
	;******************************************************************************************************************************************************************************************
	;Properties (variables que se le puede asignar un valor para establecer datos y/o obtener datos)
	;Establecer Datos: obj.Var := value
	;Obtener Datos: obj.Var
	;Nota: para invertir, usar -1.
	;******************************************************************************************************************************************************************************************
	;obtener / establece posición de la barra de dezplazamiento
	;Obtener: devuelve un array [barra horizontal, barra vertical].
	;Establecer: espesificar un array. si no espesifica un array afecta a ambas.
	ScrollPos[] {
		Get {
			VarSetCapacity(POINT, 8, 0), SendMessage(this.hWnd, 0x04DD,,,, &POINT)
			return [NumGet(POINT, 0, "Int"), NumGet(POINT, 4, "Int")]
		} Set {
			value := IsObject(value)?value:[value, value], VarSetCapacity(POINT, 8, 0)
			, NumPut(value.1, POINT, 0, "Int"), NumPut(value.2, POINT, 4, "Int")
			, SendMessage(this.hWnd, 0x04DE,,,, &POINT)
		}
	}
	
	;obtener / establecer estilo(extendido)
	Style[] {
		Get {
			return SendMessage(this.hWnd, 0x04CD)
		} Set {
			Style := _cvtvalue(this.Style, value)
			, SendMessage(this.hWnd, 0x04CC,, Style,, Style)
	}} ExStyle[] {
		Get {
			return SendMessage(this.hWnd, 1300)
		} Set {
			ExStyle := _cvtvalue(this.ExStyle, value)
			, SendMessage(this.hWnd, 1299,, ExStyle,, ExStyle)
	}}
	
	;mostrar / ocultar / comprobar estado
	Visible[] {
		Get {
			return WinVisible(this.hWnd)
		} Set {
			if (value=-1)
				this.Visible := !this.Visible
			else if (value)
				WinVisible(this.hWnd, true)
			else WinVisible(this.hWnd, false)
	}}

	;cambiar / obtener texto. 
	;Nota: espesificar un array para cambiar el modo en que se copia el texto.
	;Sintaxis: [Texto, Modo].
	;Modos:
		;0 = reemplaza todo el texto, no permite deshacerlo.
		;1 = reemplaza todo el texto, permite deshacerlo.
		;3 = reemplaza solo el texto seleccionado.
		;4 = añade sin reemplazar nada.
	Text[] {
		Get {
			VarSetCapacity(GETTEXTLENGTHEX, 8, 0), NumPut(1200, GETTEXTLENGTHEX, 4, "UInt")
			, Length := SendMessage(this.hWnd, 0x045F,, &GETTEXTLENGTHEX)
			, VarSetCapacity(GETTEXTEX, (4 * 4) + (A_PtrSize * 2), 0), NumPut((Length + 1) * 2, GETTEXTEX, 0, "UInt")
			, NumPut(1200, GETTEXTEX, 8, "UInt"), VarSetCapacity(Text, (Length + 1) * 2, 0)
			, SendMessage(this.hWnd, 0x045E,, &GETTEXTEX, "Str", Text), VarSetCapacity(Text, -1)
			return Text
		} Set {
			if IsObject(value)
				Mode := value.2, value := value.1
			else Mode := 1
			VarSetCapacity(SETTEXTEX, 8, 0), NumPut(Mode, SETTEXTEX, 0, "UInt"), NumPut(1200, SETTEXTEX, 4, "UInt") 
			, SendMessage(this.hWnd, 0x0461,, &SETTEXTEX,, &value)
	}}
	
	;habilitar / deshabilitar / comprobar estado
	Enabled[] {
		Get {
			return WinEnabled(this.hWnd)
		} Set {
			if (value=-1)
				this.Enabled := !this.Enabled
			else if (value)
				WinEnabled(this.hWnd, true)
			else WinEnabled(this.hWnd, false)
	}}

	;obtener / establecer zoom %
	Zoom[] {
		Get {
			VarSetCapacity(N, 4, 0), VarSetCapacity(D, 4, 0)
			, SendMessage(this.hWnd, 0x04E0,, &N,, &D)
			, N := NumGet(N, 0, "Int"), D := NumGet(D, 0, "Int")
			return (N = 0) && (D = 0) ? 100 : Round(N / D * 100)
		} Set {
			SendMessage(this.hWnd, 0x4E1, "Int", value>0?value:100, "Int", 100)
	}}
	
	;obtener / establecer limite de texto
	Limit[] {
		Get {
			return this.LimitText
		} Set {
			SendMessage(this.hWnd, 0x0435,,,, this.LimitText:=value)
	}}
	
	;obtener / establecer solo lectura
	ReadOnly[] {
		Get {
			return SendMessage(this.hWnd, 0x044E)&0x800
		} Set {
			Options := _cvtvalue(SendMessage(this.hWnd, 0x044E), 0x800, value)
			, SendMessage(this.hWnd, 0x044D, "UInt", 0x01, "UInt", Options)
	}}
	
	;comprueba / establece si ha sido modificado
	Modified[] {
		Get {
			return SendMessage(this.hWnd, 0xB8)
		} Set {
			SendMessage(this.hWnd, 0xB9,, !!value)
	}}
	
	;obtiene / establece el nivel de notificaciones que se envian a la etiqueta espesificada (A_EventInfo contiene el código)
	;CHANGE: 0x01, UPDATE: 0x02, SCROLL: 0x04, SCROLLEVENTS: 0x08, DRAGDROPDONE: 0x10
	;PARAGRAPHEXPANDED: 0x20, PAGECHANGE: 0x40, KEYEVENTS: 0x010000, MOUSEEVENTS: 0x020000
	;REQUESTRESIZE: 0x040000, SELCHANGE: 0x080000, DROPFILES: 0x100000, PROTECTED: 0x200000
	EventMask[] { ;ALL=0x043F0085
		Get {
			return SendMessage(this.hWnd, 1083)
		} Set {
			EventMask := _cvtvalue(this.EventMask, value)
			, SendMessage(this.hWnd, 0x0445,,, "UInt", EventMask)
	}}
	
	;muestra / oculta la selección
	SelVisible[] {
		Get {
			return this.SelIsVisible
		} Set {
			if (value=-1)
				value := !this.SelIsVisible
			SendMessage(this.hWnd, 0x043F,, !(this.SelIsVisible:=!!value))
	}}
	
	;obtiene / establece el texto seleccionado
	SelText[] {
		Get {
			this.GetSel(,, Text)
			return Text
		} Set {
			this.GetSel(Start, End)
			, SendMessage(this.hWnd, 0xC2,, true,, &value)
			, this.SetSel(Start, Start+StrLen(value))
			return true
	}}

	;activa / desactiva la detección de URLs
	AutoUrlDetect[] {
		Get {
			return this.AutoUrl
		} Set {
			if (value=-1)
				value := !this.AutoUrl
			SendMessage(this.hWnd, 0x45B,, this.AutoUrl:=!!value), this.Redraw()
	}}
	
	;obtiene el número de lineas
	Lines[] {
		Get {
			return SendMessage(this.hWnd, 0xBA)
	}}
	
	;obtiene la linea que contiene a la barra de intercalación
	CaretLine[] {
		Get {
			LineIndex := SendMessage(this.hWnd, 0xBB,, -1)
			return SendMessage(this.hWnd, 0x0436,,,, LineIndex) + 1
			
	}}
	
	;obtiene el número de caracteres
	Length[] {
		Get {
			VarSetCapacity(GETTEXTLENGTHEX, 8, 0), NumPut(1200, GETTEXTLENGTHEX, 4, "UInt")
			return SendMessage(this.hWnd, 0x045F,, &GETTEXTLENGTHEX)
	}}
	
	;activar / desactivar ajuste de linea (el ajuste de linea hace que cuando el texto alcanze el maximo ancho visible, continue en una linea aparte, que no cuenta como linea en si)
	WordWrap[] {
		Set {
			this.GetSel(Start, End), SendMessage(this.hWnd, 0x0448,,,, value?0:-1)
			, this.SetSel(Start, End), this.ScrollCaret()
	}}
	
	;******************************************************************************************************************************************************************************************
	;Methods (funciones)
	;******************************************************************************************************************************************************************************************	
	;obtener algunos valores de estadistica
	;CaretLine: linea actual
	;CaretCol: columna actual
	;LineCount: lineas tótales
	;CharLength: carácteres totales
	;SelLength: carácteres seleccionados
	;SelText: texto seleccionado
	;SelStart: posicion inicial de la barra de intercalación actual
	;SelEnd: posición final de la barra de intercalación actual
	GetStatistics() {
		Statistics := {}, Statistics.SelStart := this.GetSel(, End, Text).1, Statistics.SelEnd := End
		, Statistics.SelText := Text, Statistics.SelLength := StrLen(Text)
		, Statistics.CaretCol := Statistics.SelStart, Statistics.CaretLine := this.CaretLine
		, Statistics.LineCount := this.Lines, Statistics.CharLength := this.Length
		return Statistics
	}
	
	;busca un determinado texto, lo selecciona y lo hace visible.
	;Mode (sumar para combinar): 1 = BÚSQUEDA HACIA ADELANTE | 2 = BUSCAR PALABRA COMPLETA | 4 = BÚSQUEDA SENSIBLE A MAYÚSCULAS
	;Return: Array(Start, End)=OK | 0=ERROR
	FindText(Text, Mode := -1) {
		this.GetSel(Start, End), Min := Mode&1?End-1:Start-1, Max := Mode&1?-1:0
		, VarSetCapacity(FINDTEXTEX, 16 + A_PtrSize, 0), NumPut(Min, FINDTEXTEX, 0, "Int")
		, NumPut(Max, FINDTEXTEX, 4, "Int"), NumPut(&Text, FINDTEXTEX, 8, "Ptr")
		, SendMessage(this.hWnd, 0x047C,, Mode=-1?1:Mode,, &FINDTEXTEX)
		Start := NumGet(FINDTEXTEX, 8 + A_PtrSize, "Int")+1, End := NumGet(FINDTEXTEX, 12 + A_PtrSize, "Int")+1
		If (Start=0) && (End=0)
			return false
		return [Start, End], this.SetSel(Start, End, true)
	}

	;mueve la barra de desplazamiento a tal punto que la barra de intercalación es totalmente visible
	ScrollCaret() {
		SendMessage(this.hWnd, 0x00B7)
	}
	
	;mostrar / ocultar barras de desplazamiento
	;SB:  0 = HORIZONTAL | 1 = VERTICAL
	;Mode: 0 = OCULTAR | 1 = MOSTRAR
	ShowScrollBar(SB := 1, Mode := true) {
		SendMessage(this.hWnd, 0x0460, "UInt", SB, "Int", !!Mode)
	}
	
	;diálogo para elegir color
	;Selected: solo aplica para el texto seleccionado
	;Mode: 0 = color del texto | 1 = color de fondo
	ChooseColor(Selected := false, Mode := 0) {
		Font := this.GetFont(Selected)
		, Color := ColorSelect(this.hWnd, Mode?Font.BKColor:Font.TextColor)
		if (ErrorLevel) 
			return false
		if (Mode)
			this.SetFont({BKColor: Color}, Selected)
		else this.SetFont({TextColor: Color}, Selected)
		return true
	}
	
	;diálogo para elegir fuente
	;Selected: solo aplica para el texto seleccionado
	;Mode: 0 = color del texto | 1 = color de fondo
	ChooseFont(Selected := false, Mode := 0) {
		Font := this.GetFont(Selected)
		, Font := FontSelect(this.hWnd, Font.Name, [Mode?Font.BKColor:Font.TextColor, Font.Size, Font.Bold, Font.Italic, Font.Underline, Font.Strike, Font.CharSet])
		if (ErrorLevel)
			return false
		if (Mode)
			this.SetFont({Name: Font.0, BKColor: Font.1, Size: Font.2, Bold: Font.3, Italic: Font.4, Underline: Font.5, Strike: Font.6, CharSet: Font.7}, Selected)
		else this.SetFont({Name: Font.0, TextColor: Font.1, Size: Font.2, Bold: Font.3, Italic: Font.4, Underline: Font.5, Strike: Font.6, CharSet: Font.7}, Selected)
		return true
	}
	
	;establecer color de fondo y texto
	;BKColor: RGB color. -1 = SYSTEM_COLOR
	;TextColor: RGB color.
	;Selected: 1 = aplicar solo al texto seleccionado.
	SetColor(BKColor := "", TextColor := "", Selected := false) {
		if (Selected)
			return this.SetFont({BKColor: BKColor, TextColor: TextColor}, true)
		if !(BKColor="")
			SendMessage(this.hWnd, 0x0443,, BKColor=-1,, BKColor=-1?0:_getcolor(BKColor, true))
		if !(TextColor="")
			this.SetFont({TextColor: TextColor})
	}
	
	;limpiar, copiar, cortar, pegar, rehacer, deshacer, puede rehacer, puede deshacer.
	Clear() {
		Edit_SelClear(this.hWnd)
	} Copy() {
		Edit_SelCopy(this.hWnd)
	} Cur() {
		Edit_SelClear(this.hWnd)
	} Paste() {
		Edit_SelPaste(this.hWnd)
	} Redo() {
		SendMessage(this.hWnd, 0x454)
	} Undo() {
		SendMessage(this.hWnd, 0xC7)
	} CanRedo() {
		return SendMessage(this.hWnd, 0x0455)
	} CanUndo() {
		return SendMessage(this.hWnd, 0x00C6)
	}

   ;redibujar control
	Redraw() {
		WinRedraw(this.hWnd)
	} 
	
	;obtener fuente
	GetFont(Selected := 0) { ;0=SCF_DEFAULT | 1=SCF_SELECTION
		VarSetCapacity(CHARFORMAT2, 116, 0), NumPut(116, CHARFORMAT2, 0, "UInt"), Font := {}
		, NumPut(0xEC03001F, CHARFORMAT2, 4, "UInt"), NumPut(0xEC000000, CHARFORMAT2, 8, "UInt")
		, SendMessage(this.hWnd, 0x043A, "Int", !!Selected,, &CHARFORMAT2) ;EM_GETCHARFORMAT
		, Font.Name := StrGet(&CHARFORMAT2 + 26), Font.Size := NumGet(CHARFORMAT2, 12, "Int") / 20
		, Font.Effects := NumGet(CHARFORMAT2, 8, "UInt"), Font.Bold := Font.Effects&1, Font.Italic := Font.Effects&2
		, Font.Underline := Font.Effects&4, Font.Link := Font.Effects&0x0020, Font.Face := Font.Effects&0x20000
		, Font.Protected := Font.Effects&16, Font.AutoColor := Font.Effects&0x40000000, Font.Strike := Font.Effects&8
		, Font.SuperScript := Font.Effects&0x20000, Font.SubScript := Font.Effects&0x10000, Font.CharSet := NumGet(CHARFORMAT2, 24, "UChar")
		, Font.Normal := !Font.Underline&&!Font.Italic&&!Font.Bold&&!Font.Protected&&!Font.Strike&&!Font.SuperScript&&!Font.SubScript
		, Font.TextColor := RGB(NumGet(CHARFORMAT2, 20, "Int")), Font.BKColor := Font.Effects&0x04000000?"White":RGB(NumGet(CHARFORMAT2, 96, "UInt"))
		, Font.UnderlineType := NumGet(CHARFORMAT2, 112, "UChar"), Font.UnderlineColor := NumGet(CHARFORMAT2, 115, "UChar")
		, Font.RevAuthor := NumGet(CHARFORMAT2, 114, "UChar"), Font.Weight := NumGet(CHARFORMAT2, 90, "UShort")
		return Font
	}

	;establecer fuente
	SetFont(Font, Selected := false, Start := "", End := "") { 
		if !(End="") || !(Start="")
			this.GetSel(s, e), this.SetSel(Start=""?1:Start, End=""?0:End)
		CFont := this.GetFont(Selected), Mask := Effects := 0
		, VarSetCapacity(CHARFORMAT2, 116, 0), NumPut(116, CHARFORMAT2, 0, "UInt")
		, Mask |= 0x20000000, Effects |= 0x20000000, StrPut(Font.Name=""?CFont.Name:Font.Name, &CHARFORMAT2 + 26)
		, Mask |= 0x80000000, Effects |= 0x80000000, NumPut((Font.Size=""?CFont.Size:Font.Size)*20, CHARFORMAT2, 12, "UInt")
		, Mask |= 0x40000000, NumPut(_getcolor(Font.TextColor=""?CFont.TextColor:Font.TextColor, true), CHARFORMAT2, 20, "Int")
		, Mask |= 0x04000000, NumPut(_getcolor(Font.BKColor=""?CFont.BKColor:Font.BKColor, true), CHARFORMAT2, 96, "UInt")
		, Mask |= 0x08000000, Effects |= 0x08000000, NumPut(Font.CharSet=""?CFont.CharSet:Font.CharSet, CHARFORMAT2, 24, "UChar")
		, Mask |= 0x3001F, Effects |= (Font.Bold=""?!!CFont.Bold:!!Font.Bold) | (Font.Italic=""?(CFont.Italic?2:0):(Font.Italic?2:0)) 
			| (Font.Underline=""?(CFont.Underline?4:0):(Font.Underline?4:0)) | (Font.Strike=""?(CFont.Strike?8:0):(Font.Strike?8:0))
			| (Font.Protected=""?(CFont.Protected?16:0):(Font.Protected?16:0)) | (Font.SuperScript=""?(CFont.SuperScript?0x20000:0):(Font.SuperScript?0x20000:0))
			| (Font.SubScript=""?(CFont.SubScript?0x10000:0):(Font.SubScript?0x10000:0))
		Mask |= 0x00800000, NumPut(Font.UnderlineType=""?CFont.UnderlineType:Font.UnderlineType, CHARFORMAT2, 112, "UChar")
		, Mask |= 0x00008000, NumPut(Font.RevAuthor=""?CFont.RevAuthor:Font.RevAuthor, CHARFORMAT2, 114, "UChar")
		, Mask |= 0x00400000, NumPut(Font.Weight=""?CFont.Weight:Font.Weight, CHARFORMAT2, 90, "UShort")
		, NumPut(_getcolor(Font.UnderlineColor=""?CFont.UnderlineColor:Font.UnderlineColor, true), CHARFORMAT2, 115, "UChar")
		, NumPut(Mask, CHARFORMAT2, 4, "UInt"), NumPut(Effects, CHARFORMAT2, 8, "UInt"), SendMessage(this.hWnd, 0x0444, "Int", !!Selected,, &CHARFORMAT2)
		if !(End="") || !(Start="")
			this.SetSel(s, e)
	}
	
	;establecer seleccion, por defecto selecciona todo el texto.
	SetSel(Start := 1, End := 0, ScrollCaret := false) {
		VarSetCapacity(CHARRANGE, 8, 0), NumPut(Start-1, CHARRANGE, 0, "Int"), NumPut(End-1, CHARRANGE, 4, "Int")
		SendMessage(this.hWnd, 0x0437,,,, &CHARRANGE)
		if (ScrollCaret)
			this.ScrollCaret()
	}
	
	;obtener posición de los carácteres seleccionados, opcional el texto seleccionado
	GetSel(ByRef Start := "", ByRef End := "", ByRef SelText := "") {
		VarSetCapacity(CHARRANGE, 8, 0), SendMessage(this.hWnd, 0x0434,,,, &CHARRANGE)
		, Start := NumGet(CHARRANGE, 0, "Int"), End := NumGet(CHARRANGE, 4, "Int"), Start := Start?Start+1:0, End := End?End+1:0
		if IsByRef(SelText) && (End>0) && !(Start=End)
			VarSetCapacity(SelText, End * 2, 0), SendMessage(this.hWnd, 0x043E,,, "Str", SelText), VarSetCapacity(SelText, -1)
		return [Start, End]
	}
	
	;obtener parte editable
	GetRect(ByRef x := "", ByRef y := "", ByRef w := "", ByRef h := "") {
		return Edit_GetRect(this.hWnd, x, y, w, h)
	}

	;establecer parte editable
	SetRect(x := "", y := "", w := "", h := "") {
		return Edit_SetRect(this.hWnd, x, y, w, h)
	}
	
	;establecer el formato de párrafo
	SetTextParaFormat(Format) {
		CFormat := this.GetTextParaFormat(), Mask := 0
		, VarSetCapacity(PARAFORMAT2, 188, 0), NumPut(188, PARAFORMAT2, 0, "UInt")
		, Mask |= 0x00000008, NumPut(Format.Alignment=""?CFormat.Alignment:Format.Alignment, 24, "UShort")
		, Mask |= 0x100, NumPut(Format.LineSpacingRule=""?CFormat.LineSpacingRule:Format.LineSpacingRule, PARAFORMAT2, 170, "UChar")
		, Mask |= 0x00000100, NumPut(Abs(Format.LineSpacing=""?CFormat.LineSpacing:Format.LineSpacing)*20, PARAFORMAT2, 164, "Int")
		NumPut(Mask, PARAFORMAT2, 4, "UInt"), SendMessage(this.hWnd, 0x0447,,,, &PARAFORMAT2)
		MsgBox % this.GetTextParaFormat().LineSpacing
	}

	;obtener el formato de párrafo
	GetTextParaFormat() {
		VarSetCapacity(PARAFORMAT2, 188, 0), NumPut(0xD0FFFDFF, PARAFORMAT2, 4, "UInt")
		, SendMessage(this.hWnd, 0x043D,,,, &PARAFORMAT2), Format := {}
		, Format.Alignment := NumGet(PARAFORMAT2, 24, "UShort")
		, Format.LineSpacing := NumGet(PARAFORMAT2, 164, "Int")
		, Format.LineSpacingRule := NumGet(PARAFORMAT2, 170, "UChar")
		return Format
	}
	
	;dialogo para abrir archivo
	LoadFileDlg() {
		Filename := SelectFile("*" this.LoadFileDefaultPath)
		return ErrorLevel?false:this.LoadFile(this.LoadFileDefaultPath:=Filename)
	}
	
	;dialogo para guardar archivo
	SaveFileDlg() {
		Filename := SaveFile(this.SaveFileDefaultPath)
		return ErrorLevel?false:this.SaveFile(this.SaveFileDefaultPath:=Filename)
	}

	;cargar texto desde archivo
	;Mode: espesificar el modo
		;Open = reemplazar todo el texto
		;Append = añadir al final
		;Insert = añadir en / reemplazar selección
	LoadFile(Filename, Mode := "Open") {
		if !FileExist(Filename)
			return false
		SplitPath, Filename,,, Ext
		if (Ext="RTF") {
			if (Mode="Append")
				this.SetSel(0, -1)
			return this.LoadRTF(Filename, (Mode="Insert"||Mode="Append"))
		} else {
			if (Mode="Open")
				this.Text := ReadFile(Filename)
			else if (Mode="Insert")
				this.SelText := ReadFile(Filename)
			else if (Mode="Append")
				this.SetSel(0, -1), this.SelText := ReadFile(Filename)
			return true
	}} LoadRTF(Filename, Selection := false) {
		if !(f := FileOpen(Filename, "r"))
			return false
		Address := RegisterCallback("__RichEditClass.LoadRTFProc"), VarSetCapacity(EDITSTREAM, (A_PtrSize * 2) + 4, 0)
		, NumPut(f.__Handle, EDITSTREAM, 0, "Ptr"), NumPut(Address, EDITSTREAM, A_PtrSize + 4, "Ptr")
		, Text := SendMessage(this.hWnd, 0x0449,, 0x4002 | (Selection ? 0x8000 : 0),, &EDITSTREAM), GlobalFree(Address)
		return true, f.Close()
	} LoadRTFProc(Buff, Bytes, BytesRead) {
      return !DllCall("Kernel32.dll\ReadFile", "Ptr", this, "Ptr", Buff, "UInt", Bytes, "Ptr", BytesRead, "Ptr", 0)
	}
	
	;guardar a un archivo
	SaveFile(Filename) {
		SplitPath, Filename,,, Ext
		Text := Ext="RTF"?this.GetRTF():this.Text
		if (f := FileOpen(Filename, "w`n"))
			return true, f.Write(Text), f.Close()
		return false
	} GetRTF(Selection := false) {
		Address := RegisterCallback("__RichEditClass.GetRTFProc"), VarSetCapacity(EDITSTREAM, (A_PtrSize * 2) + 4, 0)
		, NumPut(this.hWnd, EDITSTREAM, 0, "Ptr"), NumPut(Address, EDITSTREAM, A_PtrSize + 4, "Ptr")
		, SendMessage(this.hWnd, 0x044A,, 0x4022 | (1200 << 16) | (Selection ? 0x8000 : 0),, &EDITSTREAM)
		return this.GetRTFProc("Get", 0, 0), GlobalFree(Address)
	} GetRTFProc(Buff, Bytes, BytesRead) {
		static RTF := ""
		If (Bytes > 0)
			return false, RTF .= StrGet(Buff, Bytes, "CP0")
		if (Buff="Get") {
			Text := RTF, VarSetCapacity(RTF, 0)
			return Text
		} return true
	}
}

;#############################################################################################################################################
; ::::::::::::::::::::::::::::::::::::::::::::: INCLUDE :::::::::::::::::::::::::::::::::: *i
;Notas:
	;• poner las clases y funciones en la carpeta Lib.
		;--> %A_MyDocuments%\AutoHotkey\Lib
		;--> %A_ScriptDir%\Lib
		;--> %AHK_INSTALL_PATH%\Lib
	;• las funciones y clases con *i son opcionales (omite si no existe).
return
;#############################################################################################################################################
;--------------------------------------
;CLASES
;--------------------------------------
;estilo para los botones (redondeado, color de fondo/texto/borde ...)
#Include <Class_ImageButton> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=1103
;color para los controles
#Include <Class_CtlColors> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=4026
;color para ListView controles
#Include *i <Class_LV_Colors> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=1081
;otra opcion para las funciones con archivos INI
	;#Include *i <Class_INIFile> ;https://github.com/flipeador/AutoHotKey/blob/master/Class_INIFile
;clase para archivos
	;#Include *i <Class_OpenFile> ;https://github.com/flipeador/AutoHotKey/blob/master/Class_OpenFile
;editar filas individuales en ListView
#Include *i <Class_LV_InCellEdit> ;http://ahkscript.org/boards/viewtopic.php?p=15056#p15056

;--------------------------------------
;FUNCIONES
;--------------------------------------
;otra opcion al InputBox
#Include *i <InputBoxEx> ;https://autohotkey.com/boards/viewtopic.php?f=42&t=5827
;otra opcion al TrayTip
#Include *i <TrayTipEx> ;http://ahkscript.org/boards/viewtopic.php?f=42&t=5827
;otra opcion al ToolTip
	;#Include *i <ToolTipEx> ;https://github.com/flipeador/AutoHotKey/blob/master/ToolTipEx
;color de fondo para Picture controles
#Include *i <LinearGradient> ;http://ahkscript.org/boards/viewtopic.php?f=6&t=3593
;dialogo para seleccionar un icono
#Include *i <ChooseIcon> ;https://autohotkey.com/boards/viewtopic.php?f=42&t=10802

;--------------------------------------
;CONSTANTES
;--------------------------------------
;Link: http://ahkscript.org/boards/viewtopic.php?f=6&t=4557

;--------------------------------------
;OTROS
;--------------------------------------
#NoEnv ;evita comprobar las variables vacías para ver si son variables de entorno (recomendado para todos los nuevos scripts).
#MaxMem 4095 ;establece la capacidad máxima de cada variable, en megabytes.

/* 
Example: https://msdn.microsoft.com/en-us/library/windows/desktop/bb776891(v=vs.85).aspx#Shellink_Resolving_Shortcut
GUID --> https://github.com/postgrespro/pgwininstall/blob/master/nsis/common_macro.nsh
IShellLink := ComObjCreate("{00021401-0000-0000-C000-000000000046}", "{000214F9-0000-0000-C000-000000000046}")
IPersistFile := ComObjQuery(IShellLink, "{000214F9-0000-0000-C000-000000000046}") ;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687223(v=vs.85).aspx
--> Load() https://msdn.microsoft.com/en-us/library/windows/desktop/ms687284(v=vs.85).aspx
Load() mode https://msdn.microsoft.com/en-us/library/windows/desktop/aa380337(v=vs.85).aspx
*/
